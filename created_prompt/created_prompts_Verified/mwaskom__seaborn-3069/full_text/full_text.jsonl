{"instance_id": "mwaskom__seaborn-3069", "message": "Please look through the following GitHub problem description and Full Repository and provide a list of files that one would need to edit to fix the problem.\n\n### GitHub Problem Description ###\nNominal scale should be drawn the same way as categorical scales\nThree distinctive things happen on the categorical axis in seaborn's categorical plots:\r\n\r\n1. The scale is drawn to +/- 0.5 from the first and last tick, rather than using the normal margin logic\r\n2. A grid is not shown, even when it otherwise would be with the active style\r\n3. If on the y axis, the axis is inverted\r\n\r\nIt probably makes sense to have `so.Nominal` scales (including inferred ones) do this too. Some comments on implementation:\r\n\r\n1. This is actually trickier than you'd think; I may have posted an issue over in matplotlib about this at one point, or just discussed on their gitter. I believe the suggested approach is to add an invisible artist with sticky edges and set the margin to 0. Feels like a hack! I might have looked into setting the sticky edges _on the spine artist_ at one point?\r\n\r\n2. Probably straightforward to do in `Plotter._finalize_figure`. Always a good idea? How do we defer to the theme if the user wants to force a grid? Should the grid be something that is set in the scale object itself\r\n\r\n3. Probably straightforward to implement but I am not exactly sure where would be best.\n\n\n###\n\n### Full Repository ###\n{'seaborn': {'palettes.py': {'classes': [{'name': '_ColorPalette', 'start_line': 61, 'end_line': 91, 'text': ['class _ColorPalette(list):', '    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"', '    def __enter__(self):', '        \"\"\"Open the context.\"\"\"', '        from .rcmod import set_palette', '        self._orig_palette = color_palette()', '        set_palette(self)', '        return self', '', '    def __exit__(self, *args):', '        \"\"\"Close the context.\"\"\"', '        from .rcmod import set_palette', '        set_palette(self._orig_palette)', '', '    def as_hex(self):', '        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"', '        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]', '        return _ColorPalette(hex)', '', '    def _repr_html_(self):', '        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"', '        s = 55', '        n = len(self)', '        html = f\\'<svg  width=\"{n * s}\" height=\"{s}\">\\'', '        for i, c in enumerate(self.as_hex()):', '            html += (', '                f\\'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};\\'', '                \\'stroke-width:2;stroke:rgb(255,255,255)\"/>\\'', '            )', \"        html += '</svg>'\", '        return html'], 'methods': [{'name': '__enter__', 'start_line': 63, 'end_line': 68, 'text': ['    def __enter__(self):', '        \"\"\"Open the context.\"\"\"', '        from .rcmod import set_palette', '        self._orig_palette = color_palette()', '        set_palette(self)', '        return self']}, {'name': '__exit__', 'start_line': 70, 'end_line': 73, 'text': ['    def __exit__(self, *args):', '        \"\"\"Close the context.\"\"\"', '        from .rcmod import set_palette', '        set_palette(self._orig_palette)']}, {'name': 'as_hex', 'start_line': 75, 'end_line': 78, 'text': ['    def as_hex(self):', '        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"', '        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]', '        return _ColorPalette(hex)']}, {'name': '_repr_html_', 'start_line': 80, 'end_line': 91, 'text': ['    def _repr_html_(self):', '        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"', '        s = 55', '        n = len(self)', '        html = f\\'<svg  width=\"{n * s}\" height=\"{s}\">\\'', '        for i, c in enumerate(self.as_hex()):', '            html += (', '                f\\'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};\\'', '                \\'stroke-width:2;stroke:rgb(255,255,255)\"/>\\'', '            )', \"        html += '</svg>'\", '        return html']}]}], 'functions': [{'name': '_patch_colormap_display', 'start_line': 94, 'end_line': 119, 'text': ['def _patch_colormap_display():', '    \"\"\"Simplify the rich display of matplotlib color maps in a notebook.\"\"\"', '    def _repr_png_(self):', '        \"\"\"Generate a PNG representation of the Colormap.\"\"\"', '        import io', '        from PIL import Image', '        import numpy as np', '        IMAGE_SIZE = (400, 50)', '        X = np.tile(np.linspace(0, 1, IMAGE_SIZE[0]), (IMAGE_SIZE[1], 1))', '        pixels = self(X, bytes=True)', '        png_bytes = io.BytesIO()', \"        Image.fromarray(pixels).save(png_bytes, format='png')\", '        return png_bytes.getvalue()', '', '    def _repr_html_(self):', '        \"\"\"Generate an HTML representation of the Colormap.\"\"\"', '        import base64', '        png_bytes = self._repr_png_()', \"        png_base64 = base64.b64encode(png_bytes).decode('ascii')\", \"        return ('<img '\", '                + \\'alt=\"\\' + self.name + \\' color map\" \\'', '                + \\'title=\"\\' + self.name + \\'\"\\'', '                + \\'src=\"data:image/png;base64,\\' + png_base64 + \\'\">\\')', '', '    mpl.colors.Colormap._repr_png_ = _repr_png_', '    mpl.colors.Colormap._repr_html_ = _repr_html_']}, {'name': 'color_palette', 'start_line': 122, 'end_line': 255, 'text': ['def color_palette(palette=None, n_colors=None, desat=None, as_cmap=False):', '    \"\"\"Return a list of colors or continuous colormap defining a palette.', '', '    Possible ``palette`` values include:', '        - Name of a seaborn palette (deep, muted, bright, pastel, dark, colorblind)', '        - Name of matplotlib colormap', \"        - 'husl' or 'hls'\", \"        - 'ch:<cubehelix arguments>'\", \"        - 'light:<color>', 'dark:<color>', 'blend:<color>,<color>',\", '        - A sequence of colors in any format matplotlib accepts', '', '    Calling this function with ``palette=None`` will return the current', '    matplotlib color cycle.', '', '    This function can also be used in a ``with`` statement to temporarily', '    set the color cycle for a plot or set of plots.', '', '    See the :ref:`tutorial <palette_tutorial>` for more information.', '', '    Parameters', '    ----------', '    palette : None, string, or sequence, optional', '        Name of palette or None to return current palette. If a sequence, input', '        colors are used but possibly cycled and desaturated.', '    n_colors : int, optional', '        Number of colors in the palette. If ``None``, the default will depend', '        on how ``palette`` is specified. Named palettes default to 6 colors,', '        but grabbing the current palette or passing in a list of colors will', '        not change the number of colors unless this is specified. Asking for', '        more colors than exist in the palette will cause it to cycle. Ignored', '        when ``as_cmap`` is True.', '    desat : float, optional', '        Proportion to desaturate each color by.', '    as_cmap : bool', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', '', '    Returns', '    -------', '    list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    set_palette : Set the default color cycle for all plots.', '    set_color_codes : Reassign color codes like ``\"b\"``, ``\"g\"``, etc. to', '                      colors from one of the seaborn palettes.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/color_palette.rst', '', '    \"\"\"', '    if palette is None:', '        palette = get_color_cycle()', '        if n_colors is None:', '            n_colors = len(palette)', '', '    elif not isinstance(palette, str):', '        palette = palette', '        if n_colors is None:', '            n_colors = len(palette)', '    else:', '', '        if n_colors is None:', '            # Use all colors in a qualitative palette or 6 of another kind', '            n_colors = QUAL_PALETTE_SIZES.get(palette, 6)', '', '        if palette in SEABORN_PALETTES:', '            # Named \"seaborn variant\" of matplotlib default color cycle', '            palette = SEABORN_PALETTES[palette]', '', '        elif palette == \"hls\":', '            # Evenly spaced colors in cylindrical RGB space', '            palette = hls_palette(n_colors, as_cmap=as_cmap)', '', '        elif palette == \"husl\":', '            # Evenly spaced colors in cylindrical Lab space', '            palette = husl_palette(n_colors, as_cmap=as_cmap)', '', '        elif palette.lower() == \"jet\":', '            # Paternalism', '            raise ValueError(\"No.\")', '', '        elif palette.startswith(\"ch:\"):', '            # Cubehelix palette with params specified in string', '            args, kwargs = _parse_cubehelix_args(palette)', '            palette = cubehelix_palette(n_colors, *args, **kwargs, as_cmap=as_cmap)', '', '        elif palette.startswith(\"light:\"):', '            # light palette to color specified in string', '            _, color = palette.split(\":\")', '            reverse = color.endswith(\"_r\")', '            if reverse:', '                color = color[:-2]', '            palette = light_palette(color, n_colors, reverse=reverse, as_cmap=as_cmap)', '', '        elif palette.startswith(\"dark:\"):', '            # light palette to color specified in string', '            _, color = palette.split(\":\")', '            reverse = color.endswith(\"_r\")', '            if reverse:', '                color = color[:-2]', '            palette = dark_palette(color, n_colors, reverse=reverse, as_cmap=as_cmap)', '', '        elif palette.startswith(\"blend:\"):', '            # blend palette between colors specified in string', '            _, colors = palette.split(\":\")', '            colors = colors.split(\",\")', '            palette = blend_palette(colors, n_colors, as_cmap=as_cmap)', '', '        else:', '            try:', '                # Perhaps a named matplotlib colormap?', '                palette = mpl_palette(palette, n_colors, as_cmap=as_cmap)', '            except (ValueError, KeyError):  # Error class changed in mpl36', '                raise ValueError(f\"{palette} is not a valid palette name\")', '', '    if desat is not None:', '        palette = [desaturate(c, desat) for c in palette]', '', '    if not as_cmap:', '', '        # Always return as many colors as we asked for', '        pal_cycle = cycle(palette)', '        palette = [next(pal_cycle) for _ in range(n_colors)]', '', '        # Always return in r, g, b tuple format', '        try:', '            palette = map(mpl.colors.colorConverter.to_rgb, palette)', '            palette = _ColorPalette(palette)', '        except ValueError:', '            raise ValueError(f\"Could not generate a palette for {palette}\")', '', '    return palette']}, {'name': 'hls_palette', 'start_line': 258, 'end_line': 309, 'text': ['def hls_palette(n_colors=6, h=.01, l=.6, s=.65, as_cmap=False):  # noqa', '    \"\"\"', '    Return hues with constant lightness and saturation in the HLS system.', '', '    The hues are evenly sampled along a circular path. The resulting palette will be', '    appropriate for categorical or cyclical data.', '', '    The `h`, `l`, and `s` values should be between 0 and 1.', '', '    .. note::', '        While the separation of the resulting colors will be mathematically', '        constant, the HLS system does not construct a perceptually-uniform space,', '        so their apparent intensity will vary.', '', '    Parameters', '    ----------', '    n_colors : int', '        Number of colors in the palette.', '    h : float', '        The value of the first hue.', '    l : float', '        The lightness value.', '    s : float', '        The saturation intensity.', '    as_cmap : bool', '        If True, return a matplotlib colormap object.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    husl_palette : Make a palette using evenly spaced hues in the HUSL system.', '', '    Examples', '    --------', '    .. include:: ../docstrings/hls_palette.rst', '', '    \"\"\"', '    if as_cmap:', '        n_colors = 256', '    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]', '    hues += h', '    hues %= 1', '    hues -= hues.astype(int)', '    palette = [colorsys.hls_to_rgb(h_i, l, s) for h_i in hues]', '    if as_cmap:', '        return mpl.colors.ListedColormap(palette, \"hls\")', '    else:', '        return _ColorPalette(palette)']}, {'name': 'husl_palette', 'start_line': 312, 'end_line': 363, 'text': ['def husl_palette(n_colors=6, h=.01, s=.9, l=.65, as_cmap=False):  # noqa', '    \"\"\"', '    Return hues with constant lightness and saturation in the HUSL system.', '', '    The hues are evenly sampled along a circular path. The resulting palette will be', '    appropriate for categorical or cyclical data.', '', '    The `h`, `l`, and `s` values should be between 0 and 1.', '', '    This function is similar to :func:`hls_palette`, but it uses a nonlinear color', '    space that is more perceptually uniform.', '', '    Parameters', '    ----------', '    n_colors : int', '        Number of colors in the palette.', '    h : float', '        The value of the first hue.', '    l : float', '        The lightness value.', '    s : float', '        The saturation intensity.', '    as_cmap : bool', '        If True, return a matplotlib colormap object.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    hls_palette : Make a palette using evenly spaced hues in the HSL system.', '', '    Examples', '    --------', '    .. include:: ../docstrings/husl_palette.rst', '', '    \"\"\"', '    if as_cmap:', '        n_colors = 256', '    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]', '    hues += h', '    hues %= 1', '    hues *= 359', '    s *= 99', '    l *= 99  # noqa', '    palette = [_color_to_rgb((h_i, s, l), input=\"husl\") for h_i in hues]', '    if as_cmap:', '        return mpl.colors.ListedColormap(palette, \"hsl\")', '    else:', '        return _ColorPalette(palette)']}, {'name': 'mpl_palette', 'start_line': 366, 'end_line': 417, 'text': ['def mpl_palette(name, n_colors=6, as_cmap=False):', '    \"\"\"', '    Return a palette or colormap from the matplotlib registry.', '', '    For continuous palettes, evenly-spaced discrete samples are chosen while', '    excluding the minimum and maximum value in the colormap to provide better', '    contrast at the extremes.', '', '    For qualitative palettes (e.g. those from colorbrewer), exact values are', '    indexed (rather than interpolated), but fewer than `n_colors` can be returned', '    if the palette does not define that many.', '', '    Parameters', '    ----------', '    name : string', '        Name of the palette. This should be a named matplotlib colormap.', '    n_colors : int', '        Number of discrete colors in the palette.', '', '    Returns', '    -------', '    list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    Examples', '    --------', '    .. include: ../docstrings/mpl_palette.rst', '', '    \"\"\"', '    if name.endswith(\"_d\"):', '        sub_name = name[:-2]', '        if sub_name.endswith(\"_r\"):', '            reverse = True', '            sub_name = sub_name[:-2]', '        else:', '            reverse = False', '        pal = color_palette(sub_name, 2) + [\"#333333\"]', '        if reverse:', '            pal = pal[::-1]', '        cmap = blend_palette(pal, n_colors, as_cmap=True)', '    else:', '        cmap = get_colormap(name)', '', '    if name in MPL_QUAL_PALS:', '        bins = np.linspace(0, 1, MPL_QUAL_PALS[name])[:n_colors]', '    else:', '        bins = np.linspace(0, 1, int(n_colors) + 2)[1:-1]', '    palette = list(map(tuple, cmap(bins)[:, :3]))', '', '    if as_cmap:', '        return cmap', '    else:', '        return _ColorPalette(palette)']}, {'name': '_color_to_rgb', 'start_line': 420, 'end_line': 430, 'text': ['def _color_to_rgb(color, input):', '    \"\"\"Add some more flexibility to color choices.\"\"\"', '    if input == \"hls\":', '        color = colorsys.hls_to_rgb(*color)', '    elif input == \"husl\":', '        color = husl.husl_to_rgb(*color)', '        color = tuple(np.clip(color, 0, 1))', '    elif input == \"xkcd\":', '        color = xkcd_rgb[color]', '', '    return mpl.colors.to_rgb(color)']}, {'name': 'dark_palette', 'start_line': 433, 'end_line': 481, 'text': ['def dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input=\"rgb\"):', '    \"\"\"Make a sequential palette that blends from dark to ``color``.', '', '    This kind of palette is good for data that range between relatively', '    uninteresting low values and interesting high values.', '', '    The ``color`` parameter can be specified in a number of ways, including', '    all options for defining a color in matplotlib and several additional', '    color spaces that are handled by seaborn. You can also use the database', '    of named colors from the XKCD color survey.', '', '    If you are using the IPython notebook, you can also choose this palette', '    interactively with the :func:`choose_dark_palette` function.', '', '    Parameters', '    ----------', '    color : base color for high values', '        hex, rgb-tuple, or html color name', '    n_colors : int, optional', '        number of colors in the palette', '    reverse : bool, optional', '        if True, reverse the direction of the blend', '    as_cmap : bool, optional', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', \"    input : {'rgb', 'hls', 'husl', xkcd'}\", '        Color space to interpret the input color. The first three options', '        apply to tuple inputs and the latter applies to string inputs.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    light_palette : Create a sequential palette with bright low values.', '    diverging_palette : Create a diverging palette with two colors.', '', '    Examples', '    --------', '    .. include:: ../docstrings/dark_palette.rst', '', '    \"\"\"', '    rgb = _color_to_rgb(color, input)', '    h, s, l = husl.rgb_to_husl(*rgb)', '    gray_s, gray_l = .15 * s, 15', '    gray = _color_to_rgb((h, gray_s, gray_l), input=\"husl\")', '    colors = [rgb, gray] if reverse else [gray, rgb]', '    return blend_palette(colors, n_colors, as_cmap)']}, {'name': 'light_palette', 'start_line': 484, 'end_line': 529, 'text': ['def light_palette(color, n_colors=6, reverse=False, as_cmap=False, input=\"rgb\"):', '    \"\"\"Make a sequential palette that blends from light to ``color``.', '', '    The ``color`` parameter can be specified in a number of ways, including', '    all options for defining a color in matplotlib and several additional', '    color spaces that are handled by seaborn. You can also use the database', '    of named colors from the XKCD color survey.', '', '    If you are using a Jupyter notebook, you can also choose this palette', '    interactively with the :func:`choose_light_palette` function.', '', '    Parameters', '    ----------', '    color : base color for high values', '        hex code, html color name, or tuple in `input` space.', '    n_colors : int, optional', '        number of colors in the palette', '    reverse : bool, optional', '        if True, reverse the direction of the blend', '    as_cmap : bool, optional', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', \"    input : {'rgb', 'hls', 'husl', xkcd'}\", '        Color space to interpret the input color. The first three options', '        apply to tuple inputs and the latter applies to string inputs.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    dark_palette : Create a sequential palette with dark low values.', '    diverging_palette : Create a diverging palette with two colors.', '', '    Examples', '    --------', '    .. include:: ../docstrings/light_palette.rst', '', '    \"\"\"', '    rgb = _color_to_rgb(color, input)', '    h, s, l = husl.rgb_to_husl(*rgb)', '    gray_s, gray_l = .15 * s, 95', '    gray = _color_to_rgb((h, gray_s, gray_l), input=\"husl\")', '    colors = [rgb, gray] if reverse else [gray, rgb]', '    return blend_palette(colors, n_colors, as_cmap)']}, {'name': 'diverging_palette', 'start_line': 532, 'end_line': 578, 'text': ['def diverging_palette(h_neg, h_pos, s=75, l=50, sep=1, n=6,  # noqa', '                      center=\"light\", as_cmap=False):', '    \"\"\"Make a diverging palette between two HUSL colors.', '', '    If you are using the IPython notebook, you can also choose this palette', '    interactively with the :func:`choose_diverging_palette` function.', '', '    Parameters', '    ----------', '    h_neg, h_pos : float in [0, 359]', '        Anchor hues for negative and positive extents of the map.', '    s : float in [0, 100], optional', '        Anchor saturation for both extents of the map.', '    l : float in [0, 100], optional', '        Anchor lightness for both extents of the map.', '    sep : int, optional', '        Size of the intermediate region.', '    n : int, optional', '        Number of colors in the palette (if not returning a cmap)', '    center : {\"light\", \"dark\"}, optional', '        Whether the center of the palette is light or dark', '    as_cmap : bool, optional', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    dark_palette : Create a sequential palette with dark values.', '    light_palette : Create a sequential palette with light values.', '', '    Examples', '    --------', '    .. include: ../docstrings/diverging_palette.rst', '', '    \"\"\"', '    palfunc = dict(dark=dark_palette, light=light_palette)[center]', '    n_half = int(128 - (sep // 2))', '    neg = palfunc((h_neg, s, l), n_half, reverse=True, input=\"husl\")', '    pos = palfunc((h_pos, s, l), n_half, input=\"husl\")', '    midpoint = dict(light=[(.95, .95, .95)], dark=[(.133, .133, .133)])[center]', '    mid = midpoint * sep', '    pal = blend_palette(np.concatenate([neg, mid, pos]), n, as_cmap=as_cmap)', '    return pal']}, {'name': 'blend_palette', 'start_line': 581, 'end_line': 609, 'text': ['def blend_palette(colors, n_colors=6, as_cmap=False, input=\"rgb\"):', '    \"\"\"Make a palette that blends between a list of colors.', '', '    Parameters', '    ----------', '    colors : sequence of colors in various formats interpreted by `input`', '        hex code, html color name, or tuple in `input` space.', '    n_colors : int, optional', '        Number of colors in the palette.', '    as_cmap : bool, optional', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    Examples', '    --------', '    .. include: ../docstrings/blend_palette.rst', '', '    \"\"\"', '    colors = [_color_to_rgb(color, input) for color in colors]', '    name = \"blend\"', '    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)', '    if not as_cmap:', '        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]  # no alpha', '        pal = _ColorPalette(map(tuple, rgb_array))', '    return pal']}, {'name': 'xkcd_palette', 'start_line': 612, 'end_line': 635, 'text': ['def xkcd_palette(colors):', '    \"\"\"Make a palette with color names from the xkcd color survey.', '', '    See xkcd for the full list of colors: https://xkcd.com/color/rgb/', '', '    This is just a simple wrapper around the `seaborn.xkcd_rgb` dictionary.', '', '    Parameters', '    ----------', '    colors : list of strings', '        List of keys in the `seaborn.xkcd_rgb` dictionary.', '', '    Returns', '    -------', '    palette', '        A list of colors as RGB tuples.', '', '    See Also', '    --------', '    crayon_palette : Make a palette with Crayola crayon colors.', '', '    \"\"\"', '    palette = [xkcd_rgb[name] for name in colors]', '    return color_palette(palette, len(palette))']}, {'name': 'crayon_palette', 'start_line': 638, 'end_line': 662, 'text': ['def crayon_palette(colors):', '    \"\"\"Make a palette with color names from Crayola crayons.', '', '    Colors are taken from here:', '    https://en.wikipedia.org/wiki/List_of_Crayola_crayon_colors', '', '    This is just a simple wrapper around the `seaborn.crayons` dictionary.', '', '    Parameters', '    ----------', '    colors : list of strings', '        List of keys in the `seaborn.crayons` dictionary.', '', '    Returns', '    -------', '    palette', '        A list of colors as RGB tuples.', '', '    See Also', '    --------', '    xkcd_palette : Make a palette with named colors from the XKCD color survey.', '', '    \"\"\"', '    palette = [crayons[name] for name in colors]', '    return color_palette(palette, len(palette))']}, {'name': 'cubehelix_palette', 'start_line': 665, 'end_line': 761, 'text': ['def cubehelix_palette(n_colors=6, start=0, rot=.4, gamma=1.0, hue=0.8,', '                      light=.85, dark=.15, reverse=False, as_cmap=False):', '    \"\"\"Make a sequential palette from the cubehelix system.', '', '    This produces a colormap with linearly-decreasing (or increasing)', '    brightness. That means that information will be preserved if printed to', '    black and white or viewed by someone who is colorblind.  \"cubehelix\" is', '    also available as a matplotlib-based palette, but this function gives the', '    user more control over the look of the palette and has a different set of', '    defaults.', '', '    In addition to using this function, it is also possible to generate a', '    cubehelix palette generally in seaborn using a string starting with', '    `ch:` and containing other parameters (e.g. `\"ch:s=.25,r=-.5\"`).', '', '    Parameters', '    ----------', '    n_colors : int', '        Number of colors in the palette.', '    start : float, 0 <= start <= 3', '        The hue value at the start of the helix.', '    rot : float', '        Rotations around the hue wheel over the range of the palette.', '    gamma : float 0 <= gamma', '        Nonlinearity to emphasize dark (gamma < 1) or light (gamma > 1) colors.', '    hue : float, 0 <= hue <= 1', '        Saturation of the colors.', '    dark : float 0 <= dark <= 1', '        Intensity of the darkest color in the palette.', '    light : float 0 <= light <= 1', '        Intensity of the lightest color in the palette.', '    reverse : bool', '        If True, the palette will go from dark to light.', '    as_cmap : bool', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    choose_cubehelix_palette : Launch an interactive widget to select cubehelix', '                               palette parameters.', '    dark_palette : Create a sequential palette with dark low values.', '    light_palette : Create a sequential palette with bright low values.', '', '    References', '    ----------', '    Green, D. A. (2011). \"A colour scheme for the display of astronomical', '    intensity images\". Bulletin of the Astromical Society of India, Vol. 39,', '    p. 289-295.', '', '    Examples', '    --------', '    .. include:: ../docstrings/cubehelix_palette.rst', '', '    \"\"\"', '    def get_color_function(p0, p1):', '        # Copied from matplotlib because it lives in private module', '        def color(x):', '            # Apply gamma factor to emphasise low or high intensity values', '            xg = x ** gamma', '', '            # Calculate amplitude and angle of deviation from the black', '            # to white diagonal in the plane of constant', '            # perceived intensity.', '            a = hue * xg * (1 - xg) / 2', '', '            phi = 2 * np.pi * (start / 3 + rot * x)', '', '            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))', '        return color', '', '    cdict = {', '        \"red\": get_color_function(-0.14861, 1.78277),', '        \"green\": get_color_function(-0.29227, -0.90649),', '        \"blue\": get_color_function(1.97294, 0.0),', '    }', '', '    cmap = mpl.colors.LinearSegmentedColormap(\"cubehelix\", cdict)', '', '    x = np.linspace(light, dark, int(n_colors))', '    pal = cmap(x)[:, :3].tolist()', '    if reverse:', '        pal = pal[::-1]', '', '    if as_cmap:', '        x_256 = np.linspace(light, dark, 256)', '        if reverse:', '            x_256 = x_256[::-1]', '        pal_256 = cmap(x_256)', '        cmap = mpl.colors.ListedColormap(pal_256, \"seaborn_cubehelix\")', '        return cmap', '    else:', '        return _ColorPalette(pal)']}, {'name': '_parse_cubehelix_args', 'start_line': 764, 'end_line': 796, 'text': ['def _parse_cubehelix_args(argstr):', '    \"\"\"Turn stringified cubehelix params into args/kwargs.\"\"\"', '', '    if argstr.startswith(\"ch:\"):', '        argstr = argstr[3:]', '', '    if argstr.endswith(\"_r\"):', '        reverse = True', '        argstr = argstr[:-2]', '    else:', '        reverse = False', '', '    if not argstr:', '        return [], {\"reverse\": reverse}', '', '    all_args = argstr.split(\",\")', '', '    args = [float(a.strip(\" \")) for a in all_args if \"=\" not in a]', '', '    kwargs = [a.split(\"=\") for a in all_args if \"=\" in a]', '    kwargs = {k.strip(\" \"): float(v.strip(\" \")) for k, v in kwargs}', '', '    kwarg_map = dict(', '        s=\"start\", r=\"rot\", g=\"gamma\",', '        h=\"hue\", l=\"light\", d=\"dark\",  # noqa: E741', '    )', '', '    kwargs = {kwarg_map.get(k, k): v for k, v in kwargs.items()}', '', '    if reverse:', '        kwargs[\"reverse\"] = True', '', '    return args, kwargs']}, {'name': 'set_color_codes', 'start_line': 799, 'end_line': 842, 'text': ['def set_color_codes(palette=\"deep\"):', '    \"\"\"Change how matplotlib color shorthands are interpreted.', '', '    Calling this will change how shorthand codes like \"b\" or \"g\"', '    are interpreted by matplotlib in subsequent plots.', '', '    Parameters', '    ----------', '    palette : {deep, muted, pastel, dark, bright, colorblind}', '        Named seaborn palette to use as the source of colors.', '', '    See Also', '    --------', '    set : Color codes can be set through the high-level seaborn style', '          manager.', '    set_palette : Color codes can also be set through the function that', '                  sets the matplotlib color cycle.', '', '    \"\"\"', '    if palette == \"reset\":', '        colors = [', '            (0., 0., 1.),', '            (0., .5, 0.),', '            (1., 0., 0.),', '            (.75, 0., .75),', '            (.75, .75, 0.),', '            (0., .75, .75),', '            (0., 0., 0.)', '        ]', '    elif not isinstance(palette, str):', '        err = \"set_color_codes requires a named seaborn palette\"', '        raise TypeError(err)', '    elif palette in SEABORN_PALETTES:', '        if not palette.endswith(\"6\"):', '            palette = palette + \"6\"', '        colors = SEABORN_PALETTES[palette] + [(.1, .1, .1)]', '    else:', '        err = f\"Cannot set colors with palette \\'{palette}\\'\"', '        raise ValueError(err)', '', '    for code, color in zip(\"bgrmyck\", colors):', '        rgb = mpl.colors.colorConverter.to_rgb(color)', '        mpl.colors.colorConverter.colors[code] = rgb', '        mpl.colors.colorConverter.cache[code] = rgb']}, {'name': '_repr_png_', 'start_line': 96, 'end_line': 106, 'text': ['    def _repr_png_(self):', '        \"\"\"Generate a PNG representation of the Colormap.\"\"\"', '        import io', '        from PIL import Image', '        import numpy as np', '        IMAGE_SIZE = (400, 50)', '        X = np.tile(np.linspace(0, 1, IMAGE_SIZE[0]), (IMAGE_SIZE[1], 1))', '        pixels = self(X, bytes=True)', '        png_bytes = io.BytesIO()', \"        Image.fromarray(pixels).save(png_bytes, format='png')\", '        return png_bytes.getvalue()']}, {'name': 'get_color_function', 'start_line': 724, 'end_line': 738, 'text': ['    def get_color_function(p0, p1):', '        # Copied from matplotlib because it lives in private module', '        def color(x):', '            # Apply gamma factor to emphasise low or high intensity values', '            xg = x ** gamma', '', '            # Calculate amplitude and angle of deviation from the black', '            # to white diagonal in the plane of constant', '            # perceived intensity.', '            a = hue * xg * (1 - xg) / 2', '', '            phi = 2 * np.pi * (start / 3 + rot * x)', '', '            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))', '        return color']}, {'name': 'color', 'start_line': 726, 'end_line': 737, 'text': ['        def color(x):', '            # Apply gamma factor to emphasise low or high intensity values', '            xg = x ** gamma', '', '            # Calculate amplitude and angle of deviation from the black', '            # to white diagonal in the plane of constant', '            # perceived intensity.', '            a = hue * xg * (1 - xg) / 2', '', '            phi = 2 * np.pi * (start / 3 + rot * x)', '', '            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))']}], 'text': ['import colorsys', 'from itertools import cycle', '', 'import numpy as np', 'import matplotlib as mpl', '', 'from .external import husl', '', 'from .utils import desaturate, get_color_cycle', 'from .colors import xkcd_rgb, crayons', 'from ._compat import get_colormap', '', '', '__all__ = [\"color_palette\", \"hls_palette\", \"husl_palette\", \"mpl_palette\",', '           \"dark_palette\", \"light_palette\", \"diverging_palette\",', '           \"blend_palette\", \"xkcd_palette\", \"crayon_palette\",', '           \"cubehelix_palette\", \"set_color_codes\"]', '', '', 'SEABORN_PALETTES = dict(', '    deep=[\"#4C72B0\", \"#DD8452\", \"#55A868\", \"#C44E52\", \"#8172B3\",', '          \"#937860\", \"#DA8BC3\", \"#8C8C8C\", \"#CCB974\", \"#64B5CD\"],', '    deep6=[\"#4C72B0\", \"#55A868\", \"#C44E52\",', '           \"#8172B3\", \"#CCB974\", \"#64B5CD\"],', '    muted=[\"#4878D0\", \"#EE854A\", \"#6ACC64\", \"#D65F5F\", \"#956CB4\",', '           \"#8C613C\", \"#DC7EC0\", \"#797979\", \"#D5BB67\", \"#82C6E2\"],', '    muted6=[\"#4878D0\", \"#6ACC64\", \"#D65F5F\",', '            \"#956CB4\", \"#D5BB67\", \"#82C6E2\"],', '    pastel=[\"#A1C9F4\", \"#FFB482\", \"#8DE5A1\", \"#FF9F9B\", \"#D0BBFF\",', '            \"#DEBB9B\", \"#FAB0E4\", \"#CFCFCF\", \"#FFFEA3\", \"#B9F2F0\"],', '    pastel6=[\"#A1C9F4\", \"#8DE5A1\", \"#FF9F9B\",', '             \"#D0BBFF\", \"#FFFEA3\", \"#B9F2F0\"],', '    bright=[\"#023EFF\", \"#FF7C00\", \"#1AC938\", \"#E8000B\", \"#8B2BE2\",', '            \"#9F4800\", \"#F14CC1\", \"#A3A3A3\", \"#FFC400\", \"#00D7FF\"],', '    bright6=[\"#023EFF\", \"#1AC938\", \"#E8000B\",', '             \"#8B2BE2\", \"#FFC400\", \"#00D7FF\"],', '    dark=[\"#001C7F\", \"#B1400D\", \"#12711C\", \"#8C0800\", \"#591E71\",', '          \"#592F0D\", \"#A23582\", \"#3C3C3C\", \"#B8850A\", \"#006374\"],', '    dark6=[\"#001C7F\", \"#12711C\", \"#8C0800\",', '           \"#591E71\", \"#B8850A\", \"#006374\"],', '    colorblind=[\"#0173B2\", \"#DE8F05\", \"#029E73\", \"#D55E00\", \"#CC78BC\",', '                \"#CA9161\", \"#FBAFE4\", \"#949494\", \"#ECE133\", \"#56B4E9\"],', '    colorblind6=[\"#0173B2\", \"#029E73\", \"#D55E00\",', '                 \"#CC78BC\", \"#ECE133\", \"#56B4E9\"]', ')', '', '', 'MPL_QUAL_PALS = {', '    \"tab10\": 10, \"tab20\": 20, \"tab20b\": 20, \"tab20c\": 20,', '    \"Set1\": 9, \"Set2\": 8, \"Set3\": 12,', '    \"Accent\": 8, \"Paired\": 12,', '    \"Pastel1\": 9, \"Pastel2\": 8, \"Dark2\": 8,', '}', '', '', 'QUAL_PALETTE_SIZES = MPL_QUAL_PALS.copy()', 'QUAL_PALETTE_SIZES.update({k: len(v) for k, v in SEABORN_PALETTES.items()})', 'QUAL_PALETTES = list(QUAL_PALETTE_SIZES.keys())', '', '', 'class _ColorPalette(list):', '    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"', '    def __enter__(self):', '        \"\"\"Open the context.\"\"\"', '        from .rcmod import set_palette', '        self._orig_palette = color_palette()', '        set_palette(self)', '        return self', '', '    def __exit__(self, *args):', '        \"\"\"Close the context.\"\"\"', '        from .rcmod import set_palette', '        set_palette(self._orig_palette)', '', '    def as_hex(self):', '        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"', '        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]', '        return _ColorPalette(hex)', '', '    def _repr_html_(self):', '        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"', '        s = 55', '        n = len(self)', '        html = f\\'<svg  width=\"{n * s}\" height=\"{s}\">\\'', '        for i, c in enumerate(self.as_hex()):', '            html += (', '                f\\'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};\\'', '                \\'stroke-width:2;stroke:rgb(255,255,255)\"/>\\'', '            )', \"        html += '</svg>'\", '        return html', '', '', 'def _patch_colormap_display():', '    \"\"\"Simplify the rich display of matplotlib color maps in a notebook.\"\"\"', '    def _repr_png_(self):', '        \"\"\"Generate a PNG representation of the Colormap.\"\"\"', '        import io', '        from PIL import Image', '        import numpy as np', '        IMAGE_SIZE = (400, 50)', '        X = np.tile(np.linspace(0, 1, IMAGE_SIZE[0]), (IMAGE_SIZE[1], 1))', '        pixels = self(X, bytes=True)', '        png_bytes = io.BytesIO()', \"        Image.fromarray(pixels).save(png_bytes, format='png')\", '        return png_bytes.getvalue()', '', '    def _repr_html_(self):', '        \"\"\"Generate an HTML representation of the Colormap.\"\"\"', '        import base64', '        png_bytes = self._repr_png_()', \"        png_base64 = base64.b64encode(png_bytes).decode('ascii')\", \"        return ('<img '\", '                + \\'alt=\"\\' + self.name + \\' color map\" \\'', '                + \\'title=\"\\' + self.name + \\'\"\\'', '                + \\'src=\"data:image/png;base64,\\' + png_base64 + \\'\">\\')', '', '    mpl.colors.Colormap._repr_png_ = _repr_png_', '    mpl.colors.Colormap._repr_html_ = _repr_html_', '', '', 'def color_palette(palette=None, n_colors=None, desat=None, as_cmap=False):', '    \"\"\"Return a list of colors or continuous colormap defining a palette.', '', '    Possible ``palette`` values include:', '        - Name of a seaborn palette (deep, muted, bright, pastel, dark, colorblind)', '        - Name of matplotlib colormap', \"        - 'husl' or 'hls'\", \"        - 'ch:<cubehelix arguments>'\", \"        - 'light:<color>', 'dark:<color>', 'blend:<color>,<color>',\", '        - A sequence of colors in any format matplotlib accepts', '', '    Calling this function with ``palette=None`` will return the current', '    matplotlib color cycle.', '', '    This function can also be used in a ``with`` statement to temporarily', '    set the color cycle for a plot or set of plots.', '', '    See the :ref:`tutorial <palette_tutorial>` for more information.', '', '    Parameters', '    ----------', '    palette : None, string, or sequence, optional', '        Name of palette or None to return current palette. If a sequence, input', '        colors are used but possibly cycled and desaturated.', '    n_colors : int, optional', '        Number of colors in the palette. If ``None``, the default will depend', '        on how ``palette`` is specified. Named palettes default to 6 colors,', '        but grabbing the current palette or passing in a list of colors will', '        not change the number of colors unless this is specified. Asking for', '        more colors than exist in the palette will cause it to cycle. Ignored', '        when ``as_cmap`` is True.', '    desat : float, optional', '        Proportion to desaturate each color by.', '    as_cmap : bool', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', '', '    Returns', '    -------', '    list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    set_palette : Set the default color cycle for all plots.', '    set_color_codes : Reassign color codes like ``\"b\"``, ``\"g\"``, etc. to', '                      colors from one of the seaborn palettes.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/color_palette.rst', '', '    \"\"\"', '    if palette is None:', '        palette = get_color_cycle()', '        if n_colors is None:', '            n_colors = len(palette)', '', '    elif not isinstance(palette, str):', '        palette = palette', '        if n_colors is None:', '            n_colors = len(palette)', '    else:', '', '        if n_colors is None:', '            # Use all colors in a qualitative palette or 6 of another kind', '            n_colors = QUAL_PALETTE_SIZES.get(palette, 6)', '', '        if palette in SEABORN_PALETTES:', '            # Named \"seaborn variant\" of matplotlib default color cycle', '            palette = SEABORN_PALETTES[palette]', '', '        elif palette == \"hls\":', '            # Evenly spaced colors in cylindrical RGB space', '            palette = hls_palette(n_colors, as_cmap=as_cmap)', '', '        elif palette == \"husl\":', '            # Evenly spaced colors in cylindrical Lab space', '            palette = husl_palette(n_colors, as_cmap=as_cmap)', '', '        elif palette.lower() == \"jet\":', '            # Paternalism', '            raise ValueError(\"No.\")', '', '        elif palette.startswith(\"ch:\"):', '            # Cubehelix palette with params specified in string', '            args, kwargs = _parse_cubehelix_args(palette)', '            palette = cubehelix_palette(n_colors, *args, **kwargs, as_cmap=as_cmap)', '', '        elif palette.startswith(\"light:\"):', '            # light palette to color specified in string', '            _, color = palette.split(\":\")', '            reverse = color.endswith(\"_r\")', '            if reverse:', '                color = color[:-2]', '            palette = light_palette(color, n_colors, reverse=reverse, as_cmap=as_cmap)', '', '        elif palette.startswith(\"dark:\"):', '            # light palette to color specified in string', '            _, color = palette.split(\":\")', '            reverse = color.endswith(\"_r\")', '            if reverse:', '                color = color[:-2]', '            palette = dark_palette(color, n_colors, reverse=reverse, as_cmap=as_cmap)', '', '        elif palette.startswith(\"blend:\"):', '            # blend palette between colors specified in string', '            _, colors = palette.split(\":\")', '            colors = colors.split(\",\")', '            palette = blend_palette(colors, n_colors, as_cmap=as_cmap)', '', '        else:', '            try:', '                # Perhaps a named matplotlib colormap?', '                palette = mpl_palette(palette, n_colors, as_cmap=as_cmap)', '            except (ValueError, KeyError):  # Error class changed in mpl36', '                raise ValueError(f\"{palette} is not a valid palette name\")', '', '    if desat is not None:', '        palette = [desaturate(c, desat) for c in palette]', '', '    if not as_cmap:', '', '        # Always return as many colors as we asked for', '        pal_cycle = cycle(palette)', '        palette = [next(pal_cycle) for _ in range(n_colors)]', '', '        # Always return in r, g, b tuple format', '        try:', '            palette = map(mpl.colors.colorConverter.to_rgb, palette)', '            palette = _ColorPalette(palette)', '        except ValueError:', '            raise ValueError(f\"Could not generate a palette for {palette}\")', '', '    return palette', '', '', 'def hls_palette(n_colors=6, h=.01, l=.6, s=.65, as_cmap=False):  # noqa', '    \"\"\"', '    Return hues with constant lightness and saturation in the HLS system.', '', '    The hues are evenly sampled along a circular path. The resulting palette will be', '    appropriate for categorical or cyclical data.', '', '    The `h`, `l`, and `s` values should be between 0 and 1.', '', '    .. note::', '        While the separation of the resulting colors will be mathematically', '        constant, the HLS system does not construct a perceptually-uniform space,', '        so their apparent intensity will vary.', '', '    Parameters', '    ----------', '    n_colors : int', '        Number of colors in the palette.', '    h : float', '        The value of the first hue.', '    l : float', '        The lightness value.', '    s : float', '        The saturation intensity.', '    as_cmap : bool', '        If True, return a matplotlib colormap object.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    husl_palette : Make a palette using evenly spaced hues in the HUSL system.', '', '    Examples', '    --------', '    .. include:: ../docstrings/hls_palette.rst', '', '    \"\"\"', '    if as_cmap:', '        n_colors = 256', '    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]', '    hues += h', '    hues %= 1', '    hues -= hues.astype(int)', '    palette = [colorsys.hls_to_rgb(h_i, l, s) for h_i in hues]', '    if as_cmap:', '        return mpl.colors.ListedColormap(palette, \"hls\")', '    else:', '        return _ColorPalette(palette)', '', '', 'def husl_palette(n_colors=6, h=.01, s=.9, l=.65, as_cmap=False):  # noqa', '    \"\"\"', '    Return hues with constant lightness and saturation in the HUSL system.', '', '    The hues are evenly sampled along a circular path. The resulting palette will be', '    appropriate for categorical or cyclical data.', '', '    The `h`, `l`, and `s` values should be between 0 and 1.', '', '    This function is similar to :func:`hls_palette`, but it uses a nonlinear color', '    space that is more perceptually uniform.', '', '    Parameters', '    ----------', '    n_colors : int', '        Number of colors in the palette.', '    h : float', '        The value of the first hue.', '    l : float', '        The lightness value.', '    s : float', '        The saturation intensity.', '    as_cmap : bool', '        If True, return a matplotlib colormap object.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    hls_palette : Make a palette using evenly spaced hues in the HSL system.', '', '    Examples', '    --------', '    .. include:: ../docstrings/husl_palette.rst', '', '    \"\"\"', '    if as_cmap:', '        n_colors = 256', '    hues = np.linspace(0, 1, int(n_colors) + 1)[:-1]', '    hues += h', '    hues %= 1', '    hues *= 359', '    s *= 99', '    l *= 99  # noqa', '    palette = [_color_to_rgb((h_i, s, l), input=\"husl\") for h_i in hues]', '    if as_cmap:', '        return mpl.colors.ListedColormap(palette, \"hsl\")', '    else:', '        return _ColorPalette(palette)', '', '', 'def mpl_palette(name, n_colors=6, as_cmap=False):', '    \"\"\"', '    Return a palette or colormap from the matplotlib registry.', '', '    For continuous palettes, evenly-spaced discrete samples are chosen while', '    excluding the minimum and maximum value in the colormap to provide better', '    contrast at the extremes.', '', '    For qualitative palettes (e.g. those from colorbrewer), exact values are', '    indexed (rather than interpolated), but fewer than `n_colors` can be returned', '    if the palette does not define that many.', '', '    Parameters', '    ----------', '    name : string', '        Name of the palette. This should be a named matplotlib colormap.', '    n_colors : int', '        Number of discrete colors in the palette.', '', '    Returns', '    -------', '    list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    Examples', '    --------', '    .. include: ../docstrings/mpl_palette.rst', '', '    \"\"\"', '    if name.endswith(\"_d\"):', '        sub_name = name[:-2]', '        if sub_name.endswith(\"_r\"):', '            reverse = True', '            sub_name = sub_name[:-2]', '        else:', '            reverse = False', '        pal = color_palette(sub_name, 2) + [\"#333333\"]', '        if reverse:', '            pal = pal[::-1]', '        cmap = blend_palette(pal, n_colors, as_cmap=True)', '    else:', '        cmap = get_colormap(name)', '', '    if name in MPL_QUAL_PALS:', '        bins = np.linspace(0, 1, MPL_QUAL_PALS[name])[:n_colors]', '    else:', '        bins = np.linspace(0, 1, int(n_colors) + 2)[1:-1]', '    palette = list(map(tuple, cmap(bins)[:, :3]))', '', '    if as_cmap:', '        return cmap', '    else:', '        return _ColorPalette(palette)', '', '', 'def _color_to_rgb(color, input):', '    \"\"\"Add some more flexibility to color choices.\"\"\"', '    if input == \"hls\":', '        color = colorsys.hls_to_rgb(*color)', '    elif input == \"husl\":', '        color = husl.husl_to_rgb(*color)', '        color = tuple(np.clip(color, 0, 1))', '    elif input == \"xkcd\":', '        color = xkcd_rgb[color]', '', '    return mpl.colors.to_rgb(color)', '', '', 'def dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input=\"rgb\"):', '    \"\"\"Make a sequential palette that blends from dark to ``color``.', '', '    This kind of palette is good for data that range between relatively', '    uninteresting low values and interesting high values.', '', '    The ``color`` parameter can be specified in a number of ways, including', '    all options for defining a color in matplotlib and several additional', '    color spaces that are handled by seaborn. You can also use the database', '    of named colors from the XKCD color survey.', '', '    If you are using the IPython notebook, you can also choose this palette', '    interactively with the :func:`choose_dark_palette` function.', '', '    Parameters', '    ----------', '    color : base color for high values', '        hex, rgb-tuple, or html color name', '    n_colors : int, optional', '        number of colors in the palette', '    reverse : bool, optional', '        if True, reverse the direction of the blend', '    as_cmap : bool, optional', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', \"    input : {'rgb', 'hls', 'husl', xkcd'}\", '        Color space to interpret the input color. The first three options', '        apply to tuple inputs and the latter applies to string inputs.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    light_palette : Create a sequential palette with bright low values.', '    diverging_palette : Create a diverging palette with two colors.', '', '    Examples', '    --------', '    .. include:: ../docstrings/dark_palette.rst', '', '    \"\"\"', '    rgb = _color_to_rgb(color, input)', '    h, s, l = husl.rgb_to_husl(*rgb)', '    gray_s, gray_l = .15 * s, 15', '    gray = _color_to_rgb((h, gray_s, gray_l), input=\"husl\")', '    colors = [rgb, gray] if reverse else [gray, rgb]', '    return blend_palette(colors, n_colors, as_cmap)', '', '', 'def light_palette(color, n_colors=6, reverse=False, as_cmap=False, input=\"rgb\"):', '    \"\"\"Make a sequential palette that blends from light to ``color``.', '', '    The ``color`` parameter can be specified in a number of ways, including', '    all options for defining a color in matplotlib and several additional', '    color spaces that are handled by seaborn. You can also use the database', '    of named colors from the XKCD color survey.', '', '    If you are using a Jupyter notebook, you can also choose this palette', '    interactively with the :func:`choose_light_palette` function.', '', '    Parameters', '    ----------', '    color : base color for high values', '        hex code, html color name, or tuple in `input` space.', '    n_colors : int, optional', '        number of colors in the palette', '    reverse : bool, optional', '        if True, reverse the direction of the blend', '    as_cmap : bool, optional', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', \"    input : {'rgb', 'hls', 'husl', xkcd'}\", '        Color space to interpret the input color. The first three options', '        apply to tuple inputs and the latter applies to string inputs.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    dark_palette : Create a sequential palette with dark low values.', '    diverging_palette : Create a diverging palette with two colors.', '', '    Examples', '    --------', '    .. include:: ../docstrings/light_palette.rst', '', '    \"\"\"', '    rgb = _color_to_rgb(color, input)', '    h, s, l = husl.rgb_to_husl(*rgb)', '    gray_s, gray_l = .15 * s, 95', '    gray = _color_to_rgb((h, gray_s, gray_l), input=\"husl\")', '    colors = [rgb, gray] if reverse else [gray, rgb]', '    return blend_palette(colors, n_colors, as_cmap)', '', '', 'def diverging_palette(h_neg, h_pos, s=75, l=50, sep=1, n=6,  # noqa', '                      center=\"light\", as_cmap=False):', '    \"\"\"Make a diverging palette between two HUSL colors.', '', '    If you are using the IPython notebook, you can also choose this palette', '    interactively with the :func:`choose_diverging_palette` function.', '', '    Parameters', '    ----------', '    h_neg, h_pos : float in [0, 359]', '        Anchor hues for negative and positive extents of the map.', '    s : float in [0, 100], optional', '        Anchor saturation for both extents of the map.', '    l : float in [0, 100], optional', '        Anchor lightness for both extents of the map.', '    sep : int, optional', '        Size of the intermediate region.', '    n : int, optional', '        Number of colors in the palette (if not returning a cmap)', '    center : {\"light\", \"dark\"}, optional', '        Whether the center of the palette is light or dark', '    as_cmap : bool, optional', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    dark_palette : Create a sequential palette with dark values.', '    light_palette : Create a sequential palette with light values.', '', '    Examples', '    --------', '    .. include: ../docstrings/diverging_palette.rst', '', '    \"\"\"', '    palfunc = dict(dark=dark_palette, light=light_palette)[center]', '    n_half = int(128 - (sep // 2))', '    neg = palfunc((h_neg, s, l), n_half, reverse=True, input=\"husl\")', '    pos = palfunc((h_pos, s, l), n_half, input=\"husl\")', '    midpoint = dict(light=[(.95, .95, .95)], dark=[(.133, .133, .133)])[center]', '    mid = midpoint * sep', '    pal = blend_palette(np.concatenate([neg, mid, pos]), n, as_cmap=as_cmap)', '    return pal', '', '', 'def blend_palette(colors, n_colors=6, as_cmap=False, input=\"rgb\"):', '    \"\"\"Make a palette that blends between a list of colors.', '', '    Parameters', '    ----------', '    colors : sequence of colors in various formats interpreted by `input`', '        hex code, html color name, or tuple in `input` space.', '    n_colors : int, optional', '        Number of colors in the palette.', '    as_cmap : bool, optional', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    Examples', '    --------', '    .. include: ../docstrings/blend_palette.rst', '', '    \"\"\"', '    colors = [_color_to_rgb(color, input) for color in colors]', '    name = \"blend\"', '    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)', '    if not as_cmap:', '        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]  # no alpha', '        pal = _ColorPalette(map(tuple, rgb_array))', '    return pal', '', '', 'def xkcd_palette(colors):', '    \"\"\"Make a palette with color names from the xkcd color survey.', '', '    See xkcd for the full list of colors: https://xkcd.com/color/rgb/', '', '    This is just a simple wrapper around the `seaborn.xkcd_rgb` dictionary.', '', '    Parameters', '    ----------', '    colors : list of strings', '        List of keys in the `seaborn.xkcd_rgb` dictionary.', '', '    Returns', '    -------', '    palette', '        A list of colors as RGB tuples.', '', '    See Also', '    --------', '    crayon_palette : Make a palette with Crayola crayon colors.', '', '    \"\"\"', '    palette = [xkcd_rgb[name] for name in colors]', '    return color_palette(palette, len(palette))', '', '', 'def crayon_palette(colors):', '    \"\"\"Make a palette with color names from Crayola crayons.', '', '    Colors are taken from here:', '    https://en.wikipedia.org/wiki/List_of_Crayola_crayon_colors', '', '    This is just a simple wrapper around the `seaborn.crayons` dictionary.', '', '    Parameters', '    ----------', '    colors : list of strings', '        List of keys in the `seaborn.crayons` dictionary.', '', '    Returns', '    -------', '    palette', '        A list of colors as RGB tuples.', '', '    See Also', '    --------', '    xkcd_palette : Make a palette with named colors from the XKCD color survey.', '', '    \"\"\"', '    palette = [crayons[name] for name in colors]', '    return color_palette(palette, len(palette))', '', '', 'def cubehelix_palette(n_colors=6, start=0, rot=.4, gamma=1.0, hue=0.8,', '                      light=.85, dark=.15, reverse=False, as_cmap=False):', '    \"\"\"Make a sequential palette from the cubehelix system.', '', '    This produces a colormap with linearly-decreasing (or increasing)', '    brightness. That means that information will be preserved if printed to', '    black and white or viewed by someone who is colorblind.  \"cubehelix\" is', '    also available as a matplotlib-based palette, but this function gives the', '    user more control over the look of the palette and has a different set of', '    defaults.', '', '    In addition to using this function, it is also possible to generate a', '    cubehelix palette generally in seaborn using a string starting with', '    `ch:` and containing other parameters (e.g. `\"ch:s=.25,r=-.5\"`).', '', '    Parameters', '    ----------', '    n_colors : int', '        Number of colors in the palette.', '    start : float, 0 <= start <= 3', '        The hue value at the start of the helix.', '    rot : float', '        Rotations around the hue wheel over the range of the palette.', '    gamma : float 0 <= gamma', '        Nonlinearity to emphasize dark (gamma < 1) or light (gamma > 1) colors.', '    hue : float, 0 <= hue <= 1', '        Saturation of the colors.', '    dark : float 0 <= dark <= 1', '        Intensity of the darkest color in the palette.', '    light : float 0 <= light <= 1', '        Intensity of the lightest color in the palette.', '    reverse : bool', '        If True, the palette will go from dark to light.', '    as_cmap : bool', '        If True, return a :class:`matplotlib.colors.ListedColormap`.', '', '    Returns', '    -------', '    palette', '        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`', '', '    See Also', '    --------', '    choose_cubehelix_palette : Launch an interactive widget to select cubehelix', '                               palette parameters.', '    dark_palette : Create a sequential palette with dark low values.', '    light_palette : Create a sequential palette with bright low values.', '', '    References', '    ----------', '    Green, D. A. (2011). \"A colour scheme for the display of astronomical', '    intensity images\". Bulletin of the Astromical Society of India, Vol. 39,', '    p. 289-295.', '', '    Examples', '    --------', '    .. include:: ../docstrings/cubehelix_palette.rst', '', '    \"\"\"', '    def get_color_function(p0, p1):', '        # Copied from matplotlib because it lives in private module', '        def color(x):', '            # Apply gamma factor to emphasise low or high intensity values', '            xg = x ** gamma', '', '            # Calculate amplitude and angle of deviation from the black', '            # to white diagonal in the plane of constant', '            # perceived intensity.', '            a = hue * xg * (1 - xg) / 2', '', '            phi = 2 * np.pi * (start / 3 + rot * x)', '', '            return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))', '        return color', '', '    cdict = {', '        \"red\": get_color_function(-0.14861, 1.78277),', '        \"green\": get_color_function(-0.29227, -0.90649),', '        \"blue\": get_color_function(1.97294, 0.0),', '    }', '', '    cmap = mpl.colors.LinearSegmentedColormap(\"cubehelix\", cdict)', '', '    x = np.linspace(light, dark, int(n_colors))', '    pal = cmap(x)[:, :3].tolist()', '    if reverse:', '        pal = pal[::-1]', '', '    if as_cmap:', '        x_256 = np.linspace(light, dark, 256)', '        if reverse:', '            x_256 = x_256[::-1]', '        pal_256 = cmap(x_256)', '        cmap = mpl.colors.ListedColormap(pal_256, \"seaborn_cubehelix\")', '        return cmap', '    else:', '        return _ColorPalette(pal)', '', '', 'def _parse_cubehelix_args(argstr):', '    \"\"\"Turn stringified cubehelix params into args/kwargs.\"\"\"', '', '    if argstr.startswith(\"ch:\"):', '        argstr = argstr[3:]', '', '    if argstr.endswith(\"_r\"):', '        reverse = True', '        argstr = argstr[:-2]', '    else:', '        reverse = False', '', '    if not argstr:', '        return [], {\"reverse\": reverse}', '', '    all_args = argstr.split(\",\")', '', '    args = [float(a.strip(\" \")) for a in all_args if \"=\" not in a]', '', '    kwargs = [a.split(\"=\") for a in all_args if \"=\" in a]', '    kwargs = {k.strip(\" \"): float(v.strip(\" \")) for k, v in kwargs}', '', '    kwarg_map = dict(', '        s=\"start\", r=\"rot\", g=\"gamma\",', '        h=\"hue\", l=\"light\", d=\"dark\",  # noqa: E741', '    )', '', '    kwargs = {kwarg_map.get(k, k): v for k, v in kwargs.items()}', '', '    if reverse:', '        kwargs[\"reverse\"] = True', '', '    return args, kwargs', '', '', 'def set_color_codes(palette=\"deep\"):', '    \"\"\"Change how matplotlib color shorthands are interpreted.', '', '    Calling this will change how shorthand codes like \"b\" or \"g\"', '    are interpreted by matplotlib in subsequent plots.', '', '    Parameters', '    ----------', '    palette : {deep, muted, pastel, dark, bright, colorblind}', '        Named seaborn palette to use as the source of colors.', '', '    See Also', '    --------', '    set : Color codes can be set through the high-level seaborn style', '          manager.', '    set_palette : Color codes can also be set through the function that', '                  sets the matplotlib color cycle.', '', '    \"\"\"', '    if palette == \"reset\":', '        colors = [', '            (0., 0., 1.),', '            (0., .5, 0.),', '            (1., 0., 0.),', '            (.75, 0., .75),', '            (.75, .75, 0.),', '            (0., .75, .75),', '            (0., 0., 0.)', '        ]', '    elif not isinstance(palette, str):', '        err = \"set_color_codes requires a named seaborn palette\"', '        raise TypeError(err)', '    elif palette in SEABORN_PALETTES:', '        if not palette.endswith(\"6\"):', '            palette = palette + \"6\"', '        colors = SEABORN_PALETTES[palette] + [(.1, .1, .1)]', '    else:', '        err = f\"Cannot set colors with palette \\'{palette}\\'\"', '        raise ValueError(err)', '', '    for code, color in zip(\"bgrmyck\", colors):', '        rgb = mpl.colors.colorConverter.to_rgb(color)', '        mpl.colors.colorConverter.colors[code] = rgb', '        mpl.colors.colorConverter.cache[code] = rgb']}, '_statistics.py': {'classes': [{'name': 'KDE', 'start_line': 41, 'end_line': 194, 'text': ['class KDE:', '    \"\"\"Univariate and bivariate kernel density estimator.\"\"\"', '    def __init__(', '        self, *,', '        bw_method=None,', '        bw_adjust=1,', '        gridsize=200,', '        cut=3,', '        clip=None,', '        cumulative=False,', '    ):', '        \"\"\"Initialize the estimator with its parameters.', '', '        Parameters', '        ----------', '        bw_method : string, scalar, or callable, optional', '            Method for determining the smoothing bandwidth to use; passed to', '            :class:`scipy.stats.gaussian_kde`.', '        bw_adjust : number, optional', '            Factor that multiplicatively scales the value chosen using', '            ``bw_method``. Increasing will make the curve smoother. See Notes.', '        gridsize : int, optional', '            Number of points on each dimension of the evaluation grid.', '        cut : number, optional', '            Factor, multiplied by the smoothing bandwidth, that determines how', '            far the evaluation grid extends past the extreme datapoints. When', '            set to 0, truncate the curve at the data limits.', '        clip : pair of numbers or None, or a pair of such pairs', '            Do not evaluate the density outside of these limits.', '        cumulative : bool, optional', '            If True, estimate a cumulative distribution function. Requires scipy.', '', '        \"\"\"', '        if clip is None:', '            clip = None, None', '', '        self.bw_method = bw_method', '        self.bw_adjust = bw_adjust', '        self.gridsize = gridsize', '        self.cut = cut', '        self.clip = clip', '        self.cumulative = cumulative', '', '        if cumulative and _no_scipy:', '            raise RuntimeError(\"Cumulative KDE evaluation requires scipy\")', '', '        self.support = None', '', '    def _define_support_grid(self, x, bw, cut, clip, gridsize):', '        \"\"\"Create the grid of evaluation points depending for vector x.\"\"\"', '        clip_lo = -np.inf if clip[0] is None else clip[0]', '        clip_hi = +np.inf if clip[1] is None else clip[1]', '        gridmin = max(x.min() - bw * cut, clip_lo)', '        gridmax = min(x.max() + bw * cut, clip_hi)', '        return np.linspace(gridmin, gridmax, gridsize)', '', '    def _define_support_univariate(self, x, weights):', '        \"\"\"Create a 1D grid of evaluation points.\"\"\"', '        kde = self._fit(x, weights)', '        bw = np.sqrt(kde.covariance.squeeze())', '        grid = self._define_support_grid(', '            x, bw, self.cut, self.clip, self.gridsize', '        )', '        return grid', '', '    def _define_support_bivariate(self, x1, x2, weights):', '        \"\"\"Create a 2D grid of evaluation points.\"\"\"', '        clip = self.clip', '        if clip[0] is None or np.isscalar(clip[0]):', '            clip = (clip, clip)', '', '        kde = self._fit([x1, x2], weights)', '        bw = np.sqrt(np.diag(kde.covariance).squeeze())', '', '        grid1 = self._define_support_grid(', '            x1, bw[0], self.cut, clip[0], self.gridsize', '        )', '        grid2 = self._define_support_grid(', '            x2, bw[1], self.cut, clip[1], self.gridsize', '        )', '', '        return grid1, grid2', '', '    def define_support(self, x1, x2=None, weights=None, cache=True):', '        \"\"\"Create the evaluation grid for a given data set.\"\"\"', '        if x2 is None:', '            support = self._define_support_univariate(x1, weights)', '        else:', '            support = self._define_support_bivariate(x1, x2, weights)', '', '        if cache:', '            self.support = support', '', '        return support', '', '    def _fit(self, fit_data, weights=None):', '        \"\"\"Fit the scipy kde while adding bw_adjust logic and version check.\"\"\"', '        fit_kws = {\"bw_method\": self.bw_method}', '        if weights is not None:', '            fit_kws[\"weights\"] = weights', '', '        kde = gaussian_kde(fit_data, **fit_kws)', '        kde.set_bandwidth(kde.factor * self.bw_adjust)', '', '        return kde', '', '    def _eval_univariate(self, x, weights=None):', '        \"\"\"Fit and evaluate a univariate on univariate data.\"\"\"', '        support = self.support', '        if support is None:', '            support = self.define_support(x, cache=False)', '', '        kde = self._fit(x, weights)', '', '        if self.cumulative:', '            s_0 = support[0]', '            density = np.array([', '                kde.integrate_box_1d(s_0, s_i) for s_i in support', '            ])', '        else:', '            density = kde(support)', '', '        return density, support', '', '    def _eval_bivariate(self, x1, x2, weights=None):', '        \"\"\"Fit and evaluate a univariate on bivariate data.\"\"\"', '        support = self.support', '        if support is None:', '            support = self.define_support(x1, x2, cache=False)', '', '        kde = self._fit([x1, x2], weights)', '', '        if self.cumulative:', '', '            grid1, grid2 = support', '            density = np.zeros((grid1.size, grid2.size))', '            p0 = grid1.min(), grid2.min()', '            for i, xi in enumerate(grid1):', '                for j, xj in enumerate(grid2):', '                    density[i, j] = kde.integrate_box(p0, (xi, xj))', '', '        else:', '', '            xx1, xx2 = np.meshgrid(*support)', '            density = kde([xx1.ravel(), xx2.ravel()]).reshape(xx1.shape)', '', '        return density, support', '', '    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Fit and evaluate on univariate or bivariate data.\"\"\"', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)'], 'methods': [{'name': '__init__', 'start_line': 43, 'end_line': 87, 'text': ['    def __init__(', '        self, *,', '        bw_method=None,', '        bw_adjust=1,', '        gridsize=200,', '        cut=3,', '        clip=None,', '        cumulative=False,', '    ):', '        \"\"\"Initialize the estimator with its parameters.', '', '        Parameters', '        ----------', '        bw_method : string, scalar, or callable, optional', '            Method for determining the smoothing bandwidth to use; passed to', '            :class:`scipy.stats.gaussian_kde`.', '        bw_adjust : number, optional', '            Factor that multiplicatively scales the value chosen using', '            ``bw_method``. Increasing will make the curve smoother. See Notes.', '        gridsize : int, optional', '            Number of points on each dimension of the evaluation grid.', '        cut : number, optional', '            Factor, multiplied by the smoothing bandwidth, that determines how', '            far the evaluation grid extends past the extreme datapoints. When', '            set to 0, truncate the curve at the data limits.', '        clip : pair of numbers or None, or a pair of such pairs', '            Do not evaluate the density outside of these limits.', '        cumulative : bool, optional', '            If True, estimate a cumulative distribution function. Requires scipy.', '', '        \"\"\"', '        if clip is None:', '            clip = None, None', '', '        self.bw_method = bw_method', '        self.bw_adjust = bw_adjust', '        self.gridsize = gridsize', '        self.cut = cut', '        self.clip = clip', '        self.cumulative = cumulative', '', '        if cumulative and _no_scipy:', '            raise RuntimeError(\"Cumulative KDE evaluation requires scipy\")', '', '        self.support = None']}, {'name': '_define_support_grid', 'start_line': 89, 'end_line': 95, 'text': ['    def _define_support_grid(self, x, bw, cut, clip, gridsize):', '        \"\"\"Create the grid of evaluation points depending for vector x.\"\"\"', '        clip_lo = -np.inf if clip[0] is None else clip[0]', '        clip_hi = +np.inf if clip[1] is None else clip[1]', '        gridmin = max(x.min() - bw * cut, clip_lo)', '        gridmax = min(x.max() + bw * cut, clip_hi)', '        return np.linspace(gridmin, gridmax, gridsize)']}, {'name': '_define_support_univariate', 'start_line': 97, 'end_line': 104, 'text': ['    def _define_support_univariate(self, x, weights):', '        \"\"\"Create a 1D grid of evaluation points.\"\"\"', '        kde = self._fit(x, weights)', '        bw = np.sqrt(kde.covariance.squeeze())', '        grid = self._define_support_grid(', '            x, bw, self.cut, self.clip, self.gridsize', '        )', '        return grid']}, {'name': '_define_support_bivariate', 'start_line': 106, 'end_line': 122, 'text': ['    def _define_support_bivariate(self, x1, x2, weights):', '        \"\"\"Create a 2D grid of evaluation points.\"\"\"', '        clip = self.clip', '        if clip[0] is None or np.isscalar(clip[0]):', '            clip = (clip, clip)', '', '        kde = self._fit([x1, x2], weights)', '        bw = np.sqrt(np.diag(kde.covariance).squeeze())', '', '        grid1 = self._define_support_grid(', '            x1, bw[0], self.cut, clip[0], self.gridsize', '        )', '        grid2 = self._define_support_grid(', '            x2, bw[1], self.cut, clip[1], self.gridsize', '        )', '', '        return grid1, grid2']}, {'name': 'define_support', 'start_line': 124, 'end_line': 134, 'text': ['    def define_support(self, x1, x2=None, weights=None, cache=True):', '        \"\"\"Create the evaluation grid for a given data set.\"\"\"', '        if x2 is None:', '            support = self._define_support_univariate(x1, weights)', '        else:', '            support = self._define_support_bivariate(x1, x2, weights)', '', '        if cache:', '            self.support = support', '', '        return support']}, {'name': '_fit', 'start_line': 136, 'end_line': 145, 'text': ['    def _fit(self, fit_data, weights=None):', '        \"\"\"Fit the scipy kde while adding bw_adjust logic and version check.\"\"\"', '        fit_kws = {\"bw_method\": self.bw_method}', '        if weights is not None:', '            fit_kws[\"weights\"] = weights', '', '        kde = gaussian_kde(fit_data, **fit_kws)', '        kde.set_bandwidth(kde.factor * self.bw_adjust)', '', '        return kde']}, {'name': '_eval_univariate', 'start_line': 147, 'end_line': 163, 'text': ['    def _eval_univariate(self, x, weights=None):', '        \"\"\"Fit and evaluate a univariate on univariate data.\"\"\"', '        support = self.support', '        if support is None:', '            support = self.define_support(x, cache=False)', '', '        kde = self._fit(x, weights)', '', '        if self.cumulative:', '            s_0 = support[0]', '            density = np.array([', '                kde.integrate_box_1d(s_0, s_i) for s_i in support', '            ])', '        else:', '            density = kde(support)', '', '        return density, support']}, {'name': '_eval_bivariate', 'start_line': 165, 'end_line': 187, 'text': ['    def _eval_bivariate(self, x1, x2, weights=None):', '        \"\"\"Fit and evaluate a univariate on bivariate data.\"\"\"', '        support = self.support', '        if support is None:', '            support = self.define_support(x1, x2, cache=False)', '', '        kde = self._fit([x1, x2], weights)', '', '        if self.cumulative:', '', '            grid1, grid2 = support', '            density = np.zeros((grid1.size, grid2.size))', '            p0 = grid1.min(), grid2.min()', '            for i, xi in enumerate(grid1):', '                for j, xj in enumerate(grid2):', '                    density[i, j] = kde.integrate_box(p0, (xi, xj))', '', '        else:', '', '            xx1, xx2 = np.meshgrid(*support)', '            density = kde([xx1.ravel(), xx2.ravel()]).reshape(xx1.shape)', '', '        return density, support']}, {'name': '__call__', 'start_line': 189, 'end_line': 194, 'text': ['    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Fit and evaluate on univariate or bivariate data.\"\"\"', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)']}]}, {'name': 'Histogram', 'start_line': 199, 'end_line': 398, 'text': ['class Histogram:', '    \"\"\"Univariate and bivariate histogram estimator.\"\"\"', '    def __init__(', '        self,', '        stat=\"count\",', '        bins=\"auto\",', '        binwidth=None,', '        binrange=None,', '        discrete=False,', '        cumulative=False,', '    ):', '        \"\"\"Initialize the estimator with its parameters.', '', '        Parameters', '        ----------', '        stat : str', '            Aggregate statistic to compute in each bin.', '', '            - `count`: show the number of observations in each bin', '            - `frequency`: show the number of observations divided by the bin width', '            - `probability` or `proportion`: normalize such that bar heights sum to 1', '            - `percent`: normalize such that bar heights sum to 100', '            - `density`: normalize such that the total area of the histogram equals 1', '', '        bins : str, number, vector, or a pair of such values', '            Generic bin parameter that can be the name of a reference rule,', '            the number of bins, or the breaks of the bins.', '            Passed to :func:`numpy.histogram_bin_edges`.', '        binwidth : number or pair of numbers', '            Width of each bin, overrides ``bins`` but can be used with', '            ``binrange``.', '        binrange : pair of numbers or a pair of pairs', '            Lowest and highest value for bin edges; can be used either', '            with ``bins`` or ``binwidth``. Defaults to data extremes.', '        discrete : bool or pair of bools', '            If True, set ``binwidth`` and ``binrange`` such that bin', '            edges cover integer values in the dataset.', '        cumulative : bool', '            If True, return the cumulative statistic.', '', '        \"\"\"', '        stat_choices = [', '            \"count\", \"frequency\", \"density\", \"probability\", \"proportion\", \"percent\",', '        ]', '        _check_argument(\"stat\", stat_choices, stat)', '', '        self.stat = stat', '        self.bins = bins', '        self.binwidth = binwidth', '        self.binrange = binrange', '        self.discrete = discrete', '        self.cumulative = cumulative', '', '        self.bin_kws = None', '', '    def _define_bin_edges(self, x, weights, bins, binwidth, binrange, discrete):', '        \"\"\"Inner function that takes bin parameters as arguments.\"\"\"', '        if binrange is None:', '            start, stop = x.min(), x.max()', '        else:', '            start, stop = binrange', '', '        if discrete:', '            bin_edges = np.arange(start - .5, stop + 1.5)', '        elif binwidth is not None:', '            step = binwidth', '            bin_edges = np.arange(start, stop + step, step)', '            # Handle roundoff error (maybe there is a less clumsy way?)', '            if bin_edges.max() < stop or len(bin_edges) < 2:', '                bin_edges = np.append(bin_edges, bin_edges.max() + step)', '        else:', '            bin_edges = np.histogram_bin_edges(', '                x, bins, binrange, weights,', '            )', '        return bin_edges', '', '    def define_bin_params(self, x1, x2=None, weights=None, cache=True):', '        \"\"\"Given data, return numpy.histogram parameters to define bins.\"\"\"', '        if x2 is None:', '', '            bin_edges = self._define_bin_edges(', '                x1, weights, self.bins, self.binwidth, self.binrange, self.discrete,', '            )', '', '            if isinstance(self.bins, (str, Number)):', '                n_bins = len(bin_edges) - 1', '                bin_range = bin_edges.min(), bin_edges.max()', '                bin_kws = dict(bins=n_bins, range=bin_range)', '            else:', '                bin_kws = dict(bins=bin_edges)', '', '        else:', '', '            bin_edges = []', '            for i, x in enumerate([x1, x2]):', '', '                # Resolve out whether bin parameters are shared', '                # or specific to each variable', '', '                bins = self.bins', '                if not bins or isinstance(bins, (str, Number)):', '                    pass', '                elif isinstance(bins[i], str):', '                    bins = bins[i]', '                elif len(bins) == 2:', '                    bins = bins[i]', '', '                binwidth = self.binwidth', '                if binwidth is None:', '                    pass', '                elif not isinstance(binwidth, Number):', '                    binwidth = binwidth[i]', '', '                binrange = self.binrange', '                if binrange is None:', '                    pass', '                elif not isinstance(binrange[0], Number):', '                    binrange = binrange[i]', '', '                discrete = self.discrete', '                if not isinstance(discrete, bool):', '                    discrete = discrete[i]', '', '                # Define the bins for this variable', '', '                bin_edges.append(self._define_bin_edges(', '                    x, weights, bins, binwidth, binrange, discrete,', '                ))', '', '            bin_kws = dict(bins=tuple(bin_edges))', '', '        if cache:', '            self.bin_kws = bin_kws', '', '        return bin_kws', '', '    def _eval_bivariate(self, x1, x2, weights):', '        \"\"\"Inner function for histogram of two variables.\"\"\"', '        bin_kws = self.bin_kws', '        if bin_kws is None:', '            bin_kws = self.define_bin_params(x1, x2, cache=False)', '', '        density = self.stat == \"density\"', '', '        hist, *bin_edges = np.histogram2d(', '            x1, x2, **bin_kws, weights=weights, density=density', '        )', '', '        area = np.outer(', '            np.diff(bin_edges[0]),', '            np.diff(bin_edges[1]),', '        )', '', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / area', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * area).cumsum(axis=0).cumsum(axis=1)', '            else:', '                hist = hist.cumsum(axis=0).cumsum(axis=1)', '', '        return hist, bin_edges', '', '    def _eval_univariate(self, x, weights):', '        \"\"\"Inner function for histogram of one variable.\"\"\"', '        bin_kws = self.bin_kws', '        if bin_kws is None:', '            bin_kws = self.define_bin_params(x, weights=weights, cache=False)', '', '        density = self.stat == \"density\"', '        hist, bin_edges = np.histogram(', '            x, **bin_kws, weights=weights, density=density,', '        )', '', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / np.diff(bin_edges)', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * np.diff(bin_edges)).cumsum()', '            else:', '                hist = hist.cumsum()', '', '        return hist, bin_edges', '', '    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Count the occurrences in each bin, maybe normalize.\"\"\"', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)'], 'methods': [{'name': '__init__', 'start_line': 201, 'end_line': 252, 'text': ['    def __init__(', '        self,', '        stat=\"count\",', '        bins=\"auto\",', '        binwidth=None,', '        binrange=None,', '        discrete=False,', '        cumulative=False,', '    ):', '        \"\"\"Initialize the estimator with its parameters.', '', '        Parameters', '        ----------', '        stat : str', '            Aggregate statistic to compute in each bin.', '', '            - `count`: show the number of observations in each bin', '            - `frequency`: show the number of observations divided by the bin width', '            - `probability` or `proportion`: normalize such that bar heights sum to 1', '            - `percent`: normalize such that bar heights sum to 100', '            - `density`: normalize such that the total area of the histogram equals 1', '', '        bins : str, number, vector, or a pair of such values', '            Generic bin parameter that can be the name of a reference rule,', '            the number of bins, or the breaks of the bins.', '            Passed to :func:`numpy.histogram_bin_edges`.', '        binwidth : number or pair of numbers', '            Width of each bin, overrides ``bins`` but can be used with', '            ``binrange``.', '        binrange : pair of numbers or a pair of pairs', '            Lowest and highest value for bin edges; can be used either', '            with ``bins`` or ``binwidth``. Defaults to data extremes.', '        discrete : bool or pair of bools', '            If True, set ``binwidth`` and ``binrange`` such that bin', '            edges cover integer values in the dataset.', '        cumulative : bool', '            If True, return the cumulative statistic.', '', '        \"\"\"', '        stat_choices = [', '            \"count\", \"frequency\", \"density\", \"probability\", \"proportion\", \"percent\",', '        ]', '        _check_argument(\"stat\", stat_choices, stat)', '', '        self.stat = stat', '        self.bins = bins', '        self.binwidth = binwidth', '        self.binrange = binrange', '        self.discrete = discrete', '        self.cumulative = cumulative', '', '        self.bin_kws = None']}, {'name': '_define_bin_edges', 'start_line': 254, 'end_line': 273, 'text': ['    def _define_bin_edges(self, x, weights, bins, binwidth, binrange, discrete):', '        \"\"\"Inner function that takes bin parameters as arguments.\"\"\"', '        if binrange is None:', '            start, stop = x.min(), x.max()', '        else:', '            start, stop = binrange', '', '        if discrete:', '            bin_edges = np.arange(start - .5, stop + 1.5)', '        elif binwidth is not None:', '            step = binwidth', '            bin_edges = np.arange(start, stop + step, step)', '            # Handle roundoff error (maybe there is a less clumsy way?)', '            if bin_edges.max() < stop or len(bin_edges) < 2:', '                bin_edges = np.append(bin_edges, bin_edges.max() + step)', '        else:', '            bin_edges = np.histogram_bin_edges(', '                x, bins, binrange, weights,', '            )', '        return bin_edges']}, {'name': 'define_bin_params', 'start_line': 275, 'end_line': 333, 'text': ['    def define_bin_params(self, x1, x2=None, weights=None, cache=True):', '        \"\"\"Given data, return numpy.histogram parameters to define bins.\"\"\"', '        if x2 is None:', '', '            bin_edges = self._define_bin_edges(', '                x1, weights, self.bins, self.binwidth, self.binrange, self.discrete,', '            )', '', '            if isinstance(self.bins, (str, Number)):', '                n_bins = len(bin_edges) - 1', '                bin_range = bin_edges.min(), bin_edges.max()', '                bin_kws = dict(bins=n_bins, range=bin_range)', '            else:', '                bin_kws = dict(bins=bin_edges)', '', '        else:', '', '            bin_edges = []', '            for i, x in enumerate([x1, x2]):', '', '                # Resolve out whether bin parameters are shared', '                # or specific to each variable', '', '                bins = self.bins', '                if not bins or isinstance(bins, (str, Number)):', '                    pass', '                elif isinstance(bins[i], str):', '                    bins = bins[i]', '                elif len(bins) == 2:', '                    bins = bins[i]', '', '                binwidth = self.binwidth', '                if binwidth is None:', '                    pass', '                elif not isinstance(binwidth, Number):', '                    binwidth = binwidth[i]', '', '                binrange = self.binrange', '                if binrange is None:', '                    pass', '                elif not isinstance(binrange[0], Number):', '                    binrange = binrange[i]', '', '                discrete = self.discrete', '                if not isinstance(discrete, bool):', '                    discrete = discrete[i]', '', '                # Define the bins for this variable', '', '                bin_edges.append(self._define_bin_edges(', '                    x, weights, bins, binwidth, binrange, discrete,', '                ))', '', '            bin_kws = dict(bins=tuple(bin_edges))', '', '        if cache:', '            self.bin_kws = bin_kws', '', '        return bin_kws']}, {'name': '_eval_bivariate', 'start_line': 335, 'end_line': 365, 'text': ['    def _eval_bivariate(self, x1, x2, weights):', '        \"\"\"Inner function for histogram of two variables.\"\"\"', '        bin_kws = self.bin_kws', '        if bin_kws is None:', '            bin_kws = self.define_bin_params(x1, x2, cache=False)', '', '        density = self.stat == \"density\"', '', '        hist, *bin_edges = np.histogram2d(', '            x1, x2, **bin_kws, weights=weights, density=density', '        )', '', '        area = np.outer(', '            np.diff(bin_edges[0]),', '            np.diff(bin_edges[1]),', '        )', '', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / area', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * area).cumsum(axis=0).cumsum(axis=1)', '            else:', '                hist = hist.cumsum(axis=0).cumsum(axis=1)', '', '        return hist, bin_edges']}, {'name': '_eval_univariate', 'start_line': 367, 'end_line': 391, 'text': ['    def _eval_univariate(self, x, weights):', '        \"\"\"Inner function for histogram of one variable.\"\"\"', '        bin_kws = self.bin_kws', '        if bin_kws is None:', '            bin_kws = self.define_bin_params(x, weights=weights, cache=False)', '', '        density = self.stat == \"density\"', '        hist, bin_edges = np.histogram(', '            x, **bin_kws, weights=weights, density=density,', '        )', '', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / np.diff(bin_edges)', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * np.diff(bin_edges)).cumsum()', '            else:', '                hist = hist.cumsum()', '', '        return hist, bin_edges']}, {'name': '__call__', 'start_line': 393, 'end_line': 398, 'text': ['    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Count the occurrences in each bin, maybe normalize.\"\"\"', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)']}]}, {'name': 'ECDF', 'start_line': 401, 'end_line': 451, 'text': ['class ECDF:', '    \"\"\"Univariate empirical cumulative distribution estimator.\"\"\"', '    def __init__(self, stat=\"proportion\", complementary=False):', '        \"\"\"Initialize the class with its parameters', '', '        Parameters', '        ----------', '        stat : {{\"proportion\", \"count\"}}', '            Distribution statistic to compute.', '        complementary : bool', '            If True, use the complementary CDF (1 - CDF)', '', '        \"\"\"', '        _check_argument(\"stat\", [\"count\", \"proportion\"], stat)', '        self.stat = stat', '        self.complementary = complementary', '', '    def _eval_bivariate(self, x1, x2, weights):', '        \"\"\"Inner function for ECDF of two variables.\"\"\"', '        raise NotImplementedError(\"Bivariate ECDF is not implemented\")', '', '    def _eval_univariate(self, x, weights):', '        \"\"\"Inner function for ECDF of one variable.\"\"\"', '        sorter = x.argsort()', '        x = x[sorter]', '        weights = weights[sorter]', '        y = weights.cumsum()', '', '        if self.stat == \"proportion\":', '            y = y / y.max()', '', '        x = np.r_[-np.inf, x]', '        y = np.r_[0, y]', '', '        if self.complementary:', '            y = y.max() - y', '', '        return y, x', '', '    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Return proportion or count of observations below each sorted datapoint.\"\"\"', '        x1 = np.asarray(x1)', '        if weights is None:', '            weights = np.ones_like(x1)', '        else:', '            weights = np.asarray(weights)', '', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)'], 'methods': [{'name': '__init__', 'start_line': 403, 'end_line': 416, 'text': ['    def __init__(self, stat=\"proportion\", complementary=False):', '        \"\"\"Initialize the class with its parameters', '', '        Parameters', '        ----------', '        stat : {{\"proportion\", \"count\"}}', '            Distribution statistic to compute.', '        complementary : bool', '            If True, use the complementary CDF (1 - CDF)', '', '        \"\"\"', '        _check_argument(\"stat\", [\"count\", \"proportion\"], stat)', '        self.stat = stat', '        self.complementary = complementary']}, {'name': '_eval_bivariate', 'start_line': 418, 'end_line': 420, 'text': ['    def _eval_bivariate(self, x1, x2, weights):', '        \"\"\"Inner function for ECDF of two variables.\"\"\"', '        raise NotImplementedError(\"Bivariate ECDF is not implemented\")']}, {'name': '_eval_univariate', 'start_line': 422, 'end_line': 438, 'text': ['    def _eval_univariate(self, x, weights):', '        \"\"\"Inner function for ECDF of one variable.\"\"\"', '        sorter = x.argsort()', '        x = x[sorter]', '        weights = weights[sorter]', '        y = weights.cumsum()', '', '        if self.stat == \"proportion\":', '            y = y / y.max()', '', '        x = np.r_[-np.inf, x]', '        y = np.r_[0, y]', '', '        if self.complementary:', '            y = y.max() - y', '', '        return y, x']}, {'name': '__call__', 'start_line': 440, 'end_line': 451, 'text': ['    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Return proportion or count of observations below each sorted datapoint.\"\"\"', '        x1 = np.asarray(x1)', '        if weights is None:', '            weights = np.ones_like(x1)', '        else:', '            weights = np.asarray(weights)', '', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)']}]}, {'name': 'EstimateAggregator', 'start_line': 454, 'end_line': 516, 'text': ['class EstimateAggregator:', '', '    def __init__(self, estimator, errorbar=None, **boot_kws):', '        \"\"\"', '        Data aggregator that produces an estimate and error bar interval.', '', '        Parameters', '        ----------', '        estimator : callable or string', '            Function (or method name) that maps a vector to a scalar.', '        errorbar : string, (string, number) tuple, or callable', '            Name of errorbar method (either \"ci\", \"pi\", \"se\", or \"sd\"), or a tuple', '            with a method name and a level parameter, or a function that maps from a', '            vector to a (min, max) interval.', '        boot_kws', '            Additional keywords are passed to bootstrap when error_method is \"ci\".', '', '        \"\"\"', '        self.estimator = estimator', '', '        method, level = _validate_errorbar_arg(errorbar)', '        self.error_method = method', '        self.error_level = level', '', '        self.boot_kws = boot_kws', '', '    def __call__(self, data, var):', '        \"\"\"Aggregate over `var` column of `data` with estimate and error interval.\"\"\"', '        vals = data[var]', '        if callable(self.estimator):', '            # You would think we could pass to vals.agg, and yet:', '            # https://github.com/mwaskom/seaborn/issues/2943', '            estimate = self.estimator(vals)', '        else:', '            estimate = vals.agg(self.estimator)', '', '        # Options that produce no error bars', '        if self.error_method is None:', '            err_min = err_max = np.nan', '        elif len(data) <= 1:', '            err_min = err_max = np.nan', '', '        # Generic errorbars from user-supplied function', '        elif callable(self.error_method):', '            err_min, err_max = self.error_method(vals)', '', '        # Parametric options', '        elif self.error_method == \"sd\":', '            half_interval = vals.std() * self.error_level', '            err_min, err_max = estimate - half_interval, estimate + half_interval', '        elif self.error_method == \"se\":', '            half_interval = vals.sem() * self.error_level', '            err_min, err_max = estimate - half_interval, estimate + half_interval', '', '        # Nonparametric options', '        elif self.error_method == \"pi\":', '            err_min, err_max = _percentile_interval(vals, self.error_level)', '        elif self.error_method == \"ci\":', '            units = data.get(\"units\", None)', '            boots = bootstrap(vals, units=units, func=self.estimator, **self.boot_kws)', '            err_min, err_max = _percentile_interval(boots, self.error_level)', '', '        return pd.Series({var: estimate, f\"{var}min\": err_min, f\"{var}max\": err_max})'], 'methods': [{'name': '__init__', 'start_line': 456, 'end_line': 478, 'text': ['    def __init__(self, estimator, errorbar=None, **boot_kws):', '        \"\"\"', '        Data aggregator that produces an estimate and error bar interval.', '', '        Parameters', '        ----------', '        estimator : callable or string', '            Function (or method name) that maps a vector to a scalar.', '        errorbar : string, (string, number) tuple, or callable', '            Name of errorbar method (either \"ci\", \"pi\", \"se\", or \"sd\"), or a tuple', '            with a method name and a level parameter, or a function that maps from a', '            vector to a (min, max) interval.', '        boot_kws', '            Additional keywords are passed to bootstrap when error_method is \"ci\".', '', '        \"\"\"', '        self.estimator = estimator', '', '        method, level = _validate_errorbar_arg(errorbar)', '        self.error_method = method', '        self.error_level = level', '', '        self.boot_kws = boot_kws']}, {'name': '__call__', 'start_line': 480, 'end_line': 516, 'text': ['    def __call__(self, data, var):', '        \"\"\"Aggregate over `var` column of `data` with estimate and error interval.\"\"\"', '        vals = data[var]', '        if callable(self.estimator):', '            # You would think we could pass to vals.agg, and yet:', '            # https://github.com/mwaskom/seaborn/issues/2943', '            estimate = self.estimator(vals)', '        else:', '            estimate = vals.agg(self.estimator)', '', '        # Options that produce no error bars', '        if self.error_method is None:', '            err_min = err_max = np.nan', '        elif len(data) <= 1:', '            err_min = err_max = np.nan', '', '        # Generic errorbars from user-supplied function', '        elif callable(self.error_method):', '            err_min, err_max = self.error_method(vals)', '', '        # Parametric options', '        elif self.error_method == \"sd\":', '            half_interval = vals.std() * self.error_level', '            err_min, err_max = estimate - half_interval, estimate + half_interval', '        elif self.error_method == \"se\":', '            half_interval = vals.sem() * self.error_level', '            err_min, err_max = estimate - half_interval, estimate + half_interval', '', '        # Nonparametric options', '        elif self.error_method == \"pi\":', '            err_min, err_max = _percentile_interval(vals, self.error_level)', '        elif self.error_method == \"ci\":', '            units = data.get(\"units\", None)', '            boots = bootstrap(vals, units=units, func=self.estimator, **self.boot_kws)', '            err_min, err_max = _percentile_interval(boots, self.error_level)', '', '        return pd.Series({var: estimate, f\"{var}min\": err_min, f\"{var}max\": err_max})']}]}], 'functions': [{'name': '_percentile_interval', 'start_line': 519, 'end_line': 523, 'text': ['def _percentile_interval(data, width):', '    \"\"\"Return a percentile interval from data of a given width.\"\"\"', '    edge = (100 - width) / 2', '    percentiles = edge, 100 - edge', '    return np.nanpercentile(data, percentiles)']}, {'name': '_validate_errorbar_arg', 'start_line': 526, 'end_line': 554, 'text': ['def _validate_errorbar_arg(arg):', '    \"\"\"Check type and value of errorbar argument and assign default level.\"\"\"', '    DEFAULT_LEVELS = {', '        \"ci\": 95,', '        \"pi\": 95,', '        \"se\": 1,', '        \"sd\": 1,', '    }', '', '    usage = \"`errorbar` must be a callable, string, or (string, number) tuple\"', '', '    if arg is None:', '        return None, None', '    elif callable(arg):', '        return arg, None', '    elif isinstance(arg, str):', '        method = arg', '        level = DEFAULT_LEVELS.get(method, None)', '    else:', '        try:', '            method, level = arg', '        except (ValueError, TypeError) as err:', '            raise err.__class__(usage) from err', '', '    _check_argument(\"errorbar\", list(DEFAULT_LEVELS), method)', '    if level is not None and not isinstance(level, Number):', '        raise TypeError(usage)', '', '    return method, level']}], 'text': ['\"\"\"Statistical transformations for visualization.', '', 'This module is currently private, but is being written to eventually form part', 'of the public API.', '', 'The classes should behave roughly in the style of scikit-learn.', '', '- All data-independent parameters should be passed to the class constructor.', '- Each class should implement a default transformation that is exposed through', '  __call__. These are currently written for vector arguments, but I think', '  consuming a whole `plot_data` DataFrame and return it with transformed', '  variables would make more sense.', '- Some class have data-dependent preprocessing that should be cached and used', '  multiple times (think defining histogram bins off all data and then counting', '  observations within each bin multiple times per data subsets). These currently', '  have unique names, but it would be good to have a common name. Not quite', '  `fit`, but something similar.', '- Alternatively, the transform interface could take some information about grouping', '  variables and do a groupby internally.', '- Some classes should define alternate transforms that might make the most sense', '  with a different function. For example, KDE usually evaluates the distribution', '  on a regular grid, but it would be useful for it to transform at the actual', '  datapoints. Then again, this could be controlled by a parameter at  the time of', '  class instantiation.', '', '\"\"\"', 'from numbers import Number', 'import numpy as np', 'import pandas as pd', 'try:', '    from scipy.stats import gaussian_kde', '    _no_scipy = False', 'except ImportError:', '    from .external.kde import gaussian_kde', '    _no_scipy = True', '', 'from .algorithms import bootstrap', 'from .utils import _check_argument', '', '', 'class KDE:', '    \"\"\"Univariate and bivariate kernel density estimator.\"\"\"', '    def __init__(', '        self, *,', '        bw_method=None,', '        bw_adjust=1,', '        gridsize=200,', '        cut=3,', '        clip=None,', '        cumulative=False,', '    ):', '        \"\"\"Initialize the estimator with its parameters.', '', '        Parameters', '        ----------', '        bw_method : string, scalar, or callable, optional', '            Method for determining the smoothing bandwidth to use; passed to', '            :class:`scipy.stats.gaussian_kde`.', '        bw_adjust : number, optional', '            Factor that multiplicatively scales the value chosen using', '            ``bw_method``. Increasing will make the curve smoother. See Notes.', '        gridsize : int, optional', '            Number of points on each dimension of the evaluation grid.', '        cut : number, optional', '            Factor, multiplied by the smoothing bandwidth, that determines how', '            far the evaluation grid extends past the extreme datapoints. When', '            set to 0, truncate the curve at the data limits.', '        clip : pair of numbers or None, or a pair of such pairs', '            Do not evaluate the density outside of these limits.', '        cumulative : bool, optional', '            If True, estimate a cumulative distribution function. Requires scipy.', '', '        \"\"\"', '        if clip is None:', '            clip = None, None', '', '        self.bw_method = bw_method', '        self.bw_adjust = bw_adjust', '        self.gridsize = gridsize', '        self.cut = cut', '        self.clip = clip', '        self.cumulative = cumulative', '', '        if cumulative and _no_scipy:', '            raise RuntimeError(\"Cumulative KDE evaluation requires scipy\")', '', '        self.support = None', '', '    def _define_support_grid(self, x, bw, cut, clip, gridsize):', '        \"\"\"Create the grid of evaluation points depending for vector x.\"\"\"', '        clip_lo = -np.inf if clip[0] is None else clip[0]', '        clip_hi = +np.inf if clip[1] is None else clip[1]', '        gridmin = max(x.min() - bw * cut, clip_lo)', '        gridmax = min(x.max() + bw * cut, clip_hi)', '        return np.linspace(gridmin, gridmax, gridsize)', '', '    def _define_support_univariate(self, x, weights):', '        \"\"\"Create a 1D grid of evaluation points.\"\"\"', '        kde = self._fit(x, weights)', '        bw = np.sqrt(kde.covariance.squeeze())', '        grid = self._define_support_grid(', '            x, bw, self.cut, self.clip, self.gridsize', '        )', '        return grid', '', '    def _define_support_bivariate(self, x1, x2, weights):', '        \"\"\"Create a 2D grid of evaluation points.\"\"\"', '        clip = self.clip', '        if clip[0] is None or np.isscalar(clip[0]):', '            clip = (clip, clip)', '', '        kde = self._fit([x1, x2], weights)', '        bw = np.sqrt(np.diag(kde.covariance).squeeze())', '', '        grid1 = self._define_support_grid(', '            x1, bw[0], self.cut, clip[0], self.gridsize', '        )', '        grid2 = self._define_support_grid(', '            x2, bw[1], self.cut, clip[1], self.gridsize', '        )', '', '        return grid1, grid2', '', '    def define_support(self, x1, x2=None, weights=None, cache=True):', '        \"\"\"Create the evaluation grid for a given data set.\"\"\"', '        if x2 is None:', '            support = self._define_support_univariate(x1, weights)', '        else:', '            support = self._define_support_bivariate(x1, x2, weights)', '', '        if cache:', '            self.support = support', '', '        return support', '', '    def _fit(self, fit_data, weights=None):', '        \"\"\"Fit the scipy kde while adding bw_adjust logic and version check.\"\"\"', '        fit_kws = {\"bw_method\": self.bw_method}', '        if weights is not None:', '            fit_kws[\"weights\"] = weights', '', '        kde = gaussian_kde(fit_data, **fit_kws)', '        kde.set_bandwidth(kde.factor * self.bw_adjust)', '', '        return kde', '', '    def _eval_univariate(self, x, weights=None):', '        \"\"\"Fit and evaluate a univariate on univariate data.\"\"\"', '        support = self.support', '        if support is None:', '            support = self.define_support(x, cache=False)', '', '        kde = self._fit(x, weights)', '', '        if self.cumulative:', '            s_0 = support[0]', '            density = np.array([', '                kde.integrate_box_1d(s_0, s_i) for s_i in support', '            ])', '        else:', '            density = kde(support)', '', '        return density, support', '', '    def _eval_bivariate(self, x1, x2, weights=None):', '        \"\"\"Fit and evaluate a univariate on bivariate data.\"\"\"', '        support = self.support', '        if support is None:', '            support = self.define_support(x1, x2, cache=False)', '', '        kde = self._fit([x1, x2], weights)', '', '        if self.cumulative:', '', '            grid1, grid2 = support', '            density = np.zeros((grid1.size, grid2.size))', '            p0 = grid1.min(), grid2.min()', '            for i, xi in enumerate(grid1):', '                for j, xj in enumerate(grid2):', '                    density[i, j] = kde.integrate_box(p0, (xi, xj))', '', '        else:', '', '            xx1, xx2 = np.meshgrid(*support)', '            density = kde([xx1.ravel(), xx2.ravel()]).reshape(xx1.shape)', '', '        return density, support', '', '    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Fit and evaluate on univariate or bivariate data.\"\"\"', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)', '', '', '# Note: we no longer use this for univariate histograms in histplot,', \"# preferring _stats.Hist. We'll deprecate this once we have a bivariate Stat class.\", 'class Histogram:', '    \"\"\"Univariate and bivariate histogram estimator.\"\"\"', '    def __init__(', '        self,', '        stat=\"count\",', '        bins=\"auto\",', '        binwidth=None,', '        binrange=None,', '        discrete=False,', '        cumulative=False,', '    ):', '        \"\"\"Initialize the estimator with its parameters.', '', '        Parameters', '        ----------', '        stat : str', '            Aggregate statistic to compute in each bin.', '', '            - `count`: show the number of observations in each bin', '            - `frequency`: show the number of observations divided by the bin width', '            - `probability` or `proportion`: normalize such that bar heights sum to 1', '            - `percent`: normalize such that bar heights sum to 100', '            - `density`: normalize such that the total area of the histogram equals 1', '', '        bins : str, number, vector, or a pair of such values', '            Generic bin parameter that can be the name of a reference rule,', '            the number of bins, or the breaks of the bins.', '            Passed to :func:`numpy.histogram_bin_edges`.', '        binwidth : number or pair of numbers', '            Width of each bin, overrides ``bins`` but can be used with', '            ``binrange``.', '        binrange : pair of numbers or a pair of pairs', '            Lowest and highest value for bin edges; can be used either', '            with ``bins`` or ``binwidth``. Defaults to data extremes.', '        discrete : bool or pair of bools', '            If True, set ``binwidth`` and ``binrange`` such that bin', '            edges cover integer values in the dataset.', '        cumulative : bool', '            If True, return the cumulative statistic.', '', '        \"\"\"', '        stat_choices = [', '            \"count\", \"frequency\", \"density\", \"probability\", \"proportion\", \"percent\",', '        ]', '        _check_argument(\"stat\", stat_choices, stat)', '', '        self.stat = stat', '        self.bins = bins', '        self.binwidth = binwidth', '        self.binrange = binrange', '        self.discrete = discrete', '        self.cumulative = cumulative', '', '        self.bin_kws = None', '', '    def _define_bin_edges(self, x, weights, bins, binwidth, binrange, discrete):', '        \"\"\"Inner function that takes bin parameters as arguments.\"\"\"', '        if binrange is None:', '            start, stop = x.min(), x.max()', '        else:', '            start, stop = binrange', '', '        if discrete:', '            bin_edges = np.arange(start - .5, stop + 1.5)', '        elif binwidth is not None:', '            step = binwidth', '            bin_edges = np.arange(start, stop + step, step)', '            # Handle roundoff error (maybe there is a less clumsy way?)', '            if bin_edges.max() < stop or len(bin_edges) < 2:', '                bin_edges = np.append(bin_edges, bin_edges.max() + step)', '        else:', '            bin_edges = np.histogram_bin_edges(', '                x, bins, binrange, weights,', '            )', '        return bin_edges', '', '    def define_bin_params(self, x1, x2=None, weights=None, cache=True):', '        \"\"\"Given data, return numpy.histogram parameters to define bins.\"\"\"', '        if x2 is None:', '', '            bin_edges = self._define_bin_edges(', '                x1, weights, self.bins, self.binwidth, self.binrange, self.discrete,', '            )', '', '            if isinstance(self.bins, (str, Number)):', '                n_bins = len(bin_edges) - 1', '                bin_range = bin_edges.min(), bin_edges.max()', '                bin_kws = dict(bins=n_bins, range=bin_range)', '            else:', '                bin_kws = dict(bins=bin_edges)', '', '        else:', '', '            bin_edges = []', '            for i, x in enumerate([x1, x2]):', '', '                # Resolve out whether bin parameters are shared', '                # or specific to each variable', '', '                bins = self.bins', '                if not bins or isinstance(bins, (str, Number)):', '                    pass', '                elif isinstance(bins[i], str):', '                    bins = bins[i]', '                elif len(bins) == 2:', '                    bins = bins[i]', '', '                binwidth = self.binwidth', '                if binwidth is None:', '                    pass', '                elif not isinstance(binwidth, Number):', '                    binwidth = binwidth[i]', '', '                binrange = self.binrange', '                if binrange is None:', '                    pass', '                elif not isinstance(binrange[0], Number):', '                    binrange = binrange[i]', '', '                discrete = self.discrete', '                if not isinstance(discrete, bool):', '                    discrete = discrete[i]', '', '                # Define the bins for this variable', '', '                bin_edges.append(self._define_bin_edges(', '                    x, weights, bins, binwidth, binrange, discrete,', '                ))', '', '            bin_kws = dict(bins=tuple(bin_edges))', '', '        if cache:', '            self.bin_kws = bin_kws', '', '        return bin_kws', '', '    def _eval_bivariate(self, x1, x2, weights):', '        \"\"\"Inner function for histogram of two variables.\"\"\"', '        bin_kws = self.bin_kws', '        if bin_kws is None:', '            bin_kws = self.define_bin_params(x1, x2, cache=False)', '', '        density = self.stat == \"density\"', '', '        hist, *bin_edges = np.histogram2d(', '            x1, x2, **bin_kws, weights=weights, density=density', '        )', '', '        area = np.outer(', '            np.diff(bin_edges[0]),', '            np.diff(bin_edges[1]),', '        )', '', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / area', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * area).cumsum(axis=0).cumsum(axis=1)', '            else:', '                hist = hist.cumsum(axis=0).cumsum(axis=1)', '', '        return hist, bin_edges', '', '    def _eval_univariate(self, x, weights):', '        \"\"\"Inner function for histogram of one variable.\"\"\"', '        bin_kws = self.bin_kws', '        if bin_kws is None:', '            bin_kws = self.define_bin_params(x, weights=weights, cache=False)', '', '        density = self.stat == \"density\"', '        hist, bin_edges = np.histogram(', '            x, **bin_kws, weights=weights, density=density,', '        )', '', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / np.diff(bin_edges)', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * np.diff(bin_edges)).cumsum()', '            else:', '                hist = hist.cumsum()', '', '        return hist, bin_edges', '', '    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Count the occurrences in each bin, maybe normalize.\"\"\"', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)', '', '', 'class ECDF:', '    \"\"\"Univariate empirical cumulative distribution estimator.\"\"\"', '    def __init__(self, stat=\"proportion\", complementary=False):', '        \"\"\"Initialize the class with its parameters', '', '        Parameters', '        ----------', '        stat : {{\"proportion\", \"count\"}}', '            Distribution statistic to compute.', '        complementary : bool', '            If True, use the complementary CDF (1 - CDF)', '', '        \"\"\"', '        _check_argument(\"stat\", [\"count\", \"proportion\"], stat)', '        self.stat = stat', '        self.complementary = complementary', '', '    def _eval_bivariate(self, x1, x2, weights):', '        \"\"\"Inner function for ECDF of two variables.\"\"\"', '        raise NotImplementedError(\"Bivariate ECDF is not implemented\")', '', '    def _eval_univariate(self, x, weights):', '        \"\"\"Inner function for ECDF of one variable.\"\"\"', '        sorter = x.argsort()', '        x = x[sorter]', '        weights = weights[sorter]', '        y = weights.cumsum()', '', '        if self.stat == \"proportion\":', '            y = y / y.max()', '', '        x = np.r_[-np.inf, x]', '        y = np.r_[0, y]', '', '        if self.complementary:', '            y = y.max() - y', '', '        return y, x', '', '    def __call__(self, x1, x2=None, weights=None):', '        \"\"\"Return proportion or count of observations below each sorted datapoint.\"\"\"', '        x1 = np.asarray(x1)', '        if weights is None:', '            weights = np.ones_like(x1)', '        else:', '            weights = np.asarray(weights)', '', '        if x2 is None:', '            return self._eval_univariate(x1, weights)', '        else:', '            return self._eval_bivariate(x1, x2, weights)', '', '', 'class EstimateAggregator:', '', '    def __init__(self, estimator, errorbar=None, **boot_kws):', '        \"\"\"', '        Data aggregator that produces an estimate and error bar interval.', '', '        Parameters', '        ----------', '        estimator : callable or string', '            Function (or method name) that maps a vector to a scalar.', '        errorbar : string, (string, number) tuple, or callable', '            Name of errorbar method (either \"ci\", \"pi\", \"se\", or \"sd\"), or a tuple', '            with a method name and a level parameter, or a function that maps from a', '            vector to a (min, max) interval.', '        boot_kws', '            Additional keywords are passed to bootstrap when error_method is \"ci\".', '', '        \"\"\"', '        self.estimator = estimator', '', '        method, level = _validate_errorbar_arg(errorbar)', '        self.error_method = method', '        self.error_level = level', '', '        self.boot_kws = boot_kws', '', '    def __call__(self, data, var):', '        \"\"\"Aggregate over `var` column of `data` with estimate and error interval.\"\"\"', '        vals = data[var]', '        if callable(self.estimator):', '            # You would think we could pass to vals.agg, and yet:', '            # https://github.com/mwaskom/seaborn/issues/2943', '            estimate = self.estimator(vals)', '        else:', '            estimate = vals.agg(self.estimator)', '', '        # Options that produce no error bars', '        if self.error_method is None:', '            err_min = err_max = np.nan', '        elif len(data) <= 1:', '            err_min = err_max = np.nan', '', '        # Generic errorbars from user-supplied function', '        elif callable(self.error_method):', '            err_min, err_max = self.error_method(vals)', '', '        # Parametric options', '        elif self.error_method == \"sd\":', '            half_interval = vals.std() * self.error_level', '            err_min, err_max = estimate - half_interval, estimate + half_interval', '        elif self.error_method == \"se\":', '            half_interval = vals.sem() * self.error_level', '            err_min, err_max = estimate - half_interval, estimate + half_interval', '', '        # Nonparametric options', '        elif self.error_method == \"pi\":', '            err_min, err_max = _percentile_interval(vals, self.error_level)', '        elif self.error_method == \"ci\":', '            units = data.get(\"units\", None)', '            boots = bootstrap(vals, units=units, func=self.estimator, **self.boot_kws)', '            err_min, err_max = _percentile_interval(boots, self.error_level)', '', '        return pd.Series({var: estimate, f\"{var}min\": err_min, f\"{var}max\": err_max})', '', '', 'def _percentile_interval(data, width):', '    \"\"\"Return a percentile interval from data of a given width.\"\"\"', '    edge = (100 - width) / 2', '    percentiles = edge, 100 - edge', '    return np.nanpercentile(data, percentiles)', '', '', 'def _validate_errorbar_arg(arg):', '    \"\"\"Check type and value of errorbar argument and assign default level.\"\"\"', '    DEFAULT_LEVELS = {', '        \"ci\": 95,', '        \"pi\": 95,', '        \"se\": 1,', '        \"sd\": 1,', '    }', '', '    usage = \"`errorbar` must be a callable, string, or (string, number) tuple\"', '', '    if arg is None:', '        return None, None', '    elif callable(arg):', '        return arg, None', '    elif isinstance(arg, str):', '        method = arg', '        level = DEFAULT_LEVELS.get(method, None)', '    else:', '        try:', '            method, level = arg', '        except (ValueError, TypeError) as err:', '            raise err.__class__(usage) from err', '', '    _check_argument(\"errorbar\", list(DEFAULT_LEVELS), method)', '    if level is not None and not isinstance(level, Number):', '        raise TypeError(usage)', '', '    return method, level']}, 'matrix.py': {'classes': [{'name': '_HeatMapper', 'start_line': 97, 'end_line': 352, 'text': ['class _HeatMapper:', '    \"\"\"Draw a heatmap plot of a matrix with nice labels and colormaps.\"\"\"', '', '    def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,', '                 annot_kws, cbar, cbar_kws,', '                 xticklabels=True, yticklabels=True, mask=None):', '        \"\"\"Initialize the plotting object.\"\"\"', '        # We always want to have a DataFrame with semantic information', '        # and an ndarray to pass to matplotlib', '        if isinstance(data, pd.DataFrame):', '            plot_data = data.values', '        else:', '            plot_data = np.asarray(data)', '            data = pd.DataFrame(plot_data)', '', '        # Validate the mask and convert to DataFrame', '        mask = _matrix_mask(data, mask)', '', '        plot_data = np.ma.masked_where(np.asarray(mask), plot_data)', '', '        # Get good names for the rows and columns', '        xtickevery = 1', '        if isinstance(xticklabels, int):', '            xtickevery = xticklabels', '            xticklabels = _index_to_ticklabels(data.columns)', '        elif xticklabels is True:', '            xticklabels = _index_to_ticklabels(data.columns)', '        elif xticklabels is False:', '            xticklabels = []', '', '        ytickevery = 1', '        if isinstance(yticklabels, int):', '            ytickevery = yticklabels', '            yticklabels = _index_to_ticklabels(data.index)', '        elif yticklabels is True:', '            yticklabels = _index_to_ticklabels(data.index)', '        elif yticklabels is False:', '            yticklabels = []', '', '        if not len(xticklabels):', '            self.xticks = []', '            self.xticklabels = []', '        elif isinstance(xticklabels, str) and xticklabels == \"auto\":', '            self.xticks = \"auto\"', '            self.xticklabels = _index_to_ticklabels(data.columns)', '        else:', '            self.xticks, self.xticklabels = self._skip_ticks(xticklabels,', '                                                             xtickevery)', '', '        if not len(yticklabels):', '            self.yticks = []', '            self.yticklabels = []', '        elif isinstance(yticklabels, str) and yticklabels == \"auto\":', '            self.yticks = \"auto\"', '            self.yticklabels = _index_to_ticklabels(data.index)', '        else:', '            self.yticks, self.yticklabels = self._skip_ticks(yticklabels,', '                                                             ytickevery)', '', '        # Get good names for the axis labels', '        xlabel = _index_to_label(data.columns)', '        ylabel = _index_to_label(data.index)', '        self.xlabel = xlabel if xlabel is not None else \"\"', '        self.ylabel = ylabel if ylabel is not None else \"\"', '', '        # Determine good default values for the colormapping', '        self._determine_cmap_params(plot_data, vmin, vmax,', '                                    cmap, center, robust)', '', '        # Sort out the annotations', '        if annot is None or annot is False:', '            annot = False', '            annot_data = None', '        else:', '            if isinstance(annot, bool):', '                annot_data = plot_data', '            else:', '                annot_data = np.asarray(annot)', '                if annot_data.shape != plot_data.shape:', '                    err = \"`data` and `annot` must have same shape.\"', '                    raise ValueError(err)', '            annot = True', '', '        # Save other attributes to the object', '        self.data = data', '        self.plot_data = plot_data', '', '        self.annot = annot', '        self.annot_data = annot_data', '', '        self.fmt = fmt', '        self.annot_kws = {} if annot_kws is None else annot_kws.copy()', '        self.cbar = cbar', '        self.cbar_kws = {} if cbar_kws is None else cbar_kws.copy()', '', '    def _determine_cmap_params(self, plot_data, vmin, vmax,', '                               cmap, center, robust):', '        \"\"\"Use some heuristics to set good defaults for colorbar and range.\"\"\"', '', '        # plot_data is a np.ma.array instance', '        calc_data = plot_data.astype(float).filled(np.nan)', '        if vmin is None:', '            if robust:', '                vmin = np.nanpercentile(calc_data, 2)', '            else:', '                vmin = np.nanmin(calc_data)', '        if vmax is None:', '            if robust:', '                vmax = np.nanpercentile(calc_data, 98)', '            else:', '                vmax = np.nanmax(calc_data)', '        self.vmin, self.vmax = vmin, vmax', '', '        # Choose default colormaps if not provided', '        if cmap is None:', '            if center is None:', '                self.cmap = cm.rocket', '            else:', '                self.cmap = cm.icefire', '        elif isinstance(cmap, str):', '            self.cmap = get_colormap(cmap)', '        elif isinstance(cmap, list):', '            self.cmap = mpl.colors.ListedColormap(cmap)', '        else:', '            self.cmap = cmap', '', '        # Recenter a divergent colormap', '        if center is not None:', '', '            # Copy bad values', '            # in mpl<3.2 only masked values are honored with \"bad\" color spec', '            # (see https://github.com/matplotlib/matplotlib/pull/14257)', '            bad = self.cmap(np.ma.masked_invalid([np.nan]))[0]', '', '            # under/over values are set for sure when cmap extremes', '            # do not map to the same color as +-inf', '            under = self.cmap(-np.inf)', '            over = self.cmap(np.inf)', '            under_set = under != self.cmap(0)', '            over_set = over != self.cmap(self.cmap.N - 1)', '', '            vrange = max(vmax - center, center - vmin)', '            normlize = mpl.colors.Normalize(center - vrange, center + vrange)', '            cmin, cmax = normlize([vmin, vmax])', '            cc = np.linspace(cmin, cmax, 256)', '            self.cmap = mpl.colors.ListedColormap(self.cmap(cc))', '            self.cmap.set_bad(bad)', '            if under_set:', '                self.cmap.set_under(under)', '            if over_set:', '                self.cmap.set_over(over)', '', '    def _annotate_heatmap(self, ax, mesh):', '        \"\"\"Add textual labels with the value in each cell.\"\"\"', '        mesh.update_scalarmappable()', '        height, width = self.annot_data.shape', '        xpos, ypos = np.meshgrid(np.arange(width) + .5, np.arange(height) + .5)', '        for x, y, m, color, val in zip(xpos.flat, ypos.flat,', '                                       mesh.get_array(), mesh.get_facecolors(),', '                                       self.annot_data.flat):', '            if m is not np.ma.masked:', '                lum = relative_luminance(color)', '                text_color = \".15\" if lum > .408 else \"w\"', '                annotation = (\"{:\" + self.fmt + \"}\").format(val)', '                text_kwargs = dict(color=text_color, ha=\"center\", va=\"center\")', '                text_kwargs.update(self.annot_kws)', '                ax.text(x, y, annotation, **text_kwargs)', '', '    def _skip_ticks(self, labels, tickevery):', '        \"\"\"Return ticks and labels at evenly spaced intervals.\"\"\"', '        n = len(labels)', '        if tickevery == 0:', '            ticks, labels = [], []', '        elif tickevery == 1:', '            ticks, labels = np.arange(n) + .5, labels', '        else:', '            start, end, step = 0, n, tickevery', '            ticks = np.arange(start, end, step) + .5', '            labels = labels[start:end:step]', '        return ticks, labels', '', '    def _auto_ticks(self, ax, labels, axis):', '        \"\"\"Determine ticks and ticklabels that minimize overlap.\"\"\"', '        transform = ax.figure.dpi_scale_trans.inverted()', '        bbox = ax.get_window_extent().transformed(transform)', '        size = [bbox.width, bbox.height][axis]', '        axis = [ax.xaxis, ax.yaxis][axis]', '        tick, = axis.set_ticks([0])', '        fontsize = tick.label1.get_size()', '        max_ticks = int(size // (fontsize / 72))', '        if max_ticks < 1:', '            return [], []', '        tick_every = len(labels) // max_ticks + 1', '        tick_every = 1 if tick_every == 0 else tick_every', '        ticks, labels = self._skip_ticks(labels, tick_every)', '        return ticks, labels', '', '    def plot(self, ax, cax, kws):', '        \"\"\"Draw the heatmap on the provided Axes.\"\"\"', '        # Remove all the Axes spines', '        despine(ax=ax, left=True, bottom=True)', '', '        # setting vmin/vmax in addition to norm is deprecated', '        # so avoid setting if norm is set', '        if \"norm\" not in kws:', '            kws.setdefault(\"vmin\", self.vmin)', '            kws.setdefault(\"vmax\", self.vmax)', '', '        # Draw the heatmap', '        mesh = ax.pcolormesh(self.plot_data, cmap=self.cmap, **kws)', '', '        # Set the axis limits', '        ax.set(xlim=(0, self.data.shape[1]), ylim=(0, self.data.shape[0]))', '', '        # Invert the y axis to show the plot in matrix form', '        ax.invert_yaxis()', '', '        # Possibly add a colorbar', '        if self.cbar:', '            cb = ax.figure.colorbar(mesh, cax, ax, **self.cbar_kws)', '            cb.outline.set_linewidth(0)', '            # If rasterized is passed to pcolormesh, also rasterize the', '            # colorbar to avoid white lines on the PDF rendering', \"            if kws.get('rasterized', False):\", '                cb.solids.set_rasterized(True)', '', '        # Add row and column labels', '        if isinstance(self.xticks, str) and self.xticks == \"auto\":', '            xticks, xticklabels = self._auto_ticks(ax, self.xticklabels, 0)', '        else:', '            xticks, xticklabels = self.xticks, self.xticklabels', '', '        if isinstance(self.yticks, str) and self.yticks == \"auto\":', '            yticks, yticklabels = self._auto_ticks(ax, self.yticklabels, 1)', '        else:', '            yticks, yticklabels = self.yticks, self.yticklabels', '', '        ax.set(xticks=xticks, yticks=yticks)', '        xtl = ax.set_xticklabels(xticklabels)', '        ytl = ax.set_yticklabels(yticklabels, rotation=\"vertical\")', '        plt.setp(ytl, va=\"center\")  # GH2484', '', '        # Possibly rotate them if they overlap', '        _draw_figure(ax.figure)', '', '        if axis_ticklabels_overlap(xtl):', '            plt.setp(xtl, rotation=\"vertical\")', '        if axis_ticklabels_overlap(ytl):', '            plt.setp(ytl, rotation=\"horizontal\")', '', '        # Add the axis labels', '        ax.set(xlabel=self.xlabel, ylabel=self.ylabel)', '', '        # Annotate the cells with the formatted values', '        if self.annot:', '            self._annotate_heatmap(ax, mesh)'], 'methods': [{'name': '__init__', 'start_line': 100, 'end_line': 190, 'text': ['    def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,', '                 annot_kws, cbar, cbar_kws,', '                 xticklabels=True, yticklabels=True, mask=None):', '        \"\"\"Initialize the plotting object.\"\"\"', '        # We always want to have a DataFrame with semantic information', '        # and an ndarray to pass to matplotlib', '        if isinstance(data, pd.DataFrame):', '            plot_data = data.values', '        else:', '            plot_data = np.asarray(data)', '            data = pd.DataFrame(plot_data)', '', '        # Validate the mask and convert to DataFrame', '        mask = _matrix_mask(data, mask)', '', '        plot_data = np.ma.masked_where(np.asarray(mask), plot_data)', '', '        # Get good names for the rows and columns', '        xtickevery = 1', '        if isinstance(xticklabels, int):', '            xtickevery = xticklabels', '            xticklabels = _index_to_ticklabels(data.columns)', '        elif xticklabels is True:', '            xticklabels = _index_to_ticklabels(data.columns)', '        elif xticklabels is False:', '            xticklabels = []', '', '        ytickevery = 1', '        if isinstance(yticklabels, int):', '            ytickevery = yticklabels', '            yticklabels = _index_to_ticklabels(data.index)', '        elif yticklabels is True:', '            yticklabels = _index_to_ticklabels(data.index)', '        elif yticklabels is False:', '            yticklabels = []', '', '        if not len(xticklabels):', '            self.xticks = []', '            self.xticklabels = []', '        elif isinstance(xticklabels, str) and xticklabels == \"auto\":', '            self.xticks = \"auto\"', '            self.xticklabels = _index_to_ticklabels(data.columns)', '        else:', '            self.xticks, self.xticklabels = self._skip_ticks(xticklabels,', '                                                             xtickevery)', '', '        if not len(yticklabels):', '            self.yticks = []', '            self.yticklabels = []', '        elif isinstance(yticklabels, str) and yticklabels == \"auto\":', '            self.yticks = \"auto\"', '            self.yticklabels = _index_to_ticklabels(data.index)', '        else:', '            self.yticks, self.yticklabels = self._skip_ticks(yticklabels,', '                                                             ytickevery)', '', '        # Get good names for the axis labels', '        xlabel = _index_to_label(data.columns)', '        ylabel = _index_to_label(data.index)', '        self.xlabel = xlabel if xlabel is not None else \"\"', '        self.ylabel = ylabel if ylabel is not None else \"\"', '', '        # Determine good default values for the colormapping', '        self._determine_cmap_params(plot_data, vmin, vmax,', '                                    cmap, center, robust)', '', '        # Sort out the annotations', '        if annot is None or annot is False:', '            annot = False', '            annot_data = None', '        else:', '            if isinstance(annot, bool):', '                annot_data = plot_data', '            else:', '                annot_data = np.asarray(annot)', '                if annot_data.shape != plot_data.shape:', '                    err = \"`data` and `annot` must have same shape.\"', '                    raise ValueError(err)', '            annot = True', '', '        # Save other attributes to the object', '        self.data = data', '        self.plot_data = plot_data', '', '        self.annot = annot', '        self.annot_data = annot_data', '', '        self.fmt = fmt', '        self.annot_kws = {} if annot_kws is None else annot_kws.copy()', '        self.cbar = cbar', '        self.cbar_kws = {} if cbar_kws is None else cbar_kws.copy()']}, {'name': '_determine_cmap_params', 'start_line': 192, 'end_line': 247, 'text': ['    def _determine_cmap_params(self, plot_data, vmin, vmax,', '                               cmap, center, robust):', '        \"\"\"Use some heuristics to set good defaults for colorbar and range.\"\"\"', '', '        # plot_data is a np.ma.array instance', '        calc_data = plot_data.astype(float).filled(np.nan)', '        if vmin is None:', '            if robust:', '                vmin = np.nanpercentile(calc_data, 2)', '            else:', '                vmin = np.nanmin(calc_data)', '        if vmax is None:', '            if robust:', '                vmax = np.nanpercentile(calc_data, 98)', '            else:', '                vmax = np.nanmax(calc_data)', '        self.vmin, self.vmax = vmin, vmax', '', '        # Choose default colormaps if not provided', '        if cmap is None:', '            if center is None:', '                self.cmap = cm.rocket', '            else:', '                self.cmap = cm.icefire', '        elif isinstance(cmap, str):', '            self.cmap = get_colormap(cmap)', '        elif isinstance(cmap, list):', '            self.cmap = mpl.colors.ListedColormap(cmap)', '        else:', '            self.cmap = cmap', '', '        # Recenter a divergent colormap', '        if center is not None:', '', '            # Copy bad values', '            # in mpl<3.2 only masked values are honored with \"bad\" color spec', '            # (see https://github.com/matplotlib/matplotlib/pull/14257)', '            bad = self.cmap(np.ma.masked_invalid([np.nan]))[0]', '', '            # under/over values are set for sure when cmap extremes', '            # do not map to the same color as +-inf', '            under = self.cmap(-np.inf)', '            over = self.cmap(np.inf)', '            under_set = under != self.cmap(0)', '            over_set = over != self.cmap(self.cmap.N - 1)', '', '            vrange = max(vmax - center, center - vmin)', '            normlize = mpl.colors.Normalize(center - vrange, center + vrange)', '            cmin, cmax = normlize([vmin, vmax])', '            cc = np.linspace(cmin, cmax, 256)', '            self.cmap = mpl.colors.ListedColormap(self.cmap(cc))', '            self.cmap.set_bad(bad)', '            if under_set:', '                self.cmap.set_under(under)', '            if over_set:', '                self.cmap.set_over(over)']}, {'name': '_annotate_heatmap', 'start_line': 249, 'end_line': 263, 'text': ['    def _annotate_heatmap(self, ax, mesh):', '        \"\"\"Add textual labels with the value in each cell.\"\"\"', '        mesh.update_scalarmappable()', '        height, width = self.annot_data.shape', '        xpos, ypos = np.meshgrid(np.arange(width) + .5, np.arange(height) + .5)', '        for x, y, m, color, val in zip(xpos.flat, ypos.flat,', '                                       mesh.get_array(), mesh.get_facecolors(),', '                                       self.annot_data.flat):', '            if m is not np.ma.masked:', '                lum = relative_luminance(color)', '                text_color = \".15\" if lum > .408 else \"w\"', '                annotation = (\"{:\" + self.fmt + \"}\").format(val)', '                text_kwargs = dict(color=text_color, ha=\"center\", va=\"center\")', '                text_kwargs.update(self.annot_kws)', '                ax.text(x, y, annotation, **text_kwargs)']}, {'name': '_skip_ticks', 'start_line': 265, 'end_line': 276, 'text': ['    def _skip_ticks(self, labels, tickevery):', '        \"\"\"Return ticks and labels at evenly spaced intervals.\"\"\"', '        n = len(labels)', '        if tickevery == 0:', '            ticks, labels = [], []', '        elif tickevery == 1:', '            ticks, labels = np.arange(n) + .5, labels', '        else:', '            start, end, step = 0, n, tickevery', '            ticks = np.arange(start, end, step) + .5', '            labels = labels[start:end:step]', '        return ticks, labels']}, {'name': '_auto_ticks', 'start_line': 278, 'end_line': 292, 'text': ['    def _auto_ticks(self, ax, labels, axis):', '        \"\"\"Determine ticks and ticklabels that minimize overlap.\"\"\"', '        transform = ax.figure.dpi_scale_trans.inverted()', '        bbox = ax.get_window_extent().transformed(transform)', '        size = [bbox.width, bbox.height][axis]', '        axis = [ax.xaxis, ax.yaxis][axis]', '        tick, = axis.set_ticks([0])', '        fontsize = tick.label1.get_size()', '        max_ticks = int(size // (fontsize / 72))', '        if max_ticks < 1:', '            return [], []', '        tick_every = len(labels) // max_ticks + 1', '        tick_every = 1 if tick_every == 0 else tick_every', '        ticks, labels = self._skip_ticks(labels, tick_every)', '        return ticks, labels']}, {'name': 'plot', 'start_line': 294, 'end_line': 352, 'text': ['    def plot(self, ax, cax, kws):', '        \"\"\"Draw the heatmap on the provided Axes.\"\"\"', '        # Remove all the Axes spines', '        despine(ax=ax, left=True, bottom=True)', '', '        # setting vmin/vmax in addition to norm is deprecated', '        # so avoid setting if norm is set', '        if \"norm\" not in kws:', '            kws.setdefault(\"vmin\", self.vmin)', '            kws.setdefault(\"vmax\", self.vmax)', '', '        # Draw the heatmap', '        mesh = ax.pcolormesh(self.plot_data, cmap=self.cmap, **kws)', '', '        # Set the axis limits', '        ax.set(xlim=(0, self.data.shape[1]), ylim=(0, self.data.shape[0]))', '', '        # Invert the y axis to show the plot in matrix form', '        ax.invert_yaxis()', '', '        # Possibly add a colorbar', '        if self.cbar:', '            cb = ax.figure.colorbar(mesh, cax, ax, **self.cbar_kws)', '            cb.outline.set_linewidth(0)', '            # If rasterized is passed to pcolormesh, also rasterize the', '            # colorbar to avoid white lines on the PDF rendering', \"            if kws.get('rasterized', False):\", '                cb.solids.set_rasterized(True)', '', '        # Add row and column labels', '        if isinstance(self.xticks, str) and self.xticks == \"auto\":', '            xticks, xticklabels = self._auto_ticks(ax, self.xticklabels, 0)', '        else:', '            xticks, xticklabels = self.xticks, self.xticklabels', '', '        if isinstance(self.yticks, str) and self.yticks == \"auto\":', '            yticks, yticklabels = self._auto_ticks(ax, self.yticklabels, 1)', '        else:', '            yticks, yticklabels = self.yticks, self.yticklabels', '', '        ax.set(xticks=xticks, yticks=yticks)', '        xtl = ax.set_xticklabels(xticklabels)', '        ytl = ax.set_yticklabels(yticklabels, rotation=\"vertical\")', '        plt.setp(ytl, va=\"center\")  # GH2484', '', '        # Possibly rotate them if they overlap', '        _draw_figure(ax.figure)', '', '        if axis_ticklabels_overlap(xtl):', '            plt.setp(xtl, rotation=\"vertical\")', '        if axis_ticklabels_overlap(ytl):', '            plt.setp(ytl, rotation=\"horizontal\")', '', '        # Add the axis labels', '        ax.set(xlabel=self.xlabel, ylabel=self.ylabel)', '', '        # Annotate the cells with the formatted values', '        if self.annot:', '            self._annotate_heatmap(ax, mesh)']}]}, {'name': '_DendrogramPlotter', 'start_line': 463, 'end_line': 639, 'text': ['class _DendrogramPlotter:', '    \"\"\"Object for drawing tree of similarities between data rows/columns\"\"\"', '', '    def __init__(self, data, linkage, metric, method, axis, label, rotate):', '        \"\"\"Plot a dendrogram of the relationships between the columns of data', '', '        Parameters', '        ----------', '        data : pandas.DataFrame', '            Rectangular data', '        \"\"\"', '        self.axis = axis', '        if self.axis == 1:', '            data = data.T', '', '        if isinstance(data, pd.DataFrame):', '            array = data.values', '        else:', '            array = np.asarray(data)', '            data = pd.DataFrame(array)', '', '        self.array = array', '        self.data = data', '', '        self.shape = self.data.shape', '        self.metric = metric', '        self.method = method', '        self.axis = axis', '        self.label = label', '        self.rotate = rotate', '', '        if linkage is None:', '            self.linkage = self.calculated_linkage', '        else:', '            self.linkage = linkage', '        self.dendrogram = self.calculate_dendrogram()', '', '        # Dendrogram ends are always at multiples of 5, who knows why', '        ticks = 10 * np.arange(self.data.shape[0]) + 5', '', '        if self.label:', '            ticklabels = _index_to_ticklabels(self.data.index)', '            ticklabels = [ticklabels[i] for i in self.reordered_ind]', '            if self.rotate:', '                self.xticks = []', '                self.yticks = ticks', '                self.xticklabels = []', '', '                self.yticklabels = ticklabels', '                self.ylabel = _index_to_label(self.data.index)', \"                self.xlabel = ''\", '            else:', '                self.xticks = ticks', '                self.yticks = []', '                self.xticklabels = ticklabels', '                self.yticklabels = []', \"                self.ylabel = ''\", '                self.xlabel = _index_to_label(self.data.index)', '        else:', '            self.xticks, self.yticks = [], []', '            self.yticklabels, self.xticklabels = [], []', \"            self.xlabel, self.ylabel = '', ''\", '', \"        self.dependent_coord = self.dendrogram['dcoord']\", \"        self.independent_coord = self.dendrogram['icoord']\", '', '    def _calculate_linkage_scipy(self):', '        linkage = hierarchy.linkage(self.array, method=self.method,', '                                    metric=self.metric)', '        return linkage', '', '    def _calculate_linkage_fastcluster(self):', '        import fastcluster', '        # Fastcluster has a memory-saving vectorized version, but only', '        # with certain linkage methods, and mostly with euclidean metric', \"        # vector_methods = ('single', 'centroid', 'median', 'ward')\", \"        euclidean_methods = ('centroid', 'median', 'ward')\", \"        euclidean = self.metric == 'euclidean' and self.method in \\\\\", '            euclidean_methods', \"        if euclidean or self.method == 'single':\", '            return fastcluster.linkage_vector(self.array,', '                                              method=self.method,', '                                              metric=self.metric)', '        else:', '            linkage = fastcluster.linkage(self.array, method=self.method,', '                                          metric=self.metric)', '            return linkage', '', '    @property', '    def calculated_linkage(self):', '', '        try:', '            return self._calculate_linkage_fastcluster()', '        except ImportError:', '            if np.product(self.shape) >= 10000:', '                msg = (\"Clustering large matrix with scipy. Installing \"', '                       \"`fastcluster` may give better performance.\")', '                warnings.warn(msg)', '', '        return self._calculate_linkage_scipy()', '', '    def calculate_dendrogram(self):', '        \"\"\"Calculates a dendrogram based on the linkage matrix', '', \"        Made a separate function, not a property because don't want to\", '        recalculate the dendrogram every time it is accessed.', '', '        Returns', '        -------', '        dendrogram : dict', '            Dendrogram dictionary as returned by scipy.cluster.hierarchy', '            .dendrogram. The important key-value pairing is', '            \"reordered_ind\" which indicates the re-ordering of the matrix', '        \"\"\"', '        return hierarchy.dendrogram(self.linkage, no_plot=True,', '                                    color_threshold=-np.inf)', '', '    @property', '    def reordered_ind(self):', '        \"\"\"Indices of the matrix, reordered by the dendrogram\"\"\"', \"        return self.dendrogram['leaves']\", '', '    def plot(self, ax, tree_kws):', '        \"\"\"Plots a dendrogram of the similarities between data on the axes', '', '        Parameters', '        ----------', '        ax : matplotlib.axes.Axes', '            Axes object upon which the dendrogram is plotted', '', '        \"\"\"', '        tree_kws = {} if tree_kws is None else tree_kws.copy()', '        tree_kws.setdefault(\"linewidths\", .5)', '        tree_kws.setdefault(\"colors\", tree_kws.pop(\"color\", (.2, .2, .2)))', '', '        if self.rotate and self.axis == 0:', '            coords = zip(self.dependent_coord, self.independent_coord)', '        else:', '            coords = zip(self.independent_coord, self.dependent_coord)', '        lines = LineCollection([list(zip(x, y)) for x, y in coords],', '                               **tree_kws)', '', '        ax.add_collection(lines)', '        number_of_leaves = len(self.reordered_ind)', '        max_dependent_coord = max(map(max, self.dependent_coord))', '', '        if self.rotate:', \"            ax.yaxis.set_ticks_position('right')\", '', '            # Constants 10 and 1.05 come from', '            # `scipy.cluster.hierarchy._plot_dendrogram`', '            ax.set_ylim(0, number_of_leaves * 10)', '            ax.set_xlim(0, max_dependent_coord * 1.05)', '', '            ax.invert_xaxis()', '            ax.invert_yaxis()', '        else:', '            # Constants 10 and 1.05 come from', '            # `scipy.cluster.hierarchy._plot_dendrogram`', '            ax.set_xlim(0, number_of_leaves * 10)', '            ax.set_ylim(0, max_dependent_coord * 1.05)', '', '        despine(ax=ax, bottom=True, left=True)', '', '        ax.set(xticks=self.xticks, yticks=self.yticks,', '               xlabel=self.xlabel, ylabel=self.ylabel)', '        xtl = ax.set_xticklabels(self.xticklabels)', \"        ytl = ax.set_yticklabels(self.yticklabels, rotation='vertical')\", '', '        # Force a draw of the plot to avoid matplotlib window error', '        _draw_figure(ax.figure)', '', '        if len(ytl) > 0 and axis_ticklabels_overlap(ytl):', '            plt.setp(ytl, rotation=\"horizontal\")', '        if len(xtl) > 0 and axis_ticklabels_overlap(xtl):', '            plt.setp(xtl, rotation=\"vertical\")', '        return self'], 'methods': [{'name': '__init__', 'start_line': 466, 'end_line': 527, 'text': ['    def __init__(self, data, linkage, metric, method, axis, label, rotate):', '        \"\"\"Plot a dendrogram of the relationships between the columns of data', '', '        Parameters', '        ----------', '        data : pandas.DataFrame', '            Rectangular data', '        \"\"\"', '        self.axis = axis', '        if self.axis == 1:', '            data = data.T', '', '        if isinstance(data, pd.DataFrame):', '            array = data.values', '        else:', '            array = np.asarray(data)', '            data = pd.DataFrame(array)', '', '        self.array = array', '        self.data = data', '', '        self.shape = self.data.shape', '        self.metric = metric', '        self.method = method', '        self.axis = axis', '        self.label = label', '        self.rotate = rotate', '', '        if linkage is None:', '            self.linkage = self.calculated_linkage', '        else:', '            self.linkage = linkage', '        self.dendrogram = self.calculate_dendrogram()', '', '        # Dendrogram ends are always at multiples of 5, who knows why', '        ticks = 10 * np.arange(self.data.shape[0]) + 5', '', '        if self.label:', '            ticklabels = _index_to_ticklabels(self.data.index)', '            ticklabels = [ticklabels[i] for i in self.reordered_ind]', '            if self.rotate:', '                self.xticks = []', '                self.yticks = ticks', '                self.xticklabels = []', '', '                self.yticklabels = ticklabels', '                self.ylabel = _index_to_label(self.data.index)', \"                self.xlabel = ''\", '            else:', '                self.xticks = ticks', '                self.yticks = []', '                self.xticklabels = ticklabels', '                self.yticklabels = []', \"                self.ylabel = ''\", '                self.xlabel = _index_to_label(self.data.index)', '        else:', '            self.xticks, self.yticks = [], []', '            self.yticklabels, self.xticklabels = [], []', \"            self.xlabel, self.ylabel = '', ''\", '', \"        self.dependent_coord = self.dendrogram['dcoord']\", \"        self.independent_coord = self.dendrogram['icoord']\"]}, {'name': '_calculate_linkage_scipy', 'start_line': 529, 'end_line': 532, 'text': ['    def _calculate_linkage_scipy(self):', '        linkage = hierarchy.linkage(self.array, method=self.method,', '                                    metric=self.metric)', '        return linkage']}, {'name': '_calculate_linkage_fastcluster', 'start_line': 534, 'end_line': 549, 'text': ['    def _calculate_linkage_fastcluster(self):', '        import fastcluster', '        # Fastcluster has a memory-saving vectorized version, but only', '        # with certain linkage methods, and mostly with euclidean metric', \"        # vector_methods = ('single', 'centroid', 'median', 'ward')\", \"        euclidean_methods = ('centroid', 'median', 'ward')\", \"        euclidean = self.metric == 'euclidean' and self.method in \\\\\", '            euclidean_methods', \"        if euclidean or self.method == 'single':\", '            return fastcluster.linkage_vector(self.array,', '                                              method=self.method,', '                                              metric=self.metric)', '        else:', '            linkage = fastcluster.linkage(self.array, method=self.method,', '                                          metric=self.metric)', '            return linkage']}, {'name': 'calculated_linkage', 'start_line': 552, 'end_line': 562, 'text': ['    def calculated_linkage(self):', '', '        try:', '            return self._calculate_linkage_fastcluster()', '        except ImportError:', '            if np.product(self.shape) >= 10000:', '                msg = (\"Clustering large matrix with scipy. Installing \"', '                       \"`fastcluster` may give better performance.\")', '                warnings.warn(msg)', '', '        return self._calculate_linkage_scipy()']}, {'name': 'calculate_dendrogram', 'start_line': 564, 'end_line': 578, 'text': ['    def calculate_dendrogram(self):', '        \"\"\"Calculates a dendrogram based on the linkage matrix', '', \"        Made a separate function, not a property because don't want to\", '        recalculate the dendrogram every time it is accessed.', '', '        Returns', '        -------', '        dendrogram : dict', '            Dendrogram dictionary as returned by scipy.cluster.hierarchy', '            .dendrogram. The important key-value pairing is', '            \"reordered_ind\" which indicates the re-ordering of the matrix', '        \"\"\"', '        return hierarchy.dendrogram(self.linkage, no_plot=True,', '                                    color_threshold=-np.inf)']}, {'name': 'reordered_ind', 'start_line': 581, 'end_line': 583, 'text': ['    def reordered_ind(self):', '        \"\"\"Indices of the matrix, reordered by the dendrogram\"\"\"', \"        return self.dendrogram['leaves']\"]}, {'name': 'plot', 'start_line': 585, 'end_line': 639, 'text': ['    def plot(self, ax, tree_kws):', '        \"\"\"Plots a dendrogram of the similarities between data on the axes', '', '        Parameters', '        ----------', '        ax : matplotlib.axes.Axes', '            Axes object upon which the dendrogram is plotted', '', '        \"\"\"', '        tree_kws = {} if tree_kws is None else tree_kws.copy()', '        tree_kws.setdefault(\"linewidths\", .5)', '        tree_kws.setdefault(\"colors\", tree_kws.pop(\"color\", (.2, .2, .2)))', '', '        if self.rotate and self.axis == 0:', '            coords = zip(self.dependent_coord, self.independent_coord)', '        else:', '            coords = zip(self.independent_coord, self.dependent_coord)', '        lines = LineCollection([list(zip(x, y)) for x, y in coords],', '                               **tree_kws)', '', '        ax.add_collection(lines)', '        number_of_leaves = len(self.reordered_ind)', '        max_dependent_coord = max(map(max, self.dependent_coord))', '', '        if self.rotate:', \"            ax.yaxis.set_ticks_position('right')\", '', '            # Constants 10 and 1.05 come from', '            # `scipy.cluster.hierarchy._plot_dendrogram`', '            ax.set_ylim(0, number_of_leaves * 10)', '            ax.set_xlim(0, max_dependent_coord * 1.05)', '', '            ax.invert_xaxis()', '            ax.invert_yaxis()', '        else:', '            # Constants 10 and 1.05 come from', '            # `scipy.cluster.hierarchy._plot_dendrogram`', '            ax.set_xlim(0, number_of_leaves * 10)', '            ax.set_ylim(0, max_dependent_coord * 1.05)', '', '        despine(ax=ax, bottom=True, left=True)', '', '        ax.set(xticks=self.xticks, yticks=self.yticks,', '               xlabel=self.xlabel, ylabel=self.ylabel)', '        xtl = ax.set_xticklabels(self.xticklabels)', \"        ytl = ax.set_yticklabels(self.yticklabels, rotation='vertical')\", '', '        # Force a draw of the plot to avoid matplotlib window error', '        _draw_figure(ax.figure)', '', '        if len(ytl) > 0 and axis_ticklabels_overlap(ytl):', '            plt.setp(ytl, rotation=\"horizontal\")', '        if len(xtl) > 0 and axis_ticklabels_overlap(xtl):', '            plt.setp(xtl, rotation=\"vertical\")', '        return self']}]}, {'name': 'ClusterGrid', 'start_line': 696, 'end_line': 1143, 'text': ['class ClusterGrid(Grid):', '', '    def __init__(self, data, pivot_kws=None, z_score=None, standard_scale=None,', '                 figsize=None, row_colors=None, col_colors=None, mask=None,', '                 dendrogram_ratio=None, colors_ratio=None, cbar_pos=None):', '        \"\"\"Grid object for organizing clustered heatmap input on to axes\"\"\"', '        if _no_scipy:', '            raise RuntimeError(\"ClusterGrid requires scipy to be available\")', '', '        if isinstance(data, pd.DataFrame):', '            self.data = data', '        else:', '            self.data = pd.DataFrame(data)', '', '        self.data2d = self.format_data(self.data, pivot_kws, z_score,', '                                       standard_scale)', '', '        self.mask = _matrix_mask(self.data2d, mask)', '', '        self._figure = plt.figure(figsize=figsize)', '', '        self.row_colors, self.row_color_labels = \\\\', '            self._preprocess_colors(data, row_colors, axis=0)', '        self.col_colors, self.col_color_labels = \\\\', '            self._preprocess_colors(data, col_colors, axis=1)', '', '        try:', '            row_dendrogram_ratio, col_dendrogram_ratio = dendrogram_ratio', '        except TypeError:', '            row_dendrogram_ratio = col_dendrogram_ratio = dendrogram_ratio', '', '        try:', '            row_colors_ratio, col_colors_ratio = colors_ratio', '        except TypeError:', '            row_colors_ratio = col_colors_ratio = colors_ratio', '', '        width_ratios = self.dim_ratios(self.row_colors,', '                                       row_dendrogram_ratio,', '                                       row_colors_ratio)', '        height_ratios = self.dim_ratios(self.col_colors,', '                                        col_dendrogram_ratio,', '                                        col_colors_ratio)', '', '        nrows = 2 if self.col_colors is None else 3', '        ncols = 2 if self.row_colors is None else 3', '', '        self.gs = gridspec.GridSpec(nrows, ncols,', '                                    width_ratios=width_ratios,', '                                    height_ratios=height_ratios)', '', '        self.ax_row_dendrogram = self._figure.add_subplot(self.gs[-1, 0])', '        self.ax_col_dendrogram = self._figure.add_subplot(self.gs[0, -1])', '        self.ax_row_dendrogram.set_axis_off()', '        self.ax_col_dendrogram.set_axis_off()', '', '        self.ax_row_colors = None', '        self.ax_col_colors = None', '', '        if self.row_colors is not None:', '            self.ax_row_colors = self._figure.add_subplot(', '                self.gs[-1, 1])', '        if self.col_colors is not None:', '            self.ax_col_colors = self._figure.add_subplot(', '                self.gs[1, -1])', '', '        self.ax_heatmap = self._figure.add_subplot(self.gs[-1, -1])', '        if cbar_pos is None:', '            self.ax_cbar = self.cax = None', '        else:', '            # Initialize the colorbar axes in the gridspec so that tight_layout', '            # works. We will move it where it belongs later. This is a hack.', '            self.ax_cbar = self._figure.add_subplot(self.gs[0, 0])', '            self.cax = self.ax_cbar  # Backwards compatibility', '        self.cbar_pos = cbar_pos', '', '        self.dendrogram_row = None', '        self.dendrogram_col = None', '', '    def _preprocess_colors(self, data, colors, axis):', '        \"\"\"Preprocess {row/col}_colors to extract labels and convert colors.\"\"\"', '        labels = None', '', '        if colors is not None:', '            if isinstance(colors, (pd.DataFrame, pd.Series)):', '', '                # If data is unindexed, raise', '                if (not hasattr(data, \"index\") and axis == 0) or (', '                    not hasattr(data, \"columns\") and axis == 1', '                ):', '                    axis_name = \"col\" if axis else \"row\"', '                    msg = (f\"{axis_name}_colors indices can\\'t be matched with data \"', '                           f\"indices. Provide {axis_name}_colors as a non-indexed \"', '                           \"datatype, e.g. by using `.to_numpy()``\")', '                    raise TypeError(msg)', '', '                # Ensure colors match data indices', '                if axis == 0:', '                    colors = colors.reindex(data.index)', '                else:', '                    colors = colors.reindex(data.columns)', '', \"                # Replace na's with white color\", '                # TODO We should set these to transparent instead', \"                colors = colors.astype(object).fillna('white')\", '', '                # Extract color values and labels from frame/series', '                if isinstance(colors, pd.DataFrame):', '                    labels = list(colors.columns)', '                    colors = colors.T.values', '                else:', '                    if colors.name is None:', '                        labels = [\"\"]', '                    else:', '                        labels = [colors.name]', '                    colors = colors.values', '', '            colors = _convert_colors(colors)', '', '        return colors, labels', '', '    def format_data(self, data, pivot_kws, z_score=None,', '                    standard_scale=None):', '        \"\"\"Extract variables from data or use directly.\"\"\"', '', '        # Either the data is already in 2d matrix format, or need to do a pivot', '        if pivot_kws is not None:', '            data2d = data.pivot(**pivot_kws)', '        else:', '            data2d = data', '', '        if z_score is not None and standard_scale is not None:', '            raise ValueError(', \"                'Cannot perform both z-scoring and standard-scaling on data')\", '', '        if z_score is not None:', '            data2d = self.z_score(data2d, z_score)', '        if standard_scale is not None:', '            data2d = self.standard_scale(data2d, standard_scale)', '        return data2d', '', '    @staticmethod', '    def z_score(data2d, axis=1):', '        \"\"\"Standarize the mean and variance of the data axis', '', '        Parameters', '        ----------', '        data2d : pandas.DataFrame', '            Data to normalize', '        axis : int', '            Which axis to normalize across. If 0, normalize across rows, if 1,', '            normalize across columns.', '', '        Returns', '        -------', '        normalized : pandas.DataFrame', '            Noramlized data with a mean of 0 and variance of 1 across the', '            specified axis.', '        \"\"\"', '        if axis == 1:', '            z_scored = data2d', '        else:', '            z_scored = data2d.T', '', '        z_scored = (z_scored - z_scored.mean()) / z_scored.std()', '', '        if axis == 1:', '            return z_scored', '        else:', '            return z_scored.T', '', '    @staticmethod', '    def standard_scale(data2d, axis=1):', '        \"\"\"Divide the data by the difference between the max and min', '', '        Parameters', '        ----------', '        data2d : pandas.DataFrame', '            Data to normalize', '        axis : int', '            Which axis to normalize across. If 0, normalize across rows, if 1,', '            normalize across columns.', '', '        Returns', '        -------', '        standardized : pandas.DataFrame', '            Noramlized data with a mean of 0 and variance of 1 across the', '            specified axis.', '', '        \"\"\"', '        # Normalize these values to range from 0 to 1', '        if axis == 1:', '            standardized = data2d', '        else:', '            standardized = data2d.T', '', '        subtract = standardized.min()', '        standardized = (standardized - subtract) / (', '            standardized.max() - standardized.min())', '', '        if axis == 1:', '            return standardized', '        else:', '            return standardized.T', '', '    def dim_ratios(self, colors, dendrogram_ratio, colors_ratio):', '        \"\"\"Get the proportions of the figure taken up by each axes.\"\"\"', '        ratios = [dendrogram_ratio]', '', '        if colors is not None:', '            # Colors are encoded as rgb, so there is an extra dimension', '            if np.ndim(colors) > 2:', '                n_colors = len(colors)', '            else:', '                n_colors = 1', '', '            ratios += [n_colors * colors_ratio]', '', '        # Add the ratio for the heatmap itself', '        ratios.append(1 - sum(ratios))', '', '        return ratios', '', '    @staticmethod', '    def color_list_to_matrix_and_cmap(colors, ind, axis=0):', '        \"\"\"Turns a list of colors into a numpy matrix and matplotlib colormap', '', '        These arguments can now be plotted using heatmap(matrix, cmap)', '        and the provided colors will be plotted.', '', '        Parameters', '        ----------', '        colors : list of matplotlib colors', '            Colors to label the rows or columns of a dataframe.', '        ind : list of ints', '            Ordering of the rows or columns, to reorder the original colors', '            by the clustered dendrogram order', '        axis : int', '            Which axis this is labeling', '', '        Returns', '        -------', '        matrix : numpy.array', '            A numpy array of integer values, where each indexes into the cmap', '        cmap : matplotlib.colors.ListedColormap', '', '        \"\"\"', '        try:', '            mpl.colors.to_rgb(colors[0])', '        except ValueError:', '            # We have a 2D color structure', '            m, n = len(colors), len(colors[0])', '            if not all(len(c) == n for c in colors[1:]):', '                raise ValueError(\"Multiple side color vectors must have same size\")', '        else:', '            # We have one vector of colors', '            m, n = 1, len(colors)', '            colors = [colors]', '', '        # Map from unique colors to colormap index value', '        unique_colors = {}', '        matrix = np.zeros((m, n), int)', '        for i, inner in enumerate(colors):', '            for j, color in enumerate(inner):', '                idx = unique_colors.setdefault(color, len(unique_colors))', '                matrix[i, j] = idx', '', '        # Reorder for clustering and transpose for axis', '        matrix = matrix[:, ind]', '        if axis == 0:', '            matrix = matrix.T', '', '        cmap = mpl.colors.ListedColormap(list(unique_colors))', '        return matrix, cmap', '', '    def plot_dendrograms(self, row_cluster, col_cluster, metric, method,', '                         row_linkage, col_linkage, tree_kws):', '        # Plot the row dendrogram', '        if row_cluster:', '            self.dendrogram_row = dendrogram(', '                self.data2d, metric=metric, method=method, label=False, axis=0,', '                ax=self.ax_row_dendrogram, rotate=True, linkage=row_linkage,', '                tree_kws=tree_kws', '            )', '        else:', '            self.ax_row_dendrogram.set_xticks([])', '            self.ax_row_dendrogram.set_yticks([])', '        # PLot the column dendrogram', '        if col_cluster:', '            self.dendrogram_col = dendrogram(', '                self.data2d, metric=metric, method=method, label=False,', '                axis=1, ax=self.ax_col_dendrogram, linkage=col_linkage,', '                tree_kws=tree_kws', '            )', '        else:', '            self.ax_col_dendrogram.set_xticks([])', '            self.ax_col_dendrogram.set_yticks([])', '        despine(ax=self.ax_row_dendrogram, bottom=True, left=True)', '        despine(ax=self.ax_col_dendrogram, bottom=True, left=True)', '', '    def plot_colors(self, xind, yind, **kws):', '        \"\"\"Plots color labels between the dendrogram and the heatmap', '', '        Parameters', '        ----------', '        heatmap_kws : dict', '            Keyword arguments heatmap', '', '        \"\"\"', '        # Remove any custom colormap and centering', '        # TODO this code has consistently caused problems when we', '        # have missed kwargs that need to be excluded that it might', '        # be better to rewrite *in*clusively.', '        kws = kws.copy()', \"        kws.pop('cmap', None)\", \"        kws.pop('norm', None)\", \"        kws.pop('center', None)\", \"        kws.pop('annot', None)\", \"        kws.pop('vmin', None)\", \"        kws.pop('vmax', None)\", \"        kws.pop('robust', None)\", \"        kws.pop('xticklabels', None)\", \"        kws.pop('yticklabels', None)\", '', '        # Plot the row colors', '        if self.row_colors is not None:', '            matrix, cmap = self.color_list_to_matrix_and_cmap(', '                self.row_colors, yind, axis=0)', '', '            # Get row_color labels', '            if self.row_color_labels is not None:', '                row_color_labels = self.row_color_labels', '            else:', '                row_color_labels = False', '', '            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_row_colors,', '                    xticklabels=row_color_labels, yticklabels=False, **kws)', '', '            # Adjust rotation of labels', '            if row_color_labels is not False:', '                plt.setp(self.ax_row_colors.get_xticklabels(), rotation=90)', '        else:', '            despine(self.ax_row_colors, left=True, bottom=True)', '', '        # Plot the column colors', '        if self.col_colors is not None:', '            matrix, cmap = self.color_list_to_matrix_and_cmap(', '                self.col_colors, xind, axis=1)', '', '            # Get col_color labels', '            if self.col_color_labels is not None:', '                col_color_labels = self.col_color_labels', '            else:', '                col_color_labels = False', '', '            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_col_colors,', '                    xticklabels=False, yticklabels=col_color_labels, **kws)', '', '            # Adjust rotation of labels, place on right side', '            if col_color_labels is not False:', '                self.ax_col_colors.yaxis.tick_right()', '                plt.setp(self.ax_col_colors.get_yticklabels(), rotation=0)', '        else:', '            despine(self.ax_col_colors, left=True, bottom=True)', '', '    def plot_matrix(self, colorbar_kws, xind, yind, **kws):', '        self.data2d = self.data2d.iloc[yind, xind]', '        self.mask = self.mask.iloc[yind, xind]', '', '        # Try to reorganize specified tick labels, if provided', '        xtl = kws.pop(\"xticklabels\", \"auto\")', '        try:', '            xtl = np.asarray(xtl)[xind]', '        except (TypeError, IndexError):', '            pass', '        ytl = kws.pop(\"yticklabels\", \"auto\")', '        try:', '            ytl = np.asarray(ytl)[yind]', '        except (TypeError, IndexError):', '            pass', '', '        # Reorganize the annotations to match the heatmap', '        annot = kws.pop(\"annot\", None)', '        if annot is None or annot is False:', '            pass', '        else:', '            if isinstance(annot, bool):', '                annot_data = self.data2d', '            else:', '                annot_data = np.asarray(annot)', '                if annot_data.shape != self.data2d.shape:', '                    err = \"`data` and `annot` must have same shape.\"', '                    raise ValueError(err)', '                annot_data = annot_data[yind][:, xind]', '            annot = annot_data', '', '        # Setting ax_cbar=None in clustermap call implies no colorbar', '        kws.setdefault(\"cbar\", self.ax_cbar is not None)', '        heatmap(self.data2d, ax=self.ax_heatmap, cbar_ax=self.ax_cbar,', '                cbar_kws=colorbar_kws, mask=self.mask,', '                xticklabels=xtl, yticklabels=ytl, annot=annot, **kws)', '', '        ytl = self.ax_heatmap.get_yticklabels()', '        ytl_rot = None if not ytl else ytl[0].get_rotation()', \"        self.ax_heatmap.yaxis.set_ticks_position('right')\", \"        self.ax_heatmap.yaxis.set_label_position('right')\", '        if ytl_rot is not None:', '            ytl = self.ax_heatmap.get_yticklabels()', '            plt.setp(ytl, rotation=ytl_rot)', '', '        tight_params = dict(h_pad=.02, w_pad=.02)', '        if self.ax_cbar is None:', '            self._figure.tight_layout(**tight_params)', '        else:', '            # Turn the colorbar axes off for tight layout so that its', \"            # ticks don't interfere with the rest of the plot layout.\", '            # Then move it.', '            self.ax_cbar.set_axis_off()', '            self._figure.tight_layout(**tight_params)', '            self.ax_cbar.set_axis_on()', '            self.ax_cbar.set_position(self.cbar_pos)', '', '    def plot(self, metric, method, colorbar_kws, row_cluster, col_cluster,', '             row_linkage, col_linkage, tree_kws, **kws):', '', '        # heatmap square=True sets the aspect ratio on the axes, but that is', '        # not compatible with the multi-axes layout of clustergrid', '        if kws.get(\"square\", False):', '            msg = \"``square=True`` ignored in clustermap\"', '            warnings.warn(msg)', '            kws.pop(\"square\")', '', '        colorbar_kws = {} if colorbar_kws is None else colorbar_kws', '', '        self.plot_dendrograms(row_cluster, col_cluster, metric, method,', '                              row_linkage=row_linkage, col_linkage=col_linkage,', '                              tree_kws=tree_kws)', '        try:', '            xind = self.dendrogram_col.reordered_ind', '        except AttributeError:', '            xind = np.arange(self.data2d.shape[1])', '        try:', '            yind = self.dendrogram_row.reordered_ind', '        except AttributeError:', '            yind = np.arange(self.data2d.shape[0])', '', '        self.plot_colors(xind, yind, **kws)', '        self.plot_matrix(colorbar_kws, xind, yind, **kws)', '        return self'], 'methods': [{'name': '__init__', 'start_line': 698, 'end_line': 772, 'text': ['    def __init__(self, data, pivot_kws=None, z_score=None, standard_scale=None,', '                 figsize=None, row_colors=None, col_colors=None, mask=None,', '                 dendrogram_ratio=None, colors_ratio=None, cbar_pos=None):', '        \"\"\"Grid object for organizing clustered heatmap input on to axes\"\"\"', '        if _no_scipy:', '            raise RuntimeError(\"ClusterGrid requires scipy to be available\")', '', '        if isinstance(data, pd.DataFrame):', '            self.data = data', '        else:', '            self.data = pd.DataFrame(data)', '', '        self.data2d = self.format_data(self.data, pivot_kws, z_score,', '                                       standard_scale)', '', '        self.mask = _matrix_mask(self.data2d, mask)', '', '        self._figure = plt.figure(figsize=figsize)', '', '        self.row_colors, self.row_color_labels = \\\\', '            self._preprocess_colors(data, row_colors, axis=0)', '        self.col_colors, self.col_color_labels = \\\\', '            self._preprocess_colors(data, col_colors, axis=1)', '', '        try:', '            row_dendrogram_ratio, col_dendrogram_ratio = dendrogram_ratio', '        except TypeError:', '            row_dendrogram_ratio = col_dendrogram_ratio = dendrogram_ratio', '', '        try:', '            row_colors_ratio, col_colors_ratio = colors_ratio', '        except TypeError:', '            row_colors_ratio = col_colors_ratio = colors_ratio', '', '        width_ratios = self.dim_ratios(self.row_colors,', '                                       row_dendrogram_ratio,', '                                       row_colors_ratio)', '        height_ratios = self.dim_ratios(self.col_colors,', '                                        col_dendrogram_ratio,', '                                        col_colors_ratio)', '', '        nrows = 2 if self.col_colors is None else 3', '        ncols = 2 if self.row_colors is None else 3', '', '        self.gs = gridspec.GridSpec(nrows, ncols,', '                                    width_ratios=width_ratios,', '                                    height_ratios=height_ratios)', '', '        self.ax_row_dendrogram = self._figure.add_subplot(self.gs[-1, 0])', '        self.ax_col_dendrogram = self._figure.add_subplot(self.gs[0, -1])', '        self.ax_row_dendrogram.set_axis_off()', '        self.ax_col_dendrogram.set_axis_off()', '', '        self.ax_row_colors = None', '        self.ax_col_colors = None', '', '        if self.row_colors is not None:', '            self.ax_row_colors = self._figure.add_subplot(', '                self.gs[-1, 1])', '        if self.col_colors is not None:', '            self.ax_col_colors = self._figure.add_subplot(', '                self.gs[1, -1])', '', '        self.ax_heatmap = self._figure.add_subplot(self.gs[-1, -1])', '        if cbar_pos is None:', '            self.ax_cbar = self.cax = None', '        else:', '            # Initialize the colorbar axes in the gridspec so that tight_layout', '            # works. We will move it where it belongs later. This is a hack.', '            self.ax_cbar = self._figure.add_subplot(self.gs[0, 0])', '            self.cax = self.ax_cbar  # Backwards compatibility', '        self.cbar_pos = cbar_pos', '', '        self.dendrogram_row = None', '        self.dendrogram_col = None']}, {'name': '_preprocess_colors', 'start_line': 774, 'end_line': 814, 'text': ['    def _preprocess_colors(self, data, colors, axis):', '        \"\"\"Preprocess {row/col}_colors to extract labels and convert colors.\"\"\"', '        labels = None', '', '        if colors is not None:', '            if isinstance(colors, (pd.DataFrame, pd.Series)):', '', '                # If data is unindexed, raise', '                if (not hasattr(data, \"index\") and axis == 0) or (', '                    not hasattr(data, \"columns\") and axis == 1', '                ):', '                    axis_name = \"col\" if axis else \"row\"', '                    msg = (f\"{axis_name}_colors indices can\\'t be matched with data \"', '                           f\"indices. Provide {axis_name}_colors as a non-indexed \"', '                           \"datatype, e.g. by using `.to_numpy()``\")', '                    raise TypeError(msg)', '', '                # Ensure colors match data indices', '                if axis == 0:', '                    colors = colors.reindex(data.index)', '                else:', '                    colors = colors.reindex(data.columns)', '', \"                # Replace na's with white color\", '                # TODO We should set these to transparent instead', \"                colors = colors.astype(object).fillna('white')\", '', '                # Extract color values and labels from frame/series', '                if isinstance(colors, pd.DataFrame):', '                    labels = list(colors.columns)', '                    colors = colors.T.values', '                else:', '                    if colors.name is None:', '                        labels = [\"\"]', '                    else:', '                        labels = [colors.name]', '                    colors = colors.values', '', '            colors = _convert_colors(colors)', '', '        return colors, labels']}, {'name': 'format_data', 'start_line': 816, 'end_line': 834, 'text': ['    def format_data(self, data, pivot_kws, z_score=None,', '                    standard_scale=None):', '        \"\"\"Extract variables from data or use directly.\"\"\"', '', '        # Either the data is already in 2d matrix format, or need to do a pivot', '        if pivot_kws is not None:', '            data2d = data.pivot(**pivot_kws)', '        else:', '            data2d = data', '', '        if z_score is not None and standard_scale is not None:', '            raise ValueError(', \"                'Cannot perform both z-scoring and standard-scaling on data')\", '', '        if z_score is not None:', '            data2d = self.z_score(data2d, z_score)', '        if standard_scale is not None:', '            data2d = self.standard_scale(data2d, standard_scale)', '        return data2d']}, {'name': 'z_score', 'start_line': 837, 'end_line': 864, 'text': ['    def z_score(data2d, axis=1):', '        \"\"\"Standarize the mean and variance of the data axis', '', '        Parameters', '        ----------', '        data2d : pandas.DataFrame', '            Data to normalize', '        axis : int', '            Which axis to normalize across. If 0, normalize across rows, if 1,', '            normalize across columns.', '', '        Returns', '        -------', '        normalized : pandas.DataFrame', '            Noramlized data with a mean of 0 and variance of 1 across the', '            specified axis.', '        \"\"\"', '        if axis == 1:', '            z_scored = data2d', '        else:', '            z_scored = data2d.T', '', '        z_scored = (z_scored - z_scored.mean()) / z_scored.std()', '', '        if axis == 1:', '            return z_scored', '        else:', '            return z_scored.T']}, {'name': 'standard_scale', 'start_line': 867, 'end_line': 898, 'text': ['    def standard_scale(data2d, axis=1):', '        \"\"\"Divide the data by the difference between the max and min', '', '        Parameters', '        ----------', '        data2d : pandas.DataFrame', '            Data to normalize', '        axis : int', '            Which axis to normalize across. If 0, normalize across rows, if 1,', '            normalize across columns.', '', '        Returns', '        -------', '        standardized : pandas.DataFrame', '            Noramlized data with a mean of 0 and variance of 1 across the', '            specified axis.', '', '        \"\"\"', '        # Normalize these values to range from 0 to 1', '        if axis == 1:', '            standardized = data2d', '        else:', '            standardized = data2d.T', '', '        subtract = standardized.min()', '        standardized = (standardized - subtract) / (', '            standardized.max() - standardized.min())', '', '        if axis == 1:', '            return standardized', '        else:', '            return standardized.T']}, {'name': 'dim_ratios', 'start_line': 900, 'end_line': 916, 'text': ['    def dim_ratios(self, colors, dendrogram_ratio, colors_ratio):', '        \"\"\"Get the proportions of the figure taken up by each axes.\"\"\"', '        ratios = [dendrogram_ratio]', '', '        if colors is not None:', '            # Colors are encoded as rgb, so there is an extra dimension', '            if np.ndim(colors) > 2:', '                n_colors = len(colors)', '            else:', '                n_colors = 1', '', '            ratios += [n_colors * colors_ratio]', '', '        # Add the ratio for the heatmap itself', '        ratios.append(1 - sum(ratios))', '', '        return ratios']}, {'name': 'color_list_to_matrix_and_cmap', 'start_line': 919, 'end_line': 968, 'text': ['    def color_list_to_matrix_and_cmap(colors, ind, axis=0):', '        \"\"\"Turns a list of colors into a numpy matrix and matplotlib colormap', '', '        These arguments can now be plotted using heatmap(matrix, cmap)', '        and the provided colors will be plotted.', '', '        Parameters', '        ----------', '        colors : list of matplotlib colors', '            Colors to label the rows or columns of a dataframe.', '        ind : list of ints', '            Ordering of the rows or columns, to reorder the original colors', '            by the clustered dendrogram order', '        axis : int', '            Which axis this is labeling', '', '        Returns', '        -------', '        matrix : numpy.array', '            A numpy array of integer values, where each indexes into the cmap', '        cmap : matplotlib.colors.ListedColormap', '', '        \"\"\"', '        try:', '            mpl.colors.to_rgb(colors[0])', '        except ValueError:', '            # We have a 2D color structure', '            m, n = len(colors), len(colors[0])', '            if not all(len(c) == n for c in colors[1:]):', '                raise ValueError(\"Multiple side color vectors must have same size\")', '        else:', '            # We have one vector of colors', '            m, n = 1, len(colors)', '            colors = [colors]', '', '        # Map from unique colors to colormap index value', '        unique_colors = {}', '        matrix = np.zeros((m, n), int)', '        for i, inner in enumerate(colors):', '            for j, color in enumerate(inner):', '                idx = unique_colors.setdefault(color, len(unique_colors))', '                matrix[i, j] = idx', '', '        # Reorder for clustering and transpose for axis', '        matrix = matrix[:, ind]', '        if axis == 0:', '            matrix = matrix.T', '', '        cmap = mpl.colors.ListedColormap(list(unique_colors))', '        return matrix, cmap']}, {'name': 'plot_dendrograms', 'start_line': 970, 'end_line': 993, 'text': ['    def plot_dendrograms(self, row_cluster, col_cluster, metric, method,', '                         row_linkage, col_linkage, tree_kws):', '        # Plot the row dendrogram', '        if row_cluster:', '            self.dendrogram_row = dendrogram(', '                self.data2d, metric=metric, method=method, label=False, axis=0,', '                ax=self.ax_row_dendrogram, rotate=True, linkage=row_linkage,', '                tree_kws=tree_kws', '            )', '        else:', '            self.ax_row_dendrogram.set_xticks([])', '            self.ax_row_dendrogram.set_yticks([])', '        # PLot the column dendrogram', '        if col_cluster:', '            self.dendrogram_col = dendrogram(', '                self.data2d, metric=metric, method=method, label=False,', '                axis=1, ax=self.ax_col_dendrogram, linkage=col_linkage,', '                tree_kws=tree_kws', '            )', '        else:', '            self.ax_col_dendrogram.set_xticks([])', '            self.ax_col_dendrogram.set_yticks([])', '        despine(ax=self.ax_row_dendrogram, bottom=True, left=True)', '        despine(ax=self.ax_col_dendrogram, bottom=True, left=True)']}, {'name': 'plot_colors', 'start_line': 995, 'end_line': 1058, 'text': ['    def plot_colors(self, xind, yind, **kws):', '        \"\"\"Plots color labels between the dendrogram and the heatmap', '', '        Parameters', '        ----------', '        heatmap_kws : dict', '            Keyword arguments heatmap', '', '        \"\"\"', '        # Remove any custom colormap and centering', '        # TODO this code has consistently caused problems when we', '        # have missed kwargs that need to be excluded that it might', '        # be better to rewrite *in*clusively.', '        kws = kws.copy()', \"        kws.pop('cmap', None)\", \"        kws.pop('norm', None)\", \"        kws.pop('center', None)\", \"        kws.pop('annot', None)\", \"        kws.pop('vmin', None)\", \"        kws.pop('vmax', None)\", \"        kws.pop('robust', None)\", \"        kws.pop('xticklabels', None)\", \"        kws.pop('yticklabels', None)\", '', '        # Plot the row colors', '        if self.row_colors is not None:', '            matrix, cmap = self.color_list_to_matrix_and_cmap(', '                self.row_colors, yind, axis=0)', '', '            # Get row_color labels', '            if self.row_color_labels is not None:', '                row_color_labels = self.row_color_labels', '            else:', '                row_color_labels = False', '', '            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_row_colors,', '                    xticklabels=row_color_labels, yticklabels=False, **kws)', '', '            # Adjust rotation of labels', '            if row_color_labels is not False:', '                plt.setp(self.ax_row_colors.get_xticklabels(), rotation=90)', '        else:', '            despine(self.ax_row_colors, left=True, bottom=True)', '', '        # Plot the column colors', '        if self.col_colors is not None:', '            matrix, cmap = self.color_list_to_matrix_and_cmap(', '                self.col_colors, xind, axis=1)', '', '            # Get col_color labels', '            if self.col_color_labels is not None:', '                col_color_labels = self.col_color_labels', '            else:', '                col_color_labels = False', '', '            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_col_colors,', '                    xticklabels=False, yticklabels=col_color_labels, **kws)', '', '            # Adjust rotation of labels, place on right side', '            if col_color_labels is not False:', '                self.ax_col_colors.yaxis.tick_right()', '                plt.setp(self.ax_col_colors.get_yticklabels(), rotation=0)', '        else:', '            despine(self.ax_col_colors, left=True, bottom=True)']}, {'name': 'plot_matrix', 'start_line': 1060, 'end_line': 1115, 'text': ['    def plot_matrix(self, colorbar_kws, xind, yind, **kws):', '        self.data2d = self.data2d.iloc[yind, xind]', '        self.mask = self.mask.iloc[yind, xind]', '', '        # Try to reorganize specified tick labels, if provided', '        xtl = kws.pop(\"xticklabels\", \"auto\")', '        try:', '            xtl = np.asarray(xtl)[xind]', '        except (TypeError, IndexError):', '            pass', '        ytl = kws.pop(\"yticklabels\", \"auto\")', '        try:', '            ytl = np.asarray(ytl)[yind]', '        except (TypeError, IndexError):', '            pass', '', '        # Reorganize the annotations to match the heatmap', '        annot = kws.pop(\"annot\", None)', '        if annot is None or annot is False:', '            pass', '        else:', '            if isinstance(annot, bool):', '                annot_data = self.data2d', '            else:', '                annot_data = np.asarray(annot)', '                if annot_data.shape != self.data2d.shape:', '                    err = \"`data` and `annot` must have same shape.\"', '                    raise ValueError(err)', '                annot_data = annot_data[yind][:, xind]', '            annot = annot_data', '', '        # Setting ax_cbar=None in clustermap call implies no colorbar', '        kws.setdefault(\"cbar\", self.ax_cbar is not None)', '        heatmap(self.data2d, ax=self.ax_heatmap, cbar_ax=self.ax_cbar,', '                cbar_kws=colorbar_kws, mask=self.mask,', '                xticklabels=xtl, yticklabels=ytl, annot=annot, **kws)', '', '        ytl = self.ax_heatmap.get_yticklabels()', '        ytl_rot = None if not ytl else ytl[0].get_rotation()', \"        self.ax_heatmap.yaxis.set_ticks_position('right')\", \"        self.ax_heatmap.yaxis.set_label_position('right')\", '        if ytl_rot is not None:', '            ytl = self.ax_heatmap.get_yticklabels()', '            plt.setp(ytl, rotation=ytl_rot)', '', '        tight_params = dict(h_pad=.02, w_pad=.02)', '        if self.ax_cbar is None:', '            self._figure.tight_layout(**tight_params)', '        else:', '            # Turn the colorbar axes off for tight layout so that its', \"            # ticks don't interfere with the rest of the plot layout.\", '            # Then move it.', '            self.ax_cbar.set_axis_off()', '            self._figure.tight_layout(**tight_params)', '            self.ax_cbar.set_axis_on()', '            self.ax_cbar.set_position(self.cbar_pos)']}, {'name': 'plot', 'start_line': 1117, 'end_line': 1143, 'text': ['    def plot(self, metric, method, colorbar_kws, row_cluster, col_cluster,', '             row_linkage, col_linkage, tree_kws, **kws):', '', '        # heatmap square=True sets the aspect ratio on the axes, but that is', '        # not compatible with the multi-axes layout of clustergrid', '        if kws.get(\"square\", False):', '            msg = \"``square=True`` ignored in clustermap\"', '            warnings.warn(msg)', '            kws.pop(\"square\")', '', '        colorbar_kws = {} if colorbar_kws is None else colorbar_kws', '', '        self.plot_dendrograms(row_cluster, col_cluster, metric, method,', '                              row_linkage=row_linkage, col_linkage=col_linkage,', '                              tree_kws=tree_kws)', '        try:', '            xind = self.dendrogram_col.reordered_ind', '        except AttributeError:', '            xind = np.arange(self.data2d.shape[1])', '        try:', '            yind = self.dendrogram_row.reordered_ind', '        except AttributeError:', '            yind = np.arange(self.data2d.shape[0])', '', '        self.plot_colors(xind, yind, **kws)', '        self.plot_matrix(colorbar_kws, xind, yind, **kws)', '        return self']}]}], 'functions': [{'name': '_index_to_label', 'start_line': 31, 'end_line': 36, 'text': ['def _index_to_label(index):', '    \"\"\"Convert a pandas index or multiindex to an axis label.\"\"\"', '    if isinstance(index, pd.MultiIndex):', '        return \"-\".join(map(to_utf8, index.names))', '    else:', '        return index.name']}, {'name': '_index_to_ticklabels', 'start_line': 39, 'end_line': 44, 'text': ['def _index_to_ticklabels(index):', '    \"\"\"Convert a pandas index or multiindex into ticklabels.\"\"\"', '    if isinstance(index, pd.MultiIndex):', '        return [\"-\".join(map(to_utf8, i)) for i in index.values]', '    else:', '        return index.values']}, {'name': '_convert_colors', 'start_line': 47, 'end_line': 57, 'text': ['def _convert_colors(colors):', '    \"\"\"Convert either a list of colors or nested lists of colors to RGB.\"\"\"', '    to_rgb = mpl.colors.to_rgb', '', '    try:', '        to_rgb(colors[0])', '        # If this works, there is only one level of colors', '        return list(map(to_rgb, colors))', '    except ValueError:', '        # If we get here, we have nested lists', '        return [list(map(to_rgb, l)) for l in colors]']}, {'name': '_matrix_mask', 'start_line': 60, 'end_line': 94, 'text': ['def _matrix_mask(data, mask):', '    \"\"\"Ensure that data and mask are compatible and add missing values.', '', '    Values will be plotted for cells where ``mask`` is ``False``.', '', '    ``data`` is expected to be a DataFrame; ``mask`` can be an array or', '    a DataFrame.', '', '    \"\"\"', '    if mask is None:', '        mask = np.zeros(data.shape, bool)', '', '    if isinstance(mask, np.ndarray):', '        # For array masks, ensure that shape matches data then convert', '        if mask.shape != data.shape:', '            raise ValueError(\"Mask must have the same shape as data.\")', '', '        mask = pd.DataFrame(mask,', '                            index=data.index,', '                            columns=data.columns,', '                            dtype=bool)', '', '    elif isinstance(mask, pd.DataFrame):', '        # For DataFrame masks, ensure that semantic labels match data', '        if not mask.index.equals(data.index) \\\\', '           and mask.columns.equals(data.columns):', '            err = \"Mask must have the same index and columns as data.\"', '            raise ValueError(err)', '', '    # Add any cells with missing data to the mask', \"    # This works around an issue where `plt.pcolormesh` doesn't represent\", '    # missing data properly', '    mask = mask | pd.isnull(data)', '', '    return mask']}, {'name': 'heatmap', 'start_line': 355, 'end_line': 460, 'text': ['def heatmap(', '    data, *,', '    vmin=None, vmax=None, cmap=None, center=None, robust=False,', '    annot=None, fmt=\".2g\", annot_kws=None,', '    linewidths=0, linecolor=\"white\",', '    cbar=True, cbar_kws=None, cbar_ax=None,', '    square=False, xticklabels=\"auto\", yticklabels=\"auto\",', '    mask=None, ax=None,', '    **kwargs', '):', '    \"\"\"Plot rectangular data as a color-encoded matrix.', '', '    This is an Axes-level function and will draw the heatmap into the', '    currently-active Axes if none is provided to the ``ax`` argument.  Part of', '    this Axes space will be taken and used to plot a colormap, unless ``cbar``', '    is False or a separate Axes is provided to ``cbar_ax``.', '', '    Parameters', '    ----------', '    data : rectangular dataset', '        2D dataset that can be coerced into an ndarray. If a Pandas DataFrame', '        is provided, the index/column information will be used to label the', '        columns and rows.', '    vmin, vmax : floats, optional', '        Values to anchor the colormap, otherwise they are inferred from the', '        data and other keyword arguments.', '    cmap : matplotlib colormap name or object, or list of colors, optional', '        The mapping from data values to color space. If not provided, the', '        default will depend on whether ``center`` is set.', '    center : float, optional', '        The value at which to center the colormap when plotting divergent data.', '        Using this parameter will change the default ``cmap`` if none is', '        specified.', '    robust : bool, optional', '        If True and ``vmin`` or ``vmax`` are absent, the colormap range is', '        computed with robust quantiles instead of the extreme values.', '    annot : bool or rectangular dataset, optional', '        If True, write the data value in each cell. If an array-like with the', '        same shape as ``data``, then use this to annotate the heatmap instead', '        of the data. Note that DataFrames will match on position, not index.', '    fmt : str, optional', '        String formatting code to use when adding annotations.', '    annot_kws : dict of key, value mappings, optional', '        Keyword arguments for :meth:`matplotlib.axes.Axes.text` when ``annot``', '        is True.', '    linewidths : float, optional', '        Width of the lines that will divide each cell.', '    linecolor : color, optional', '        Color of the lines that will divide each cell.', '    cbar : bool, optional', '        Whether to draw a colorbar.', '    cbar_kws : dict of key, value mappings, optional', '        Keyword arguments for :meth:`matplotlib.figure.Figure.colorbar`.', '    cbar_ax : matplotlib Axes, optional', '        Axes in which to draw the colorbar, otherwise take space from the', '        main Axes.', '    square : bool, optional', '        If True, set the Axes aspect to \"equal\" so each cell will be', '        square-shaped.', '    xticklabels, yticklabels : \"auto\", bool, list-like, or int, optional', \"        If True, plot the column names of the dataframe. If False, don't plot\", '        the column names. If list-like, plot these alternate labels as the', '        xticklabels. If an integer, use the column names but plot only every', '        n label. If \"auto\", try to densely plot non-overlapping labels.', '    mask : bool array or DataFrame, optional', '        If passed, data will not be shown in cells where ``mask`` is True.', '        Cells with missing values are automatically masked.', '    ax : matplotlib Axes, optional', '        Axes in which to draw the plot, otherwise use the currently-active', '        Axes.', '    kwargs : other keyword arguments', '        All other keyword arguments are passed to', '        :meth:`matplotlib.axes.Axes.pcolormesh`.', '', '    Returns', '    -------', '    ax : matplotlib Axes', '        Axes object with the heatmap.', '', '    See Also', '    --------', '    clustermap : Plot a matrix using hierarchical clustering to arrange the', '                 rows and columns.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/heatmap.rst', '', '    \"\"\"', '    # Initialize the plotter object', '    plotter = _HeatMapper(data, vmin, vmax, cmap, center, robust, annot, fmt,', '                          annot_kws, cbar, cbar_kws, xticklabels,', '                          yticklabels, mask)', '', '    # Add the pcolormesh kwargs here', '    kwargs[\"linewidths\"] = linewidths', '    kwargs[\"edgecolor\"] = linecolor', '', '    # Draw the plot and return the Axes', '    if ax is None:', '        ax = plt.gca()', '    if square:', '        ax.set_aspect(\"equal\")', '    plotter.plot(ax, cbar_ax, kwargs)', '    return ax']}, {'name': 'dendrogram', 'start_line': 642, 'end_line': 693, 'text': ['def dendrogram(', '    data, *,', \"    linkage=None, axis=1, label=True, metric='euclidean',\", \"    method='average', rotate=False, tree_kws=None, ax=None\", '):', '    \"\"\"Draw a tree diagram of relationships within a matrix', '', '    Parameters', '    ----------', '    data : pandas.DataFrame', '        Rectangular data', '    linkage : numpy.array, optional', '        Linkage matrix', '    axis : int, optional', '        Which axis to use to calculate linkage. 0 is rows, 1 is columns.', '    label : bool, optional', '        If True, label the dendrogram at leaves with column or row names', '    metric : str, optional', '        Distance metric. Anything valid for scipy.spatial.distance.pdist', '    method : str, optional', '        Linkage method to use. Anything valid for', '        scipy.cluster.hierarchy.linkage', '    rotate : bool, optional', '        When plotting the matrix, whether to rotate it 90 degrees', '        counter-clockwise, so the leaves face right', '    tree_kws : dict, optional', '        Keyword arguments for the ``matplotlib.collections.LineCollection``', '        that is used for plotting the lines of the dendrogram tree.', '    ax : matplotlib axis, optional', '        Axis to plot on, otherwise uses current axis', '', '    Returns', '    -------', '    dendrogramplotter : _DendrogramPlotter', '        A Dendrogram plotter object.', '', '    Notes', '    -----', '    Access the reordered dendrogram indices with', '    dendrogramplotter.reordered_ind', '', '    \"\"\"', '    if _no_scipy:', '        raise RuntimeError(\"dendrogram requires scipy to be installed\")', '', '    plotter = _DendrogramPlotter(data, linkage=linkage, axis=axis,', '                                 metric=metric, method=method,', '                                 label=label, rotate=rotate)', '    if ax is None:', '        ax = plt.gca()', '', '    return plotter.plot(ax=ax, tree_kws=tree_kws)']}, {'name': 'clustermap', 'start_line': 1146, 'end_line': 1262, 'text': ['def clustermap(', '    data, *,', \"    pivot_kws=None, method='average', metric='euclidean',\", '    z_score=None, standard_scale=None, figsize=(10, 10),', '    cbar_kws=None, row_cluster=True, col_cluster=True,', '    row_linkage=None, col_linkage=None,', '    row_colors=None, col_colors=None, mask=None,', '    dendrogram_ratio=.2, colors_ratio=0.03,', '    cbar_pos=(.02, .8, .05, .18), tree_kws=None,', '    **kwargs', '):', '    \"\"\"', '    Plot a matrix dataset as a hierarchically-clustered heatmap.', '', '    This function requires scipy to be available.', '', '    Parameters', '    ----------', '    data : 2D array-like', '        Rectangular data for clustering. Cannot contain NAs.', '    pivot_kws : dict, optional', '        If `data` is a tidy dataframe, can provide keyword arguments for', '        pivot to create a rectangular dataframe.', '    method : str, optional', '        Linkage method to use for calculating clusters. See', '        :func:`scipy.cluster.hierarchy.linkage` documentation for more', '        information.', '    metric : str, optional', '        Distance metric to use for the data. See', '        :func:`scipy.spatial.distance.pdist` documentation for more options.', '        To use different metrics (or methods) for rows and columns, you may', '        construct each linkage matrix yourself and provide them as', '        `{row,col}_linkage`.', '    z_score : int or None, optional', '        Either 0 (rows) or 1 (columns). Whether or not to calculate z-scores', '        for the rows or the columns. Z scores are: z = (x - mean)/std, so', '        values in each row (column) will get the mean of the row (column)', '        subtracted, then divided by the standard deviation of the row (column).', '        This ensures that each row (column) has mean of 0 and variance of 1.', '    standard_scale : int or None, optional', '        Either 0 (rows) or 1 (columns). Whether or not to standardize that', '        dimension, meaning for each row or column, subtract the minimum and', '        divide each by its maximum.', '    figsize : tuple of (width, height), optional', '        Overall size of the figure.', '    cbar_kws : dict, optional', '        Keyword arguments to pass to `cbar_kws` in :func:`heatmap`, e.g. to', '        add a label to the colorbar.', '    {row,col}_cluster : bool, optional', '        If ``True``, cluster the {rows, columns}.', '    {row,col}_linkage : :class:`numpy.ndarray`, optional', '        Precomputed linkage matrix for the rows or columns. See', '        :func:`scipy.cluster.hierarchy.linkage` for specific formats.', '    {row,col}_colors : list-like or pandas DataFrame/Series, optional', '        List of colors to label for either the rows or columns. Useful to evaluate', '        whether samples within a group are clustered together. Can use nested lists or', '        DataFrame for multiple color levels of labeling. If given as a', '        :class:`pandas.DataFrame` or :class:`pandas.Series`, labels for the colors are', '        extracted from the DataFrames column names or from the name of the Series.', '        DataFrame/Series colors are also matched to the data by their index, ensuring', '        colors are drawn in the correct order.', '    mask : bool array or DataFrame, optional', '        If passed, data will not be shown in cells where `mask` is True.', '        Cells with missing values are automatically masked. Only used for', '        visualizing, not for calculating.', '    {dendrogram,colors}_ratio : float, or pair of floats, optional', '        Proportion of the figure size devoted to the two marginal elements. If', '        a pair is given, they correspond to (row, col) ratios.', '    cbar_pos : tuple of (left, bottom, width, height), optional', '        Position of the colorbar axes in the figure. Setting to ``None`` will', '        disable the colorbar.', '    tree_kws : dict, optional', '        Parameters for the :class:`matplotlib.collections.LineCollection`', '        that is used to plot the lines of the dendrogram tree.', '    kwargs : other keyword arguments', '        All other keyword arguments are passed to :func:`heatmap`.', '', '    Returns', '    -------', '    :class:`ClusterGrid`', '        A :class:`ClusterGrid` instance.', '', '    See Also', '    --------', '    heatmap : Plot rectangular data as a color-encoded matrix.', '', '    Notes', '    -----', '    The returned object has a ``savefig`` method that should be used if you', '    want to save the figure object without clipping the dendrograms.', '', '    To access the reordered row indices, use:', '    ``clustergrid.dendrogram_row.reordered_ind``', '', '    Column indices, use:', '    ``clustergrid.dendrogram_col.reordered_ind``', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/clustermap.rst', '', '    \"\"\"', '    if _no_scipy:', '        raise RuntimeError(\"clustermap requires scipy to be available\")', '', '    plotter = ClusterGrid(data, pivot_kws=pivot_kws, figsize=figsize,', '                          row_colors=row_colors, col_colors=col_colors,', '                          z_score=z_score, standard_scale=standard_scale,', '                          mask=mask, dendrogram_ratio=dendrogram_ratio,', '                          colors_ratio=colors_ratio, cbar_pos=cbar_pos)', '', '    return plotter.plot(metric=metric, method=method,', '                        colorbar_kws=cbar_kws,', '                        row_cluster=row_cluster, col_cluster=col_cluster,', '                        row_linkage=row_linkage, col_linkage=col_linkage,', '                        tree_kws=tree_kws, **kwargs)']}], 'text': ['\"\"\"Functions to visualize matrices of data.\"\"\"', 'import warnings', '', 'import matplotlib as mpl', 'from matplotlib.collections import LineCollection', 'import matplotlib.pyplot as plt', 'from matplotlib import gridspec', 'import numpy as np', 'import pandas as pd', 'try:', '    from scipy.cluster import hierarchy', '    _no_scipy = False', 'except ImportError:', '    _no_scipy = True', '', 'from . import cm', 'from .axisgrid import Grid', 'from ._compat import get_colormap', 'from .utils import (', '    despine,', '    axis_ticklabels_overlap,', '    relative_luminance,', '    to_utf8,', '    _draw_figure,', ')', '', '', '__all__ = [\"heatmap\", \"clustermap\"]', '', '', 'def _index_to_label(index):', '    \"\"\"Convert a pandas index or multiindex to an axis label.\"\"\"', '    if isinstance(index, pd.MultiIndex):', '        return \"-\".join(map(to_utf8, index.names))', '    else:', '        return index.name', '', '', 'def _index_to_ticklabels(index):', '    \"\"\"Convert a pandas index or multiindex into ticklabels.\"\"\"', '    if isinstance(index, pd.MultiIndex):', '        return [\"-\".join(map(to_utf8, i)) for i in index.values]', '    else:', '        return index.values', '', '', 'def _convert_colors(colors):', '    \"\"\"Convert either a list of colors or nested lists of colors to RGB.\"\"\"', '    to_rgb = mpl.colors.to_rgb', '', '    try:', '        to_rgb(colors[0])', '        # If this works, there is only one level of colors', '        return list(map(to_rgb, colors))', '    except ValueError:', '        # If we get here, we have nested lists', '        return [list(map(to_rgb, l)) for l in colors]', '', '', 'def _matrix_mask(data, mask):', '    \"\"\"Ensure that data and mask are compatible and add missing values.', '', '    Values will be plotted for cells where ``mask`` is ``False``.', '', '    ``data`` is expected to be a DataFrame; ``mask`` can be an array or', '    a DataFrame.', '', '    \"\"\"', '    if mask is None:', '        mask = np.zeros(data.shape, bool)', '', '    if isinstance(mask, np.ndarray):', '        # For array masks, ensure that shape matches data then convert', '        if mask.shape != data.shape:', '            raise ValueError(\"Mask must have the same shape as data.\")', '', '        mask = pd.DataFrame(mask,', '                            index=data.index,', '                            columns=data.columns,', '                            dtype=bool)', '', '    elif isinstance(mask, pd.DataFrame):', '        # For DataFrame masks, ensure that semantic labels match data', '        if not mask.index.equals(data.index) \\\\', '           and mask.columns.equals(data.columns):', '            err = \"Mask must have the same index and columns as data.\"', '            raise ValueError(err)', '', '    # Add any cells with missing data to the mask', \"    # This works around an issue where `plt.pcolormesh` doesn't represent\", '    # missing data properly', '    mask = mask | pd.isnull(data)', '', '    return mask', '', '', 'class _HeatMapper:', '    \"\"\"Draw a heatmap plot of a matrix with nice labels and colormaps.\"\"\"', '', '    def __init__(self, data, vmin, vmax, cmap, center, robust, annot, fmt,', '                 annot_kws, cbar, cbar_kws,', '                 xticklabels=True, yticklabels=True, mask=None):', '        \"\"\"Initialize the plotting object.\"\"\"', '        # We always want to have a DataFrame with semantic information', '        # and an ndarray to pass to matplotlib', '        if isinstance(data, pd.DataFrame):', '            plot_data = data.values', '        else:', '            plot_data = np.asarray(data)', '            data = pd.DataFrame(plot_data)', '', '        # Validate the mask and convert to DataFrame', '        mask = _matrix_mask(data, mask)', '', '        plot_data = np.ma.masked_where(np.asarray(mask), plot_data)', '', '        # Get good names for the rows and columns', '        xtickevery = 1', '        if isinstance(xticklabels, int):', '            xtickevery = xticklabels', '            xticklabels = _index_to_ticklabels(data.columns)', '        elif xticklabels is True:', '            xticklabels = _index_to_ticklabels(data.columns)', '        elif xticklabels is False:', '            xticklabels = []', '', '        ytickevery = 1', '        if isinstance(yticklabels, int):', '            ytickevery = yticklabels', '            yticklabels = _index_to_ticklabels(data.index)', '        elif yticklabels is True:', '            yticklabels = _index_to_ticklabels(data.index)', '        elif yticklabels is False:', '            yticklabels = []', '', '        if not len(xticklabels):', '            self.xticks = []', '            self.xticklabels = []', '        elif isinstance(xticklabels, str) and xticklabels == \"auto\":', '            self.xticks = \"auto\"', '            self.xticklabels = _index_to_ticklabels(data.columns)', '        else:', '            self.xticks, self.xticklabels = self._skip_ticks(xticklabels,', '                                                             xtickevery)', '', '        if not len(yticklabels):', '            self.yticks = []', '            self.yticklabels = []', '        elif isinstance(yticklabels, str) and yticklabels == \"auto\":', '            self.yticks = \"auto\"', '            self.yticklabels = _index_to_ticklabels(data.index)', '        else:', '            self.yticks, self.yticklabels = self._skip_ticks(yticklabels,', '                                                             ytickevery)', '', '        # Get good names for the axis labels', '        xlabel = _index_to_label(data.columns)', '        ylabel = _index_to_label(data.index)', '        self.xlabel = xlabel if xlabel is not None else \"\"', '        self.ylabel = ylabel if ylabel is not None else \"\"', '', '        # Determine good default values for the colormapping', '        self._determine_cmap_params(plot_data, vmin, vmax,', '                                    cmap, center, robust)', '', '        # Sort out the annotations', '        if annot is None or annot is False:', '            annot = False', '            annot_data = None', '        else:', '            if isinstance(annot, bool):', '                annot_data = plot_data', '            else:', '                annot_data = np.asarray(annot)', '                if annot_data.shape != plot_data.shape:', '                    err = \"`data` and `annot` must have same shape.\"', '                    raise ValueError(err)', '            annot = True', '', '        # Save other attributes to the object', '        self.data = data', '        self.plot_data = plot_data', '', '        self.annot = annot', '        self.annot_data = annot_data', '', '        self.fmt = fmt', '        self.annot_kws = {} if annot_kws is None else annot_kws.copy()', '        self.cbar = cbar', '        self.cbar_kws = {} if cbar_kws is None else cbar_kws.copy()', '', '    def _determine_cmap_params(self, plot_data, vmin, vmax,', '                               cmap, center, robust):', '        \"\"\"Use some heuristics to set good defaults for colorbar and range.\"\"\"', '', '        # plot_data is a np.ma.array instance', '        calc_data = plot_data.astype(float).filled(np.nan)', '        if vmin is None:', '            if robust:', '                vmin = np.nanpercentile(calc_data, 2)', '            else:', '                vmin = np.nanmin(calc_data)', '        if vmax is None:', '            if robust:', '                vmax = np.nanpercentile(calc_data, 98)', '            else:', '                vmax = np.nanmax(calc_data)', '        self.vmin, self.vmax = vmin, vmax', '', '        # Choose default colormaps if not provided', '        if cmap is None:', '            if center is None:', '                self.cmap = cm.rocket', '            else:', '                self.cmap = cm.icefire', '        elif isinstance(cmap, str):', '            self.cmap = get_colormap(cmap)', '        elif isinstance(cmap, list):', '            self.cmap = mpl.colors.ListedColormap(cmap)', '        else:', '            self.cmap = cmap', '', '        # Recenter a divergent colormap', '        if center is not None:', '', '            # Copy bad values', '            # in mpl<3.2 only masked values are honored with \"bad\" color spec', '            # (see https://github.com/matplotlib/matplotlib/pull/14257)', '            bad = self.cmap(np.ma.masked_invalid([np.nan]))[0]', '', '            # under/over values are set for sure when cmap extremes', '            # do not map to the same color as +-inf', '            under = self.cmap(-np.inf)', '            over = self.cmap(np.inf)', '            under_set = under != self.cmap(0)', '            over_set = over != self.cmap(self.cmap.N - 1)', '', '            vrange = max(vmax - center, center - vmin)', '            normlize = mpl.colors.Normalize(center - vrange, center + vrange)', '            cmin, cmax = normlize([vmin, vmax])', '            cc = np.linspace(cmin, cmax, 256)', '            self.cmap = mpl.colors.ListedColormap(self.cmap(cc))', '            self.cmap.set_bad(bad)', '            if under_set:', '                self.cmap.set_under(under)', '            if over_set:', '                self.cmap.set_over(over)', '', '    def _annotate_heatmap(self, ax, mesh):', '        \"\"\"Add textual labels with the value in each cell.\"\"\"', '        mesh.update_scalarmappable()', '        height, width = self.annot_data.shape', '        xpos, ypos = np.meshgrid(np.arange(width) + .5, np.arange(height) + .5)', '        for x, y, m, color, val in zip(xpos.flat, ypos.flat,', '                                       mesh.get_array(), mesh.get_facecolors(),', '                                       self.annot_data.flat):', '            if m is not np.ma.masked:', '                lum = relative_luminance(color)', '                text_color = \".15\" if lum > .408 else \"w\"', '                annotation = (\"{:\" + self.fmt + \"}\").format(val)', '                text_kwargs = dict(color=text_color, ha=\"center\", va=\"center\")', '                text_kwargs.update(self.annot_kws)', '                ax.text(x, y, annotation, **text_kwargs)', '', '    def _skip_ticks(self, labels, tickevery):', '        \"\"\"Return ticks and labels at evenly spaced intervals.\"\"\"', '        n = len(labels)', '        if tickevery == 0:', '            ticks, labels = [], []', '        elif tickevery == 1:', '            ticks, labels = np.arange(n) + .5, labels', '        else:', '            start, end, step = 0, n, tickevery', '            ticks = np.arange(start, end, step) + .5', '            labels = labels[start:end:step]', '        return ticks, labels', '', '    def _auto_ticks(self, ax, labels, axis):', '        \"\"\"Determine ticks and ticklabels that minimize overlap.\"\"\"', '        transform = ax.figure.dpi_scale_trans.inverted()', '        bbox = ax.get_window_extent().transformed(transform)', '        size = [bbox.width, bbox.height][axis]', '        axis = [ax.xaxis, ax.yaxis][axis]', '        tick, = axis.set_ticks([0])', '        fontsize = tick.label1.get_size()', '        max_ticks = int(size // (fontsize / 72))', '        if max_ticks < 1:', '            return [], []', '        tick_every = len(labels) // max_ticks + 1', '        tick_every = 1 if tick_every == 0 else tick_every', '        ticks, labels = self._skip_ticks(labels, tick_every)', '        return ticks, labels', '', '    def plot(self, ax, cax, kws):', '        \"\"\"Draw the heatmap on the provided Axes.\"\"\"', '        # Remove all the Axes spines', '        despine(ax=ax, left=True, bottom=True)', '', '        # setting vmin/vmax in addition to norm is deprecated', '        # so avoid setting if norm is set', '        if \"norm\" not in kws:', '            kws.setdefault(\"vmin\", self.vmin)', '            kws.setdefault(\"vmax\", self.vmax)', '', '        # Draw the heatmap', '        mesh = ax.pcolormesh(self.plot_data, cmap=self.cmap, **kws)', '', '        # Set the axis limits', '        ax.set(xlim=(0, self.data.shape[1]), ylim=(0, self.data.shape[0]))', '', '        # Invert the y axis to show the plot in matrix form', '        ax.invert_yaxis()', '', '        # Possibly add a colorbar', '        if self.cbar:', '            cb = ax.figure.colorbar(mesh, cax, ax, **self.cbar_kws)', '            cb.outline.set_linewidth(0)', '            # If rasterized is passed to pcolormesh, also rasterize the', '            # colorbar to avoid white lines on the PDF rendering', \"            if kws.get('rasterized', False):\", '                cb.solids.set_rasterized(True)', '', '        # Add row and column labels', '        if isinstance(self.xticks, str) and self.xticks == \"auto\":', '            xticks, xticklabels = self._auto_ticks(ax, self.xticklabels, 0)', '        else:', '            xticks, xticklabels = self.xticks, self.xticklabels', '', '        if isinstance(self.yticks, str) and self.yticks == \"auto\":', '            yticks, yticklabels = self._auto_ticks(ax, self.yticklabels, 1)', '        else:', '            yticks, yticklabels = self.yticks, self.yticklabels', '', '        ax.set(xticks=xticks, yticks=yticks)', '        xtl = ax.set_xticklabels(xticklabels)', '        ytl = ax.set_yticklabels(yticklabels, rotation=\"vertical\")', '        plt.setp(ytl, va=\"center\")  # GH2484', '', '        # Possibly rotate them if they overlap', '        _draw_figure(ax.figure)', '', '        if axis_ticklabels_overlap(xtl):', '            plt.setp(xtl, rotation=\"vertical\")', '        if axis_ticklabels_overlap(ytl):', '            plt.setp(ytl, rotation=\"horizontal\")', '', '        # Add the axis labels', '        ax.set(xlabel=self.xlabel, ylabel=self.ylabel)', '', '        # Annotate the cells with the formatted values', '        if self.annot:', '            self._annotate_heatmap(ax, mesh)', '', '', 'def heatmap(', '    data, *,', '    vmin=None, vmax=None, cmap=None, center=None, robust=False,', '    annot=None, fmt=\".2g\", annot_kws=None,', '    linewidths=0, linecolor=\"white\",', '    cbar=True, cbar_kws=None, cbar_ax=None,', '    square=False, xticklabels=\"auto\", yticklabels=\"auto\",', '    mask=None, ax=None,', '    **kwargs', '):', '    \"\"\"Plot rectangular data as a color-encoded matrix.', '', '    This is an Axes-level function and will draw the heatmap into the', '    currently-active Axes if none is provided to the ``ax`` argument.  Part of', '    this Axes space will be taken and used to plot a colormap, unless ``cbar``', '    is False or a separate Axes is provided to ``cbar_ax``.', '', '    Parameters', '    ----------', '    data : rectangular dataset', '        2D dataset that can be coerced into an ndarray. If a Pandas DataFrame', '        is provided, the index/column information will be used to label the', '        columns and rows.', '    vmin, vmax : floats, optional', '        Values to anchor the colormap, otherwise they are inferred from the', '        data and other keyword arguments.', '    cmap : matplotlib colormap name or object, or list of colors, optional', '        The mapping from data values to color space. If not provided, the', '        default will depend on whether ``center`` is set.', '    center : float, optional', '        The value at which to center the colormap when plotting divergent data.', '        Using this parameter will change the default ``cmap`` if none is', '        specified.', '    robust : bool, optional', '        If True and ``vmin`` or ``vmax`` are absent, the colormap range is', '        computed with robust quantiles instead of the extreme values.', '    annot : bool or rectangular dataset, optional', '        If True, write the data value in each cell. If an array-like with the', '        same shape as ``data``, then use this to annotate the heatmap instead', '        of the data. Note that DataFrames will match on position, not index.', '    fmt : str, optional', '        String formatting code to use when adding annotations.', '    annot_kws : dict of key, value mappings, optional', '        Keyword arguments for :meth:`matplotlib.axes.Axes.text` when ``annot``', '        is True.', '    linewidths : float, optional', '        Width of the lines that will divide each cell.', '    linecolor : color, optional', '        Color of the lines that will divide each cell.', '    cbar : bool, optional', '        Whether to draw a colorbar.', '    cbar_kws : dict of key, value mappings, optional', '        Keyword arguments for :meth:`matplotlib.figure.Figure.colorbar`.', '    cbar_ax : matplotlib Axes, optional', '        Axes in which to draw the colorbar, otherwise take space from the', '        main Axes.', '    square : bool, optional', '        If True, set the Axes aspect to \"equal\" so each cell will be', '        square-shaped.', '    xticklabels, yticklabels : \"auto\", bool, list-like, or int, optional', \"        If True, plot the column names of the dataframe. If False, don't plot\", '        the column names. If list-like, plot these alternate labels as the', '        xticklabels. If an integer, use the column names but plot only every', '        n label. If \"auto\", try to densely plot non-overlapping labels.', '    mask : bool array or DataFrame, optional', '        If passed, data will not be shown in cells where ``mask`` is True.', '        Cells with missing values are automatically masked.', '    ax : matplotlib Axes, optional', '        Axes in which to draw the plot, otherwise use the currently-active', '        Axes.', '    kwargs : other keyword arguments', '        All other keyword arguments are passed to', '        :meth:`matplotlib.axes.Axes.pcolormesh`.', '', '    Returns', '    -------', '    ax : matplotlib Axes', '        Axes object with the heatmap.', '', '    See Also', '    --------', '    clustermap : Plot a matrix using hierarchical clustering to arrange the', '                 rows and columns.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/heatmap.rst', '', '    \"\"\"', '    # Initialize the plotter object', '    plotter = _HeatMapper(data, vmin, vmax, cmap, center, robust, annot, fmt,', '                          annot_kws, cbar, cbar_kws, xticklabels,', '                          yticklabels, mask)', '', '    # Add the pcolormesh kwargs here', '    kwargs[\"linewidths\"] = linewidths', '    kwargs[\"edgecolor\"] = linecolor', '', '    # Draw the plot and return the Axes', '    if ax is None:', '        ax = plt.gca()', '    if square:', '        ax.set_aspect(\"equal\")', '    plotter.plot(ax, cbar_ax, kwargs)', '    return ax', '', '', 'class _DendrogramPlotter:', '    \"\"\"Object for drawing tree of similarities between data rows/columns\"\"\"', '', '    def __init__(self, data, linkage, metric, method, axis, label, rotate):', '        \"\"\"Plot a dendrogram of the relationships between the columns of data', '', '        Parameters', '        ----------', '        data : pandas.DataFrame', '            Rectangular data', '        \"\"\"', '        self.axis = axis', '        if self.axis == 1:', '            data = data.T', '', '        if isinstance(data, pd.DataFrame):', '            array = data.values', '        else:', '            array = np.asarray(data)', '            data = pd.DataFrame(array)', '', '        self.array = array', '        self.data = data', '', '        self.shape = self.data.shape', '        self.metric = metric', '        self.method = method', '        self.axis = axis', '        self.label = label', '        self.rotate = rotate', '', '        if linkage is None:', '            self.linkage = self.calculated_linkage', '        else:', '            self.linkage = linkage', '        self.dendrogram = self.calculate_dendrogram()', '', '        # Dendrogram ends are always at multiples of 5, who knows why', '        ticks = 10 * np.arange(self.data.shape[0]) + 5', '', '        if self.label:', '            ticklabels = _index_to_ticklabels(self.data.index)', '            ticklabels = [ticklabels[i] for i in self.reordered_ind]', '            if self.rotate:', '                self.xticks = []', '                self.yticks = ticks', '                self.xticklabels = []', '', '                self.yticklabels = ticklabels', '                self.ylabel = _index_to_label(self.data.index)', \"                self.xlabel = ''\", '            else:', '                self.xticks = ticks', '                self.yticks = []', '                self.xticklabels = ticklabels', '                self.yticklabels = []', \"                self.ylabel = ''\", '                self.xlabel = _index_to_label(self.data.index)', '        else:', '            self.xticks, self.yticks = [], []', '            self.yticklabels, self.xticklabels = [], []', \"            self.xlabel, self.ylabel = '', ''\", '', \"        self.dependent_coord = self.dendrogram['dcoord']\", \"        self.independent_coord = self.dendrogram['icoord']\", '', '    def _calculate_linkage_scipy(self):', '        linkage = hierarchy.linkage(self.array, method=self.method,', '                                    metric=self.metric)', '        return linkage', '', '    def _calculate_linkage_fastcluster(self):', '        import fastcluster', '        # Fastcluster has a memory-saving vectorized version, but only', '        # with certain linkage methods, and mostly with euclidean metric', \"        # vector_methods = ('single', 'centroid', 'median', 'ward')\", \"        euclidean_methods = ('centroid', 'median', 'ward')\", \"        euclidean = self.metric == 'euclidean' and self.method in \\\\\", '            euclidean_methods', \"        if euclidean or self.method == 'single':\", '            return fastcluster.linkage_vector(self.array,', '                                              method=self.method,', '                                              metric=self.metric)', '        else:', '            linkage = fastcluster.linkage(self.array, method=self.method,', '                                          metric=self.metric)', '            return linkage', '', '    @property', '    def calculated_linkage(self):', '', '        try:', '            return self._calculate_linkage_fastcluster()', '        except ImportError:', '            if np.product(self.shape) >= 10000:', '                msg = (\"Clustering large matrix with scipy. Installing \"', '                       \"`fastcluster` may give better performance.\")', '                warnings.warn(msg)', '', '        return self._calculate_linkage_scipy()', '', '    def calculate_dendrogram(self):', '        \"\"\"Calculates a dendrogram based on the linkage matrix', '', \"        Made a separate function, not a property because don't want to\", '        recalculate the dendrogram every time it is accessed.', '', '        Returns', '        -------', '        dendrogram : dict', '            Dendrogram dictionary as returned by scipy.cluster.hierarchy', '            .dendrogram. The important key-value pairing is', '            \"reordered_ind\" which indicates the re-ordering of the matrix', '        \"\"\"', '        return hierarchy.dendrogram(self.linkage, no_plot=True,', '                                    color_threshold=-np.inf)', '', '    @property', '    def reordered_ind(self):', '        \"\"\"Indices of the matrix, reordered by the dendrogram\"\"\"', \"        return self.dendrogram['leaves']\", '', '    def plot(self, ax, tree_kws):', '        \"\"\"Plots a dendrogram of the similarities between data on the axes', '', '        Parameters', '        ----------', '        ax : matplotlib.axes.Axes', '            Axes object upon which the dendrogram is plotted', '', '        \"\"\"', '        tree_kws = {} if tree_kws is None else tree_kws.copy()', '        tree_kws.setdefault(\"linewidths\", .5)', '        tree_kws.setdefault(\"colors\", tree_kws.pop(\"color\", (.2, .2, .2)))', '', '        if self.rotate and self.axis == 0:', '            coords = zip(self.dependent_coord, self.independent_coord)', '        else:', '            coords = zip(self.independent_coord, self.dependent_coord)', '        lines = LineCollection([list(zip(x, y)) for x, y in coords],', '                               **tree_kws)', '', '        ax.add_collection(lines)', '        number_of_leaves = len(self.reordered_ind)', '        max_dependent_coord = max(map(max, self.dependent_coord))', '', '        if self.rotate:', \"            ax.yaxis.set_ticks_position('right')\", '', '            # Constants 10 and 1.05 come from', '            # `scipy.cluster.hierarchy._plot_dendrogram`', '            ax.set_ylim(0, number_of_leaves * 10)', '            ax.set_xlim(0, max_dependent_coord * 1.05)', '', '            ax.invert_xaxis()', '            ax.invert_yaxis()', '        else:', '            # Constants 10 and 1.05 come from', '            # `scipy.cluster.hierarchy._plot_dendrogram`', '            ax.set_xlim(0, number_of_leaves * 10)', '            ax.set_ylim(0, max_dependent_coord * 1.05)', '', '        despine(ax=ax, bottom=True, left=True)', '', '        ax.set(xticks=self.xticks, yticks=self.yticks,', '               xlabel=self.xlabel, ylabel=self.ylabel)', '        xtl = ax.set_xticklabels(self.xticklabels)', \"        ytl = ax.set_yticklabels(self.yticklabels, rotation='vertical')\", '', '        # Force a draw of the plot to avoid matplotlib window error', '        _draw_figure(ax.figure)', '', '        if len(ytl) > 0 and axis_ticklabels_overlap(ytl):', '            plt.setp(ytl, rotation=\"horizontal\")', '        if len(xtl) > 0 and axis_ticklabels_overlap(xtl):', '            plt.setp(xtl, rotation=\"vertical\")', '        return self', '', '', 'def dendrogram(', '    data, *,', \"    linkage=None, axis=1, label=True, metric='euclidean',\", \"    method='average', rotate=False, tree_kws=None, ax=None\", '):', '    \"\"\"Draw a tree diagram of relationships within a matrix', '', '    Parameters', '    ----------', '    data : pandas.DataFrame', '        Rectangular data', '    linkage : numpy.array, optional', '        Linkage matrix', '    axis : int, optional', '        Which axis to use to calculate linkage. 0 is rows, 1 is columns.', '    label : bool, optional', '        If True, label the dendrogram at leaves with column or row names', '    metric : str, optional', '        Distance metric. Anything valid for scipy.spatial.distance.pdist', '    method : str, optional', '        Linkage method to use. Anything valid for', '        scipy.cluster.hierarchy.linkage', '    rotate : bool, optional', '        When plotting the matrix, whether to rotate it 90 degrees', '        counter-clockwise, so the leaves face right', '    tree_kws : dict, optional', '        Keyword arguments for the ``matplotlib.collections.LineCollection``', '        that is used for plotting the lines of the dendrogram tree.', '    ax : matplotlib axis, optional', '        Axis to plot on, otherwise uses current axis', '', '    Returns', '    -------', '    dendrogramplotter : _DendrogramPlotter', '        A Dendrogram plotter object.', '', '    Notes', '    -----', '    Access the reordered dendrogram indices with', '    dendrogramplotter.reordered_ind', '', '    \"\"\"', '    if _no_scipy:', '        raise RuntimeError(\"dendrogram requires scipy to be installed\")', '', '    plotter = _DendrogramPlotter(data, linkage=linkage, axis=axis,', '                                 metric=metric, method=method,', '                                 label=label, rotate=rotate)', '    if ax is None:', '        ax = plt.gca()', '', '    return plotter.plot(ax=ax, tree_kws=tree_kws)', '', '', 'class ClusterGrid(Grid):', '', '    def __init__(self, data, pivot_kws=None, z_score=None, standard_scale=None,', '                 figsize=None, row_colors=None, col_colors=None, mask=None,', '                 dendrogram_ratio=None, colors_ratio=None, cbar_pos=None):', '        \"\"\"Grid object for organizing clustered heatmap input on to axes\"\"\"', '        if _no_scipy:', '            raise RuntimeError(\"ClusterGrid requires scipy to be available\")', '', '        if isinstance(data, pd.DataFrame):', '            self.data = data', '        else:', '            self.data = pd.DataFrame(data)', '', '        self.data2d = self.format_data(self.data, pivot_kws, z_score,', '                                       standard_scale)', '', '        self.mask = _matrix_mask(self.data2d, mask)', '', '        self._figure = plt.figure(figsize=figsize)', '', '        self.row_colors, self.row_color_labels = \\\\', '            self._preprocess_colors(data, row_colors, axis=0)', '        self.col_colors, self.col_color_labels = \\\\', '            self._preprocess_colors(data, col_colors, axis=1)', '', '        try:', '            row_dendrogram_ratio, col_dendrogram_ratio = dendrogram_ratio', '        except TypeError:', '            row_dendrogram_ratio = col_dendrogram_ratio = dendrogram_ratio', '', '        try:', '            row_colors_ratio, col_colors_ratio = colors_ratio', '        except TypeError:', '            row_colors_ratio = col_colors_ratio = colors_ratio', '', '        width_ratios = self.dim_ratios(self.row_colors,', '                                       row_dendrogram_ratio,', '                                       row_colors_ratio)', '        height_ratios = self.dim_ratios(self.col_colors,', '                                        col_dendrogram_ratio,', '                                        col_colors_ratio)', '', '        nrows = 2 if self.col_colors is None else 3', '        ncols = 2 if self.row_colors is None else 3', '', '        self.gs = gridspec.GridSpec(nrows, ncols,', '                                    width_ratios=width_ratios,', '                                    height_ratios=height_ratios)', '', '        self.ax_row_dendrogram = self._figure.add_subplot(self.gs[-1, 0])', '        self.ax_col_dendrogram = self._figure.add_subplot(self.gs[0, -1])', '        self.ax_row_dendrogram.set_axis_off()', '        self.ax_col_dendrogram.set_axis_off()', '', '        self.ax_row_colors = None', '        self.ax_col_colors = None', '', '        if self.row_colors is not None:', '            self.ax_row_colors = self._figure.add_subplot(', '                self.gs[-1, 1])', '        if self.col_colors is not None:', '            self.ax_col_colors = self._figure.add_subplot(', '                self.gs[1, -1])', '', '        self.ax_heatmap = self._figure.add_subplot(self.gs[-1, -1])', '        if cbar_pos is None:', '            self.ax_cbar = self.cax = None', '        else:', '            # Initialize the colorbar axes in the gridspec so that tight_layout', '            # works. We will move it where it belongs later. This is a hack.', '            self.ax_cbar = self._figure.add_subplot(self.gs[0, 0])', '            self.cax = self.ax_cbar  # Backwards compatibility', '        self.cbar_pos = cbar_pos', '', '        self.dendrogram_row = None', '        self.dendrogram_col = None', '', '    def _preprocess_colors(self, data, colors, axis):', '        \"\"\"Preprocess {row/col}_colors to extract labels and convert colors.\"\"\"', '        labels = None', '', '        if colors is not None:', '            if isinstance(colors, (pd.DataFrame, pd.Series)):', '', '                # If data is unindexed, raise', '                if (not hasattr(data, \"index\") and axis == 0) or (', '                    not hasattr(data, \"columns\") and axis == 1', '                ):', '                    axis_name = \"col\" if axis else \"row\"', '                    msg = (f\"{axis_name}_colors indices can\\'t be matched with data \"', '                           f\"indices. Provide {axis_name}_colors as a non-indexed \"', '                           \"datatype, e.g. by using `.to_numpy()``\")', '                    raise TypeError(msg)', '', '                # Ensure colors match data indices', '                if axis == 0:', '                    colors = colors.reindex(data.index)', '                else:', '                    colors = colors.reindex(data.columns)', '', \"                # Replace na's with white color\", '                # TODO We should set these to transparent instead', \"                colors = colors.astype(object).fillna('white')\", '', '                # Extract color values and labels from frame/series', '                if isinstance(colors, pd.DataFrame):', '                    labels = list(colors.columns)', '                    colors = colors.T.values', '                else:', '                    if colors.name is None:', '                        labels = [\"\"]', '                    else:', '                        labels = [colors.name]', '                    colors = colors.values', '', '            colors = _convert_colors(colors)', '', '        return colors, labels', '', '    def format_data(self, data, pivot_kws, z_score=None,', '                    standard_scale=None):', '        \"\"\"Extract variables from data or use directly.\"\"\"', '', '        # Either the data is already in 2d matrix format, or need to do a pivot', '        if pivot_kws is not None:', '            data2d = data.pivot(**pivot_kws)', '        else:', '            data2d = data', '', '        if z_score is not None and standard_scale is not None:', '            raise ValueError(', \"                'Cannot perform both z-scoring and standard-scaling on data')\", '', '        if z_score is not None:', '            data2d = self.z_score(data2d, z_score)', '        if standard_scale is not None:', '            data2d = self.standard_scale(data2d, standard_scale)', '        return data2d', '', '    @staticmethod', '    def z_score(data2d, axis=1):', '        \"\"\"Standarize the mean and variance of the data axis', '', '        Parameters', '        ----------', '        data2d : pandas.DataFrame', '            Data to normalize', '        axis : int', '            Which axis to normalize across. If 0, normalize across rows, if 1,', '            normalize across columns.', '', '        Returns', '        -------', '        normalized : pandas.DataFrame', '            Noramlized data with a mean of 0 and variance of 1 across the', '            specified axis.', '        \"\"\"', '        if axis == 1:', '            z_scored = data2d', '        else:', '            z_scored = data2d.T', '', '        z_scored = (z_scored - z_scored.mean()) / z_scored.std()', '', '        if axis == 1:', '            return z_scored', '        else:', '            return z_scored.T', '', '    @staticmethod', '    def standard_scale(data2d, axis=1):', '        \"\"\"Divide the data by the difference between the max and min', '', '        Parameters', '        ----------', '        data2d : pandas.DataFrame', '            Data to normalize', '        axis : int', '            Which axis to normalize across. If 0, normalize across rows, if 1,', '            normalize across columns.', '', '        Returns', '        -------', '        standardized : pandas.DataFrame', '            Noramlized data with a mean of 0 and variance of 1 across the', '            specified axis.', '', '        \"\"\"', '        # Normalize these values to range from 0 to 1', '        if axis == 1:', '            standardized = data2d', '        else:', '            standardized = data2d.T', '', '        subtract = standardized.min()', '        standardized = (standardized - subtract) / (', '            standardized.max() - standardized.min())', '', '        if axis == 1:', '            return standardized', '        else:', '            return standardized.T', '', '    def dim_ratios(self, colors, dendrogram_ratio, colors_ratio):', '        \"\"\"Get the proportions of the figure taken up by each axes.\"\"\"', '        ratios = [dendrogram_ratio]', '', '        if colors is not None:', '            # Colors are encoded as rgb, so there is an extra dimension', '            if np.ndim(colors) > 2:', '                n_colors = len(colors)', '            else:', '                n_colors = 1', '', '            ratios += [n_colors * colors_ratio]', '', '        # Add the ratio for the heatmap itself', '        ratios.append(1 - sum(ratios))', '', '        return ratios', '', '    @staticmethod', '    def color_list_to_matrix_and_cmap(colors, ind, axis=0):', '        \"\"\"Turns a list of colors into a numpy matrix and matplotlib colormap', '', '        These arguments can now be plotted using heatmap(matrix, cmap)', '        and the provided colors will be plotted.', '', '        Parameters', '        ----------', '        colors : list of matplotlib colors', '            Colors to label the rows or columns of a dataframe.', '        ind : list of ints', '            Ordering of the rows or columns, to reorder the original colors', '            by the clustered dendrogram order', '        axis : int', '            Which axis this is labeling', '', '        Returns', '        -------', '        matrix : numpy.array', '            A numpy array of integer values, where each indexes into the cmap', '        cmap : matplotlib.colors.ListedColormap', '', '        \"\"\"', '        try:', '            mpl.colors.to_rgb(colors[0])', '        except ValueError:', '            # We have a 2D color structure', '            m, n = len(colors), len(colors[0])', '            if not all(len(c) == n for c in colors[1:]):', '                raise ValueError(\"Multiple side color vectors must have same size\")', '        else:', '            # We have one vector of colors', '            m, n = 1, len(colors)', '            colors = [colors]', '', '        # Map from unique colors to colormap index value', '        unique_colors = {}', '        matrix = np.zeros((m, n), int)', '        for i, inner in enumerate(colors):', '            for j, color in enumerate(inner):', '                idx = unique_colors.setdefault(color, len(unique_colors))', '                matrix[i, j] = idx', '', '        # Reorder for clustering and transpose for axis', '        matrix = matrix[:, ind]', '        if axis == 0:', '            matrix = matrix.T', '', '        cmap = mpl.colors.ListedColormap(list(unique_colors))', '        return matrix, cmap', '', '    def plot_dendrograms(self, row_cluster, col_cluster, metric, method,', '                         row_linkage, col_linkage, tree_kws):', '        # Plot the row dendrogram', '        if row_cluster:', '            self.dendrogram_row = dendrogram(', '                self.data2d, metric=metric, method=method, label=False, axis=0,', '                ax=self.ax_row_dendrogram, rotate=True, linkage=row_linkage,', '                tree_kws=tree_kws', '            )', '        else:', '            self.ax_row_dendrogram.set_xticks([])', '            self.ax_row_dendrogram.set_yticks([])', '        # PLot the column dendrogram', '        if col_cluster:', '            self.dendrogram_col = dendrogram(', '                self.data2d, metric=metric, method=method, label=False,', '                axis=1, ax=self.ax_col_dendrogram, linkage=col_linkage,', '                tree_kws=tree_kws', '            )', '        else:', '            self.ax_col_dendrogram.set_xticks([])', '            self.ax_col_dendrogram.set_yticks([])', '        despine(ax=self.ax_row_dendrogram, bottom=True, left=True)', '        despine(ax=self.ax_col_dendrogram, bottom=True, left=True)', '', '    def plot_colors(self, xind, yind, **kws):', '        \"\"\"Plots color labels between the dendrogram and the heatmap', '', '        Parameters', '        ----------', '        heatmap_kws : dict', '            Keyword arguments heatmap', '', '        \"\"\"', '        # Remove any custom colormap and centering', '        # TODO this code has consistently caused problems when we', '        # have missed kwargs that need to be excluded that it might', '        # be better to rewrite *in*clusively.', '        kws = kws.copy()', \"        kws.pop('cmap', None)\", \"        kws.pop('norm', None)\", \"        kws.pop('center', None)\", \"        kws.pop('annot', None)\", \"        kws.pop('vmin', None)\", \"        kws.pop('vmax', None)\", \"        kws.pop('robust', None)\", \"        kws.pop('xticklabels', None)\", \"        kws.pop('yticklabels', None)\", '', '        # Plot the row colors', '        if self.row_colors is not None:', '            matrix, cmap = self.color_list_to_matrix_and_cmap(', '                self.row_colors, yind, axis=0)', '', '            # Get row_color labels', '            if self.row_color_labels is not None:', '                row_color_labels = self.row_color_labels', '            else:', '                row_color_labels = False', '', '            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_row_colors,', '                    xticklabels=row_color_labels, yticklabels=False, **kws)', '', '            # Adjust rotation of labels', '            if row_color_labels is not False:', '                plt.setp(self.ax_row_colors.get_xticklabels(), rotation=90)', '        else:', '            despine(self.ax_row_colors, left=True, bottom=True)', '', '        # Plot the column colors', '        if self.col_colors is not None:', '            matrix, cmap = self.color_list_to_matrix_and_cmap(', '                self.col_colors, xind, axis=1)', '', '            # Get col_color labels', '            if self.col_color_labels is not None:', '                col_color_labels = self.col_color_labels', '            else:', '                col_color_labels = False', '', '            heatmap(matrix, cmap=cmap, cbar=False, ax=self.ax_col_colors,', '                    xticklabels=False, yticklabels=col_color_labels, **kws)', '', '            # Adjust rotation of labels, place on right side', '            if col_color_labels is not False:', '                self.ax_col_colors.yaxis.tick_right()', '                plt.setp(self.ax_col_colors.get_yticklabels(), rotation=0)', '        else:', '            despine(self.ax_col_colors, left=True, bottom=True)', '', '    def plot_matrix(self, colorbar_kws, xind, yind, **kws):', '        self.data2d = self.data2d.iloc[yind, xind]', '        self.mask = self.mask.iloc[yind, xind]', '', '        # Try to reorganize specified tick labels, if provided', '        xtl = kws.pop(\"xticklabels\", \"auto\")', '        try:', '            xtl = np.asarray(xtl)[xind]', '        except (TypeError, IndexError):', '            pass', '        ytl = kws.pop(\"yticklabels\", \"auto\")', '        try:', '            ytl = np.asarray(ytl)[yind]', '        except (TypeError, IndexError):', '            pass', '', '        # Reorganize the annotations to match the heatmap', '        annot = kws.pop(\"annot\", None)', '        if annot is None or annot is False:', '            pass', '        else:', '            if isinstance(annot, bool):', '                annot_data = self.data2d', '            else:', '                annot_data = np.asarray(annot)', '                if annot_data.shape != self.data2d.shape:', '                    err = \"`data` and `annot` must have same shape.\"', '                    raise ValueError(err)', '                annot_data = annot_data[yind][:, xind]', '            annot = annot_data', '', '        # Setting ax_cbar=None in clustermap call implies no colorbar', '        kws.setdefault(\"cbar\", self.ax_cbar is not None)', '        heatmap(self.data2d, ax=self.ax_heatmap, cbar_ax=self.ax_cbar,', '                cbar_kws=colorbar_kws, mask=self.mask,', '                xticklabels=xtl, yticklabels=ytl, annot=annot, **kws)', '', '        ytl = self.ax_heatmap.get_yticklabels()', '        ytl_rot = None if not ytl else ytl[0].get_rotation()', \"        self.ax_heatmap.yaxis.set_ticks_position('right')\", \"        self.ax_heatmap.yaxis.set_label_position('right')\", '        if ytl_rot is not None:', '            ytl = self.ax_heatmap.get_yticklabels()', '            plt.setp(ytl, rotation=ytl_rot)', '', '        tight_params = dict(h_pad=.02, w_pad=.02)', '        if self.ax_cbar is None:', '            self._figure.tight_layout(**tight_params)', '        else:', '            # Turn the colorbar axes off for tight layout so that its', \"            # ticks don't interfere with the rest of the plot layout.\", '            # Then move it.', '            self.ax_cbar.set_axis_off()', '            self._figure.tight_layout(**tight_params)', '            self.ax_cbar.set_axis_on()', '            self.ax_cbar.set_position(self.cbar_pos)', '', '    def plot(self, metric, method, colorbar_kws, row_cluster, col_cluster,', '             row_linkage, col_linkage, tree_kws, **kws):', '', '        # heatmap square=True sets the aspect ratio on the axes, but that is', '        # not compatible with the multi-axes layout of clustergrid', '        if kws.get(\"square\", False):', '            msg = \"``square=True`` ignored in clustermap\"', '            warnings.warn(msg)', '            kws.pop(\"square\")', '', '        colorbar_kws = {} if colorbar_kws is None else colorbar_kws', '', '        self.plot_dendrograms(row_cluster, col_cluster, metric, method,', '                              row_linkage=row_linkage, col_linkage=col_linkage,', '                              tree_kws=tree_kws)', '        try:', '            xind = self.dendrogram_col.reordered_ind', '        except AttributeError:', '            xind = np.arange(self.data2d.shape[1])', '        try:', '            yind = self.dendrogram_row.reordered_ind', '        except AttributeError:', '            yind = np.arange(self.data2d.shape[0])', '', '        self.plot_colors(xind, yind, **kws)', '        self.plot_matrix(colorbar_kws, xind, yind, **kws)', '        return self', '', '', 'def clustermap(', '    data, *,', \"    pivot_kws=None, method='average', metric='euclidean',\", '    z_score=None, standard_scale=None, figsize=(10, 10),', '    cbar_kws=None, row_cluster=True, col_cluster=True,', '    row_linkage=None, col_linkage=None,', '    row_colors=None, col_colors=None, mask=None,', '    dendrogram_ratio=.2, colors_ratio=0.03,', '    cbar_pos=(.02, .8, .05, .18), tree_kws=None,', '    **kwargs', '):', '    \"\"\"', '    Plot a matrix dataset as a hierarchically-clustered heatmap.', '', '    This function requires scipy to be available.', '', '    Parameters', '    ----------', '    data : 2D array-like', '        Rectangular data for clustering. Cannot contain NAs.', '    pivot_kws : dict, optional', '        If `data` is a tidy dataframe, can provide keyword arguments for', '        pivot to create a rectangular dataframe.', '    method : str, optional', '        Linkage method to use for calculating clusters. See', '        :func:`scipy.cluster.hierarchy.linkage` documentation for more', '        information.', '    metric : str, optional', '        Distance metric to use for the data. See', '        :func:`scipy.spatial.distance.pdist` documentation for more options.', '        To use different metrics (or methods) for rows and columns, you may', '        construct each linkage matrix yourself and provide them as', '        `{row,col}_linkage`.', '    z_score : int or None, optional', '        Either 0 (rows) or 1 (columns). Whether or not to calculate z-scores', '        for the rows or the columns. Z scores are: z = (x - mean)/std, so', '        values in each row (column) will get the mean of the row (column)', '        subtracted, then divided by the standard deviation of the row (column).', '        This ensures that each row (column) has mean of 0 and variance of 1.', '    standard_scale : int or None, optional', '        Either 0 (rows) or 1 (columns). Whether or not to standardize that', '        dimension, meaning for each row or column, subtract the minimum and', '        divide each by its maximum.', '    figsize : tuple of (width, height), optional', '        Overall size of the figure.', '    cbar_kws : dict, optional', '        Keyword arguments to pass to `cbar_kws` in :func:`heatmap`, e.g. to', '        add a label to the colorbar.', '    {row,col}_cluster : bool, optional', '        If ``True``, cluster the {rows, columns}.', '    {row,col}_linkage : :class:`numpy.ndarray`, optional', '        Precomputed linkage matrix for the rows or columns. See', '        :func:`scipy.cluster.hierarchy.linkage` for specific formats.', '    {row,col}_colors : list-like or pandas DataFrame/Series, optional', '        List of colors to label for either the rows or columns. Useful to evaluate', '        whether samples within a group are clustered together. Can use nested lists or', '        DataFrame for multiple color levels of labeling. If given as a', '        :class:`pandas.DataFrame` or :class:`pandas.Series`, labels for the colors are', '        extracted from the DataFrames column names or from the name of the Series.', '        DataFrame/Series colors are also matched to the data by their index, ensuring', '        colors are drawn in the correct order.', '    mask : bool array or DataFrame, optional', '        If passed, data will not be shown in cells where `mask` is True.', '        Cells with missing values are automatically masked. Only used for', '        visualizing, not for calculating.', '    {dendrogram,colors}_ratio : float, or pair of floats, optional', '        Proportion of the figure size devoted to the two marginal elements. If', '        a pair is given, they correspond to (row, col) ratios.', '    cbar_pos : tuple of (left, bottom, width, height), optional', '        Position of the colorbar axes in the figure. Setting to ``None`` will', '        disable the colorbar.', '    tree_kws : dict, optional', '        Parameters for the :class:`matplotlib.collections.LineCollection`', '        that is used to plot the lines of the dendrogram tree.', '    kwargs : other keyword arguments', '        All other keyword arguments are passed to :func:`heatmap`.', '', '    Returns', '    -------', '    :class:`ClusterGrid`', '        A :class:`ClusterGrid` instance.', '', '    See Also', '    --------', '    heatmap : Plot rectangular data as a color-encoded matrix.', '', '    Notes', '    -----', '    The returned object has a ``savefig`` method that should be used if you', '    want to save the figure object without clipping the dendrograms.', '', '    To access the reordered row indices, use:', '    ``clustergrid.dendrogram_row.reordered_ind``', '', '    Column indices, use:', '    ``clustergrid.dendrogram_col.reordered_ind``', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/clustermap.rst', '', '    \"\"\"', '    if _no_scipy:', '        raise RuntimeError(\"clustermap requires scipy to be available\")', '', '    plotter = ClusterGrid(data, pivot_kws=pivot_kws, figsize=figsize,', '                          row_colors=row_colors, col_colors=col_colors,', '                          z_score=z_score, standard_scale=standard_scale,', '                          mask=mask, dendrogram_ratio=dendrogram_ratio,', '                          colors_ratio=colors_ratio, cbar_pos=cbar_pos)', '', '    return plotter.plot(metric=metric, method=method,', '                        colorbar_kws=cbar_kws,', '                        row_cluster=row_cluster, col_cluster=col_cluster,', '                        row_linkage=row_linkage, col_linkage=col_linkage,', '                        tree_kws=tree_kws, **kwargs)']}, 'widgets.py': {'classes': [], 'functions': [{'name': '_init_mutable_colormap', 'start_line': 22, 'end_line': 28, 'text': ['def _init_mutable_colormap():', '    \"\"\"Create a matplotlib colormap that will be updated by the widgets.\"\"\"', '    greys = color_palette(\"Greys\", 256)', '    cmap = LinearSegmentedColormap.from_list(\"interactive\", greys)', '    cmap._init()', '    cmap._set_extremes()', '    return cmap']}, {'name': '_update_lut', 'start_line': 31, 'end_line': 34, 'text': ['def _update_lut(cmap, colors):', '    \"\"\"Change the LUT values in a matplotlib colormap in-place.\"\"\"', '    cmap._lut[:256] = colors', '    cmap._set_extremes()']}, {'name': '_show_cmap', 'start_line': 37, 'end_line': 44, 'text': ['def _show_cmap(cmap):', '    \"\"\"Show a continuous matplotlib colormap.\"\"\"', '    from .rcmod import axes_style  # Avoid circular import', '    with axes_style(\"white\"):', '        f, ax = plt.subplots(figsize=(8.25, .75))', '    ax.set(xticks=[], yticks=[])', '    x = np.linspace(0, 1, 256)[np.newaxis, :]', '    ax.pcolormesh(x, cmap=cmap)']}, {'name': 'choose_colorbrewer_palette', 'start_line': 47, 'end_line': 140, 'text': ['def choose_colorbrewer_palette(data_type, as_cmap=False):', '    \"\"\"Select a palette from the ColorBrewer set.', '', '    These palettes are built into matplotlib and can be used by name in', '    many seaborn functions, or by passing the object returned by this function.', '', '    Parameters', '    ----------', \"    data_type : {'sequential', 'diverging', 'qualitative'}\", '        This describes the kind of data you want to visualize. See the seaborn', '        color palette docs for more information about how to choose this value.', \"        Note that you can pass substrings (e.g. 'q' for 'qualitative.\", '', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    dark_palette : Create a sequential palette with dark low values.', '    light_palette : Create a sequential palette with bright low values.', '    diverging_palette : Create a diverging palette from selected colors.', '    cubehelix_palette : Create a sequential palette or colormap using the', '                        cubehelix system.', '', '', '    \"\"\"', '    if data_type.startswith(\"q\") and as_cmap:', '        raise ValueError(\"Qualitative palettes cannot be colormaps.\")', '', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    if data_type.startswith(\"s\"):', '        opts = [\"Greys\", \"Reds\", \"Greens\", \"Blues\", \"Oranges\", \"Purples\",', '                \"BuGn\", \"BuPu\", \"GnBu\", \"OrRd\", \"PuBu\", \"PuRd\", \"RdPu\", \"YlGn\",', '                \"PuBuGn\", \"YlGnBu\", \"YlOrBr\", \"YlOrRd\"]', '        variants = [\"regular\", \"reverse\", \"dark\"]', '', '        @interact', '        def choose_sequential(name=opts, n=(2, 18),', '                              desat=FloatSlider(min=0, max=1, value=1),', '                              variant=variants):', '            if variant == \"reverse\":', '                name += \"_r\"', '            elif variant == \"dark\":', '                name += \"_d\"', '', '            if as_cmap:', '                colors = color_palette(name, 256, desat)', '                _update_lut(cmap, np.c_[colors, np.ones(256)])', '                _show_cmap(cmap)', '            else:', '                pal[:] = color_palette(name, n, desat)', '                palplot(pal)', '', '    elif data_type.startswith(\"d\"):', '        opts = [\"RdBu\", \"RdGy\", \"PRGn\", \"PiYG\", \"BrBG\",', '                \"RdYlBu\", \"RdYlGn\", \"Spectral\"]', '        variants = [\"regular\", \"reverse\"]', '', '        @interact', '        def choose_diverging(name=opts, n=(2, 16),', '                             desat=FloatSlider(min=0, max=1, value=1),', '                             variant=variants):', '            if variant == \"reverse\":', '                name += \"_r\"', '            if as_cmap:', '                colors = color_palette(name, 256, desat)', '                _update_lut(cmap, np.c_[colors, np.ones(256)])', '                _show_cmap(cmap)', '            else:', '                pal[:] = color_palette(name, n, desat)', '                palplot(pal)', '', '    elif data_type.startswith(\"q\"):', '        opts = [\"Set1\", \"Set2\", \"Set3\", \"Paired\", \"Accent\",', '                \"Pastel1\", \"Pastel2\", \"Dark2\"]', '', '        @interact', '        def choose_qualitative(name=opts, n=(2, 16),', '                               desat=FloatSlider(min=0, max=1, value=1)):', '            pal[:] = color_palette(name, n, desat)', '            palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal']}, {'name': 'choose_dark_palette', 'start_line': 143, 'end_line': 225, 'text': ['def choose_dark_palette(input=\"husl\", as_cmap=False):', '    \"\"\"Launch an interactive widget to create a dark sequential palette.', '', '    This corresponds with the :func:`dark_palette` function. This kind', '    of palette is good for data that range between relatively uninteresting', '    low values and interesting high values.', '', '    Requires IPython 2+ and must be used in the notebook.', '', '    Parameters', '    ----------', \"    input : {'husl', 'hls', 'rgb'}\", '        Color space for defining the seed value. Note that the default is', '        different than the default input for :func:`dark_palette`.', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    dark_palette : Create a sequential palette with dark low values.', '    light_palette : Create a sequential palette with bright low values.', '    cubehelix_palette : Create a sequential palette or colormap using the', '                        cubehelix system.', '', '    \"\"\"', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    if input == \"rgb\":', '        @interact', '        def choose_dark_palette_rgb(r=(0., 1.),', '                                    g=(0., 1.),', '                                    b=(0., 1.),', '                                    n=(3, 17)):', '            color = r, g, b', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"rgb\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"rgb\")', '                palplot(pal)', '', '    elif input == \"hls\":', '        @interact', '        def choose_dark_palette_hls(h=(0., 1.),', '                                    l=(0., 1.),  # noqa: E741', '                                    s=(0., 1.),', '                                    n=(3, 17)):', '            color = h, l, s', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"hls\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"hls\")', '                palplot(pal)', '', '    elif input == \"husl\":', '        @interact', '        def choose_dark_palette_husl(h=(0, 359),', '                                     s=(0, 99),', '                                     l=(0, 99),  # noqa: E741', '                                     n=(3, 17)):', '            color = h, s, l', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"husl\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"husl\")', '                palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal']}, {'name': 'choose_light_palette', 'start_line': 228, 'end_line': 310, 'text': ['def choose_light_palette(input=\"husl\", as_cmap=False):', '    \"\"\"Launch an interactive widget to create a light sequential palette.', '', '    This corresponds with the :func:`light_palette` function. This kind', '    of palette is good for data that range between relatively uninteresting', '    low values and interesting high values.', '', '    Requires IPython 2+ and must be used in the notebook.', '', '    Parameters', '    ----------', \"    input : {'husl', 'hls', 'rgb'}\", '        Color space for defining the seed value. Note that the default is', '        different than the default input for :func:`light_palette`.', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    light_palette : Create a sequential palette with bright low values.', '    dark_palette : Create a sequential palette with dark low values.', '    cubehelix_palette : Create a sequential palette or colormap using the', '                        cubehelix system.', '', '    \"\"\"', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    if input == \"rgb\":', '        @interact', '        def choose_light_palette_rgb(r=(0., 1.),', '                                     g=(0., 1.),', '                                     b=(0., 1.),', '                                     n=(3, 17)):', '            color = r, g, b', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"rgb\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"rgb\")', '                palplot(pal)', '', '    elif input == \"hls\":', '        @interact', '        def choose_light_palette_hls(h=(0., 1.),', '                                     l=(0., 1.),  # noqa: E741', '                                     s=(0., 1.),', '                                     n=(3, 17)):', '            color = h, l, s', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"hls\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"hls\")', '                palplot(pal)', '', '    elif input == \"husl\":', '        @interact', '        def choose_light_palette_husl(h=(0, 359),', '                                      s=(0, 99),', '                                      l=(0, 99),  # noqa: E741', '                                      n=(3, 17)):', '            color = h, s, l', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"husl\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"husl\")', '                palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal']}, {'name': 'choose_diverging_palette', 'start_line': 313, 'end_line': 369, 'text': ['def choose_diverging_palette(as_cmap=False):', '    \"\"\"Launch an interactive widget to choose a diverging color palette.', '', '    This corresponds with the :func:`diverging_palette` function. This kind', '    of palette is good for data that range between interesting low values', '    and interesting high values with a meaningful midpoint. (For example,', '    change scores relative to some baseline value).', '', '    Requires IPython 2+ and must be used in the notebook.', '', '    Parameters', '    ----------', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    diverging_palette : Create a diverging color palette or colormap.', '    choose_colorbrewer_palette : Interactively choose palettes from the', '                                 colorbrewer set, including diverging palettes.', '', '    \"\"\"', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    @interact', '    def choose_diverging_palette(', '        h_neg=IntSlider(min=0,', '                        max=359,', '                        value=220),', '        h_pos=IntSlider(min=0,', '                        max=359,', '                        value=10),', '        s=IntSlider(min=0, max=99, value=74),', '        l=IntSlider(min=0, max=99, value=50),  # noqa: E741', '        sep=IntSlider(min=1, max=50, value=10),', '        n=(2, 16),', '        center=[\"light\", \"dark\"]', '    ):', '        if as_cmap:', '            colors = diverging_palette(h_neg, h_pos, s, l, sep, 256, center)', '            _update_lut(cmap, colors)', '            _show_cmap(cmap)', '        else:', '            pal[:] = diverging_palette(h_neg, h_pos, s, l, sep, n, center)', '            palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal']}, {'name': 'choose_cubehelix_palette', 'start_line': 372, 'end_line': 426, 'text': ['def choose_cubehelix_palette(as_cmap=False):', '    \"\"\"Launch an interactive widget to create a sequential cubehelix palette.', '', '    This corresponds with the :func:`cubehelix_palette` function. This kind', '    of palette is good for data that range between relatively uninteresting', '    low values and interesting high values. The cubehelix system allows the', '    palette to have more hue variance across the range, which can be helpful', '    for distinguishing a wider range of values.', '', '    Requires IPython 2+ and must be used in the notebook.', '', '    Parameters', '    ----------', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    cubehelix_palette : Create a sequential palette or colormap using the', '                        cubehelix system.', '', '    \"\"\"', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    @interact', '    def choose_cubehelix(n_colors=IntSlider(min=2, max=16, value=9),', '                         start=FloatSlider(min=0, max=3, value=0),', '                         rot=FloatSlider(min=-1, max=1, value=.4),', '                         gamma=FloatSlider(min=0, max=5, value=1),', '                         hue=FloatSlider(min=0, max=1, value=.8),', '                         light=FloatSlider(min=0, max=1, value=.85),', '                         dark=FloatSlider(min=0, max=1, value=.15),', '                         reverse=False):', '', '        if as_cmap:', '            colors = cubehelix_palette(256, start, rot, gamma,', '                                       hue, light, dark, reverse)', '            _update_lut(cmap, np.c_[colors, np.ones(256)])', '            _show_cmap(cmap)', '        else:', '            pal[:] = cubehelix_palette(n_colors, start, rot, gamma,', '                                       hue, light, dark, reverse)', '            palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal']}, {'name': 'choose_diverging_palette', 'start_line': 346, 'end_line': 365, 'text': ['    def choose_diverging_palette(', '        h_neg=IntSlider(min=0,', '                        max=359,', '                        value=220),', '        h_pos=IntSlider(min=0,', '                        max=359,', '                        value=10),', '        s=IntSlider(min=0, max=99, value=74),', '        l=IntSlider(min=0, max=99, value=50),  # noqa: E741', '        sep=IntSlider(min=1, max=50, value=10),', '        n=(2, 16),', '        center=[\"light\", \"dark\"]', '    ):', '        if as_cmap:', '            colors = diverging_palette(h_neg, h_pos, s, l, sep, 256, center)', '            _update_lut(cmap, colors)', '            _show_cmap(cmap)', '        else:', '            pal[:] = diverging_palette(h_neg, h_pos, s, l, sep, n, center)', '            palplot(pal)']}, {'name': 'choose_cubehelix', 'start_line': 405, 'end_line': 422, 'text': ['    def choose_cubehelix(n_colors=IntSlider(min=2, max=16, value=9),', '                         start=FloatSlider(min=0, max=3, value=0),', '                         rot=FloatSlider(min=-1, max=1, value=.4),', '                         gamma=FloatSlider(min=0, max=5, value=1),', '                         hue=FloatSlider(min=0, max=1, value=.8),', '                         light=FloatSlider(min=0, max=1, value=.85),', '                         dark=FloatSlider(min=0, max=1, value=.15),', '                         reverse=False):', '', '        if as_cmap:', '            colors = cubehelix_palette(256, start, rot, gamma,', '                                       hue, light, dark, reverse)', '            _update_lut(cmap, np.c_[colors, np.ones(256)])', '            _show_cmap(cmap)', '        else:', '            pal[:] = cubehelix_palette(n_colors, start, rot, gamma,', '                                       hue, light, dark, reverse)', '            palplot(pal)']}, {'name': 'interact', 'start_line': 8, 'end_line': 10, 'text': ['    def interact(f):', '        msg = \"Interactive palettes require `ipywidgets`, which is not installed.\"', '        raise ImportError(msg)']}, {'name': 'choose_sequential', 'start_line': 93, 'end_line': 107, 'text': ['        def choose_sequential(name=opts, n=(2, 18),', '                              desat=FloatSlider(min=0, max=1, value=1),', '                              variant=variants):', '            if variant == \"reverse\":', '                name += \"_r\"', '            elif variant == \"dark\":', '                name += \"_d\"', '', '            if as_cmap:', '                colors = color_palette(name, 256, desat)', '                _update_lut(cmap, np.c_[colors, np.ones(256)])', '                _show_cmap(cmap)', '            else:', '                pal[:] = color_palette(name, n, desat)', '                palplot(pal)']}, {'name': 'choose_dark_palette_rgb', 'start_line': 180, 'end_line': 191, 'text': ['        def choose_dark_palette_rgb(r=(0., 1.),', '                                    g=(0., 1.),', '                                    b=(0., 1.),', '                                    n=(3, 17)):', '            color = r, g, b', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"rgb\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"rgb\")', '                palplot(pal)']}, {'name': 'choose_light_palette_rgb', 'start_line': 265, 'end_line': 276, 'text': ['        def choose_light_palette_rgb(r=(0., 1.),', '                                     g=(0., 1.),', '                                     b=(0., 1.),', '                                     n=(3, 17)):', '            color = r, g, b', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"rgb\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"rgb\")', '                palplot(pal)']}, {'name': 'choose_diverging', 'start_line': 115, 'end_line': 126, 'text': ['        def choose_diverging(name=opts, n=(2, 16),', '                             desat=FloatSlider(min=0, max=1, value=1),', '                             variant=variants):', '            if variant == \"reverse\":', '                name += \"_r\"', '            if as_cmap:', '                colors = color_palette(name, 256, desat)', '                _update_lut(cmap, np.c_[colors, np.ones(256)])', '                _show_cmap(cmap)', '            else:', '                pal[:] = color_palette(name, n, desat)', '                palplot(pal)']}, {'name': 'choose_dark_palette_hls', 'start_line': 195, 'end_line': 206, 'text': ['        def choose_dark_palette_hls(h=(0., 1.),', '                                    l=(0., 1.),  # noqa: E741', '                                    s=(0., 1.),', '                                    n=(3, 17)):', '            color = h, l, s', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"hls\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"hls\")', '                palplot(pal)']}, {'name': 'choose_light_palette_hls', 'start_line': 280, 'end_line': 291, 'text': ['        def choose_light_palette_hls(h=(0., 1.),', '                                     l=(0., 1.),  # noqa: E741', '                                     s=(0., 1.),', '                                     n=(3, 17)):', '            color = h, l, s', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"hls\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"hls\")', '                palplot(pal)']}, {'name': 'choose_qualitative', 'start_line': 133, 'end_line': 136, 'text': ['        def choose_qualitative(name=opts, n=(2, 16),', '                               desat=FloatSlider(min=0, max=1, value=1)):', '            pal[:] = color_palette(name, n, desat)', '            palplot(pal)']}, {'name': 'choose_dark_palette_husl', 'start_line': 210, 'end_line': 221, 'text': ['        def choose_dark_palette_husl(h=(0, 359),', '                                     s=(0, 99),', '                                     l=(0, 99),  # noqa: E741', '                                     n=(3, 17)):', '            color = h, s, l', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"husl\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"husl\")', '                palplot(pal)']}, {'name': 'choose_light_palette_husl', 'start_line': 295, 'end_line': 306, 'text': ['        def choose_light_palette_husl(h=(0, 359),', '                                      s=(0, 99),', '                                      l=(0, 99),  # noqa: E741', '                                      n=(3, 17)):', '            color = h, s, l', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"husl\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"husl\")', '                palplot(pal)']}], 'text': ['import numpy as np', 'import matplotlib.pyplot as plt', 'from matplotlib.colors import LinearSegmentedColormap', '', 'try:', '    from ipywidgets import interact, FloatSlider, IntSlider', 'except ImportError:', '    def interact(f):', '        msg = \"Interactive palettes require `ipywidgets`, which is not installed.\"', '        raise ImportError(msg)', '', 'from .miscplot import palplot', 'from .palettes import (color_palette, dark_palette, light_palette,', '                       diverging_palette, cubehelix_palette)', '', '', '__all__ = [\"choose_colorbrewer_palette\", \"choose_cubehelix_palette\",', '           \"choose_dark_palette\", \"choose_light_palette\",', '           \"choose_diverging_palette\"]', '', '', 'def _init_mutable_colormap():', '    \"\"\"Create a matplotlib colormap that will be updated by the widgets.\"\"\"', '    greys = color_palette(\"Greys\", 256)', '    cmap = LinearSegmentedColormap.from_list(\"interactive\", greys)', '    cmap._init()', '    cmap._set_extremes()', '    return cmap', '', '', 'def _update_lut(cmap, colors):', '    \"\"\"Change the LUT values in a matplotlib colormap in-place.\"\"\"', '    cmap._lut[:256] = colors', '    cmap._set_extremes()', '', '', 'def _show_cmap(cmap):', '    \"\"\"Show a continuous matplotlib colormap.\"\"\"', '    from .rcmod import axes_style  # Avoid circular import', '    with axes_style(\"white\"):', '        f, ax = plt.subplots(figsize=(8.25, .75))', '    ax.set(xticks=[], yticks=[])', '    x = np.linspace(0, 1, 256)[np.newaxis, :]', '    ax.pcolormesh(x, cmap=cmap)', '', '', 'def choose_colorbrewer_palette(data_type, as_cmap=False):', '    \"\"\"Select a palette from the ColorBrewer set.', '', '    These palettes are built into matplotlib and can be used by name in', '    many seaborn functions, or by passing the object returned by this function.', '', '    Parameters', '    ----------', \"    data_type : {'sequential', 'diverging', 'qualitative'}\", '        This describes the kind of data you want to visualize. See the seaborn', '        color palette docs for more information about how to choose this value.', \"        Note that you can pass substrings (e.g. 'q' for 'qualitative.\", '', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    dark_palette : Create a sequential palette with dark low values.', '    light_palette : Create a sequential palette with bright low values.', '    diverging_palette : Create a diverging palette from selected colors.', '    cubehelix_palette : Create a sequential palette or colormap using the', '                        cubehelix system.', '', '', '    \"\"\"', '    if data_type.startswith(\"q\") and as_cmap:', '        raise ValueError(\"Qualitative palettes cannot be colormaps.\")', '', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    if data_type.startswith(\"s\"):', '        opts = [\"Greys\", \"Reds\", \"Greens\", \"Blues\", \"Oranges\", \"Purples\",', '                \"BuGn\", \"BuPu\", \"GnBu\", \"OrRd\", \"PuBu\", \"PuRd\", \"RdPu\", \"YlGn\",', '                \"PuBuGn\", \"YlGnBu\", \"YlOrBr\", \"YlOrRd\"]', '        variants = [\"regular\", \"reverse\", \"dark\"]', '', '        @interact', '        def choose_sequential(name=opts, n=(2, 18),', '                              desat=FloatSlider(min=0, max=1, value=1),', '                              variant=variants):', '            if variant == \"reverse\":', '                name += \"_r\"', '            elif variant == \"dark\":', '                name += \"_d\"', '', '            if as_cmap:', '                colors = color_palette(name, 256, desat)', '                _update_lut(cmap, np.c_[colors, np.ones(256)])', '                _show_cmap(cmap)', '            else:', '                pal[:] = color_palette(name, n, desat)', '                palplot(pal)', '', '    elif data_type.startswith(\"d\"):', '        opts = [\"RdBu\", \"RdGy\", \"PRGn\", \"PiYG\", \"BrBG\",', '                \"RdYlBu\", \"RdYlGn\", \"Spectral\"]', '        variants = [\"regular\", \"reverse\"]', '', '        @interact', '        def choose_diverging(name=opts, n=(2, 16),', '                             desat=FloatSlider(min=0, max=1, value=1),', '                             variant=variants):', '            if variant == \"reverse\":', '                name += \"_r\"', '            if as_cmap:', '                colors = color_palette(name, 256, desat)', '                _update_lut(cmap, np.c_[colors, np.ones(256)])', '                _show_cmap(cmap)', '            else:', '                pal[:] = color_palette(name, n, desat)', '                palplot(pal)', '', '    elif data_type.startswith(\"q\"):', '        opts = [\"Set1\", \"Set2\", \"Set3\", \"Paired\", \"Accent\",', '                \"Pastel1\", \"Pastel2\", \"Dark2\"]', '', '        @interact', '        def choose_qualitative(name=opts, n=(2, 16),', '                               desat=FloatSlider(min=0, max=1, value=1)):', '            pal[:] = color_palette(name, n, desat)', '            palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal', '', '', 'def choose_dark_palette(input=\"husl\", as_cmap=False):', '    \"\"\"Launch an interactive widget to create a dark sequential palette.', '', '    This corresponds with the :func:`dark_palette` function. This kind', '    of palette is good for data that range between relatively uninteresting', '    low values and interesting high values.', '', '    Requires IPython 2+ and must be used in the notebook.', '', '    Parameters', '    ----------', \"    input : {'husl', 'hls', 'rgb'}\", '        Color space for defining the seed value. Note that the default is', '        different than the default input for :func:`dark_palette`.', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    dark_palette : Create a sequential palette with dark low values.', '    light_palette : Create a sequential palette with bright low values.', '    cubehelix_palette : Create a sequential palette or colormap using the', '                        cubehelix system.', '', '    \"\"\"', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    if input == \"rgb\":', '        @interact', '        def choose_dark_palette_rgb(r=(0., 1.),', '                                    g=(0., 1.),', '                                    b=(0., 1.),', '                                    n=(3, 17)):', '            color = r, g, b', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"rgb\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"rgb\")', '                palplot(pal)', '', '    elif input == \"hls\":', '        @interact', '        def choose_dark_palette_hls(h=(0., 1.),', '                                    l=(0., 1.),  # noqa: E741', '                                    s=(0., 1.),', '                                    n=(3, 17)):', '            color = h, l, s', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"hls\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"hls\")', '                palplot(pal)', '', '    elif input == \"husl\":', '        @interact', '        def choose_dark_palette_husl(h=(0, 359),', '                                     s=(0, 99),', '                                     l=(0, 99),  # noqa: E741', '                                     n=(3, 17)):', '            color = h, s, l', '            if as_cmap:', '                colors = dark_palette(color, 256, input=\"husl\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = dark_palette(color, n, input=\"husl\")', '                palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal', '', '', 'def choose_light_palette(input=\"husl\", as_cmap=False):', '    \"\"\"Launch an interactive widget to create a light sequential palette.', '', '    This corresponds with the :func:`light_palette` function. This kind', '    of palette is good for data that range between relatively uninteresting', '    low values and interesting high values.', '', '    Requires IPython 2+ and must be used in the notebook.', '', '    Parameters', '    ----------', \"    input : {'husl', 'hls', 'rgb'}\", '        Color space for defining the seed value. Note that the default is', '        different than the default input for :func:`light_palette`.', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    light_palette : Create a sequential palette with bright low values.', '    dark_palette : Create a sequential palette with dark low values.', '    cubehelix_palette : Create a sequential palette or colormap using the', '                        cubehelix system.', '', '    \"\"\"', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    if input == \"rgb\":', '        @interact', '        def choose_light_palette_rgb(r=(0., 1.),', '                                     g=(0., 1.),', '                                     b=(0., 1.),', '                                     n=(3, 17)):', '            color = r, g, b', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"rgb\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"rgb\")', '                palplot(pal)', '', '    elif input == \"hls\":', '        @interact', '        def choose_light_palette_hls(h=(0., 1.),', '                                     l=(0., 1.),  # noqa: E741', '                                     s=(0., 1.),', '                                     n=(3, 17)):', '            color = h, l, s', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"hls\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"hls\")', '                palplot(pal)', '', '    elif input == \"husl\":', '        @interact', '        def choose_light_palette_husl(h=(0, 359),', '                                      s=(0, 99),', '                                      l=(0, 99),  # noqa: E741', '                                      n=(3, 17)):', '            color = h, s, l', '            if as_cmap:', '                colors = light_palette(color, 256, input=\"husl\")', '                _update_lut(cmap, colors)', '                _show_cmap(cmap)', '            else:', '                pal[:] = light_palette(color, n, input=\"husl\")', '                palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal', '', '', 'def choose_diverging_palette(as_cmap=False):', '    \"\"\"Launch an interactive widget to choose a diverging color palette.', '', '    This corresponds with the :func:`diverging_palette` function. This kind', '    of palette is good for data that range between interesting low values', '    and interesting high values with a meaningful midpoint. (For example,', '    change scores relative to some baseline value).', '', '    Requires IPython 2+ and must be used in the notebook.', '', '    Parameters', '    ----------', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    diverging_palette : Create a diverging color palette or colormap.', '    choose_colorbrewer_palette : Interactively choose palettes from the', '                                 colorbrewer set, including diverging palettes.', '', '    \"\"\"', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    @interact', '    def choose_diverging_palette(', '        h_neg=IntSlider(min=0,', '                        max=359,', '                        value=220),', '        h_pos=IntSlider(min=0,', '                        max=359,', '                        value=10),', '        s=IntSlider(min=0, max=99, value=74),', '        l=IntSlider(min=0, max=99, value=50),  # noqa: E741', '        sep=IntSlider(min=1, max=50, value=10),', '        n=(2, 16),', '        center=[\"light\", \"dark\"]', '    ):', '        if as_cmap:', '            colors = diverging_palette(h_neg, h_pos, s, l, sep, 256, center)', '            _update_lut(cmap, colors)', '            _show_cmap(cmap)', '        else:', '            pal[:] = diverging_palette(h_neg, h_pos, s, l, sep, n, center)', '            palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal', '', '', 'def choose_cubehelix_palette(as_cmap=False):', '    \"\"\"Launch an interactive widget to create a sequential cubehelix palette.', '', '    This corresponds with the :func:`cubehelix_palette` function. This kind', '    of palette is good for data that range between relatively uninteresting', '    low values and interesting high values. The cubehelix system allows the', '    palette to have more hue variance across the range, which can be helpful', '    for distinguishing a wider range of values.', '', '    Requires IPython 2+ and must be used in the notebook.', '', '    Parameters', '    ----------', '    as_cmap : bool', '        If True, the return value is a matplotlib colormap rather than a', '        list of discrete colors.', '', '    Returns', '    -------', '    pal or cmap : list of colors or matplotlib colormap', '        Object that can be passed to plotting functions.', '', '    See Also', '    --------', '    cubehelix_palette : Create a sequential palette or colormap using the', '                        cubehelix system.', '', '    \"\"\"', '    pal = []', '    if as_cmap:', '        cmap = _init_mutable_colormap()', '', '    @interact', '    def choose_cubehelix(n_colors=IntSlider(min=2, max=16, value=9),', '                         start=FloatSlider(min=0, max=3, value=0),', '                         rot=FloatSlider(min=-1, max=1, value=.4),', '                         gamma=FloatSlider(min=0, max=5, value=1),', '                         hue=FloatSlider(min=0, max=1, value=.8),', '                         light=FloatSlider(min=0, max=1, value=.85),', '                         dark=FloatSlider(min=0, max=1, value=.15),', '                         reverse=False):', '', '        if as_cmap:', '            colors = cubehelix_palette(256, start, rot, gamma,', '                                       hue, light, dark, reverse)', '            _update_lut(cmap, np.c_[colors, np.ones(256)])', '            _show_cmap(cmap)', '        else:', '            pal[:] = cubehelix_palette(n_colors, start, rot, gamma,', '                                       hue, light, dark, reverse)', '            palplot(pal)', '', '    if as_cmap:', '        return cmap', '    return pal']}, '_oldcore.py': {'classes': [{'name': 'SemanticMapping', 'start_line': 29, 'end_line': 91, 'text': ['class SemanticMapping:', '    \"\"\"Base class for mapping data values to plot attributes.\"\"\"', '', '    # -- Default attributes that all SemanticMapping subclasses must set', '', '    # Whether the mapping is numeric, categorical, or datetime', '    map_type = None', '', '    # Ordered list of unique values in the input data', '    levels = None', '', '    # A mapping from the data values to corresponding plot attributes', '    lookup_table = None', '', '    def __init__(self, plotter):', '', '        # TODO Putting this here so we can continue to use a lot of the', \"        # logic that's built into the library, but the idea of this class\", '        # is to move towards semantic mappings that are agnostic about the', \"        # kind of plot they're going to be used to draw.\", '        # Fully achieving that is going to take some thinking.', '        self.plotter = plotter', '', '    def map(cls, plotter, *args, **kwargs):', '        # This method is assigned the __init__ docstring', '        method_name = f\"_{cls.__name__[:-7].lower()}_map\"', '        setattr(plotter, method_name, cls(plotter, *args, **kwargs))', '        return plotter', '', '    def _check_list_length(self, levels, values, variable):', '        \"\"\"Input check when values are provided as a list.\"\"\"', '        # Copied from _core/properties; eventually will be replaced for that.', '        message = \"\"', '        if len(levels) > len(values):', '            message = \" \".join([', '                f\"\\\\nThe {variable} list has fewer values ({len(values)})\",', '                f\"than needed ({len(levels)}) and will cycle, which may\",', '                \"produce an uninterpretable plot.\"', '            ])', '            values = [x for _, x in zip(levels, itertools.cycle(values))]', '', '        elif len(values) > len(levels):', '            message = \" \".join([', '                f\"The {variable} list has more values ({len(values)})\",', '                f\"than needed ({len(levels)}), which may not be intended.\",', '            ])', '            values = values[:len(levels)]', '', '        if message:', '            warnings.warn(message, UserWarning, stacklevel=6)', '', '        return values', '', '    def _lookup_single(self, key):', '        \"\"\"Apply the mapping to a single data value.\"\"\"', '        return self.lookup_table[key]', '', '    def __call__(self, key, *args, **kwargs):', '        \"\"\"Get the attribute(s) values for the data key.\"\"\"', '        if isinstance(key, (list, np.ndarray, pd.Series)):', '            return [self._lookup_single(k, *args, **kwargs) for k in key]', '        else:', '            return self._lookup_single(key, *args, **kwargs)'], 'methods': [{'name': '__init__', 'start_line': 43, 'end_line': 50, 'text': ['    def __init__(self, plotter):', '', '        # TODO Putting this here so we can continue to use a lot of the', \"        # logic that's built into the library, but the idea of this class\", '        # is to move towards semantic mappings that are agnostic about the', \"        # kind of plot they're going to be used to draw.\", '        # Fully achieving that is going to take some thinking.', '        self.plotter = plotter']}, {'name': 'map', 'start_line': 52, 'end_line': 56, 'text': ['    def map(cls, plotter, *args, **kwargs):', '        # This method is assigned the __init__ docstring', '        method_name = f\"_{cls.__name__[:-7].lower()}_map\"', '        setattr(plotter, method_name, cls(plotter, *args, **kwargs))', '        return plotter']}, {'name': '_check_list_length', 'start_line': 58, 'end_line': 80, 'text': ['    def _check_list_length(self, levels, values, variable):', '        \"\"\"Input check when values are provided as a list.\"\"\"', '        # Copied from _core/properties; eventually will be replaced for that.', '        message = \"\"', '        if len(levels) > len(values):', '            message = \" \".join([', '                f\"\\\\nThe {variable} list has fewer values ({len(values)})\",', '                f\"than needed ({len(levels)}) and will cycle, which may\",', '                \"produce an uninterpretable plot.\"', '            ])', '            values = [x for _, x in zip(levels, itertools.cycle(values))]', '', '        elif len(values) > len(levels):', '            message = \" \".join([', '                f\"The {variable} list has more values ({len(values)})\",', '                f\"than needed ({len(levels)}), which may not be intended.\",', '            ])', '            values = values[:len(levels)]', '', '        if message:', '            warnings.warn(message, UserWarning, stacklevel=6)', '', '        return values']}, {'name': '_lookup_single', 'start_line': 82, 'end_line': 84, 'text': ['    def _lookup_single(self, key):', '        \"\"\"Apply the mapping to a single data value.\"\"\"', '        return self.lookup_table[key]']}, {'name': '__call__', 'start_line': 86, 'end_line': 91, 'text': ['    def __call__(self, key, *args, **kwargs):', '        \"\"\"Get the attribute(s) values for the data key.\"\"\"', '        if isinstance(key, (list, np.ndarray, pd.Series)):', '            return [self._lookup_single(k, *args, **kwargs) for k in key]', '        else:', '            return self._lookup_single(key, *args, **kwargs)']}]}, {'name': 'HueMapping', 'start_line': 95, 'end_line': 288, 'text': ['class HueMapping(SemanticMapping):', '    \"\"\"Mapping that sets artist colors according to data values.\"\"\"', '    # A specification of the colors that should appear in the plot', '    palette = None', '', '    # An object that normalizes data values to [0, 1] range for color mapping', '    norm = None', '', '    # A continuous colormap object for interpolating in a numeric context', '    cmap = None', '', '    def __init__(', '        self, plotter, palette=None, order=None, norm=None,', '    ):', '        \"\"\"Map the levels of the `hue` variable to distinct colors.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"hue\", pd.Series(dtype=float))', '', '        if data.isna().all():', '            if palette is not None:', '                msg = \"Ignoring `palette` because no `hue` variable has been assigned.\"', '                warnings.warn(msg, stacklevel=4)', '        else:', '', '            map_type = self.infer_map_type(', '                palette, norm, plotter.input_format, plotter.var_types[\"hue\"]', '            )', '', '            # Our goal is to end up with a dictionary mapping every unique', '            # value in `data` to a color. We will also keep track of the', '            # metadata about this mapping we will need for, e.g., a legend', '', '            # --- Option 1: numeric mapping with a matplotlib colormap', '', '            if map_type == \"numeric\":', '', '                data = pd.to_numeric(data)', '                levels, lookup_table, norm, cmap = self.numeric_mapping(', '                    data, palette, norm,', '                )', '', '            # --- Option 2: categorical mapping using seaborn palette', '', '            elif map_type == \"categorical\":', '', '                cmap = norm = None', '                levels, lookup_table = self.categorical_mapping(', '                    data, palette, order,', '                )', '', '            # --- Option 3: datetime mapping', '', '            else:', '                # TODO this needs actual implementation', '                cmap = norm = None', '                levels, lookup_table = self.categorical_mapping(', '                    # Casting data to list to handle differences in the way', '                    # pandas and numpy represent datetime64 data', '                    list(data), palette, order,', '                )', '', '            self.map_type = map_type', '            self.lookup_table = lookup_table', '            self.palette = palette', '            self.levels = levels', '            self.norm = norm', '            self.cmap = cmap', '', '    def _lookup_single(self, key):', '        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"', '        try:', \"            # Use a value that's in the original data vector\", '            value = self.lookup_table[key]', '        except KeyError:', '', '            if self.norm is None:', '                # Currently we only get here in scatterplot with hue_order,', '                # because scatterplot does not consider hue a grouping variable', '                # So unused hue levels are in the data, but not the lookup table', '                return (0, 0, 0, 0)', '', '            # Use the colormap to interpolate between existing datapoints', '            # (e.g. in the context of making a continuous legend)', '            try:', '                normed = self.norm(key)', '            except TypeError as err:', '                if np.isnan(key):', '                    value = (0, 0, 0, 0)', '                else:', '                    raise err', '            else:', '                if np.ma.is_masked(normed):', '                    normed = np.nan', '                value = self.cmap(normed)', '        return value', '', '    def infer_map_type(self, palette, norm, input_format, var_type):', '        \"\"\"Determine how to implement the mapping.\"\"\"', '        if palette in QUAL_PALETTES:', '            map_type = \"categorical\"', '        elif norm is not None:', '            map_type = \"numeric\"', '        elif isinstance(palette, (dict, list)):', '            map_type = \"categorical\"', '        elif input_format == \"wide\":', '            map_type = \"categorical\"', '        else:', '            map_type = var_type', '', '        return map_type', '', '    def categorical_mapping(self, data, palette, order):', '        \"\"\"Determine colors when the hue mapping is categorical.\"\"\"', '        # -- Identify the order and name of the levels', '', '        levels = categorical_order(data, order)', '        n_colors = len(levels)', '', '        # -- Identify the set of colors to use', '', '        if isinstance(palette, dict):', '', '            missing = set(levels) - set(palette)', '            if any(missing):', '                err = \"The palette dictionary is missing keys: {}\"', '                raise ValueError(err.format(missing))', '', '            lookup_table = palette', '', '        else:', '', '            if palette is None:', '                if n_colors <= len(get_color_cycle()):', '                    colors = color_palette(None, n_colors)', '                else:', '                    colors = color_palette(\"husl\", n_colors)', '            elif isinstance(palette, list):', '                colors = self._check_list_length(levels, palette, \"palette\")', '            else:', '                colors = color_palette(palette, n_colors)', '', '            lookup_table = dict(zip(levels, colors))', '', '        return levels, lookup_table', '', '    def numeric_mapping(self, data, palette, norm):', '        \"\"\"Determine colors when the hue variable is quantitative.\"\"\"', '        if isinstance(palette, dict):', '', '            # The presence of a norm object overrides a dictionary of hues', '            # in specifying a numeric mapping, so we need to process it here.', '            levels = list(sorted(palette))', '            colors = [palette[k] for k in sorted(palette)]', '            cmap = mpl.colors.ListedColormap(colors)', '            lookup_table = palette.copy()', '', '        else:', '', '            # The levels are the sorted unique values in the data', '            levels = list(np.sort(remove_na(data.unique())))', '', '            # --- Sort out the colormap to use from the palette argument', '', '            # Default numeric palette is our default cubehelix palette', '            # TODO do we want to do something complicated to ensure contrast?', '            palette = \"ch:\" if palette is None else palette', '', '            if isinstance(palette, mpl.colors.Colormap):', '                cmap = palette', '            else:', '                cmap = color_palette(palette, as_cmap=True)', '', '            # Now sort out the data normalization', '            if norm is None:', '                norm = mpl.colors.Normalize()', '            elif isinstance(norm, tuple):', '                norm = mpl.colors.Normalize(*norm)', '            elif not isinstance(norm, mpl.colors.Normalize):', '                err = \"``hue_norm`` must be None, tuple, or Normalize object.\"', '                raise ValueError(err)', '', '            if not norm.scaled():', '                norm(np.asarray(data.dropna()))', '', '            lookup_table = dict(zip(levels, cmap(norm(levels))))', '', '        return levels, lookup_table, norm, cmap'], 'methods': [{'name': '__init__', 'start_line': 106, 'end_line': 168, 'text': ['    def __init__(', '        self, plotter, palette=None, order=None, norm=None,', '    ):', '        \"\"\"Map the levels of the `hue` variable to distinct colors.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"hue\", pd.Series(dtype=float))', '', '        if data.isna().all():', '            if palette is not None:', '                msg = \"Ignoring `palette` because no `hue` variable has been assigned.\"', '                warnings.warn(msg, stacklevel=4)', '        else:', '', '            map_type = self.infer_map_type(', '                palette, norm, plotter.input_format, plotter.var_types[\"hue\"]', '            )', '', '            # Our goal is to end up with a dictionary mapping every unique', '            # value in `data` to a color. We will also keep track of the', '            # metadata about this mapping we will need for, e.g., a legend', '', '            # --- Option 1: numeric mapping with a matplotlib colormap', '', '            if map_type == \"numeric\":', '', '                data = pd.to_numeric(data)', '                levels, lookup_table, norm, cmap = self.numeric_mapping(', '                    data, palette, norm,', '                )', '', '            # --- Option 2: categorical mapping using seaborn palette', '', '            elif map_type == \"categorical\":', '', '                cmap = norm = None', '                levels, lookup_table = self.categorical_mapping(', '                    data, palette, order,', '                )', '', '            # --- Option 3: datetime mapping', '', '            else:', '                # TODO this needs actual implementation', '                cmap = norm = None', '                levels, lookup_table = self.categorical_mapping(', '                    # Casting data to list to handle differences in the way', '                    # pandas and numpy represent datetime64 data', '                    list(data), palette, order,', '                )', '', '            self.map_type = map_type', '            self.lookup_table = lookup_table', '            self.palette = palette', '            self.levels = levels', '            self.norm = norm', '            self.cmap = cmap']}, {'name': '_lookup_single', 'start_line': 170, 'end_line': 196, 'text': ['    def _lookup_single(self, key):', '        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"', '        try:', \"            # Use a value that's in the original data vector\", '            value = self.lookup_table[key]', '        except KeyError:', '', '            if self.norm is None:', '                # Currently we only get here in scatterplot with hue_order,', '                # because scatterplot does not consider hue a grouping variable', '                # So unused hue levels are in the data, but not the lookup table', '                return (0, 0, 0, 0)', '', '            # Use the colormap to interpolate between existing datapoints', '            # (e.g. in the context of making a continuous legend)', '            try:', '                normed = self.norm(key)', '            except TypeError as err:', '                if np.isnan(key):', '                    value = (0, 0, 0, 0)', '                else:', '                    raise err', '            else:', '                if np.ma.is_masked(normed):', '                    normed = np.nan', '                value = self.cmap(normed)', '        return value']}, {'name': 'infer_map_type', 'start_line': 198, 'end_line': 211, 'text': ['    def infer_map_type(self, palette, norm, input_format, var_type):', '        \"\"\"Determine how to implement the mapping.\"\"\"', '        if palette in QUAL_PALETTES:', '            map_type = \"categorical\"', '        elif norm is not None:', '            map_type = \"numeric\"', '        elif isinstance(palette, (dict, list)):', '            map_type = \"categorical\"', '        elif input_format == \"wide\":', '            map_type = \"categorical\"', '        else:', '            map_type = var_type', '', '        return map_type']}, {'name': 'categorical_mapping', 'start_line': 213, 'end_line': 245, 'text': ['    def categorical_mapping(self, data, palette, order):', '        \"\"\"Determine colors when the hue mapping is categorical.\"\"\"', '        # -- Identify the order and name of the levels', '', '        levels = categorical_order(data, order)', '        n_colors = len(levels)', '', '        # -- Identify the set of colors to use', '', '        if isinstance(palette, dict):', '', '            missing = set(levels) - set(palette)', '            if any(missing):', '                err = \"The palette dictionary is missing keys: {}\"', '                raise ValueError(err.format(missing))', '', '            lookup_table = palette', '', '        else:', '', '            if palette is None:', '                if n_colors <= len(get_color_cycle()):', '                    colors = color_palette(None, n_colors)', '                else:', '                    colors = color_palette(\"husl\", n_colors)', '            elif isinstance(palette, list):', '                colors = self._check_list_length(levels, palette, \"palette\")', '            else:', '                colors = color_palette(palette, n_colors)', '', '            lookup_table = dict(zip(levels, colors))', '', '        return levels, lookup_table']}, {'name': 'numeric_mapping', 'start_line': 247, 'end_line': 288, 'text': ['    def numeric_mapping(self, data, palette, norm):', '        \"\"\"Determine colors when the hue variable is quantitative.\"\"\"', '        if isinstance(palette, dict):', '', '            # The presence of a norm object overrides a dictionary of hues', '            # in specifying a numeric mapping, so we need to process it here.', '            levels = list(sorted(palette))', '            colors = [palette[k] for k in sorted(palette)]', '            cmap = mpl.colors.ListedColormap(colors)', '            lookup_table = palette.copy()', '', '        else:', '', '            # The levels are the sorted unique values in the data', '            levels = list(np.sort(remove_na(data.unique())))', '', '            # --- Sort out the colormap to use from the palette argument', '', '            # Default numeric palette is our default cubehelix palette', '            # TODO do we want to do something complicated to ensure contrast?', '            palette = \"ch:\" if palette is None else palette', '', '            if isinstance(palette, mpl.colors.Colormap):', '                cmap = palette', '            else:', '                cmap = color_palette(palette, as_cmap=True)', '', '            # Now sort out the data normalization', '            if norm is None:', '                norm = mpl.colors.Normalize()', '            elif isinstance(norm, tuple):', '                norm = mpl.colors.Normalize(*norm)', '            elif not isinstance(norm, mpl.colors.Normalize):', '                err = \"``hue_norm`` must be None, tuple, or Normalize object.\"', '                raise ValueError(err)', '', '            if not norm.scaled():', '                norm(np.asarray(data.dropna()))', '', '            lookup_table = dict(zip(levels, cmap(norm(levels))))', '', '        return levels, lookup_table, norm, cmap']}]}, {'name': 'SizeMapping', 'start_line': 292, 'end_line': 510, 'text': ['class SizeMapping(SemanticMapping):', '    \"\"\"Mapping that sets artist sizes according to data values.\"\"\"', '    # An object that normalizes data values to [0, 1] range', '    norm = None', '', '    def __init__(', '        self, plotter, sizes=None, order=None, norm=None,', '    ):', '        \"\"\"Map the levels of the `size` variable to distinct values.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"size\", pd.Series(dtype=float))', '', '        if data.notna().any():', '', '            map_type = self.infer_map_type(', '                norm, sizes, plotter.var_types[\"size\"]', '            )', '', '            # --- Option 1: numeric mapping', '', '            if map_type == \"numeric\":', '', '                levels, lookup_table, norm, size_range = self.numeric_mapping(', '                    data, sizes, norm,', '                )', '', '            # --- Option 2: categorical mapping', '', '            elif map_type == \"categorical\":', '', '                levels, lookup_table = self.categorical_mapping(', '                    data, sizes, order,', '                )', '                size_range = None', '', '            # --- Option 3: datetime mapping', '', '            # TODO this needs an actual implementation', '            else:', '', '                levels, lookup_table = self.categorical_mapping(', '                    # Casting data to list to handle differences in the way', '                    # pandas and numpy represent datetime64 data', '                    list(data), sizes, order,', '                )', '                size_range = None', '', '            self.map_type = map_type', '            self.levels = levels', '            self.norm = norm', '            self.sizes = sizes', '            self.size_range = size_range', '            self.lookup_table = lookup_table', '', '    def infer_map_type(self, norm, sizes, var_type):', '', '        if norm is not None:', '            map_type = \"numeric\"', '        elif isinstance(sizes, (dict, list)):', '            map_type = \"categorical\"', '        else:', '            map_type = var_type', '', '        return map_type', '', '    def _lookup_single(self, key):', '', '        try:', '            value = self.lookup_table[key]', '        except KeyError:', '            normed = self.norm(key)', '            if np.ma.is_masked(normed):', '                normed = np.nan', '            value = self.size_range[0] + normed * np.ptp(self.size_range)', '        return value', '', '    def categorical_mapping(self, data, sizes, order):', '', '        levels = categorical_order(data, order)', '', '        if isinstance(sizes, dict):', '', '            # Dict inputs map existing data values to the size attribute', '            missing = set(levels) - set(sizes)', '            if any(missing):', '                err = f\"Missing sizes for the following levels: {missing}\"', '                raise ValueError(err)', '            lookup_table = sizes.copy()', '', '        elif isinstance(sizes, list):', '', '            # List inputs give size values in the same order as the levels', '            sizes = self._check_list_length(levels, sizes, \"sizes\")', '            lookup_table = dict(zip(levels, sizes))', '', '        else:', '', '            if isinstance(sizes, tuple):', '', '                # Tuple input sets the min, max size values', '                if len(sizes) != 2:', '                    err = \"A `sizes` tuple must have only 2 values\"', '                    raise ValueError(err)', '', '            elif sizes is not None:', '', '                err = f\"Value for `sizes` not understood: {sizes}\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, we need to get the min, max size values from', '                # the plotter object we are attached to.', '', '                # TODO this is going to cause us trouble later, because we', '                # want to restructure things so that the plotter is generic', '                # across the visual representation of the data. But at this', \"                # point, we don't know the visual representation. Likely we\", '                # want to change the logic of this Mapping so that it gives', '                # points on a normalized range that then gets un-normalized', \"                # when we know what we're drawing. But given the way the\", '                # package works now, this way is cleanest.', '                sizes = self.plotter._default_size_range', '', '            # For categorical sizes, use regularly-spaced linear steps', '            # between the minimum and maximum sizes. Then reverse the', '            # ramp so that the largest value is used for the first entry', '            # in size_order, etc. This is because \"ordered\" categories', '            # are often though to go in decreasing priority.', '            sizes = np.linspace(*sizes, len(levels))[::-1]', '            lookup_table = dict(zip(levels, sizes))', '', '        return levels, lookup_table', '', '    def numeric_mapping(self, data, sizes, norm):', '', '        if isinstance(sizes, dict):', '            # The presence of a norm object overrides a dictionary of sizes', '            # in specifying a numeric mapping, so we need to process it', '            # dictionary here', '            levels = list(np.sort(list(sizes)))', '            size_values = sizes.values()', '            size_range = min(size_values), max(size_values)', '', '        else:', '', '            # The levels here will be the unique values in the data', '            levels = list(np.sort(remove_na(data.unique())))', '', '            if isinstance(sizes, tuple):', '', '                # For numeric inputs, the size can be parametrized by', '                # the minimum and maximum artist values to map to. The', '                # norm object that gets set up next specifies how to', '                # do the mapping.', '', '                if len(sizes) != 2:', '                    err = \"A `sizes` tuple must have only 2 values\"', '                    raise ValueError(err)', '', '                size_range = sizes', '', '            elif sizes is not None:', '', '                err = f\"Value for `sizes` not understood: {sizes}\"', '                raise ValueError(err)', '', '            else:', '', '                # When not provided, we get the size range from the plotter', '                # object we are attached to. See the note in the categorical', '                # method about how this is suboptimal for future development.', '                size_range = self.plotter._default_size_range', '', '        # Now that we know the minimum and maximum sizes that will get drawn,', '        # we need to map the data values that we have into that range. We will', '        # use a matplotlib Normalize class, which is typically used for numeric', '        # color mapping but works fine here too. It takes data values and maps', '        # them into a [0, 1] interval, potentially nonlinear-ly.', '', '        if norm is None:', '            # Default is a linear function between the min and max data values', '            norm = mpl.colors.Normalize()', '        elif isinstance(norm, tuple):', '            # It is also possible to give different limits in data space', '            norm = mpl.colors.Normalize(*norm)', '        elif not isinstance(norm, mpl.colors.Normalize):', '            err = f\"Value for size `norm` parameter not understood: {norm}\"', '            raise ValueError(err)', '        else:', '            # If provided with Normalize object, copy it so we can modify', '            norm = copy(norm)', '', '        # Set the mapping so all output values are in [0, 1]', '        norm.clip = True', '', '        # If the input range is not set, use the full range of the data', '        if not norm.scaled():', '            norm(levels)', '', '        # Map from data values to [0, 1] range', '        sizes_scaled = norm(levels)', '', '        # Now map from the scaled range into the artist units', '        if isinstance(sizes, dict):', '            lookup_table = sizes', '        else:', '            lo, hi = size_range', '            sizes = lo + sizes_scaled * (hi - lo)', '            lookup_table = dict(zip(levels, sizes))', '', '        return levels, lookup_table, norm, size_range'], 'methods': [{'name': '__init__', 'start_line': 297, 'end_line': 351, 'text': ['    def __init__(', '        self, plotter, sizes=None, order=None, norm=None,', '    ):', '        \"\"\"Map the levels of the `size` variable to distinct values.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"size\", pd.Series(dtype=float))', '', '        if data.notna().any():', '', '            map_type = self.infer_map_type(', '                norm, sizes, plotter.var_types[\"size\"]', '            )', '', '            # --- Option 1: numeric mapping', '', '            if map_type == \"numeric\":', '', '                levels, lookup_table, norm, size_range = self.numeric_mapping(', '                    data, sizes, norm,', '                )', '', '            # --- Option 2: categorical mapping', '', '            elif map_type == \"categorical\":', '', '                levels, lookup_table = self.categorical_mapping(', '                    data, sizes, order,', '                )', '                size_range = None', '', '            # --- Option 3: datetime mapping', '', '            # TODO this needs an actual implementation', '            else:', '', '                levels, lookup_table = self.categorical_mapping(', '                    # Casting data to list to handle differences in the way', '                    # pandas and numpy represent datetime64 data', '                    list(data), sizes, order,', '                )', '                size_range = None', '', '            self.map_type = map_type', '            self.levels = levels', '            self.norm = norm', '            self.sizes = sizes', '            self.size_range = size_range', '            self.lookup_table = lookup_table']}, {'name': 'infer_map_type', 'start_line': 353, 'end_line': 362, 'text': ['    def infer_map_type(self, norm, sizes, var_type):', '', '        if norm is not None:', '            map_type = \"numeric\"', '        elif isinstance(sizes, (dict, list)):', '            map_type = \"categorical\"', '        else:', '            map_type = var_type', '', '        return map_type']}, {'name': '_lookup_single', 'start_line': 364, 'end_line': 373, 'text': ['    def _lookup_single(self, key):', '', '        try:', '            value = self.lookup_table[key]', '        except KeyError:', '            normed = self.norm(key)', '            if np.ma.is_masked(normed):', '                normed = np.nan', '            value = self.size_range[0] + normed * np.ptp(self.size_range)', '        return value']}, {'name': 'categorical_mapping', 'start_line': 375, 'end_line': 431, 'text': ['    def categorical_mapping(self, data, sizes, order):', '', '        levels = categorical_order(data, order)', '', '        if isinstance(sizes, dict):', '', '            # Dict inputs map existing data values to the size attribute', '            missing = set(levels) - set(sizes)', '            if any(missing):', '                err = f\"Missing sizes for the following levels: {missing}\"', '                raise ValueError(err)', '            lookup_table = sizes.copy()', '', '        elif isinstance(sizes, list):', '', '            # List inputs give size values in the same order as the levels', '            sizes = self._check_list_length(levels, sizes, \"sizes\")', '            lookup_table = dict(zip(levels, sizes))', '', '        else:', '', '            if isinstance(sizes, tuple):', '', '                # Tuple input sets the min, max size values', '                if len(sizes) != 2:', '                    err = \"A `sizes` tuple must have only 2 values\"', '                    raise ValueError(err)', '', '            elif sizes is not None:', '', '                err = f\"Value for `sizes` not understood: {sizes}\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, we need to get the min, max size values from', '                # the plotter object we are attached to.', '', '                # TODO this is going to cause us trouble later, because we', '                # want to restructure things so that the plotter is generic', '                # across the visual representation of the data. But at this', \"                # point, we don't know the visual representation. Likely we\", '                # want to change the logic of this Mapping so that it gives', '                # points on a normalized range that then gets un-normalized', \"                # when we know what we're drawing. But given the way the\", '                # package works now, this way is cleanest.', '                sizes = self.plotter._default_size_range', '', '            # For categorical sizes, use regularly-spaced linear steps', '            # between the minimum and maximum sizes. Then reverse the', '            # ramp so that the largest value is used for the first entry', '            # in size_order, etc. This is because \"ordered\" categories', '            # are often though to go in decreasing priority.', '            sizes = np.linspace(*sizes, len(levels))[::-1]', '            lookup_table = dict(zip(levels, sizes))', '', '        return levels, lookup_table']}, {'name': 'numeric_mapping', 'start_line': 433, 'end_line': 510, 'text': ['    def numeric_mapping(self, data, sizes, norm):', '', '        if isinstance(sizes, dict):', '            # The presence of a norm object overrides a dictionary of sizes', '            # in specifying a numeric mapping, so we need to process it', '            # dictionary here', '            levels = list(np.sort(list(sizes)))', '            size_values = sizes.values()', '            size_range = min(size_values), max(size_values)', '', '        else:', '', '            # The levels here will be the unique values in the data', '            levels = list(np.sort(remove_na(data.unique())))', '', '            if isinstance(sizes, tuple):', '', '                # For numeric inputs, the size can be parametrized by', '                # the minimum and maximum artist values to map to. The', '                # norm object that gets set up next specifies how to', '                # do the mapping.', '', '                if len(sizes) != 2:', '                    err = \"A `sizes` tuple must have only 2 values\"', '                    raise ValueError(err)', '', '                size_range = sizes', '', '            elif sizes is not None:', '', '                err = f\"Value for `sizes` not understood: {sizes}\"', '                raise ValueError(err)', '', '            else:', '', '                # When not provided, we get the size range from the plotter', '                # object we are attached to. See the note in the categorical', '                # method about how this is suboptimal for future development.', '                size_range = self.plotter._default_size_range', '', '        # Now that we know the minimum and maximum sizes that will get drawn,', '        # we need to map the data values that we have into that range. We will', '        # use a matplotlib Normalize class, which is typically used for numeric', '        # color mapping but works fine here too. It takes data values and maps', '        # them into a [0, 1] interval, potentially nonlinear-ly.', '', '        if norm is None:', '            # Default is a linear function between the min and max data values', '            norm = mpl.colors.Normalize()', '        elif isinstance(norm, tuple):', '            # It is also possible to give different limits in data space', '            norm = mpl.colors.Normalize(*norm)', '        elif not isinstance(norm, mpl.colors.Normalize):', '            err = f\"Value for size `norm` parameter not understood: {norm}\"', '            raise ValueError(err)', '        else:', '            # If provided with Normalize object, copy it so we can modify', '            norm = copy(norm)', '', '        # Set the mapping so all output values are in [0, 1]', '        norm.clip = True', '', '        # If the input range is not set, use the full range of the data', '        if not norm.scaled():', '            norm(levels)', '', '        # Map from data values to [0, 1] range', '        sizes_scaled = norm(levels)', '', '        # Now map from the scaled range into the artist units', '        if isinstance(sizes, dict):', '            lookup_table = sizes', '        else:', '            lo, hi = size_range', '            sizes = lo + sizes_scaled * (hi - lo)', '            lookup_table = dict(zip(levels, sizes))', '', '        return levels, lookup_table, norm, size_range']}]}, {'name': 'StyleMapping', 'start_line': 514, 'end_line': 607, 'text': ['class StyleMapping(SemanticMapping):', '    \"\"\"Mapping that sets artist style according to data values.\"\"\"', '', '    # Style mapping is always treated as categorical', '    map_type = \"categorical\"', '', '    def __init__(', '        self, plotter, markers=None, dashes=None, order=None,', '    ):', '        \"\"\"Map the levels of the `style` variable to distinct values.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"style\", pd.Series(dtype=float))', '', '        if data.notna().any():', '', '            # Cast to list to handle numpy/pandas datetime quirks', '            if variable_type(data) == \"datetime\":', '                data = list(data)', '', '            # Find ordered unique values', '            levels = categorical_order(data, order)', '', '            markers = self._map_attributes(', '                markers, levels, unique_markers(len(levels)), \"markers\",', '            )', '            dashes = self._map_attributes(', '                dashes, levels, unique_dashes(len(levels)), \"dashes\",', '            )', '', '            # Build the paths matplotlib will use to draw the markers', '            paths = {}', '            filled_markers = []', '            for k, m in markers.items():', '                if not isinstance(m, mpl.markers.MarkerStyle):', '                    m = mpl.markers.MarkerStyle(m)', '                paths[k] = m.get_path().transformed(m.get_transform())', '                filled_markers.append(m.is_filled())', '', '            # Mixture of filled and unfilled markers will show line art markers', '            # in the edge color, which defaults to white. This can be handled,', '            # but there would be additional complexity with specifying the', '            # weight of the line art markers without overwhelming the filled', '            # ones with the edges. So for now, we will disallow mixtures.', '            if any(filled_markers) and not all(filled_markers):', '                err = \"Filled and line art markers cannot be mixed\"', '                raise ValueError(err)', '', '            lookup_table = {}', '            for key in levels:', '                lookup_table[key] = {}', '                if markers:', '                    lookup_table[key][\"marker\"] = markers[key]', '                    lookup_table[key][\"path\"] = paths[key]', '                if dashes:', '                    lookup_table[key][\"dashes\"] = dashes[key]', '', '            self.levels = levels', '            self.lookup_table = lookup_table', '', '    def _lookup_single(self, key, attr=None):', '        \"\"\"Get attribute(s) for a given data point.\"\"\"', '        if attr is None:', '            value = self.lookup_table[key]', '        else:', '            value = self.lookup_table[key][attr]', '        return value', '', '    def _map_attributes(self, arg, levels, defaults, attr):', '        \"\"\"Handle the specification for a given style attribute.\"\"\"', '        if arg is True:', '            lookup_table = dict(zip(levels, defaults))', '        elif isinstance(arg, dict):', '            missing = set(levels) - set(arg)', '            if missing:', '                err = f\"These `{attr}` levels are missing values: {missing}\"', '                raise ValueError(err)', '            lookup_table = arg', '        elif isinstance(arg, Sequence):', '            arg = self._check_list_length(levels, arg, attr)', '            lookup_table = dict(zip(levels, arg))', '        elif arg:', '            err = f\"This `{attr}` argument was not understood: {arg}\"', '            raise ValueError(err)', '        else:', '            lookup_table = {}', '', '        return lookup_table'], 'methods': [{'name': '__init__', 'start_line': 520, 'end_line': 578, 'text': ['    def __init__(', '        self, plotter, markers=None, dashes=None, order=None,', '    ):', '        \"\"\"Map the levels of the `style` variable to distinct values.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"style\", pd.Series(dtype=float))', '', '        if data.notna().any():', '', '            # Cast to list to handle numpy/pandas datetime quirks', '            if variable_type(data) == \"datetime\":', '                data = list(data)', '', '            # Find ordered unique values', '            levels = categorical_order(data, order)', '', '            markers = self._map_attributes(', '                markers, levels, unique_markers(len(levels)), \"markers\",', '            )', '            dashes = self._map_attributes(', '                dashes, levels, unique_dashes(len(levels)), \"dashes\",', '            )', '', '            # Build the paths matplotlib will use to draw the markers', '            paths = {}', '            filled_markers = []', '            for k, m in markers.items():', '                if not isinstance(m, mpl.markers.MarkerStyle):', '                    m = mpl.markers.MarkerStyle(m)', '                paths[k] = m.get_path().transformed(m.get_transform())', '                filled_markers.append(m.is_filled())', '', '            # Mixture of filled and unfilled markers will show line art markers', '            # in the edge color, which defaults to white. This can be handled,', '            # but there would be additional complexity with specifying the', '            # weight of the line art markers without overwhelming the filled', '            # ones with the edges. So for now, we will disallow mixtures.', '            if any(filled_markers) and not all(filled_markers):', '                err = \"Filled and line art markers cannot be mixed\"', '                raise ValueError(err)', '', '            lookup_table = {}', '            for key in levels:', '                lookup_table[key] = {}', '                if markers:', '                    lookup_table[key][\"marker\"] = markers[key]', '                    lookup_table[key][\"path\"] = paths[key]', '                if dashes:', '                    lookup_table[key][\"dashes\"] = dashes[key]', '', '            self.levels = levels', '            self.lookup_table = lookup_table']}, {'name': '_lookup_single', 'start_line': 580, 'end_line': 586, 'text': ['    def _lookup_single(self, key, attr=None):', '        \"\"\"Get attribute(s) for a given data point.\"\"\"', '        if attr is None:', '            value = self.lookup_table[key]', '        else:', '            value = self.lookup_table[key][attr]', '        return value']}, {'name': '_map_attributes', 'start_line': 588, 'end_line': 607, 'text': ['    def _map_attributes(self, arg, levels, defaults, attr):', '        \"\"\"Handle the specification for a given style attribute.\"\"\"', '        if arg is True:', '            lookup_table = dict(zip(levels, defaults))', '        elif isinstance(arg, dict):', '            missing = set(levels) - set(arg)', '            if missing:', '                err = f\"These `{attr}` levels are missing values: {missing}\"', '                raise ValueError(err)', '            lookup_table = arg', '        elif isinstance(arg, Sequence):', '            arg = self._check_list_length(levels, arg, attr)', '            lookup_table = dict(zip(levels, arg))', '        elif arg:', '            err = f\"This `{attr}` argument was not understood: {arg}\"', '            raise ValueError(err)', '        else:', '            lookup_table = {}', '', '        return lookup_table']}]}, {'name': 'VectorPlotter', 'start_line': 613, 'end_line': 1450, 'text': ['class VectorPlotter:', '    \"\"\"Base class for objects underlying *plot functions.\"\"\"', '', '    _semantic_mappings = {', '        \"hue\": HueMapping,', '        \"size\": SizeMapping,', '        \"style\": StyleMapping,', '    }', '', '    # TODO units is another example of a non-mapping \"semantic\"', '    # we need a general name for this and separate handling', '    semantics = \"x\", \"y\", \"hue\", \"size\", \"style\", \"units\"', '    wide_structure = {', '        \"x\": \"@index\", \"y\": \"@values\", \"hue\": \"@columns\", \"style\": \"@columns\",', '    }', '    flat_structure = {\"x\": \"@index\", \"y\": \"@values\"}', '', '    _default_size_range = 1, 2  # Unused but needed in tests, ugh', '', '    def __init__(self, data=None, variables={}):', '', '        self._var_levels = {}', '        # var_ordered is relevant only for categorical axis variables, and may', '        # be better handled by an internal axis information object that tracks', '        # such information and is set up by the scale_* methods. The analogous', '        # information for numeric axes would be information about log scales.', '        self._var_ordered = {\"x\": False, \"y\": False}  # alt., used DefaultDict', '        self.assign_variables(data, variables)', '', '        for var, cls in self._semantic_mappings.items():', '', '            # Create the mapping function', '            map_func = partial(cls.map, plotter=self)', '            setattr(self, f\"map_{var}\", map_func)', '', '            # Call the mapping function to initialize with default values', '            getattr(self, f\"map_{var}\")()', '', '    @classmethod', '    def get_semantics(cls, kwargs, semantics=None):', '        \"\"\"Subset a dictionary arguments with known semantic variables.\"\"\"', '        # TODO this should be get_variables since we have included x and y', '        if semantics is None:', '            semantics = cls.semantics', '        variables = {}', '        for key, val in kwargs.items():', '            if key in semantics and val is not None:', '                variables[key] = val', '        return variables', '', '    @property', '    def has_xy_data(self):', '        \"\"\"Return True at least one of x or y is defined.\"\"\"', '        return bool({\"x\", \"y\"} & set(self.variables))', '', '    @property', '    def var_levels(self):', '        \"\"\"Property interface to ordered list of variables levels.', '', \"        Each time it's accessed, it updates the var_levels dictionary with the\", '        list of levels in the current semantic mappers. But it also allows the', '        dictionary to persist, so it can be used to set levels by a key. This is', '        used to track the list of col/row levels using an attached FacetGrid', \"        object, but it's kind of messy and ideally fixed by improving the\", '        faceting logic so it interfaces better with the modern approach to', '        tracking plot variables.', '', '        \"\"\"', '        for var in self.variables:', '            try:', '                map_obj = getattr(self, f\"_{var}_map\")', '                self._var_levels[var] = map_obj.levels', '            except AttributeError:', '                pass', '        return self._var_levels', '', '    def assign_variables(self, data=None, variables={}):', '        \"\"\"Define plot variables, optionally using lookup from `data`.\"\"\"', '        x = variables.get(\"x\", None)', '        y = variables.get(\"y\", None)', '', '        if x is None and y is None:', '            self.input_format = \"wide\"', '            plot_data, variables = self._assign_variables_wideform(', '                data, **variables,', '            )', '        else:', '            self.input_format = \"long\"', '            plot_data, variables = self._assign_variables_longform(', '                data, **variables,', '            )', '', '        self.plot_data = plot_data', '        self.variables = variables', '        self.var_types = {', '            v: variable_type(', '                plot_data[v],', '                boolean_type=\"numeric\" if v in \"xy\" else \"categorical\"', '            )', '            for v in variables', '        }', '', '        return self', '', '    def _assign_variables_wideform(self, data=None, **kwargs):', '        \"\"\"Define plot variables given wide-form data.', '', '        Parameters', '        ----------', '        data : flat vector or collection of vectors', '            Data can be a vector or mapping that is coerceable to a Series', '            or a sequence- or mapping-based collection of such vectors, or a', '            rectangular numpy array, or a Pandas DataFrame.', '        kwargs : variable -> data mappings', '            Behavior with keyword arguments is currently undefined.', '', '        Returns', '        -------', '        plot_data : :class:`pandas.DataFrame`', '            Long-form data object mapping seaborn variables (x, y, hue, ...)', '            to data vectors.', '        variables : dict', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '', '        \"\"\"', '        # Raise if semantic or other variables are assigned in wide-form mode', '        assigned = [k for k, v in kwargs.items() if v is not None]', '        if any(assigned):', '            s = \"s\" if len(assigned) > 1 else \"\"', '            err = f\"The following variable{s} cannot be assigned with wide-form data: \"', '            err += \", \".join(f\"`{v}`\" for v in assigned)', '            raise ValueError(err)', '', '        # Determine if the data object actually has any data in it', '        empty = data is None or not len(data)', '', '        # Then, determine if we have \"flat\" data (a single vector)', '        if isinstance(data, dict):', '            values = data.values()', '        else:', '            values = np.atleast_1d(np.asarray(data, dtype=object))', '        flat = not any(', '            isinstance(v, Iterable) and not isinstance(v, (str, bytes))', '            for v in values', '        )', '', '        if empty:', '', '            # Make an object with the structure of plot_data, but empty', '            plot_data = pd.DataFrame()', '            variables = {}', '', '        elif flat:', '', '            # Handle flat data by converting to pandas Series and using the', '            # index and/or values to define x and/or y', '            # (Could be accomplished with a more general to_series() interface)', '            flat_data = pd.Series(data).copy()', '            names = {', '                \"@values\": flat_data.name,', '                \"@index\": flat_data.index.name', '            }', '', '            plot_data = {}', '            variables = {}', '', '            for var in [\"x\", \"y\"]:', '                if var in self.flat_structure:', '                    attr = self.flat_structure[var]', '                    plot_data[var] = getattr(flat_data, attr[1:])', '                    variables[var] = names[self.flat_structure[var]]', '', '            plot_data = pd.DataFrame(plot_data)', '', '        else:', '', '            # Otherwise assume we have some collection of vectors.', '', '            # Handle Python sequences such that entries end up in the columns,', '            # not in the rows, of the intermediate wide DataFrame.', '            # One way to accomplish this is to convert to a dict of Series.', '            if isinstance(data, Sequence):', '                data_dict = {}', '                for i, var in enumerate(data):', '                    key = getattr(var, \"name\", i)', '                    # TODO is there a safer/more generic way to ensure Series?', '                    # sort of like np.asarray, but for pandas?', '                    data_dict[key] = pd.Series(var)', '', '                data = data_dict', '', '            # Pandas requires that dict values either be Series objects', '            # or all have the same length, but we want to allow \"ragged\" inputs', '            if isinstance(data, Mapping):', '                data = {key: pd.Series(val) for key, val in data.items()}', '', '            # Otherwise, delegate to the pandas DataFrame constructor', \"            # This is where we'd prefer to use a general interface that says\", '            # \"give me this data as a pandas DataFrame\", so we can accept', '            # DataFrame objects from other libraries', '            wide_data = pd.DataFrame(data, copy=True)', '', '            # At this point we should reduce the dataframe to numeric cols', '            numeric_cols = [', '                k for k, v in wide_data.items() if variable_type(v) == \"numeric\"', '            ]', '            wide_data = wide_data[numeric_cols]', '', '            # Now melt the data to long form', '            melt_kws = {\"var_name\": \"@columns\", \"value_name\": \"@values\"}', '            use_index = \"@index\" in self.wide_structure.values()', '            if use_index:', '                melt_kws[\"id_vars\"] = \"@index\"', '                try:', '                    orig_categories = wide_data.columns.categories', '                    orig_ordered = wide_data.columns.ordered', '                    wide_data.columns = wide_data.columns.add_categories(\"@index\")', '                except AttributeError:', '                    category_columns = False', '                else:', '                    category_columns = True', '                wide_data[\"@index\"] = wide_data.index.to_series()', '', '            plot_data = wide_data.melt(**melt_kws)', '', '            if use_index and category_columns:', '                plot_data[\"@columns\"] = pd.Categorical(plot_data[\"@columns\"],', '                                                       orig_categories,', '                                                       orig_ordered)', '', '            # Assign names corresponding to plot semantics', '            for var, attr in self.wide_structure.items():', '                plot_data[var] = plot_data[attr]', '', '            # Define the variable names', '            variables = {}', '            for var, attr in self.wide_structure.items():', '                obj = getattr(wide_data, attr[1:])', '                variables[var] = getattr(obj, \"name\", None)', '', '            # Remove redundant columns from plot_data', '            plot_data = plot_data[list(variables)]', '', '        return plot_data, variables', '', '    def _assign_variables_longform(self, data=None, **kwargs):', '        \"\"\"Define plot variables given long-form data and/or vector inputs.', '', '        Parameters', '        ----------', '        data : dict-like collection of vectors', '            Input data where variable names map to vector values.', '        kwargs : variable -> data mappings', '            Keys are seaborn variables (x, y, hue, ...) and values are vectors', '            in any format that can construct a :class:`pandas.DataFrame` or', '            names of columns or index levels in ``data``.', '', '        Returns', '        -------', '        plot_data : :class:`pandas.DataFrame`', '            Long-form data object mapping seaborn variables (x, y, hue, ...)', '            to data vectors.', '        variables : dict', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '', '        Raises', '        ------', '        ValueError', \"            When variables are strings that don't appear in ``data``.\", '', '        \"\"\"', '        plot_data = {}', '        variables = {}', '', '        # Data is optional; all variables can be defined as vectors', '        if data is None:', '            data = {}', '', '        # TODO should we try a data.to_dict() or similar here to more', '        # generally accept objects with that interface?', '        # Note that dict(df) also works for pandas, and gives us what we', '        # want, whereas DataFrame.to_dict() gives a nested dict instead of', '        # a dict of series.', '', '        # Variables can also be extracted from the index attribute', '        # TODO is this the most general way to enable it?', '        # There is no index.to_dict on multiindex, unfortunately', '        try:', '            index = data.index.to_frame()', '        except AttributeError:', '            index = {}', '', '        # The caller will determine the order of variables in plot_data', '        for key, val in kwargs.items():', '', '            # First try to treat the argument as a key for the data collection.', '            # But be flexible about what can be used as a key.', '            # Usually it will be a string, but allow numbers or tuples too when', '            # taking from the main data object. Only allow strings to reference', '            # fields in the index, because otherwise there is too much ambiguity.', '            try:', '                val_as_data_key = (', '                    val in data', '                    or (isinstance(val, (str, bytes)) and val in index)', '                )', '            except (KeyError, TypeError):', '                val_as_data_key = False', '', '            if val_as_data_key:', '', '                # We know that __getitem__ will work', '', '                if val in data:', '                    plot_data[key] = data[val]', '                elif val in index:', '                    plot_data[key] = index[val]', '                variables[key] = val', '', '            elif isinstance(val, (str, bytes)):', '', \"                # This looks like a column name but we don't know what it means!\", '', '                err = f\"Could not interpret value `{val}` for parameter `{key}`\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, assume the value is itself data', '', \"                # Raise when data object is present and a vector can't matched\", '                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):', '                    if np.ndim(val) and len(data) != len(val):', '                        val_cls = val.__class__.__name__', '                        err = (', '                            f\"Length of {val_cls} vectors must match length of `data`\"', '                            f\" when both are used, but `data` has length {len(data)}\"', '                            f\" and the vector passed to `{key}` has length {len(val)}.\"', '                        )', '                        raise ValueError(err)', '', '                plot_data[key] = val', '', '                # Try to infer the name of the variable', '                variables[key] = getattr(val, \"name\", None)', '', '        # Construct a tidy plot DataFrame. This will convert a number of', '        # types automatically, aligning on index in case of pandas objects', '        plot_data = pd.DataFrame(plot_data)', '', '        # Reduce the variables dictionary to fields with valid data', '        variables = {', '            var: name', '            for var, name in variables.items()', '            if plot_data[var].notnull().any()', '        }', '', '        return plot_data, variables', '', '    def iter_data(', '        self, grouping_vars=None, *,', '        reverse=False, from_comp_data=False,', '        by_facet=True, allow_empty=False, dropna=True,', '    ):', '        \"\"\"Generator for getting subsets of data defined by semantic variables.', '', '        Also injects \"col\" and \"row\" into grouping semantics.', '', '        Parameters', '        ----------', '        grouping_vars : string or list of strings', '            Semantic variables that define the subsets of data.', '        reverse : bool', '            If True, reverse the order of iteration.', '        from_comp_data : bool', '            If True, use self.comp_data rather than self.plot_data', '        by_facet : bool', '            If True, add faceting variables to the set of grouping variables.', '        allow_empty : bool', '            If True, yield an empty dataframe when no observations exist for', '            combinations of grouping variables.', '        dropna : bool', '            If True, remove rows with missing data.', '', '        Yields', '        ------', '        sub_vars : dict', '            Keys are semantic names, values are the level of that semantic.', '        sub_data : :class:`pandas.DataFrame`', '            Subset of ``plot_data`` for this combination of semantic values.', '', '        \"\"\"', '        # TODO should this default to using all (non x/y?) semantics?', '        # or define grouping vars somewhere?', '        if grouping_vars is None:', '            grouping_vars = []', '        elif isinstance(grouping_vars, str):', '            grouping_vars = [grouping_vars]', '        elif isinstance(grouping_vars, tuple):', '            grouping_vars = list(grouping_vars)', '', '        # Always insert faceting variables', '        if by_facet:', '            facet_vars = {\"col\", \"row\"}', '            grouping_vars.extend(', '                facet_vars & set(self.variables) - set(grouping_vars)', '            )', '', '        # Reduce to the semantics used in this plot', '        grouping_vars = [', '            var for var in grouping_vars if var in self.variables', '        ]', '', '        if from_comp_data:', '            data = self.comp_data', '        else:', '            data = self.plot_data', '', '        if dropna:', '            data = data.dropna()', '', '        levels = self.var_levels.copy()', '        if from_comp_data:', '            for axis in {\"x\", \"y\"} & set(grouping_vars):', '                if self.var_types[axis] == \"categorical\":', '                    if self._var_ordered[axis]:', '                        # If the axis is ordered, then the axes in a possible', '                        # facet grid are by definition \"shared\", or there is a', '                        # single axis with a unique cat -> idx mapping.', '                        # So we can just take the first converter object.', '                        converter = self.converters[axis].iloc[0]', '                        levels[axis] = converter.convert_units(levels[axis])', '                    else:', '                        # Otherwise, the mappings may not be unique, but we can', '                        # use the unique set of index values in comp_data.', '                        levels[axis] = np.sort(data[axis].unique())', '                elif self.var_types[axis] == \"datetime\":', '                    levels[axis] = mpl.dates.date2num(levels[axis])', '                elif self.var_types[axis] == \"numeric\" and self._log_scaled(axis):', '                    levels[axis] = np.log10(levels[axis])', '', '        if grouping_vars:', '', '            grouped_data = data.groupby(', '                grouping_vars, sort=False, as_index=False', '            )', '', '            grouping_keys = []', '            for var in grouping_vars:', '                grouping_keys.append(levels.get(var, []))', '', '            iter_keys = itertools.product(*grouping_keys)', '            if reverse:', '                iter_keys = reversed(list(iter_keys))', '', '            for key in iter_keys:', '', '                # Pandas fails with singleton tuple inputs', '                pd_key = key[0] if len(key) == 1 else key', '', '                try:', '                    data_subset = grouped_data.get_group(pd_key)', '                except KeyError:', '                    # XXX we are adding this to allow backwards compatibility', '                    # with the empty artists that old categorical plots would', '                    # add (before 0.12), which we may decide to break, in which', '                    # case this option could be removed', '                    data_subset = data.loc[[]]', '', '                if data_subset.empty and not allow_empty:', '                    continue', '', '                sub_vars = dict(zip(grouping_vars, key))', '', '                yield sub_vars, data_subset.copy()', '', '        else:', '', '            yield {}, data.copy()', '', '    @property', '    def comp_data(self):', '        \"\"\"Dataframe with numeric x and y, after unit conversion and log scaling.\"\"\"', '        if not hasattr(self, \"ax\"):', '            # Probably a good idea, but will need a bunch of tests updated', '            # Most of these tests should just use the external interface', '            # Then this can be re-enabled.', '            # raise AttributeError(\"No Axes attached to plotter\")', '            return self.plot_data', '', '        if not hasattr(self, \"_comp_data\"):', '', '            comp_data = (', '                self.plot_data', '                .copy(deep=False)', '                .drop([\"x\", \"y\"], axis=1, errors=\"ignore\")', '            )', '', '            for var in \"yx\":', '                if var not in self.variables:', '                    continue', '', '                parts = []', '                grouped = self.plot_data[var].groupby(self.converters[var], sort=False)', '                for converter, orig in grouped:', \"                    with pd.option_context('mode.use_inf_as_null', True):\", '                        orig = orig.dropna()', '                        if var in self.var_levels:', '                            # TODO this should happen in some centralized location', '                            # it is similar to GH2419, but more complicated because', '                            # supporting `order` in categorical plots is tricky', '                            orig = orig[orig.isin(self.var_levels[var])]', '                    comp = pd.to_numeric(converter.convert_units(orig))', '                    if converter.get_scale() == \"log\":', '                        comp = np.log10(comp)', '                    parts.append(pd.Series(comp, orig.index, name=orig.name))', '                if parts:', '                    comp_col = pd.concat(parts)', '                else:', '                    comp_col = pd.Series(dtype=float, name=var)', '                comp_data.insert(0, var, comp_col)', '', '            self._comp_data = comp_data', '', '        return self._comp_data', '', '    def _get_axes(self, sub_vars):', '        \"\"\"Return an Axes object based on existence of row/col variables.\"\"\"', '        row = sub_vars.get(\"row\", None)', '        col = sub_vars.get(\"col\", None)', '        if row is not None and col is not None:', '            return self.facets.axes_dict[(row, col)]', '        elif row is not None:', '            return self.facets.axes_dict[row]', '        elif col is not None:', '            return self.facets.axes_dict[col]', '        elif self.ax is None:', '            return self.facets.ax', '        else:', '            return self.ax', '', '    def _attach(', '        self,', '        obj,', '        allowed_types=None,', '        log_scale=None,', '    ):', '        \"\"\"Associate the plotter with an Axes manager and initialize its units.', '', '        Parameters', '        ----------', \"        obj : :class:`matplotlib.axes.Axes` or :class:'FacetGrid`\", '            Structural object that we will eventually plot onto.', '        allowed_types : str or list of str', '            If provided, raise when either the x or y variable does not have', '            one of the declared seaborn types.', '        log_scale : bool, number, or pair of bools or numbers', '            If not False, set the axes to use log scaling, with the given', '            base or defaulting to 10. If a tuple, interpreted as separate', '            arguments for the x and y axes.', '', '        \"\"\"', '        from .axisgrid import FacetGrid', '        if isinstance(obj, FacetGrid):', '            self.ax = None', '            self.facets = obj', '            ax_list = obj.axes.flatten()', '            if obj.col_names is not None:', '                self.var_levels[\"col\"] = obj.col_names', '            if obj.row_names is not None:', '                self.var_levels[\"row\"] = obj.row_names', '        else:', '            self.ax = obj', '            self.facets = None', '            ax_list = [obj]', '', '        # Identify which \"axis\" variables we have defined', '        axis_variables = set(\"xy\").intersection(self.variables)', '', '        # -- Verify the types of our x and y variables here.', \"        # This doesn't really make complete sense being here here, but it's a fine\", '        # place for it, given  the current system.', '        # (Note that for some plots, there might be more complicated restrictions)', '        # e.g. the categorical plots have their own check that as specific to the', '        # non-categorical axis.', '        if allowed_types is None:', '            allowed_types = [\"numeric\", \"datetime\", \"categorical\"]', '        elif isinstance(allowed_types, str):', '            allowed_types = [allowed_types]', '', '        for var in axis_variables:', '            var_type = self.var_types[var]', '            if var_type not in allowed_types:', '                err = (', '                    f\"The {var} variable is {var_type}, but one of \"', '                    f\"{allowed_types} is required\"', '                )', '                raise TypeError(err)', '', '        # -- Get axis objects for each row in plot_data for type conversions and scaling', '', '        facet_dim = {\"x\": \"col\", \"y\": \"row\"}', '', '        self.converters = {}', '        for var in axis_variables:', '            other_var = {\"x\": \"y\", \"y\": \"x\"}[var]', '', '            converter = pd.Series(index=self.plot_data.index, name=var, dtype=object)', '            share_state = getattr(self.facets, f\"_share{var}\", True)', '', '            # Simplest cases are that we have a single axes, all axes are shared,', '            # or sharing is only on the orthogonal facet dimension. In these cases,', '            # all datapoints get converted the same way, so use the first axis', '            if share_state is True or share_state == facet_dim[other_var]:', '                converter.loc[:] = getattr(ax_list[0], f\"{var}axis\")', '', '            else:', '', '                # Next simplest case is when no axes are shared, and we can', '                # use the axis objects within each facet', '                if share_state is False:', '                    for axes_vars, axes_data in self.iter_data():', '                        ax = self._get_axes(axes_vars)', '                        converter.loc[axes_data.index] = getattr(ax, f\"{var}axis\")', '', '                # In the more complicated case, the axes are shared within each', '                # \"file\" of the facetgrid. In that case, we need to subset the data', '                # for that file and assign it the first axis in the slice of the grid', '                else:', '', '                    names = getattr(self.facets, f\"{share_state}_names\")', '                    for i, level in enumerate(names):', '                        idx = (i, 0) if share_state == \"row\" else (0, i)', '                        axis = getattr(self.facets.axes[idx], f\"{var}axis\")', '                        converter.loc[self.plot_data[share_state] == level] = axis', '', '            # Store the converter vector, which we use elsewhere (e.g comp_data)', '            self.converters[var] = converter', '', '            # Now actually update the matplotlib objects to do the conversion we want', '            grouped = self.plot_data[var].groupby(self.converters[var], sort=False)', '            for converter, seed_data in grouped:', '                if self.var_types[var] == \"categorical\":', '                    if self._var_ordered[var]:', '                        order = self.var_levels[var]', '                    else:', '                        order = None', '                    seed_data = categorical_order(seed_data, order)', '                converter.update_units(seed_data)', '', '        # -- Set numerical axis scales', '', '        # First unpack the log_scale argument', '        if log_scale is None:', '            scalex = scaley = False', '        else:', '            # Allow single value or x, y tuple', '            try:', '                scalex, scaley = log_scale', '            except TypeError:', '                scalex = log_scale if \"x\" in self.variables else False', '                scaley = log_scale if \"y\" in self.variables else False', '', '        # Now use it', '        for axis, scale in zip(\"xy\", (scalex, scaley)):', '            if scale:', '                for ax in ax_list:', '                    set_scale = getattr(ax, f\"set_{axis}scale\")', '                    if scale is True:', '                        set_scale(\"log\")', '                    else:', '                        if Version(mpl.__version__) >= Version(\"3.3\"):', '                            set_scale(\"log\", base=scale)', '                        else:', '                            set_scale(\"log\", **{f\"base{axis}\": scale})', '', '        # For categorical y, we want the \"first\" level to be at the top of the axis', '        if self.var_types.get(\"y\", None) == \"categorical\":', '            for ax in ax_list:', '                try:', '                    ax.yaxis.set_inverted(True)', '                except AttributeError:  # mpl < 3.1', '                    if not ax.yaxis_inverted():', '                        ax.invert_yaxis()', '', '        # TODO -- Add axes labels', '', '    def _log_scaled(self, axis):', '        \"\"\"Return True if specified axis is log scaled on all attached axes.\"\"\"', '        if not hasattr(self, \"ax\"):', '            return False', '', '        if self.ax is None:', '            axes_list = self.facets.axes.flatten()', '        else:', '            axes_list = [self.ax]', '', '        log_scaled = []', '        for ax in axes_list:', '            data_axis = getattr(ax, f\"{axis}axis\")', '            log_scaled.append(data_axis.get_scale() == \"log\")', '', '        if any(log_scaled) and not all(log_scaled):', '            raise RuntimeError(\"Axis scaling is not consistent\")', '', '        return any(log_scaled)', '', '    def _add_axis_labels(self, ax, default_x=\"\", default_y=\"\"):', '        \"\"\"Add axis labels if not present, set visibility to match ticklabels.\"\"\"', '        # TODO ax could default to None and use attached axes if present', \"        # but what to do about the case of facets? Currently using FacetGrid's\", \"        # set_axis_labels method, which doesn't add labels to the interior even\", '        # when the axes are not shared. Maybe that makes sense?', '        if not ax.get_xlabel():', '            x_visible = any(t.get_visible() for t in ax.get_xticklabels())', '            ax.set_xlabel(self.variables.get(\"x\", default_x), visible=x_visible)', '        if not ax.get_ylabel():', '            y_visible = any(t.get_visible() for t in ax.get_yticklabels())', '            ax.set_ylabel(self.variables.get(\"y\", default_y), visible=y_visible)', '', '    # XXX If the scale_* methods are going to modify the plot_data structure, they', \"    # can't be called twice. That means that if they are called twice, they should\", '    # raise. Alternatively, we could store an original version of plot_data and each', '    # time they are called they operate on the store, not the current state.', '', '    def scale_native(self, axis, *args, **kwargs):', '', '        # Default, defer to matplotlib', '', '        raise NotImplementedError', '', '    def scale_numeric(self, axis, *args, **kwargs):', '', '        # Feels needed to completeness, what should it do?', '        # Perhaps handle log scaling? Set the ticker/formatter/limits?', '', '        raise NotImplementedError', '', '    def scale_datetime(self, axis, *args, **kwargs):', '', '        # Use pd.to_datetime to convert strings or numbers to datetime objects', '        # Note, use day-resolution for numeric->datetime to match matplotlib', '', '        raise NotImplementedError', '', '    def scale_categorical(self, axis, order=None, formatter=None):', '        \"\"\"', '        Enforce categorical (fixed-scale) rules for the data on given axis.', '', '        Parameters', '        ----------', '        axis : \"x\" or \"y\"', '            Axis of the plot to operate on.', '        order : list', '            Order that unique values should appear in.', '        formatter : callable', '            Function mapping values to a string representation.', '', '        Returns', '        -------', '        self', '', '        \"\"\"', '        # This method both modifies the internal representation of the data', '        # (converting it to string) and sets some attributes on self. It might be', '        # a good idea to have a separate object attached to self that contains the', '        # information in those attributes (i.e. whether to enforce variable order', '        # across facets, the order to use) similar to the SemanticMapping objects', '        # we have for semantic variables. That object could also hold the converter', '        # objects that get used, if we can decouple those from an existing axis', '        # (cf. https://github.com/matplotlib/matplotlib/issues/19229).', '        # There are some interactions with faceting information that would need', '        # to be thought through, since the converts to use depend on facets.', '        # If we go that route, these methods could become \"borrowed\" methods similar', '        # to what happens with the alternate semantic mapper constructors, although', '        # that approach is kind of fussy and confusing.', '', '        # TODO this method could also set the grid state? Since we like to have no', \"        # grid on the categorical axis by default. Again, a case where we'll need to\", '        # store information until we use it, so best to have a way to collect the', '        # attributes that this method sets.', '', '        # TODO if we are going to set visual properties of the axes with these methods,', '        # then we could do the steps currently in CategoricalPlotter._adjust_cat_axis', '', '        # TODO another, and distinct idea, is to expose a cut= param here', '', '        _check_argument(\"axis\", [\"x\", \"y\"], axis)', '', '        # Categorical plots can be \"univariate\" in which case they get an anonymous', '        # category label on the opposite axis.', '        if axis not in self.variables:', '            self.variables[axis] = None', '            self.var_types[axis] = \"categorical\"', '            self.plot_data[axis] = \"\"', '', '        # If the \"categorical\" variable has a numeric type, sort the rows so that', '        # the default result from categorical_order has those values sorted after', '        # they have been coerced to strings. The reason for this is so that later', '        # we can get facet-wise orders that are correct.', '        # XXX Should this also sort datetimes?', '        # It feels more consistent, but technically will be a default change', '        # If so, should also change categorical_order to behave that way', '        if self.var_types[axis] == \"numeric\":', '            self.plot_data = self.plot_data.sort_values(axis, kind=\"mergesort\")', '', '        # Now get a reference to the categorical data vector', '        cat_data = self.plot_data[axis]', '', '        # Get the initial categorical order, which we do before string', '        # conversion to respect the original types of the order list.', '        # Track whether the order is given explicitly so that we can know', '        # whether or not to use the order constructed here downstream', '        self._var_ordered[axis] = order is not None or cat_data.dtype.name == \"category\"', '        order = pd.Index(categorical_order(cat_data, order))', '', '        # Then convert data to strings. This is because in matplotlib,', '        # \"categorical\" data really mean \"string\" data, so doing this artists', '        # will be drawn on the categorical axis with a fixed scale.', '        # TODO implement formatter here; check that it returns strings?', '        if formatter is not None:', '            cat_data = cat_data.map(formatter)', '            order = order.map(formatter)', '        else:', '            cat_data = cat_data.astype(str)', '            order = order.astype(str)', '', '        # Update the levels list with the type-converted order variable', '        self.var_levels[axis] = order', '', '        # Now ensure that seaborn will use categorical rules internally', '        self.var_types[axis] = \"categorical\"', '', '        # Put the string-typed categorical vector back into the plot_data structure', '        self.plot_data[axis] = cat_data', '', '        return self'], 'methods': [{'name': '__init__', 'start_line': 632, 'end_line': 649, 'text': ['    def __init__(self, data=None, variables={}):', '', '        self._var_levels = {}', '        # var_ordered is relevant only for categorical axis variables, and may', '        # be better handled by an internal axis information object that tracks', '        # such information and is set up by the scale_* methods. The analogous', '        # information for numeric axes would be information about log scales.', '        self._var_ordered = {\"x\": False, \"y\": False}  # alt., used DefaultDict', '        self.assign_variables(data, variables)', '', '        for var, cls in self._semantic_mappings.items():', '', '            # Create the mapping function', '            map_func = partial(cls.map, plotter=self)', '            setattr(self, f\"map_{var}\", map_func)', '', '            # Call the mapping function to initialize with default values', '            getattr(self, f\"map_{var}\")()']}, {'name': 'get_semantics', 'start_line': 652, 'end_line': 661, 'text': ['    def get_semantics(cls, kwargs, semantics=None):', '        \"\"\"Subset a dictionary arguments with known semantic variables.\"\"\"', '        # TODO this should be get_variables since we have included x and y', '        if semantics is None:', '            semantics = cls.semantics', '        variables = {}', '        for key, val in kwargs.items():', '            if key in semantics and val is not None:', '                variables[key] = val', '        return variables']}, {'name': 'has_xy_data', 'start_line': 664, 'end_line': 666, 'text': ['    def has_xy_data(self):', '        \"\"\"Return True at least one of x or y is defined.\"\"\"', '        return bool({\"x\", \"y\"} & set(self.variables))']}, {'name': 'var_levels', 'start_line': 669, 'end_line': 687, 'text': ['    def var_levels(self):', '        \"\"\"Property interface to ordered list of variables levels.', '', \"        Each time it's accessed, it updates the var_levels dictionary with the\", '        list of levels in the current semantic mappers. But it also allows the', '        dictionary to persist, so it can be used to set levels by a key. This is', '        used to track the list of col/row levels using an attached FacetGrid', \"        object, but it's kind of messy and ideally fixed by improving the\", '        faceting logic so it interfaces better with the modern approach to', '        tracking plot variables.', '', '        \"\"\"', '        for var in self.variables:', '            try:', '                map_obj = getattr(self, f\"_{var}_map\")', '                self._var_levels[var] = map_obj.levels', '            except AttributeError:', '                pass', '        return self._var_levels']}, {'name': 'assign_variables', 'start_line': 689, 'end_line': 715, 'text': ['    def assign_variables(self, data=None, variables={}):', '        \"\"\"Define plot variables, optionally using lookup from `data`.\"\"\"', '        x = variables.get(\"x\", None)', '        y = variables.get(\"y\", None)', '', '        if x is None and y is None:', '            self.input_format = \"wide\"', '            plot_data, variables = self._assign_variables_wideform(', '                data, **variables,', '            )', '        else:', '            self.input_format = \"long\"', '            plot_data, variables = self._assign_variables_longform(', '                data, **variables,', '            )', '', '        self.plot_data = plot_data', '        self.variables = variables', '        self.var_types = {', '            v: variable_type(', '                plot_data[v],', '                boolean_type=\"numeric\" if v in \"xy\" else \"categorical\"', '            )', '            for v in variables', '        }', '', '        return self']}, {'name': '_assign_variables_wideform', 'start_line': 717, 'end_line': 857, 'text': ['    def _assign_variables_wideform(self, data=None, **kwargs):', '        \"\"\"Define plot variables given wide-form data.', '', '        Parameters', '        ----------', '        data : flat vector or collection of vectors', '            Data can be a vector or mapping that is coerceable to a Series', '            or a sequence- or mapping-based collection of such vectors, or a', '            rectangular numpy array, or a Pandas DataFrame.', '        kwargs : variable -> data mappings', '            Behavior with keyword arguments is currently undefined.', '', '        Returns', '        -------', '        plot_data : :class:`pandas.DataFrame`', '            Long-form data object mapping seaborn variables (x, y, hue, ...)', '            to data vectors.', '        variables : dict', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '', '        \"\"\"', '        # Raise if semantic or other variables are assigned in wide-form mode', '        assigned = [k for k, v in kwargs.items() if v is not None]', '        if any(assigned):', '            s = \"s\" if len(assigned) > 1 else \"\"', '            err = f\"The following variable{s} cannot be assigned with wide-form data: \"', '            err += \", \".join(f\"`{v}`\" for v in assigned)', '            raise ValueError(err)', '', '        # Determine if the data object actually has any data in it', '        empty = data is None or not len(data)', '', '        # Then, determine if we have \"flat\" data (a single vector)', '        if isinstance(data, dict):', '            values = data.values()', '        else:', '            values = np.atleast_1d(np.asarray(data, dtype=object))', '        flat = not any(', '            isinstance(v, Iterable) and not isinstance(v, (str, bytes))', '            for v in values', '        )', '', '        if empty:', '', '            # Make an object with the structure of plot_data, but empty', '            plot_data = pd.DataFrame()', '            variables = {}', '', '        elif flat:', '', '            # Handle flat data by converting to pandas Series and using the', '            # index and/or values to define x and/or y', '            # (Could be accomplished with a more general to_series() interface)', '            flat_data = pd.Series(data).copy()', '            names = {', '                \"@values\": flat_data.name,', '                \"@index\": flat_data.index.name', '            }', '', '            plot_data = {}', '            variables = {}', '', '            for var in [\"x\", \"y\"]:', '                if var in self.flat_structure:', '                    attr = self.flat_structure[var]', '                    plot_data[var] = getattr(flat_data, attr[1:])', '                    variables[var] = names[self.flat_structure[var]]', '', '            plot_data = pd.DataFrame(plot_data)', '', '        else:', '', '            # Otherwise assume we have some collection of vectors.', '', '            # Handle Python sequences such that entries end up in the columns,', '            # not in the rows, of the intermediate wide DataFrame.', '            # One way to accomplish this is to convert to a dict of Series.', '            if isinstance(data, Sequence):', '                data_dict = {}', '                for i, var in enumerate(data):', '                    key = getattr(var, \"name\", i)', '                    # TODO is there a safer/more generic way to ensure Series?', '                    # sort of like np.asarray, but for pandas?', '                    data_dict[key] = pd.Series(var)', '', '                data = data_dict', '', '            # Pandas requires that dict values either be Series objects', '            # or all have the same length, but we want to allow \"ragged\" inputs', '            if isinstance(data, Mapping):', '                data = {key: pd.Series(val) for key, val in data.items()}', '', '            # Otherwise, delegate to the pandas DataFrame constructor', \"            # This is where we'd prefer to use a general interface that says\", '            # \"give me this data as a pandas DataFrame\", so we can accept', '            # DataFrame objects from other libraries', '            wide_data = pd.DataFrame(data, copy=True)', '', '            # At this point we should reduce the dataframe to numeric cols', '            numeric_cols = [', '                k for k, v in wide_data.items() if variable_type(v) == \"numeric\"', '            ]', '            wide_data = wide_data[numeric_cols]', '', '            # Now melt the data to long form', '            melt_kws = {\"var_name\": \"@columns\", \"value_name\": \"@values\"}', '            use_index = \"@index\" in self.wide_structure.values()', '            if use_index:', '                melt_kws[\"id_vars\"] = \"@index\"', '                try:', '                    orig_categories = wide_data.columns.categories', '                    orig_ordered = wide_data.columns.ordered', '                    wide_data.columns = wide_data.columns.add_categories(\"@index\")', '                except AttributeError:', '                    category_columns = False', '                else:', '                    category_columns = True', '                wide_data[\"@index\"] = wide_data.index.to_series()', '', '            plot_data = wide_data.melt(**melt_kws)', '', '            if use_index and category_columns:', '                plot_data[\"@columns\"] = pd.Categorical(plot_data[\"@columns\"],', '                                                       orig_categories,', '                                                       orig_ordered)', '', '            # Assign names corresponding to plot semantics', '            for var, attr in self.wide_structure.items():', '                plot_data[var] = plot_data[attr]', '', '            # Define the variable names', '            variables = {}', '            for var, attr in self.wide_structure.items():', '                obj = getattr(wide_data, attr[1:])', '                variables[var] = getattr(obj, \"name\", None)', '', '            # Remove redundant columns from plot_data', '            plot_data = plot_data[list(variables)]', '', '        return plot_data, variables']}, {'name': '_assign_variables_longform', 'start_line': 859, 'end_line': 971, 'text': ['    def _assign_variables_longform(self, data=None, **kwargs):', '        \"\"\"Define plot variables given long-form data and/or vector inputs.', '', '        Parameters', '        ----------', '        data : dict-like collection of vectors', '            Input data where variable names map to vector values.', '        kwargs : variable -> data mappings', '            Keys are seaborn variables (x, y, hue, ...) and values are vectors', '            in any format that can construct a :class:`pandas.DataFrame` or', '            names of columns or index levels in ``data``.', '', '        Returns', '        -------', '        plot_data : :class:`pandas.DataFrame`', '            Long-form data object mapping seaborn variables (x, y, hue, ...)', '            to data vectors.', '        variables : dict', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '', '        Raises', '        ------', '        ValueError', \"            When variables are strings that don't appear in ``data``.\", '', '        \"\"\"', '        plot_data = {}', '        variables = {}', '', '        # Data is optional; all variables can be defined as vectors', '        if data is None:', '            data = {}', '', '        # TODO should we try a data.to_dict() or similar here to more', '        # generally accept objects with that interface?', '        # Note that dict(df) also works for pandas, and gives us what we', '        # want, whereas DataFrame.to_dict() gives a nested dict instead of', '        # a dict of series.', '', '        # Variables can also be extracted from the index attribute', '        # TODO is this the most general way to enable it?', '        # There is no index.to_dict on multiindex, unfortunately', '        try:', '            index = data.index.to_frame()', '        except AttributeError:', '            index = {}', '', '        # The caller will determine the order of variables in plot_data', '        for key, val in kwargs.items():', '', '            # First try to treat the argument as a key for the data collection.', '            # But be flexible about what can be used as a key.', '            # Usually it will be a string, but allow numbers or tuples too when', '            # taking from the main data object. Only allow strings to reference', '            # fields in the index, because otherwise there is too much ambiguity.', '            try:', '                val_as_data_key = (', '                    val in data', '                    or (isinstance(val, (str, bytes)) and val in index)', '                )', '            except (KeyError, TypeError):', '                val_as_data_key = False', '', '            if val_as_data_key:', '', '                # We know that __getitem__ will work', '', '                if val in data:', '                    plot_data[key] = data[val]', '                elif val in index:', '                    plot_data[key] = index[val]', '                variables[key] = val', '', '            elif isinstance(val, (str, bytes)):', '', \"                # This looks like a column name but we don't know what it means!\", '', '                err = f\"Could not interpret value `{val}` for parameter `{key}`\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, assume the value is itself data', '', \"                # Raise when data object is present and a vector can't matched\", '                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):', '                    if np.ndim(val) and len(data) != len(val):', '                        val_cls = val.__class__.__name__', '                        err = (', '                            f\"Length of {val_cls} vectors must match length of `data`\"', '                            f\" when both are used, but `data` has length {len(data)}\"', '                            f\" and the vector passed to `{key}` has length {len(val)}.\"', '                        )', '                        raise ValueError(err)', '', '                plot_data[key] = val', '', '                # Try to infer the name of the variable', '                variables[key] = getattr(val, \"name\", None)', '', '        # Construct a tidy plot DataFrame. This will convert a number of', '        # types automatically, aligning on index in case of pandas objects', '        plot_data = pd.DataFrame(plot_data)', '', '        # Reduce the variables dictionary to fields with valid data', '        variables = {', '            var: name', '            for var, name in variables.items()', '            if plot_data[var].notnull().any()', '        }', '', '        return plot_data, variables']}, {'name': 'iter_data', 'start_line': 973, 'end_line': 1092, 'text': ['    def iter_data(', '        self, grouping_vars=None, *,', '        reverse=False, from_comp_data=False,', '        by_facet=True, allow_empty=False, dropna=True,', '    ):', '        \"\"\"Generator for getting subsets of data defined by semantic variables.', '', '        Also injects \"col\" and \"row\" into grouping semantics.', '', '        Parameters', '        ----------', '        grouping_vars : string or list of strings', '            Semantic variables that define the subsets of data.', '        reverse : bool', '            If True, reverse the order of iteration.', '        from_comp_data : bool', '            If True, use self.comp_data rather than self.plot_data', '        by_facet : bool', '            If True, add faceting variables to the set of grouping variables.', '        allow_empty : bool', '            If True, yield an empty dataframe when no observations exist for', '            combinations of grouping variables.', '        dropna : bool', '            If True, remove rows with missing data.', '', '        Yields', '        ------', '        sub_vars : dict', '            Keys are semantic names, values are the level of that semantic.', '        sub_data : :class:`pandas.DataFrame`', '            Subset of ``plot_data`` for this combination of semantic values.', '', '        \"\"\"', '        # TODO should this default to using all (non x/y?) semantics?', '        # or define grouping vars somewhere?', '        if grouping_vars is None:', '            grouping_vars = []', '        elif isinstance(grouping_vars, str):', '            grouping_vars = [grouping_vars]', '        elif isinstance(grouping_vars, tuple):', '            grouping_vars = list(grouping_vars)', '', '        # Always insert faceting variables', '        if by_facet:', '            facet_vars = {\"col\", \"row\"}', '            grouping_vars.extend(', '                facet_vars & set(self.variables) - set(grouping_vars)', '            )', '', '        # Reduce to the semantics used in this plot', '        grouping_vars = [', '            var for var in grouping_vars if var in self.variables', '        ]', '', '        if from_comp_data:', '            data = self.comp_data', '        else:', '            data = self.plot_data', '', '        if dropna:', '            data = data.dropna()', '', '        levels = self.var_levels.copy()', '        if from_comp_data:', '            for axis in {\"x\", \"y\"} & set(grouping_vars):', '                if self.var_types[axis] == \"categorical\":', '                    if self._var_ordered[axis]:', '                        # If the axis is ordered, then the axes in a possible', '                        # facet grid are by definition \"shared\", or there is a', '                        # single axis with a unique cat -> idx mapping.', '                        # So we can just take the first converter object.', '                        converter = self.converters[axis].iloc[0]', '                        levels[axis] = converter.convert_units(levels[axis])', '                    else:', '                        # Otherwise, the mappings may not be unique, but we can', '                        # use the unique set of index values in comp_data.', '                        levels[axis] = np.sort(data[axis].unique())', '                elif self.var_types[axis] == \"datetime\":', '                    levels[axis] = mpl.dates.date2num(levels[axis])', '                elif self.var_types[axis] == \"numeric\" and self._log_scaled(axis):', '                    levels[axis] = np.log10(levels[axis])', '', '        if grouping_vars:', '', '            grouped_data = data.groupby(', '                grouping_vars, sort=False, as_index=False', '            )', '', '            grouping_keys = []', '            for var in grouping_vars:', '                grouping_keys.append(levels.get(var, []))', '', '            iter_keys = itertools.product(*grouping_keys)', '            if reverse:', '                iter_keys = reversed(list(iter_keys))', '', '            for key in iter_keys:', '', '                # Pandas fails with singleton tuple inputs', '                pd_key = key[0] if len(key) == 1 else key', '', '                try:', '                    data_subset = grouped_data.get_group(pd_key)', '                except KeyError:', '                    # XXX we are adding this to allow backwards compatibility', '                    # with the empty artists that old categorical plots would', '                    # add (before 0.12), which we may decide to break, in which', '                    # case this option could be removed', '                    data_subset = data.loc[[]]', '', '                if data_subset.empty and not allow_empty:', '                    continue', '', '                sub_vars = dict(zip(grouping_vars, key))', '', '                yield sub_vars, data_subset.copy()', '', '        else:', '', '            yield {}, data.copy()']}, {'name': 'comp_data', 'start_line': 1095, 'end_line': 1138, 'text': ['    def comp_data(self):', '        \"\"\"Dataframe with numeric x and y, after unit conversion and log scaling.\"\"\"', '        if not hasattr(self, \"ax\"):', '            # Probably a good idea, but will need a bunch of tests updated', '            # Most of these tests should just use the external interface', '            # Then this can be re-enabled.', '            # raise AttributeError(\"No Axes attached to plotter\")', '            return self.plot_data', '', '        if not hasattr(self, \"_comp_data\"):', '', '            comp_data = (', '                self.plot_data', '                .copy(deep=False)', '                .drop([\"x\", \"y\"], axis=1, errors=\"ignore\")', '            )', '', '            for var in \"yx\":', '                if var not in self.variables:', '                    continue', '', '                parts = []', '                grouped = self.plot_data[var].groupby(self.converters[var], sort=False)', '                for converter, orig in grouped:', \"                    with pd.option_context('mode.use_inf_as_null', True):\", '                        orig = orig.dropna()', '                        if var in self.var_levels:', '                            # TODO this should happen in some centralized location', '                            # it is similar to GH2419, but more complicated because', '                            # supporting `order` in categorical plots is tricky', '                            orig = orig[orig.isin(self.var_levels[var])]', '                    comp = pd.to_numeric(converter.convert_units(orig))', '                    if converter.get_scale() == \"log\":', '                        comp = np.log10(comp)', '                    parts.append(pd.Series(comp, orig.index, name=orig.name))', '                if parts:', '                    comp_col = pd.concat(parts)', '                else:', '                    comp_col = pd.Series(dtype=float, name=var)', '                comp_data.insert(0, var, comp_col)', '', '            self._comp_data = comp_data', '', '        return self._comp_data']}, {'name': '_get_axes', 'start_line': 1140, 'end_line': 1153, 'text': ['    def _get_axes(self, sub_vars):', '        \"\"\"Return an Axes object based on existence of row/col variables.\"\"\"', '        row = sub_vars.get(\"row\", None)', '        col = sub_vars.get(\"col\", None)', '        if row is not None and col is not None:', '            return self.facets.axes_dict[(row, col)]', '        elif row is not None:', '            return self.facets.axes_dict[row]', '        elif col is not None:', '            return self.facets.axes_dict[col]', '        elif self.ax is None:', '            return self.facets.ax', '        else:', '            return self.ax']}, {'name': '_attach', 'start_line': 1155, 'end_line': 1297, 'text': ['    def _attach(', '        self,', '        obj,', '        allowed_types=None,', '        log_scale=None,', '    ):', '        \"\"\"Associate the plotter with an Axes manager and initialize its units.', '', '        Parameters', '        ----------', \"        obj : :class:`matplotlib.axes.Axes` or :class:'FacetGrid`\", '            Structural object that we will eventually plot onto.', '        allowed_types : str or list of str', '            If provided, raise when either the x or y variable does not have', '            one of the declared seaborn types.', '        log_scale : bool, number, or pair of bools or numbers', '            If not False, set the axes to use log scaling, with the given', '            base or defaulting to 10. If a tuple, interpreted as separate', '            arguments for the x and y axes.', '', '        \"\"\"', '        from .axisgrid import FacetGrid', '        if isinstance(obj, FacetGrid):', '            self.ax = None', '            self.facets = obj', '            ax_list = obj.axes.flatten()', '            if obj.col_names is not None:', '                self.var_levels[\"col\"] = obj.col_names', '            if obj.row_names is not None:', '                self.var_levels[\"row\"] = obj.row_names', '        else:', '            self.ax = obj', '            self.facets = None', '            ax_list = [obj]', '', '        # Identify which \"axis\" variables we have defined', '        axis_variables = set(\"xy\").intersection(self.variables)', '', '        # -- Verify the types of our x and y variables here.', \"        # This doesn't really make complete sense being here here, but it's a fine\", '        # place for it, given  the current system.', '        # (Note that for some plots, there might be more complicated restrictions)', '        # e.g. the categorical plots have their own check that as specific to the', '        # non-categorical axis.', '        if allowed_types is None:', '            allowed_types = [\"numeric\", \"datetime\", \"categorical\"]', '        elif isinstance(allowed_types, str):', '            allowed_types = [allowed_types]', '', '        for var in axis_variables:', '            var_type = self.var_types[var]', '            if var_type not in allowed_types:', '                err = (', '                    f\"The {var} variable is {var_type}, but one of \"', '                    f\"{allowed_types} is required\"', '                )', '                raise TypeError(err)', '', '        # -- Get axis objects for each row in plot_data for type conversions and scaling', '', '        facet_dim = {\"x\": \"col\", \"y\": \"row\"}', '', '        self.converters = {}', '        for var in axis_variables:', '            other_var = {\"x\": \"y\", \"y\": \"x\"}[var]', '', '            converter = pd.Series(index=self.plot_data.index, name=var, dtype=object)', '            share_state = getattr(self.facets, f\"_share{var}\", True)', '', '            # Simplest cases are that we have a single axes, all axes are shared,', '            # or sharing is only on the orthogonal facet dimension. In these cases,', '            # all datapoints get converted the same way, so use the first axis', '            if share_state is True or share_state == facet_dim[other_var]:', '                converter.loc[:] = getattr(ax_list[0], f\"{var}axis\")', '', '            else:', '', '                # Next simplest case is when no axes are shared, and we can', '                # use the axis objects within each facet', '                if share_state is False:', '                    for axes_vars, axes_data in self.iter_data():', '                        ax = self._get_axes(axes_vars)', '                        converter.loc[axes_data.index] = getattr(ax, f\"{var}axis\")', '', '                # In the more complicated case, the axes are shared within each', '                # \"file\" of the facetgrid. In that case, we need to subset the data', '                # for that file and assign it the first axis in the slice of the grid', '                else:', '', '                    names = getattr(self.facets, f\"{share_state}_names\")', '                    for i, level in enumerate(names):', '                        idx = (i, 0) if share_state == \"row\" else (0, i)', '                        axis = getattr(self.facets.axes[idx], f\"{var}axis\")', '                        converter.loc[self.plot_data[share_state] == level] = axis', '', '            # Store the converter vector, which we use elsewhere (e.g comp_data)', '            self.converters[var] = converter', '', '            # Now actually update the matplotlib objects to do the conversion we want', '            grouped = self.plot_data[var].groupby(self.converters[var], sort=False)', '            for converter, seed_data in grouped:', '                if self.var_types[var] == \"categorical\":', '                    if self._var_ordered[var]:', '                        order = self.var_levels[var]', '                    else:', '                        order = None', '                    seed_data = categorical_order(seed_data, order)', '                converter.update_units(seed_data)', '', '        # -- Set numerical axis scales', '', '        # First unpack the log_scale argument', '        if log_scale is None:', '            scalex = scaley = False', '        else:', '            # Allow single value or x, y tuple', '            try:', '                scalex, scaley = log_scale', '            except TypeError:', '                scalex = log_scale if \"x\" in self.variables else False', '                scaley = log_scale if \"y\" in self.variables else False', '', '        # Now use it', '        for axis, scale in zip(\"xy\", (scalex, scaley)):', '            if scale:', '                for ax in ax_list:', '                    set_scale = getattr(ax, f\"set_{axis}scale\")', '                    if scale is True:', '                        set_scale(\"log\")', '                    else:', '                        if Version(mpl.__version__) >= Version(\"3.3\"):', '                            set_scale(\"log\", base=scale)', '                        else:', '                            set_scale(\"log\", **{f\"base{axis}\": scale})', '', '        # For categorical y, we want the \"first\" level to be at the top of the axis', '        if self.var_types.get(\"y\", None) == \"categorical\":', '            for ax in ax_list:', '                try:', '                    ax.yaxis.set_inverted(True)', '                except AttributeError:  # mpl < 3.1', '                    if not ax.yaxis_inverted():', '                        ax.invert_yaxis()']}, {'name': '_log_scaled', 'start_line': 1301, 'end_line': 1319, 'text': ['    def _log_scaled(self, axis):', '        \"\"\"Return True if specified axis is log scaled on all attached axes.\"\"\"', '        if not hasattr(self, \"ax\"):', '            return False', '', '        if self.ax is None:', '            axes_list = self.facets.axes.flatten()', '        else:', '            axes_list = [self.ax]', '', '        log_scaled = []', '        for ax in axes_list:', '            data_axis = getattr(ax, f\"{axis}axis\")', '            log_scaled.append(data_axis.get_scale() == \"log\")', '', '        if any(log_scaled) and not all(log_scaled):', '            raise RuntimeError(\"Axis scaling is not consistent\")', '', '        return any(log_scaled)']}, {'name': '_add_axis_labels', 'start_line': 1321, 'end_line': 1332, 'text': ['    def _add_axis_labels(self, ax, default_x=\"\", default_y=\"\"):', '        \"\"\"Add axis labels if not present, set visibility to match ticklabels.\"\"\"', '        # TODO ax could default to None and use attached axes if present', \"        # but what to do about the case of facets? Currently using FacetGrid's\", \"        # set_axis_labels method, which doesn't add labels to the interior even\", '        # when the axes are not shared. Maybe that makes sense?', '        if not ax.get_xlabel():', '            x_visible = any(t.get_visible() for t in ax.get_xticklabels())', '            ax.set_xlabel(self.variables.get(\"x\", default_x), visible=x_visible)', '        if not ax.get_ylabel():', '            y_visible = any(t.get_visible() for t in ax.get_yticklabels())', '            ax.set_ylabel(self.variables.get(\"y\", default_y), visible=y_visible)']}, {'name': 'scale_native', 'start_line': 1339, 'end_line': 1343, 'text': ['    def scale_native(self, axis, *args, **kwargs):', '', '        # Default, defer to matplotlib', '', '        raise NotImplementedError']}, {'name': 'scale_numeric', 'start_line': 1345, 'end_line': 1350, 'text': ['    def scale_numeric(self, axis, *args, **kwargs):', '', '        # Feels needed to completeness, what should it do?', '        # Perhaps handle log scaling? Set the ticker/formatter/limits?', '', '        raise NotImplementedError']}, {'name': 'scale_datetime', 'start_line': 1352, 'end_line': 1357, 'text': ['    def scale_datetime(self, axis, *args, **kwargs):', '', '        # Use pd.to_datetime to convert strings or numbers to datetime objects', '        # Note, use day-resolution for numeric->datetime to match matplotlib', '', '        raise NotImplementedError']}, {'name': 'scale_categorical', 'start_line': 1359, 'end_line': 1450, 'text': ['    def scale_categorical(self, axis, order=None, formatter=None):', '        \"\"\"', '        Enforce categorical (fixed-scale) rules for the data on given axis.', '', '        Parameters', '        ----------', '        axis : \"x\" or \"y\"', '            Axis of the plot to operate on.', '        order : list', '            Order that unique values should appear in.', '        formatter : callable', '            Function mapping values to a string representation.', '', '        Returns', '        -------', '        self', '', '        \"\"\"', '        # This method both modifies the internal representation of the data', '        # (converting it to string) and sets some attributes on self. It might be', '        # a good idea to have a separate object attached to self that contains the', '        # information in those attributes (i.e. whether to enforce variable order', '        # across facets, the order to use) similar to the SemanticMapping objects', '        # we have for semantic variables. That object could also hold the converter', '        # objects that get used, if we can decouple those from an existing axis', '        # (cf. https://github.com/matplotlib/matplotlib/issues/19229).', '        # There are some interactions with faceting information that would need', '        # to be thought through, since the converts to use depend on facets.', '        # If we go that route, these methods could become \"borrowed\" methods similar', '        # to what happens with the alternate semantic mapper constructors, although', '        # that approach is kind of fussy and confusing.', '', '        # TODO this method could also set the grid state? Since we like to have no', \"        # grid on the categorical axis by default. Again, a case where we'll need to\", '        # store information until we use it, so best to have a way to collect the', '        # attributes that this method sets.', '', '        # TODO if we are going to set visual properties of the axes with these methods,', '        # then we could do the steps currently in CategoricalPlotter._adjust_cat_axis', '', '        # TODO another, and distinct idea, is to expose a cut= param here', '', '        _check_argument(\"axis\", [\"x\", \"y\"], axis)', '', '        # Categorical plots can be \"univariate\" in which case they get an anonymous', '        # category label on the opposite axis.', '        if axis not in self.variables:', '            self.variables[axis] = None', '            self.var_types[axis] = \"categorical\"', '            self.plot_data[axis] = \"\"', '', '        # If the \"categorical\" variable has a numeric type, sort the rows so that', '        # the default result from categorical_order has those values sorted after', '        # they have been coerced to strings. The reason for this is so that later', '        # we can get facet-wise orders that are correct.', '        # XXX Should this also sort datetimes?', '        # It feels more consistent, but technically will be a default change', '        # If so, should also change categorical_order to behave that way', '        if self.var_types[axis] == \"numeric\":', '            self.plot_data = self.plot_data.sort_values(axis, kind=\"mergesort\")', '', '        # Now get a reference to the categorical data vector', '        cat_data = self.plot_data[axis]', '', '        # Get the initial categorical order, which we do before string', '        # conversion to respect the original types of the order list.', '        # Track whether the order is given explicitly so that we can know', '        # whether or not to use the order constructed here downstream', '        self._var_ordered[axis] = order is not None or cat_data.dtype.name == \"category\"', '        order = pd.Index(categorical_order(cat_data, order))', '', '        # Then convert data to strings. This is because in matplotlib,', '        # \"categorical\" data really mean \"string\" data, so doing this artists', '        # will be drawn on the categorical axis with a fixed scale.', '        # TODO implement formatter here; check that it returns strings?', '        if formatter is not None:', '            cat_data = cat_data.map(formatter)', '            order = order.map(formatter)', '        else:', '            cat_data = cat_data.astype(str)', '            order = order.astype(str)', '', '        # Update the levels list with the type-converted order variable', '        self.var_levels[axis] = order', '', '        # Now ensure that seaborn will use categorical rules internally', '        self.var_types[axis] = \"categorical\"', '', '        # Put the string-typed categorical vector back into the plot_data structure', '        self.plot_data[axis] = cat_data', '', '        return self']}]}, {'name': 'VariableType', 'start_line': 1453, 'end_line': 1470, 'text': ['class VariableType(UserString):', '    \"\"\"', '    Prevent comparisons elsewhere in the library from using the wrong name.', '', '    Errors are simple assertions because users should not be able to trigger', '    them. If that changes, they should be more verbose.', '', '    \"\"\"', '    # TODO we can replace this with typing.Literal on Python 3.8+', '    allowed = \"numeric\", \"datetime\", \"categorical\"', '', '    def __init__(self, data):', '        assert data in self.allowed, data', '        super().__init__(data)', '', '    def __eq__(self, other):', '        assert other in self.allowed, other', '        return self.data == other'], 'methods': [{'name': '__init__', 'start_line': 1464, 'end_line': 1466, 'text': ['    def __init__(self, data):', '        assert data in self.allowed, data', '        super().__init__(data)']}, {'name': '__eq__', 'start_line': 1468, 'end_line': 1470, 'text': ['    def __eq__(self, other):', '        assert other in self.allowed, other', '        return self.data == other']}]}], 'functions': [{'name': 'variable_type', 'start_line': 1473, 'end_line': 1553, 'text': ['def variable_type(vector, boolean_type=\"numeric\"):', '    \"\"\"', '    Determine whether a vector contains numeric, categorical, or datetime data.', '', '    This function differs from the pandas typing API in two ways:', '', '    - Python sequences or object-typed PyData objects are considered numeric if', '      all of their entries are numeric.', '    - String or mixed-type data are considered categorical even if not', '      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.', '', '    Parameters', '    ----------', '    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence', '        Input data to test.', \"    boolean_type : 'numeric' or 'categorical'\", '        Type to use for vectors containing only 0s and 1s (and NAs).', '', '    Returns', '    -------', \"    var_type : 'numeric', 'categorical', or 'datetime'\", '        Name identifying the type of data in the vector.', '    \"\"\"', '', '    # If a categorical dtype is set, infer categorical', '    if pd.api.types.is_categorical_dtype(vector):', '        return VariableType(\"categorical\")', '', '    # Special-case all-na data, which is always \"numeric\"', '    if pd.isna(vector).all():', '        return VariableType(\"numeric\")', '', '    # Special-case binary/boolean data, allow caller to determine', '    # This triggers a numpy warning when vector has strings/objects', '    # https://github.com/numpy/numpy/issues/6784', '    # Because we reduce with .all(), we are agnostic about whether the', '    # comparison returns a scalar or vector, so we will ignore the warning.', '    # It triggers a separate DeprecationWarning when the vector has datetimes:', '    # https://github.com/numpy/numpy/issues/13548', '    # This is considered a bug by numpy and will likely go away.', '    with warnings.catch_warnings():', '        warnings.simplefilter(', \"            action='ignore', category=(FutureWarning, DeprecationWarning)\", '        )', '        if np.isin(vector, [0, 1, np.nan]).all():', '            return VariableType(boolean_type)', '', '    # Defer to positive pandas tests', '    if pd.api.types.is_numeric_dtype(vector):', '        return VariableType(\"numeric\")', '', '    if pd.api.types.is_datetime64_dtype(vector):', '        return VariableType(\"datetime\")', '', '    # --- If we get to here, we need to check the entries', '', '    # Check for a collection where everything is a number', '', '    def all_numeric(x):', '        for x_i in x:', '            if not isinstance(x_i, Number):', '                return False', '        return True', '', '    if all_numeric(vector):', '        return VariableType(\"numeric\")', '', '    # Check for a collection where everything is a datetime', '', '    def all_datetime(x):', '        for x_i in x:', '            if not isinstance(x_i, (datetime, np.datetime64)):', '                return False', '        return True', '', '    if all_datetime(vector):', '        return VariableType(\"datetime\")', '', '    # Otherwise, our final fallback is to consider things categorical', '', '    return VariableType(\"categorical\")']}, {'name': 'infer_orient', 'start_line': 1556, 'end_line': 1635, 'text': ['def infer_orient(x=None, y=None, orient=None, require_numeric=True):', '    \"\"\"Determine how the plot should be oriented based on the data.', '', '    For historical reasons, the convention is to call a plot \"horizontally\"', '    or \"vertically\" oriented based on the axis representing its dependent', '    variable. Practically, this is used when determining the axis for', '    numerical aggregation.', '', '    Parameters', '    ----------', '    x, y : Vector data or None', '        Positional data vectors for the plot.', '    orient : string or None', '        Specified orientation, which must start with \"v\" or \"h\" if not None.', '    require_numeric : bool', '        If set, raise when the implied dependent variable is not numeric.', '', '    Returns', '    -------', '    orient : \"v\" or \"h\"', '', '    Raises', '    ------', '    ValueError: When `orient` is not None and does not start with \"h\" or \"v\"', '    TypeError: When dependent variable is not numeric, with `require_numeric`', '', '    \"\"\"', '', '    x_type = None if x is None else variable_type(x)', '    y_type = None if y is None else variable_type(y)', '', '    nonnumeric_dv_error = \"{} orientation requires numeric `{}` variable.\"', '    single_var_warning = \"{} orientation ignored with only `{}` specified.\"', '', '    if x is None:', '        if str(orient).startswith(\"h\"):', '            warnings.warn(single_var_warning.format(\"Horizontal\", \"y\"))', '        if require_numeric and y_type != \"numeric\":', '            raise TypeError(nonnumeric_dv_error.format(\"Vertical\", \"y\"))', '        return \"v\"', '', '    elif y is None:', '        if str(orient).startswith(\"v\"):', '            warnings.warn(single_var_warning.format(\"Vertical\", \"x\"))', '        if require_numeric and x_type != \"numeric\":', '            raise TypeError(nonnumeric_dv_error.format(\"Horizontal\", \"x\"))', '        return \"h\"', '', '    elif str(orient).startswith(\"v\"):', '        if require_numeric and y_type != \"numeric\":', '            raise TypeError(nonnumeric_dv_error.format(\"Vertical\", \"y\"))', '        return \"v\"', '', '    elif str(orient).startswith(\"h\"):', '        if require_numeric and x_type != \"numeric\":', '            raise TypeError(nonnumeric_dv_error.format(\"Horizontal\", \"x\"))', '        return \"h\"', '', '    elif orient is not None:', '        err = (', '            \"`orient` must start with \\'v\\' or \\'h\\' or be None, \"', '            f\"but `{repr(orient)}` was passed.\"', '        )', '        raise ValueError(err)', '', '    elif x_type != \"categorical\" and y_type == \"categorical\":', '        return \"h\"', '', '    elif x_type != \"numeric\" and y_type == \"numeric\":', '        return \"v\"', '', '    elif x_type == \"numeric\" and y_type != \"numeric\":', '        return \"h\"', '', '    elif require_numeric and \"numeric\" not in (x_type, y_type):', '        err = \"Neither the `x` nor `y` variable appears to be numeric.\"', '        raise TypeError(err)', '', '    else:', '        return \"v\"']}, {'name': 'unique_dashes', 'start_line': 1638, 'end_line': 1686, 'text': ['def unique_dashes(n):', '    \"\"\"Build an arbitrarily long list of unique dash styles for lines.', '', '    Parameters', '    ----------', '    n : int', '        Number of unique dash specs to generate.', '', '    Returns', '    -------', '    dashes : list of strings or tuples', '        Valid arguments for the ``dashes`` parameter on', '        :class:`matplotlib.lines.Line2D`. The first spec is a solid', '        line (``\"\"``), the remainder are sequences of long and short', '        dashes.', '', '    \"\"\"', '    # Start with dash specs that are well distinguishable', '    dashes = [', '        \"\",', '        (4, 1.5),', '        (1, 1),', '        (3, 1.25, 1.5, 1.25),', '        (5, 1, 1, 1),', '    ]', '', '    # Now programmatically build as many as we need', '    p = 3', '    while len(dashes) < n:', '', '        # Take combinations of long and short dashes', '        a = itertools.combinations_with_replacement([3, 1.25], p)', '        b = itertools.combinations_with_replacement([4, 1], p)', '', '        # Interleave the combinations, reversing one of the streams', '        segment_list = itertools.chain(*zip(', '            list(a)[1:-1][::-1],', '            list(b)[1:-1]', '        ))', '', '        # Now insert the gaps', '        for segments in segment_list:', '            gap = min(segments)', '            spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))', '            dashes.append(spec)', '', '        p += 1', '', '    return dashes[:n]']}, {'name': 'unique_markers', 'start_line': 1689, 'end_line': 1732, 'text': ['def unique_markers(n):', '    \"\"\"Build an arbitrarily long list of unique marker styles for points.', '', '    Parameters', '    ----------', '    n : int', '        Number of unique marker specs to generate.', '', '    Returns', '    -------', '    markers : list of string or tuples', '        Values for defining :class:`matplotlib.markers.MarkerStyle` objects.', '        All markers will be filled.', '', '    \"\"\"', '    # Start with marker specs that are well distinguishable', '    markers = [', '        \"o\",', '        \"X\",', '        (4, 0, 45),', '        \"P\",', '        (4, 0, 0),', '        (4, 1, 0),', '        \"^\",', '        (4, 1, 45),', '        \"v\",', '    ]', '', '    # Now generate more from regular polygons of increasing order', '    s = 5', '    while len(markers) < n:', '        a = 360 / (s + 1) / 2', '        markers.extend([', '            (s + 1, 1, a),', '            (s + 1, 0, a),', '            (s, 1, 0),', '            (s, 0, 0),', '        ])', '        s += 1', '', '    # Convert to MarkerStyle object, using only exactly what we need', '    # markers = [mpl.markers.MarkerStyle(m) for m in markers[:n]]', '', '    return markers[:n]']}, {'name': 'categorical_order', 'start_line': 1735, 'end_line': 1771, 'text': ['def categorical_order(vector, order=None):', '    \"\"\"Return a list of unique data values.', '', '    Determine an ordered list of levels in ``values``.', '', '    Parameters', '    ----------', '    vector : list, array, Categorical, or Series', '        Vector of \"categorical\" values', '    order : list-like, optional', '        Desired order of category levels to override the order determined', '        from the ``values`` object.', '', '    Returns', '    -------', '    order : list', '        Ordered list of category levels not including null values.', '', '    \"\"\"', '    if order is None:', '        if hasattr(vector, \"categories\"):', '            order = vector.categories', '        else:', '            try:', '                order = vector.cat.categories', '            except (TypeError, AttributeError):', '', '                try:', '                    order = vector.unique()', '                except AttributeError:', '                    order = pd.unique(vector)', '', '                if variable_type(vector) == \"numeric\":', '                    order = np.sort(order)', '', '        order = filter(pd.notnull, order)', '    return list(order)']}, {'name': 'all_numeric', 'start_line': 1531, 'end_line': 1535, 'text': ['    def all_numeric(x):', '        for x_i in x:', '            if not isinstance(x_i, Number):', '                return False', '        return True']}, {'name': 'all_datetime', 'start_line': 1542, 'end_line': 1546, 'text': ['    def all_datetime(x):', '        for x_i in x:', '            if not isinstance(x_i, (datetime, np.datetime64)):', '                return False', '        return True']}], 'text': ['import warnings', 'import itertools', 'from copy import copy', 'from functools import partial', 'from collections import UserString', 'from collections.abc import Iterable, Sequence, Mapping', 'from numbers import Number', 'from datetime import datetime', '', 'import numpy as np', 'import pandas as pd', 'import matplotlib as mpl', '', 'from ._decorators import (', '    share_init_params_with_map,', ')', 'from .external.version import Version', 'from .palettes import (', '    QUAL_PALETTES,', '    color_palette,', ')', 'from .utils import (', '    _check_argument,', '    get_color_cycle,', '    remove_na,', ')', '', '', 'class SemanticMapping:', '    \"\"\"Base class for mapping data values to plot attributes.\"\"\"', '', '    # -- Default attributes that all SemanticMapping subclasses must set', '', '    # Whether the mapping is numeric, categorical, or datetime', '    map_type = None', '', '    # Ordered list of unique values in the input data', '    levels = None', '', '    # A mapping from the data values to corresponding plot attributes', '    lookup_table = None', '', '    def __init__(self, plotter):', '', '        # TODO Putting this here so we can continue to use a lot of the', \"        # logic that's built into the library, but the idea of this class\", '        # is to move towards semantic mappings that are agnostic about the', \"        # kind of plot they're going to be used to draw.\", '        # Fully achieving that is going to take some thinking.', '        self.plotter = plotter', '', '    def map(cls, plotter, *args, **kwargs):', '        # This method is assigned the __init__ docstring', '        method_name = f\"_{cls.__name__[:-7].lower()}_map\"', '        setattr(plotter, method_name, cls(plotter, *args, **kwargs))', '        return plotter', '', '    def _check_list_length(self, levels, values, variable):', '        \"\"\"Input check when values are provided as a list.\"\"\"', '        # Copied from _core/properties; eventually will be replaced for that.', '        message = \"\"', '        if len(levels) > len(values):', '            message = \" \".join([', '                f\"\\\\nThe {variable} list has fewer values ({len(values)})\",', '                f\"than needed ({len(levels)}) and will cycle, which may\",', '                \"produce an uninterpretable plot.\"', '            ])', '            values = [x for _, x in zip(levels, itertools.cycle(values))]', '', '        elif len(values) > len(levels):', '            message = \" \".join([', '                f\"The {variable} list has more values ({len(values)})\",', '                f\"than needed ({len(levels)}), which may not be intended.\",', '            ])', '            values = values[:len(levels)]', '', '        if message:', '            warnings.warn(message, UserWarning, stacklevel=6)', '', '        return values', '', '    def _lookup_single(self, key):', '        \"\"\"Apply the mapping to a single data value.\"\"\"', '        return self.lookup_table[key]', '', '    def __call__(self, key, *args, **kwargs):', '        \"\"\"Get the attribute(s) values for the data key.\"\"\"', '        if isinstance(key, (list, np.ndarray, pd.Series)):', '            return [self._lookup_single(k, *args, **kwargs) for k in key]', '        else:', '            return self._lookup_single(key, *args, **kwargs)', '', '', '@share_init_params_with_map', 'class HueMapping(SemanticMapping):', '    \"\"\"Mapping that sets artist colors according to data values.\"\"\"', '    # A specification of the colors that should appear in the plot', '    palette = None', '', '    # An object that normalizes data values to [0, 1] range for color mapping', '    norm = None', '', '    # A continuous colormap object for interpolating in a numeric context', '    cmap = None', '', '    def __init__(', '        self, plotter, palette=None, order=None, norm=None,', '    ):', '        \"\"\"Map the levels of the `hue` variable to distinct colors.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"hue\", pd.Series(dtype=float))', '', '        if data.isna().all():', '            if palette is not None:', '                msg = \"Ignoring `palette` because no `hue` variable has been assigned.\"', '                warnings.warn(msg, stacklevel=4)', '        else:', '', '            map_type = self.infer_map_type(', '                palette, norm, plotter.input_format, plotter.var_types[\"hue\"]', '            )', '', '            # Our goal is to end up with a dictionary mapping every unique', '            # value in `data` to a color. We will also keep track of the', '            # metadata about this mapping we will need for, e.g., a legend', '', '            # --- Option 1: numeric mapping with a matplotlib colormap', '', '            if map_type == \"numeric\":', '', '                data = pd.to_numeric(data)', '                levels, lookup_table, norm, cmap = self.numeric_mapping(', '                    data, palette, norm,', '                )', '', '            # --- Option 2: categorical mapping using seaborn palette', '', '            elif map_type == \"categorical\":', '', '                cmap = norm = None', '                levels, lookup_table = self.categorical_mapping(', '                    data, palette, order,', '                )', '', '            # --- Option 3: datetime mapping', '', '            else:', '                # TODO this needs actual implementation', '                cmap = norm = None', '                levels, lookup_table = self.categorical_mapping(', '                    # Casting data to list to handle differences in the way', '                    # pandas and numpy represent datetime64 data', '                    list(data), palette, order,', '                )', '', '            self.map_type = map_type', '            self.lookup_table = lookup_table', '            self.palette = palette', '            self.levels = levels', '            self.norm = norm', '            self.cmap = cmap', '', '    def _lookup_single(self, key):', '        \"\"\"Get the color for a single value, using colormap to interpolate.\"\"\"', '        try:', \"            # Use a value that's in the original data vector\", '            value = self.lookup_table[key]', '        except KeyError:', '', '            if self.norm is None:', '                # Currently we only get here in scatterplot with hue_order,', '                # because scatterplot does not consider hue a grouping variable', '                # So unused hue levels are in the data, but not the lookup table', '                return (0, 0, 0, 0)', '', '            # Use the colormap to interpolate between existing datapoints', '            # (e.g. in the context of making a continuous legend)', '            try:', '                normed = self.norm(key)', '            except TypeError as err:', '                if np.isnan(key):', '                    value = (0, 0, 0, 0)', '                else:', '                    raise err', '            else:', '                if np.ma.is_masked(normed):', '                    normed = np.nan', '                value = self.cmap(normed)', '        return value', '', '    def infer_map_type(self, palette, norm, input_format, var_type):', '        \"\"\"Determine how to implement the mapping.\"\"\"', '        if palette in QUAL_PALETTES:', '            map_type = \"categorical\"', '        elif norm is not None:', '            map_type = \"numeric\"', '        elif isinstance(palette, (dict, list)):', '            map_type = \"categorical\"', '        elif input_format == \"wide\":', '            map_type = \"categorical\"', '        else:', '            map_type = var_type', '', '        return map_type', '', '    def categorical_mapping(self, data, palette, order):', '        \"\"\"Determine colors when the hue mapping is categorical.\"\"\"', '        # -- Identify the order and name of the levels', '', '        levels = categorical_order(data, order)', '        n_colors = len(levels)', '', '        # -- Identify the set of colors to use', '', '        if isinstance(palette, dict):', '', '            missing = set(levels) - set(palette)', '            if any(missing):', '                err = \"The palette dictionary is missing keys: {}\"', '                raise ValueError(err.format(missing))', '', '            lookup_table = palette', '', '        else:', '', '            if palette is None:', '                if n_colors <= len(get_color_cycle()):', '                    colors = color_palette(None, n_colors)', '                else:', '                    colors = color_palette(\"husl\", n_colors)', '            elif isinstance(palette, list):', '                colors = self._check_list_length(levels, palette, \"palette\")', '            else:', '                colors = color_palette(palette, n_colors)', '', '            lookup_table = dict(zip(levels, colors))', '', '        return levels, lookup_table', '', '    def numeric_mapping(self, data, palette, norm):', '        \"\"\"Determine colors when the hue variable is quantitative.\"\"\"', '        if isinstance(palette, dict):', '', '            # The presence of a norm object overrides a dictionary of hues', '            # in specifying a numeric mapping, so we need to process it here.', '            levels = list(sorted(palette))', '            colors = [palette[k] for k in sorted(palette)]', '            cmap = mpl.colors.ListedColormap(colors)', '            lookup_table = palette.copy()', '', '        else:', '', '            # The levels are the sorted unique values in the data', '            levels = list(np.sort(remove_na(data.unique())))', '', '            # --- Sort out the colormap to use from the palette argument', '', '            # Default numeric palette is our default cubehelix palette', '            # TODO do we want to do something complicated to ensure contrast?', '            palette = \"ch:\" if palette is None else palette', '', '            if isinstance(palette, mpl.colors.Colormap):', '                cmap = palette', '            else:', '                cmap = color_palette(palette, as_cmap=True)', '', '            # Now sort out the data normalization', '            if norm is None:', '                norm = mpl.colors.Normalize()', '            elif isinstance(norm, tuple):', '                norm = mpl.colors.Normalize(*norm)', '            elif not isinstance(norm, mpl.colors.Normalize):', '                err = \"``hue_norm`` must be None, tuple, or Normalize object.\"', '                raise ValueError(err)', '', '            if not norm.scaled():', '                norm(np.asarray(data.dropna()))', '', '            lookup_table = dict(zip(levels, cmap(norm(levels))))', '', '        return levels, lookup_table, norm, cmap', '', '', '@share_init_params_with_map', 'class SizeMapping(SemanticMapping):', '    \"\"\"Mapping that sets artist sizes according to data values.\"\"\"', '    # An object that normalizes data values to [0, 1] range', '    norm = None', '', '    def __init__(', '        self, plotter, sizes=None, order=None, norm=None,', '    ):', '        \"\"\"Map the levels of the `size` variable to distinct values.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"size\", pd.Series(dtype=float))', '', '        if data.notna().any():', '', '            map_type = self.infer_map_type(', '                norm, sizes, plotter.var_types[\"size\"]', '            )', '', '            # --- Option 1: numeric mapping', '', '            if map_type == \"numeric\":', '', '                levels, lookup_table, norm, size_range = self.numeric_mapping(', '                    data, sizes, norm,', '                )', '', '            # --- Option 2: categorical mapping', '', '            elif map_type == \"categorical\":', '', '                levels, lookup_table = self.categorical_mapping(', '                    data, sizes, order,', '                )', '                size_range = None', '', '            # --- Option 3: datetime mapping', '', '            # TODO this needs an actual implementation', '            else:', '', '                levels, lookup_table = self.categorical_mapping(', '                    # Casting data to list to handle differences in the way', '                    # pandas and numpy represent datetime64 data', '                    list(data), sizes, order,', '                )', '                size_range = None', '', '            self.map_type = map_type', '            self.levels = levels', '            self.norm = norm', '            self.sizes = sizes', '            self.size_range = size_range', '            self.lookup_table = lookup_table', '', '    def infer_map_type(self, norm, sizes, var_type):', '', '        if norm is not None:', '            map_type = \"numeric\"', '        elif isinstance(sizes, (dict, list)):', '            map_type = \"categorical\"', '        else:', '            map_type = var_type', '', '        return map_type', '', '    def _lookup_single(self, key):', '', '        try:', '            value = self.lookup_table[key]', '        except KeyError:', '            normed = self.norm(key)', '            if np.ma.is_masked(normed):', '                normed = np.nan', '            value = self.size_range[0] + normed * np.ptp(self.size_range)', '        return value', '', '    def categorical_mapping(self, data, sizes, order):', '', '        levels = categorical_order(data, order)', '', '        if isinstance(sizes, dict):', '', '            # Dict inputs map existing data values to the size attribute', '            missing = set(levels) - set(sizes)', '            if any(missing):', '                err = f\"Missing sizes for the following levels: {missing}\"', '                raise ValueError(err)', '            lookup_table = sizes.copy()', '', '        elif isinstance(sizes, list):', '', '            # List inputs give size values in the same order as the levels', '            sizes = self._check_list_length(levels, sizes, \"sizes\")', '            lookup_table = dict(zip(levels, sizes))', '', '        else:', '', '            if isinstance(sizes, tuple):', '', '                # Tuple input sets the min, max size values', '                if len(sizes) != 2:', '                    err = \"A `sizes` tuple must have only 2 values\"', '                    raise ValueError(err)', '', '            elif sizes is not None:', '', '                err = f\"Value for `sizes` not understood: {sizes}\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, we need to get the min, max size values from', '                # the plotter object we are attached to.', '', '                # TODO this is going to cause us trouble later, because we', '                # want to restructure things so that the plotter is generic', '                # across the visual representation of the data. But at this', \"                # point, we don't know the visual representation. Likely we\", '                # want to change the logic of this Mapping so that it gives', '                # points on a normalized range that then gets un-normalized', \"                # when we know what we're drawing. But given the way the\", '                # package works now, this way is cleanest.', '                sizes = self.plotter._default_size_range', '', '            # For categorical sizes, use regularly-spaced linear steps', '            # between the minimum and maximum sizes. Then reverse the', '            # ramp so that the largest value is used for the first entry', '            # in size_order, etc. This is because \"ordered\" categories', '            # are often though to go in decreasing priority.', '            sizes = np.linspace(*sizes, len(levels))[::-1]', '            lookup_table = dict(zip(levels, sizes))', '', '        return levels, lookup_table', '', '    def numeric_mapping(self, data, sizes, norm):', '', '        if isinstance(sizes, dict):', '            # The presence of a norm object overrides a dictionary of sizes', '            # in specifying a numeric mapping, so we need to process it', '            # dictionary here', '            levels = list(np.sort(list(sizes)))', '            size_values = sizes.values()', '            size_range = min(size_values), max(size_values)', '', '        else:', '', '            # The levels here will be the unique values in the data', '            levels = list(np.sort(remove_na(data.unique())))', '', '            if isinstance(sizes, tuple):', '', '                # For numeric inputs, the size can be parametrized by', '                # the minimum and maximum artist values to map to. The', '                # norm object that gets set up next specifies how to', '                # do the mapping.', '', '                if len(sizes) != 2:', '                    err = \"A `sizes` tuple must have only 2 values\"', '                    raise ValueError(err)', '', '                size_range = sizes', '', '            elif sizes is not None:', '', '                err = f\"Value for `sizes` not understood: {sizes}\"', '                raise ValueError(err)', '', '            else:', '', '                # When not provided, we get the size range from the plotter', '                # object we are attached to. See the note in the categorical', '                # method about how this is suboptimal for future development.', '                size_range = self.plotter._default_size_range', '', '        # Now that we know the minimum and maximum sizes that will get drawn,', '        # we need to map the data values that we have into that range. We will', '        # use a matplotlib Normalize class, which is typically used for numeric', '        # color mapping but works fine here too. It takes data values and maps', '        # them into a [0, 1] interval, potentially nonlinear-ly.', '', '        if norm is None:', '            # Default is a linear function between the min and max data values', '            norm = mpl.colors.Normalize()', '        elif isinstance(norm, tuple):', '            # It is also possible to give different limits in data space', '            norm = mpl.colors.Normalize(*norm)', '        elif not isinstance(norm, mpl.colors.Normalize):', '            err = f\"Value for size `norm` parameter not understood: {norm}\"', '            raise ValueError(err)', '        else:', '            # If provided with Normalize object, copy it so we can modify', '            norm = copy(norm)', '', '        # Set the mapping so all output values are in [0, 1]', '        norm.clip = True', '', '        # If the input range is not set, use the full range of the data', '        if not norm.scaled():', '            norm(levels)', '', '        # Map from data values to [0, 1] range', '        sizes_scaled = norm(levels)', '', '        # Now map from the scaled range into the artist units', '        if isinstance(sizes, dict):', '            lookup_table = sizes', '        else:', '            lo, hi = size_range', '            sizes = lo + sizes_scaled * (hi - lo)', '            lookup_table = dict(zip(levels, sizes))', '', '        return levels, lookup_table, norm, size_range', '', '', '@share_init_params_with_map', 'class StyleMapping(SemanticMapping):', '    \"\"\"Mapping that sets artist style according to data values.\"\"\"', '', '    # Style mapping is always treated as categorical', '    map_type = \"categorical\"', '', '    def __init__(', '        self, plotter, markers=None, dashes=None, order=None,', '    ):', '        \"\"\"Map the levels of the `style` variable to distinct values.', '', '        Parameters', '        ----------', '        # TODO add generic parameters', '', '        \"\"\"', '        super().__init__(plotter)', '', '        data = plotter.plot_data.get(\"style\", pd.Series(dtype=float))', '', '        if data.notna().any():', '', '            # Cast to list to handle numpy/pandas datetime quirks', '            if variable_type(data) == \"datetime\":', '                data = list(data)', '', '            # Find ordered unique values', '            levels = categorical_order(data, order)', '', '            markers = self._map_attributes(', '                markers, levels, unique_markers(len(levels)), \"markers\",', '            )', '            dashes = self._map_attributes(', '                dashes, levels, unique_dashes(len(levels)), \"dashes\",', '            )', '', '            # Build the paths matplotlib will use to draw the markers', '            paths = {}', '            filled_markers = []', '            for k, m in markers.items():', '                if not isinstance(m, mpl.markers.MarkerStyle):', '                    m = mpl.markers.MarkerStyle(m)', '                paths[k] = m.get_path().transformed(m.get_transform())', '                filled_markers.append(m.is_filled())', '', '            # Mixture of filled and unfilled markers will show line art markers', '            # in the edge color, which defaults to white. This can be handled,', '            # but there would be additional complexity with specifying the', '            # weight of the line art markers without overwhelming the filled', '            # ones with the edges. So for now, we will disallow mixtures.', '            if any(filled_markers) and not all(filled_markers):', '                err = \"Filled and line art markers cannot be mixed\"', '                raise ValueError(err)', '', '            lookup_table = {}', '            for key in levels:', '                lookup_table[key] = {}', '                if markers:', '                    lookup_table[key][\"marker\"] = markers[key]', '                    lookup_table[key][\"path\"] = paths[key]', '                if dashes:', '                    lookup_table[key][\"dashes\"] = dashes[key]', '', '            self.levels = levels', '            self.lookup_table = lookup_table', '', '    def _lookup_single(self, key, attr=None):', '        \"\"\"Get attribute(s) for a given data point.\"\"\"', '        if attr is None:', '            value = self.lookup_table[key]', '        else:', '            value = self.lookup_table[key][attr]', '        return value', '', '    def _map_attributes(self, arg, levels, defaults, attr):', '        \"\"\"Handle the specification for a given style attribute.\"\"\"', '        if arg is True:', '            lookup_table = dict(zip(levels, defaults))', '        elif isinstance(arg, dict):', '            missing = set(levels) - set(arg)', '            if missing:', '                err = f\"These `{attr}` levels are missing values: {missing}\"', '                raise ValueError(err)', '            lookup_table = arg', '        elif isinstance(arg, Sequence):', '            arg = self._check_list_length(levels, arg, attr)', '            lookup_table = dict(zip(levels, arg))', '        elif arg:', '            err = f\"This `{attr}` argument was not understood: {arg}\"', '            raise ValueError(err)', '        else:', '            lookup_table = {}', '', '        return lookup_table', '', '', '# =========================================================================== #', '', '', 'class VectorPlotter:', '    \"\"\"Base class for objects underlying *plot functions.\"\"\"', '', '    _semantic_mappings = {', '        \"hue\": HueMapping,', '        \"size\": SizeMapping,', '        \"style\": StyleMapping,', '    }', '', '    # TODO units is another example of a non-mapping \"semantic\"', '    # we need a general name for this and separate handling', '    semantics = \"x\", \"y\", \"hue\", \"size\", \"style\", \"units\"', '    wide_structure = {', '        \"x\": \"@index\", \"y\": \"@values\", \"hue\": \"@columns\", \"style\": \"@columns\",', '    }', '    flat_structure = {\"x\": \"@index\", \"y\": \"@values\"}', '', '    _default_size_range = 1, 2  # Unused but needed in tests, ugh', '', '    def __init__(self, data=None, variables={}):', '', '        self._var_levels = {}', '        # var_ordered is relevant only for categorical axis variables, and may', '        # be better handled by an internal axis information object that tracks', '        # such information and is set up by the scale_* methods. The analogous', '        # information for numeric axes would be information about log scales.', '        self._var_ordered = {\"x\": False, \"y\": False}  # alt., used DefaultDict', '        self.assign_variables(data, variables)', '', '        for var, cls in self._semantic_mappings.items():', '', '            # Create the mapping function', '            map_func = partial(cls.map, plotter=self)', '            setattr(self, f\"map_{var}\", map_func)', '', '            # Call the mapping function to initialize with default values', '            getattr(self, f\"map_{var}\")()', '', '    @classmethod', '    def get_semantics(cls, kwargs, semantics=None):', '        \"\"\"Subset a dictionary arguments with known semantic variables.\"\"\"', '        # TODO this should be get_variables since we have included x and y', '        if semantics is None:', '            semantics = cls.semantics', '        variables = {}', '        for key, val in kwargs.items():', '            if key in semantics and val is not None:', '                variables[key] = val', '        return variables', '', '    @property', '    def has_xy_data(self):', '        \"\"\"Return True at least one of x or y is defined.\"\"\"', '        return bool({\"x\", \"y\"} & set(self.variables))', '', '    @property', '    def var_levels(self):', '        \"\"\"Property interface to ordered list of variables levels.', '', \"        Each time it's accessed, it updates the var_levels dictionary with the\", '        list of levels in the current semantic mappers. But it also allows the', '        dictionary to persist, so it can be used to set levels by a key. This is', '        used to track the list of col/row levels using an attached FacetGrid', \"        object, but it's kind of messy and ideally fixed by improving the\", '        faceting logic so it interfaces better with the modern approach to', '        tracking plot variables.', '', '        \"\"\"', '        for var in self.variables:', '            try:', '                map_obj = getattr(self, f\"_{var}_map\")', '                self._var_levels[var] = map_obj.levels', '            except AttributeError:', '                pass', '        return self._var_levels', '', '    def assign_variables(self, data=None, variables={}):', '        \"\"\"Define plot variables, optionally using lookup from `data`.\"\"\"', '        x = variables.get(\"x\", None)', '        y = variables.get(\"y\", None)', '', '        if x is None and y is None:', '            self.input_format = \"wide\"', '            plot_data, variables = self._assign_variables_wideform(', '                data, **variables,', '            )', '        else:', '            self.input_format = \"long\"', '            plot_data, variables = self._assign_variables_longform(', '                data, **variables,', '            )', '', '        self.plot_data = plot_data', '        self.variables = variables', '        self.var_types = {', '            v: variable_type(', '                plot_data[v],', '                boolean_type=\"numeric\" if v in \"xy\" else \"categorical\"', '            )', '            for v in variables', '        }', '', '        return self', '', '    def _assign_variables_wideform(self, data=None, **kwargs):', '        \"\"\"Define plot variables given wide-form data.', '', '        Parameters', '        ----------', '        data : flat vector or collection of vectors', '            Data can be a vector or mapping that is coerceable to a Series', '            or a sequence- or mapping-based collection of such vectors, or a', '            rectangular numpy array, or a Pandas DataFrame.', '        kwargs : variable -> data mappings', '            Behavior with keyword arguments is currently undefined.', '', '        Returns', '        -------', '        plot_data : :class:`pandas.DataFrame`', '            Long-form data object mapping seaborn variables (x, y, hue, ...)', '            to data vectors.', '        variables : dict', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '', '        \"\"\"', '        # Raise if semantic or other variables are assigned in wide-form mode', '        assigned = [k for k, v in kwargs.items() if v is not None]', '        if any(assigned):', '            s = \"s\" if len(assigned) > 1 else \"\"', '            err = f\"The following variable{s} cannot be assigned with wide-form data: \"', '            err += \", \".join(f\"`{v}`\" for v in assigned)', '            raise ValueError(err)', '', '        # Determine if the data object actually has any data in it', '        empty = data is None or not len(data)', '', '        # Then, determine if we have \"flat\" data (a single vector)', '        if isinstance(data, dict):', '            values = data.values()', '        else:', '            values = np.atleast_1d(np.asarray(data, dtype=object))', '        flat = not any(', '            isinstance(v, Iterable) and not isinstance(v, (str, bytes))', '            for v in values', '        )', '', '        if empty:', '', '            # Make an object with the structure of plot_data, but empty', '            plot_data = pd.DataFrame()', '            variables = {}', '', '        elif flat:', '', '            # Handle flat data by converting to pandas Series and using the', '            # index and/or values to define x and/or y', '            # (Could be accomplished with a more general to_series() interface)', '            flat_data = pd.Series(data).copy()', '            names = {', '                \"@values\": flat_data.name,', '                \"@index\": flat_data.index.name', '            }', '', '            plot_data = {}', '            variables = {}', '', '            for var in [\"x\", \"y\"]:', '                if var in self.flat_structure:', '                    attr = self.flat_structure[var]', '                    plot_data[var] = getattr(flat_data, attr[1:])', '                    variables[var] = names[self.flat_structure[var]]', '', '            plot_data = pd.DataFrame(plot_data)', '', '        else:', '', '            # Otherwise assume we have some collection of vectors.', '', '            # Handle Python sequences such that entries end up in the columns,', '            # not in the rows, of the intermediate wide DataFrame.', '            # One way to accomplish this is to convert to a dict of Series.', '            if isinstance(data, Sequence):', '                data_dict = {}', '                for i, var in enumerate(data):', '                    key = getattr(var, \"name\", i)', '                    # TODO is there a safer/more generic way to ensure Series?', '                    # sort of like np.asarray, but for pandas?', '                    data_dict[key] = pd.Series(var)', '', '                data = data_dict', '', '            # Pandas requires that dict values either be Series objects', '            # or all have the same length, but we want to allow \"ragged\" inputs', '            if isinstance(data, Mapping):', '                data = {key: pd.Series(val) for key, val in data.items()}', '', '            # Otherwise, delegate to the pandas DataFrame constructor', \"            # This is where we'd prefer to use a general interface that says\", '            # \"give me this data as a pandas DataFrame\", so we can accept', '            # DataFrame objects from other libraries', '            wide_data = pd.DataFrame(data, copy=True)', '', '            # At this point we should reduce the dataframe to numeric cols', '            numeric_cols = [', '                k for k, v in wide_data.items() if variable_type(v) == \"numeric\"', '            ]', '            wide_data = wide_data[numeric_cols]', '', '            # Now melt the data to long form', '            melt_kws = {\"var_name\": \"@columns\", \"value_name\": \"@values\"}', '            use_index = \"@index\" in self.wide_structure.values()', '            if use_index:', '                melt_kws[\"id_vars\"] = \"@index\"', '                try:', '                    orig_categories = wide_data.columns.categories', '                    orig_ordered = wide_data.columns.ordered', '                    wide_data.columns = wide_data.columns.add_categories(\"@index\")', '                except AttributeError:', '                    category_columns = False', '                else:', '                    category_columns = True', '                wide_data[\"@index\"] = wide_data.index.to_series()', '', '            plot_data = wide_data.melt(**melt_kws)', '', '            if use_index and category_columns:', '                plot_data[\"@columns\"] = pd.Categorical(plot_data[\"@columns\"],', '                                                       orig_categories,', '                                                       orig_ordered)', '', '            # Assign names corresponding to plot semantics', '            for var, attr in self.wide_structure.items():', '                plot_data[var] = plot_data[attr]', '', '            # Define the variable names', '            variables = {}', '            for var, attr in self.wide_structure.items():', '                obj = getattr(wide_data, attr[1:])', '                variables[var] = getattr(obj, \"name\", None)', '', '            # Remove redundant columns from plot_data', '            plot_data = plot_data[list(variables)]', '', '        return plot_data, variables', '', '    def _assign_variables_longform(self, data=None, **kwargs):', '        \"\"\"Define plot variables given long-form data and/or vector inputs.', '', '        Parameters', '        ----------', '        data : dict-like collection of vectors', '            Input data where variable names map to vector values.', '        kwargs : variable -> data mappings', '            Keys are seaborn variables (x, y, hue, ...) and values are vectors', '            in any format that can construct a :class:`pandas.DataFrame` or', '            names of columns or index levels in ``data``.', '', '        Returns', '        -------', '        plot_data : :class:`pandas.DataFrame`', '            Long-form data object mapping seaborn variables (x, y, hue, ...)', '            to data vectors.', '        variables : dict', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '', '        Raises', '        ------', '        ValueError', \"            When variables are strings that don't appear in ``data``.\", '', '        \"\"\"', '        plot_data = {}', '        variables = {}', '', '        # Data is optional; all variables can be defined as vectors', '        if data is None:', '            data = {}', '', '        # TODO should we try a data.to_dict() or similar here to more', '        # generally accept objects with that interface?', '        # Note that dict(df) also works for pandas, and gives us what we', '        # want, whereas DataFrame.to_dict() gives a nested dict instead of', '        # a dict of series.', '', '        # Variables can also be extracted from the index attribute', '        # TODO is this the most general way to enable it?', '        # There is no index.to_dict on multiindex, unfortunately', '        try:', '            index = data.index.to_frame()', '        except AttributeError:', '            index = {}', '', '        # The caller will determine the order of variables in plot_data', '        for key, val in kwargs.items():', '', '            # First try to treat the argument as a key for the data collection.', '            # But be flexible about what can be used as a key.', '            # Usually it will be a string, but allow numbers or tuples too when', '            # taking from the main data object. Only allow strings to reference', '            # fields in the index, because otherwise there is too much ambiguity.', '            try:', '                val_as_data_key = (', '                    val in data', '                    or (isinstance(val, (str, bytes)) and val in index)', '                )', '            except (KeyError, TypeError):', '                val_as_data_key = False', '', '            if val_as_data_key:', '', '                # We know that __getitem__ will work', '', '                if val in data:', '                    plot_data[key] = data[val]', '                elif val in index:', '                    plot_data[key] = index[val]', '                variables[key] = val', '', '            elif isinstance(val, (str, bytes)):', '', \"                # This looks like a column name but we don't know what it means!\", '', '                err = f\"Could not interpret value `{val}` for parameter `{key}`\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, assume the value is itself data', '', \"                # Raise when data object is present and a vector can't matched\", '                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):', '                    if np.ndim(val) and len(data) != len(val):', '                        val_cls = val.__class__.__name__', '                        err = (', '                            f\"Length of {val_cls} vectors must match length of `data`\"', '                            f\" when both are used, but `data` has length {len(data)}\"', '                            f\" and the vector passed to `{key}` has length {len(val)}.\"', '                        )', '                        raise ValueError(err)', '', '                plot_data[key] = val', '', '                # Try to infer the name of the variable', '                variables[key] = getattr(val, \"name\", None)', '', '        # Construct a tidy plot DataFrame. This will convert a number of', '        # types automatically, aligning on index in case of pandas objects', '        plot_data = pd.DataFrame(plot_data)', '', '        # Reduce the variables dictionary to fields with valid data', '        variables = {', '            var: name', '            for var, name in variables.items()', '            if plot_data[var].notnull().any()', '        }', '', '        return plot_data, variables', '', '    def iter_data(', '        self, grouping_vars=None, *,', '        reverse=False, from_comp_data=False,', '        by_facet=True, allow_empty=False, dropna=True,', '    ):', '        \"\"\"Generator for getting subsets of data defined by semantic variables.', '', '        Also injects \"col\" and \"row\" into grouping semantics.', '', '        Parameters', '        ----------', '        grouping_vars : string or list of strings', '            Semantic variables that define the subsets of data.', '        reverse : bool', '            If True, reverse the order of iteration.', '        from_comp_data : bool', '            If True, use self.comp_data rather than self.plot_data', '        by_facet : bool', '            If True, add faceting variables to the set of grouping variables.', '        allow_empty : bool', '            If True, yield an empty dataframe when no observations exist for', '            combinations of grouping variables.', '        dropna : bool', '            If True, remove rows with missing data.', '', '        Yields', '        ------', '        sub_vars : dict', '            Keys are semantic names, values are the level of that semantic.', '        sub_data : :class:`pandas.DataFrame`', '            Subset of ``plot_data`` for this combination of semantic values.', '', '        \"\"\"', '        # TODO should this default to using all (non x/y?) semantics?', '        # or define grouping vars somewhere?', '        if grouping_vars is None:', '            grouping_vars = []', '        elif isinstance(grouping_vars, str):', '            grouping_vars = [grouping_vars]', '        elif isinstance(grouping_vars, tuple):', '            grouping_vars = list(grouping_vars)', '', '        # Always insert faceting variables', '        if by_facet:', '            facet_vars = {\"col\", \"row\"}', '            grouping_vars.extend(', '                facet_vars & set(self.variables) - set(grouping_vars)', '            )', '', '        # Reduce to the semantics used in this plot', '        grouping_vars = [', '            var for var in grouping_vars if var in self.variables', '        ]', '', '        if from_comp_data:', '            data = self.comp_data', '        else:', '            data = self.plot_data', '', '        if dropna:', '            data = data.dropna()', '', '        levels = self.var_levels.copy()', '        if from_comp_data:', '            for axis in {\"x\", \"y\"} & set(grouping_vars):', '                if self.var_types[axis] == \"categorical\":', '                    if self._var_ordered[axis]:', '                        # If the axis is ordered, then the axes in a possible', '                        # facet grid are by definition \"shared\", or there is a', '                        # single axis with a unique cat -> idx mapping.', '                        # So we can just take the first converter object.', '                        converter = self.converters[axis].iloc[0]', '                        levels[axis] = converter.convert_units(levels[axis])', '                    else:', '                        # Otherwise, the mappings may not be unique, but we can', '                        # use the unique set of index values in comp_data.', '                        levels[axis] = np.sort(data[axis].unique())', '                elif self.var_types[axis] == \"datetime\":', '                    levels[axis] = mpl.dates.date2num(levels[axis])', '                elif self.var_types[axis] == \"numeric\" and self._log_scaled(axis):', '                    levels[axis] = np.log10(levels[axis])', '', '        if grouping_vars:', '', '            grouped_data = data.groupby(', '                grouping_vars, sort=False, as_index=False', '            )', '', '            grouping_keys = []', '            for var in grouping_vars:', '                grouping_keys.append(levels.get(var, []))', '', '            iter_keys = itertools.product(*grouping_keys)', '            if reverse:', '                iter_keys = reversed(list(iter_keys))', '', '            for key in iter_keys:', '', '                # Pandas fails with singleton tuple inputs', '                pd_key = key[0] if len(key) == 1 else key', '', '                try:', '                    data_subset = grouped_data.get_group(pd_key)', '                except KeyError:', '                    # XXX we are adding this to allow backwards compatibility', '                    # with the empty artists that old categorical plots would', '                    # add (before 0.12), which we may decide to break, in which', '                    # case this option could be removed', '                    data_subset = data.loc[[]]', '', '                if data_subset.empty and not allow_empty:', '                    continue', '', '                sub_vars = dict(zip(grouping_vars, key))', '', '                yield sub_vars, data_subset.copy()', '', '        else:', '', '            yield {}, data.copy()', '', '    @property', '    def comp_data(self):', '        \"\"\"Dataframe with numeric x and y, after unit conversion and log scaling.\"\"\"', '        if not hasattr(self, \"ax\"):', '            # Probably a good idea, but will need a bunch of tests updated', '            # Most of these tests should just use the external interface', '            # Then this can be re-enabled.', '            # raise AttributeError(\"No Axes attached to plotter\")', '            return self.plot_data', '', '        if not hasattr(self, \"_comp_data\"):', '', '            comp_data = (', '                self.plot_data', '                .copy(deep=False)', '                .drop([\"x\", \"y\"], axis=1, errors=\"ignore\")', '            )', '', '            for var in \"yx\":', '                if var not in self.variables:', '                    continue', '', '                parts = []', '                grouped = self.plot_data[var].groupby(self.converters[var], sort=False)', '                for converter, orig in grouped:', \"                    with pd.option_context('mode.use_inf_as_null', True):\", '                        orig = orig.dropna()', '                        if var in self.var_levels:', '                            # TODO this should happen in some centralized location', '                            # it is similar to GH2419, but more complicated because', '                            # supporting `order` in categorical plots is tricky', '                            orig = orig[orig.isin(self.var_levels[var])]', '                    comp = pd.to_numeric(converter.convert_units(orig))', '                    if converter.get_scale() == \"log\":', '                        comp = np.log10(comp)', '                    parts.append(pd.Series(comp, orig.index, name=orig.name))', '                if parts:', '                    comp_col = pd.concat(parts)', '                else:', '                    comp_col = pd.Series(dtype=float, name=var)', '                comp_data.insert(0, var, comp_col)', '', '            self._comp_data = comp_data', '', '        return self._comp_data', '', '    def _get_axes(self, sub_vars):', '        \"\"\"Return an Axes object based on existence of row/col variables.\"\"\"', '        row = sub_vars.get(\"row\", None)', '        col = sub_vars.get(\"col\", None)', '        if row is not None and col is not None:', '            return self.facets.axes_dict[(row, col)]', '        elif row is not None:', '            return self.facets.axes_dict[row]', '        elif col is not None:', '            return self.facets.axes_dict[col]', '        elif self.ax is None:', '            return self.facets.ax', '        else:', '            return self.ax', '', '    def _attach(', '        self,', '        obj,', '        allowed_types=None,', '        log_scale=None,', '    ):', '        \"\"\"Associate the plotter with an Axes manager and initialize its units.', '', '        Parameters', '        ----------', \"        obj : :class:`matplotlib.axes.Axes` or :class:'FacetGrid`\", '            Structural object that we will eventually plot onto.', '        allowed_types : str or list of str', '            If provided, raise when either the x or y variable does not have', '            one of the declared seaborn types.', '        log_scale : bool, number, or pair of bools or numbers', '            If not False, set the axes to use log scaling, with the given', '            base or defaulting to 10. If a tuple, interpreted as separate', '            arguments for the x and y axes.', '', '        \"\"\"', '        from .axisgrid import FacetGrid', '        if isinstance(obj, FacetGrid):', '            self.ax = None', '            self.facets = obj', '            ax_list = obj.axes.flatten()', '            if obj.col_names is not None:', '                self.var_levels[\"col\"] = obj.col_names', '            if obj.row_names is not None:', '                self.var_levels[\"row\"] = obj.row_names', '        else:', '            self.ax = obj', '            self.facets = None', '            ax_list = [obj]', '', '        # Identify which \"axis\" variables we have defined', '        axis_variables = set(\"xy\").intersection(self.variables)', '', '        # -- Verify the types of our x and y variables here.', \"        # This doesn't really make complete sense being here here, but it's a fine\", '        # place for it, given  the current system.', '        # (Note that for some plots, there might be more complicated restrictions)', '        # e.g. the categorical plots have their own check that as specific to the', '        # non-categorical axis.', '        if allowed_types is None:', '            allowed_types = [\"numeric\", \"datetime\", \"categorical\"]', '        elif isinstance(allowed_types, str):', '            allowed_types = [allowed_types]', '', '        for var in axis_variables:', '            var_type = self.var_types[var]', '            if var_type not in allowed_types:', '                err = (', '                    f\"The {var} variable is {var_type}, but one of \"', '                    f\"{allowed_types} is required\"', '                )', '                raise TypeError(err)', '', '        # -- Get axis objects for each row in plot_data for type conversions and scaling', '', '        facet_dim = {\"x\": \"col\", \"y\": \"row\"}', '', '        self.converters = {}', '        for var in axis_variables:', '            other_var = {\"x\": \"y\", \"y\": \"x\"}[var]', '', '            converter = pd.Series(index=self.plot_data.index, name=var, dtype=object)', '            share_state = getattr(self.facets, f\"_share{var}\", True)', '', '            # Simplest cases are that we have a single axes, all axes are shared,', '            # or sharing is only on the orthogonal facet dimension. In these cases,', '            # all datapoints get converted the same way, so use the first axis', '            if share_state is True or share_state == facet_dim[other_var]:', '                converter.loc[:] = getattr(ax_list[0], f\"{var}axis\")', '', '            else:', '', '                # Next simplest case is when no axes are shared, and we can', '                # use the axis objects within each facet', '                if share_state is False:', '                    for axes_vars, axes_data in self.iter_data():', '                        ax = self._get_axes(axes_vars)', '                        converter.loc[axes_data.index] = getattr(ax, f\"{var}axis\")', '', '                # In the more complicated case, the axes are shared within each', '                # \"file\" of the facetgrid. In that case, we need to subset the data', '                # for that file and assign it the first axis in the slice of the grid', '                else:', '', '                    names = getattr(self.facets, f\"{share_state}_names\")', '                    for i, level in enumerate(names):', '                        idx = (i, 0) if share_state == \"row\" else (0, i)', '                        axis = getattr(self.facets.axes[idx], f\"{var}axis\")', '                        converter.loc[self.plot_data[share_state] == level] = axis', '', '            # Store the converter vector, which we use elsewhere (e.g comp_data)', '            self.converters[var] = converter', '', '            # Now actually update the matplotlib objects to do the conversion we want', '            grouped = self.plot_data[var].groupby(self.converters[var], sort=False)', '            for converter, seed_data in grouped:', '                if self.var_types[var] == \"categorical\":', '                    if self._var_ordered[var]:', '                        order = self.var_levels[var]', '                    else:', '                        order = None', '                    seed_data = categorical_order(seed_data, order)', '                converter.update_units(seed_data)', '', '        # -- Set numerical axis scales', '', '        # First unpack the log_scale argument', '        if log_scale is None:', '            scalex = scaley = False', '        else:', '            # Allow single value or x, y tuple', '            try:', '                scalex, scaley = log_scale', '            except TypeError:', '                scalex = log_scale if \"x\" in self.variables else False', '                scaley = log_scale if \"y\" in self.variables else False', '', '        # Now use it', '        for axis, scale in zip(\"xy\", (scalex, scaley)):', '            if scale:', '                for ax in ax_list:', '                    set_scale = getattr(ax, f\"set_{axis}scale\")', '                    if scale is True:', '                        set_scale(\"log\")', '                    else:', '                        if Version(mpl.__version__) >= Version(\"3.3\"):', '                            set_scale(\"log\", base=scale)', '                        else:', '                            set_scale(\"log\", **{f\"base{axis}\": scale})', '', '        # For categorical y, we want the \"first\" level to be at the top of the axis', '        if self.var_types.get(\"y\", None) == \"categorical\":', '            for ax in ax_list:', '                try:', '                    ax.yaxis.set_inverted(True)', '                except AttributeError:  # mpl < 3.1', '                    if not ax.yaxis_inverted():', '                        ax.invert_yaxis()', '', '        # TODO -- Add axes labels', '', '    def _log_scaled(self, axis):', '        \"\"\"Return True if specified axis is log scaled on all attached axes.\"\"\"', '        if not hasattr(self, \"ax\"):', '            return False', '', '        if self.ax is None:', '            axes_list = self.facets.axes.flatten()', '        else:', '            axes_list = [self.ax]', '', '        log_scaled = []', '        for ax in axes_list:', '            data_axis = getattr(ax, f\"{axis}axis\")', '            log_scaled.append(data_axis.get_scale() == \"log\")', '', '        if any(log_scaled) and not all(log_scaled):', '            raise RuntimeError(\"Axis scaling is not consistent\")', '', '        return any(log_scaled)', '', '    def _add_axis_labels(self, ax, default_x=\"\", default_y=\"\"):', '        \"\"\"Add axis labels if not present, set visibility to match ticklabels.\"\"\"', '        # TODO ax could default to None and use attached axes if present', \"        # but what to do about the case of facets? Currently using FacetGrid's\", \"        # set_axis_labels method, which doesn't add labels to the interior even\", '        # when the axes are not shared. Maybe that makes sense?', '        if not ax.get_xlabel():', '            x_visible = any(t.get_visible() for t in ax.get_xticklabels())', '            ax.set_xlabel(self.variables.get(\"x\", default_x), visible=x_visible)', '        if not ax.get_ylabel():', '            y_visible = any(t.get_visible() for t in ax.get_yticklabels())', '            ax.set_ylabel(self.variables.get(\"y\", default_y), visible=y_visible)', '', '    # XXX If the scale_* methods are going to modify the plot_data structure, they', \"    # can't be called twice. That means that if they are called twice, they should\", '    # raise. Alternatively, we could store an original version of plot_data and each', '    # time they are called they operate on the store, not the current state.', '', '    def scale_native(self, axis, *args, **kwargs):', '', '        # Default, defer to matplotlib', '', '        raise NotImplementedError', '', '    def scale_numeric(self, axis, *args, **kwargs):', '', '        # Feels needed to completeness, what should it do?', '        # Perhaps handle log scaling? Set the ticker/formatter/limits?', '', '        raise NotImplementedError', '', '    def scale_datetime(self, axis, *args, **kwargs):', '', '        # Use pd.to_datetime to convert strings or numbers to datetime objects', '        # Note, use day-resolution for numeric->datetime to match matplotlib', '', '        raise NotImplementedError', '', '    def scale_categorical(self, axis, order=None, formatter=None):', '        \"\"\"', '        Enforce categorical (fixed-scale) rules for the data on given axis.', '', '        Parameters', '        ----------', '        axis : \"x\" or \"y\"', '            Axis of the plot to operate on.', '        order : list', '            Order that unique values should appear in.', '        formatter : callable', '            Function mapping values to a string representation.', '', '        Returns', '        -------', '        self', '', '        \"\"\"', '        # This method both modifies the internal representation of the data', '        # (converting it to string) and sets some attributes on self. It might be', '        # a good idea to have a separate object attached to self that contains the', '        # information in those attributes (i.e. whether to enforce variable order', '        # across facets, the order to use) similar to the SemanticMapping objects', '        # we have for semantic variables. That object could also hold the converter', '        # objects that get used, if we can decouple those from an existing axis', '        # (cf. https://github.com/matplotlib/matplotlib/issues/19229).', '        # There are some interactions with faceting information that would need', '        # to be thought through, since the converts to use depend on facets.', '        # If we go that route, these methods could become \"borrowed\" methods similar', '        # to what happens with the alternate semantic mapper constructors, although', '        # that approach is kind of fussy and confusing.', '', '        # TODO this method could also set the grid state? Since we like to have no', \"        # grid on the categorical axis by default. Again, a case where we'll need to\", '        # store information until we use it, so best to have a way to collect the', '        # attributes that this method sets.', '', '        # TODO if we are going to set visual properties of the axes with these methods,', '        # then we could do the steps currently in CategoricalPlotter._adjust_cat_axis', '', '        # TODO another, and distinct idea, is to expose a cut= param here', '', '        _check_argument(\"axis\", [\"x\", \"y\"], axis)', '', '        # Categorical plots can be \"univariate\" in which case they get an anonymous', '        # category label on the opposite axis.', '        if axis not in self.variables:', '            self.variables[axis] = None', '            self.var_types[axis] = \"categorical\"', '            self.plot_data[axis] = \"\"', '', '        # If the \"categorical\" variable has a numeric type, sort the rows so that', '        # the default result from categorical_order has those values sorted after', '        # they have been coerced to strings. The reason for this is so that later', '        # we can get facet-wise orders that are correct.', '        # XXX Should this also sort datetimes?', '        # It feels more consistent, but technically will be a default change', '        # If so, should also change categorical_order to behave that way', '        if self.var_types[axis] == \"numeric\":', '            self.plot_data = self.plot_data.sort_values(axis, kind=\"mergesort\")', '', '        # Now get a reference to the categorical data vector', '        cat_data = self.plot_data[axis]', '', '        # Get the initial categorical order, which we do before string', '        # conversion to respect the original types of the order list.', '        # Track whether the order is given explicitly so that we can know', '        # whether or not to use the order constructed here downstream', '        self._var_ordered[axis] = order is not None or cat_data.dtype.name == \"category\"', '        order = pd.Index(categorical_order(cat_data, order))', '', '        # Then convert data to strings. This is because in matplotlib,', '        # \"categorical\" data really mean \"string\" data, so doing this artists', '        # will be drawn on the categorical axis with a fixed scale.', '        # TODO implement formatter here; check that it returns strings?', '        if formatter is not None:', '            cat_data = cat_data.map(formatter)', '            order = order.map(formatter)', '        else:', '            cat_data = cat_data.astype(str)', '            order = order.astype(str)', '', '        # Update the levels list with the type-converted order variable', '        self.var_levels[axis] = order', '', '        # Now ensure that seaborn will use categorical rules internally', '        self.var_types[axis] = \"categorical\"', '', '        # Put the string-typed categorical vector back into the plot_data structure', '        self.plot_data[axis] = cat_data', '', '        return self', '', '', 'class VariableType(UserString):', '    \"\"\"', '    Prevent comparisons elsewhere in the library from using the wrong name.', '', '    Errors are simple assertions because users should not be able to trigger', '    them. If that changes, they should be more verbose.', '', '    \"\"\"', '    # TODO we can replace this with typing.Literal on Python 3.8+', '    allowed = \"numeric\", \"datetime\", \"categorical\"', '', '    def __init__(self, data):', '        assert data in self.allowed, data', '        super().__init__(data)', '', '    def __eq__(self, other):', '        assert other in self.allowed, other', '        return self.data == other', '', '', 'def variable_type(vector, boolean_type=\"numeric\"):', '    \"\"\"', '    Determine whether a vector contains numeric, categorical, or datetime data.', '', '    This function differs from the pandas typing API in two ways:', '', '    - Python sequences or object-typed PyData objects are considered numeric if', '      all of their entries are numeric.', '    - String or mixed-type data are considered categorical even if not', '      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.', '', '    Parameters', '    ----------', '    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence', '        Input data to test.', \"    boolean_type : 'numeric' or 'categorical'\", '        Type to use for vectors containing only 0s and 1s (and NAs).', '', '    Returns', '    -------', \"    var_type : 'numeric', 'categorical', or 'datetime'\", '        Name identifying the type of data in the vector.', '    \"\"\"', '', '    # If a categorical dtype is set, infer categorical', '    if pd.api.types.is_categorical_dtype(vector):', '        return VariableType(\"categorical\")', '', '    # Special-case all-na data, which is always \"numeric\"', '    if pd.isna(vector).all():', '        return VariableType(\"numeric\")', '', '    # Special-case binary/boolean data, allow caller to determine', '    # This triggers a numpy warning when vector has strings/objects', '    # https://github.com/numpy/numpy/issues/6784', '    # Because we reduce with .all(), we are agnostic about whether the', '    # comparison returns a scalar or vector, so we will ignore the warning.', '    # It triggers a separate DeprecationWarning when the vector has datetimes:', '    # https://github.com/numpy/numpy/issues/13548', '    # This is considered a bug by numpy and will likely go away.', '    with warnings.catch_warnings():', '        warnings.simplefilter(', \"            action='ignore', category=(FutureWarning, DeprecationWarning)\", '        )', '        if np.isin(vector, [0, 1, np.nan]).all():', '            return VariableType(boolean_type)', '', '    # Defer to positive pandas tests', '    if pd.api.types.is_numeric_dtype(vector):', '        return VariableType(\"numeric\")', '', '    if pd.api.types.is_datetime64_dtype(vector):', '        return VariableType(\"datetime\")', '', '    # --- If we get to here, we need to check the entries', '', '    # Check for a collection where everything is a number', '', '    def all_numeric(x):', '        for x_i in x:', '            if not isinstance(x_i, Number):', '                return False', '        return True', '', '    if all_numeric(vector):', '        return VariableType(\"numeric\")', '', '    # Check for a collection where everything is a datetime', '', '    def all_datetime(x):', '        for x_i in x:', '            if not isinstance(x_i, (datetime, np.datetime64)):', '                return False', '        return True', '', '    if all_datetime(vector):', '        return VariableType(\"datetime\")', '', '    # Otherwise, our final fallback is to consider things categorical', '', '    return VariableType(\"categorical\")', '', '', 'def infer_orient(x=None, y=None, orient=None, require_numeric=True):', '    \"\"\"Determine how the plot should be oriented based on the data.', '', '    For historical reasons, the convention is to call a plot \"horizontally\"', '    or \"vertically\" oriented based on the axis representing its dependent', '    variable. Practically, this is used when determining the axis for', '    numerical aggregation.', '', '    Parameters', '    ----------', '    x, y : Vector data or None', '        Positional data vectors for the plot.', '    orient : string or None', '        Specified orientation, which must start with \"v\" or \"h\" if not None.', '    require_numeric : bool', '        If set, raise when the implied dependent variable is not numeric.', '', '    Returns', '    -------', '    orient : \"v\" or \"h\"', '', '    Raises', '    ------', '    ValueError: When `orient` is not None and does not start with \"h\" or \"v\"', '    TypeError: When dependent variable is not numeric, with `require_numeric`', '', '    \"\"\"', '', '    x_type = None if x is None else variable_type(x)', '    y_type = None if y is None else variable_type(y)', '', '    nonnumeric_dv_error = \"{} orientation requires numeric `{}` variable.\"', '    single_var_warning = \"{} orientation ignored with only `{}` specified.\"', '', '    if x is None:', '        if str(orient).startswith(\"h\"):', '            warnings.warn(single_var_warning.format(\"Horizontal\", \"y\"))', '        if require_numeric and y_type != \"numeric\":', '            raise TypeError(nonnumeric_dv_error.format(\"Vertical\", \"y\"))', '        return \"v\"', '', '    elif y is None:', '        if str(orient).startswith(\"v\"):', '            warnings.warn(single_var_warning.format(\"Vertical\", \"x\"))', '        if require_numeric and x_type != \"numeric\":', '            raise TypeError(nonnumeric_dv_error.format(\"Horizontal\", \"x\"))', '        return \"h\"', '', '    elif str(orient).startswith(\"v\"):', '        if require_numeric and y_type != \"numeric\":', '            raise TypeError(nonnumeric_dv_error.format(\"Vertical\", \"y\"))', '        return \"v\"', '', '    elif str(orient).startswith(\"h\"):', '        if require_numeric and x_type != \"numeric\":', '            raise TypeError(nonnumeric_dv_error.format(\"Horizontal\", \"x\"))', '        return \"h\"', '', '    elif orient is not None:', '        err = (', '            \"`orient` must start with \\'v\\' or \\'h\\' or be None, \"', '            f\"but `{repr(orient)}` was passed.\"', '        )', '        raise ValueError(err)', '', '    elif x_type != \"categorical\" and y_type == \"categorical\":', '        return \"h\"', '', '    elif x_type != \"numeric\" and y_type == \"numeric\":', '        return \"v\"', '', '    elif x_type == \"numeric\" and y_type != \"numeric\":', '        return \"h\"', '', '    elif require_numeric and \"numeric\" not in (x_type, y_type):', '        err = \"Neither the `x` nor `y` variable appears to be numeric.\"', '        raise TypeError(err)', '', '    else:', '        return \"v\"', '', '', 'def unique_dashes(n):', '    \"\"\"Build an arbitrarily long list of unique dash styles for lines.', '', '    Parameters', '    ----------', '    n : int', '        Number of unique dash specs to generate.', '', '    Returns', '    -------', '    dashes : list of strings or tuples', '        Valid arguments for the ``dashes`` parameter on', '        :class:`matplotlib.lines.Line2D`. The first spec is a solid', '        line (``\"\"``), the remainder are sequences of long and short', '        dashes.', '', '    \"\"\"', '    # Start with dash specs that are well distinguishable', '    dashes = [', '        \"\",', '        (4, 1.5),', '        (1, 1),', '        (3, 1.25, 1.5, 1.25),', '        (5, 1, 1, 1),', '    ]', '', '    # Now programmatically build as many as we need', '    p = 3', '    while len(dashes) < n:', '', '        # Take combinations of long and short dashes', '        a = itertools.combinations_with_replacement([3, 1.25], p)', '        b = itertools.combinations_with_replacement([4, 1], p)', '', '        # Interleave the combinations, reversing one of the streams', '        segment_list = itertools.chain(*zip(', '            list(a)[1:-1][::-1],', '            list(b)[1:-1]', '        ))', '', '        # Now insert the gaps', '        for segments in segment_list:', '            gap = min(segments)', '            spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))', '            dashes.append(spec)', '', '        p += 1', '', '    return dashes[:n]', '', '', 'def unique_markers(n):', '    \"\"\"Build an arbitrarily long list of unique marker styles for points.', '', '    Parameters', '    ----------', '    n : int', '        Number of unique marker specs to generate.', '', '    Returns', '    -------', '    markers : list of string or tuples', '        Values for defining :class:`matplotlib.markers.MarkerStyle` objects.', '        All markers will be filled.', '', '    \"\"\"', '    # Start with marker specs that are well distinguishable', '    markers = [', '        \"o\",', '        \"X\",', '        (4, 0, 45),', '        \"P\",', '        (4, 0, 0),', '        (4, 1, 0),', '        \"^\",', '        (4, 1, 45),', '        \"v\",', '    ]', '', '    # Now generate more from regular polygons of increasing order', '    s = 5', '    while len(markers) < n:', '        a = 360 / (s + 1) / 2', '        markers.extend([', '            (s + 1, 1, a),', '            (s + 1, 0, a),', '            (s, 1, 0),', '            (s, 0, 0),', '        ])', '        s += 1', '', '    # Convert to MarkerStyle object, using only exactly what we need', '    # markers = [mpl.markers.MarkerStyle(m) for m in markers[:n]]', '', '    return markers[:n]', '', '', 'def categorical_order(vector, order=None):', '    \"\"\"Return a list of unique data values.', '', '    Determine an ordered list of levels in ``values``.', '', '    Parameters', '    ----------', '    vector : list, array, Categorical, or Series', '        Vector of \"categorical\" values', '    order : list-like, optional', '        Desired order of category levels to override the order determined', '        from the ``values`` object.', '', '    Returns', '    -------', '    order : list', '        Ordered list of category levels not including null values.', '', '    \"\"\"', '    if order is None:', '        if hasattr(vector, \"categories\"):', '            order = vector.categories', '        else:', '            try:', '                order = vector.cat.categories', '            except (TypeError, AttributeError):', '', '                try:', '                    order = vector.unique()', '                except AttributeError:', '                    order = pd.unique(vector)', '', '                if variable_type(vector) == \"numeric\":', '                    order = np.sort(order)', '', '        order = filter(pd.notnull, order)', '    return list(order)']}, '__init__.py': {'classes': [], 'functions': [], 'text': ['# Import seaborn objects', 'from .rcmod import *  # noqa: F401,F403', 'from .utils import *  # noqa: F401,F403', 'from .palettes import *  # noqa: F401,F403', 'from .relational import *  # noqa: F401,F403', 'from .regression import *  # noqa: F401,F403', 'from .categorical import *  # noqa: F401,F403', 'from .distributions import *  # noqa: F401,F403', 'from .matrix import *  # noqa: F401,F403', 'from .miscplot import *  # noqa: F401,F403', 'from .axisgrid import *  # noqa: F401,F403', 'from .widgets import *  # noqa: F401,F403', 'from .colors import xkcd_rgb, crayons  # noqa: F401', 'from . import cm  # noqa: F401', '', '# Capture the original matplotlib rcParams', 'import matplotlib as mpl', '_orig_rc_params = mpl.rcParams.copy()', '', '# Define the seaborn version', '__version__ = \"0.12.1.dev0\"']}, 'utils.py': {'classes': [{'name': 'dummy_axis', 'start_line': 690, 'end_line': 692, 'text': ['    class dummy_axis:', '        def get_view_interval(self):', '            return limits'], 'methods': [{'name': 'get_view_interval', 'start_line': 691, 'end_line': 692, 'text': ['        def get_view_interval(self):', '            return limits']}]}], 'functions': [{'name': 'ci_to_errsize', 'start_line': 24, 'end_line': 51, 'text': ['def ci_to_errsize(cis, heights):', '    \"\"\"Convert intervals to error arguments relative to plot heights.', '', '    Parameters', '    ----------', '    cis : 2 x n sequence', '        sequence of confidence interval limits', '    heights : n sequence', '        sequence of plot heights', '', '    Returns', '    -------', '    errsize : 2 x n array', '        sequence of error size relative to height values in correct', '        format as argument for plt.bar', '', '    \"\"\"', '    cis = np.atleast_2d(cis).reshape(2, -1)', '    heights = np.atleast_1d(heights)', '    errsize = []', '    for i, (low, high) in enumerate(np.transpose(cis)):', '        h = heights[i]', '        elow = h - low', '        ehigh = high - h', '        errsize.append([elow, ehigh])', '', '    errsize = np.asarray(errsize).T', '    return errsize']}, {'name': '_normal_quantile_func', 'start_line': 54, 'end_line': 74, 'text': ['def _normal_quantile_func(q):', '    \"\"\"', '    Compute the quantile function of the standard normal distribution.', '', '    This wrapper exists because we are dropping scipy as a mandatory dependency', '    but statistics.NormalDist was added to the standard library in 3.8.', '', '    \"\"\"', '    try:', '        from statistics import NormalDist', '        qf = np.vectorize(NormalDist().inv_cdf)', '    except ImportError:', '        try:', '            from scipy.stats import norm', '            qf = norm.ppf', '        except ImportError:', '            msg = (', '                \"Standard normal quantile functions require either Python>=3.8 or scipy\"', '            )', '            raise RuntimeError(msg)', '    return qf(q)']}, {'name': '_draw_figure', 'start_line': 77, 'end_line': 85, 'text': ['def _draw_figure(fig):', '    \"\"\"Force draw of a matplotlib figure, accounting for back-compat.\"\"\"', '    # See https://github.com/matplotlib/matplotlib/issues/19197 for context', '    fig.canvas.draw()', '    if fig.stale:', '        try:', '            fig.draw(fig.canvas.get_renderer())', '        except AttributeError:', '            pass']}, {'name': '_default_color', 'start_line': 88, 'end_line': 165, 'text': ['def _default_color(method, hue, color, kws):', '    \"\"\"If needed, get a default color by using the matplotlib property cycle.\"\"\"', '    if hue is not None:', \"        # This warning is probably user-friendly, but it's currently triggered\", \"        # in a FacetGrid context and I don't want to mess with that logic right now\", '        #  if color is not None:', '        #      msg = \"`color` is ignored when `hue` is assigned.\"', '        #      warnings.warn(msg)', '        return None', '', '    if color is not None:', '        return color', '', '    elif method.__name__ == \"plot\":', '', '        color = _normalize_kwargs(kws, mpl.lines.Line2D).get(\"color\")', '        scout, = method([], [], scalex=False, scaley=False, color=color)', '        color = scout.get_color()', '        scout.remove()', '', '    elif method.__name__ == \"scatter\":', '', \"        # Matplotlib will raise if the size of x/y don't match s/c,\", '        # and the latter might be in the kws dict', '        scout_size = max(', '            np.atleast_1d(kws.get(key, [])).shape[0]', '            for key in [\"s\", \"c\", \"fc\", \"facecolor\", \"facecolors\"]', '        )', '        scout_x = scout_y = np.full(scout_size, np.nan)', '', '        scout = method(scout_x, scout_y, **kws)', '        facecolors = scout.get_facecolors()', '', '        if not len(facecolors):', '            # Handle bug in matplotlib <= 3.2 (I think)', '            # This will limit the ability to use non color= kwargs to specify', '            # a color in versions of matplotlib with the bug, but trying to', '            # work out what the user wanted by re-implementing the broken logic', '            # of inspecting the kwargs is probably too brittle.', '            single_color = False', '        else:', '            single_color = np.unique(facecolors, axis=0).shape[0] == 1', '', '        # Allow the user to specify an array of colors through various kwargs', '        if \"c\" not in kws and single_color:', '            color = to_rgb(facecolors[0])', '', '        scout.remove()', '', '    elif method.__name__ == \"bar\":', '', '        # bar() needs masked, not empty data, to generate a patch', '        scout, = method([np.nan], [np.nan], **kws)', '        color = to_rgb(scout.get_facecolor())', '        scout.remove()', '', '    elif method.__name__ == \"fill_between\":', '', '        # There is a bug on matplotlib < 3.3 where fill_between with', '        # datetime units and empty data will set incorrect autoscale limits', \"        # To workaround it, we'll always return the first color in the cycle.\", '        # https://github.com/matplotlib/matplotlib/issues/17586', '        ax = method.__self__', '        datetime_axis = any([', '            isinstance(ax.xaxis.converter, mpl.dates.DateConverter),', '            isinstance(ax.yaxis.converter, mpl.dates.DateConverter),', '        ])', '        if Version(mpl.__version__) < Version(\"3.3\") and datetime_axis:', '            return \"C0\"', '', '        kws = _normalize_kwargs(kws, mpl.collections.PolyCollection)', '', '        scout = method([], [], **kws)', '        facecolor = scout.get_facecolor()', '        color = to_rgb(facecolor[0])', '        scout.remove()', '', '    return color']}, {'name': 'desaturate', 'start_line': 168, 'end_line': 200, 'text': ['def desaturate(color, prop):', '    \"\"\"Decrease the saturation channel of a color by some percent.', '', '    Parameters', '    ----------', '    color : matplotlib color', '        hex, rgb-tuple, or html color name', '    prop : float', '        saturation channel of color will be multiplied by this value', '', '    Returns', '    -------', '    new_color : rgb tuple', '        desaturated color code in RGB tuple representation', '', '    \"\"\"', '    # Check inputs', '    if not 0 <= prop <= 1:', '        raise ValueError(\"prop must be between 0 and 1\")', '', '    # Get rgb tuple rep', '    rgb = to_rgb(color)', '', '    # Convert to hls', '    h, l, s = colorsys.rgb_to_hls(*rgb)', '', '    # Desaturate the saturation channel', '    s *= prop', '', '    # Convert back to rgb', '    new_color = colorsys.hls_to_rgb(h, l, s)', '', '    return new_color']}, {'name': 'saturate', 'start_line': 203, 'end_line': 217, 'text': ['def saturate(color):', '    \"\"\"Return a fully saturated color with the same hue.', '', '    Parameters', '    ----------', '    color : matplotlib color', '        hex, rgb-tuple, or html color name', '', '    Returns', '    -------', '    new_color : rgb tuple', '        saturated color code in RGB tuple representation', '', '    \"\"\"', '    return set_hls_values(color, s=1)']}, {'name': 'set_hls_values', 'start_line': 220, 'end_line': 244, 'text': ['def set_hls_values(color, h=None, l=None, s=None):  # noqa', '    \"\"\"Independently manipulate the h, l, or s channels of a color.', '', '    Parameters', '    ----------', '    color : matplotlib color', '        hex, rgb-tuple, or html color name', '    h, l, s : floats between 0 and 1, or None', '        new values for each channel in hls space', '', '    Returns', '    -------', '    new_color : rgb tuple', '        new color code in RGB tuple representation', '', '    \"\"\"', '    # Get an RGB tuple representation', '    rgb = to_rgb(color)', '    vals = list(colorsys.rgb_to_hls(*rgb))', '    for i, val in enumerate([h, l, s]):', '        if val is not None:', '            vals[i] = val', '', '    rgb = colorsys.hls_to_rgb(*vals)', '    return rgb']}, {'name': 'axlabel', 'start_line': 247, 'end_line': 257, 'text': ['def axlabel(xlabel, ylabel, **kwargs):', '    \"\"\"Grab current axis and label it.', '', '    DEPRECATED: will be removed in a future version.', '', '    \"\"\"', '    msg = \"This function is deprecated and will be removed in a future version\"', '    warnings.warn(msg, FutureWarning)', '    ax = plt.gca()', '    ax.set_xlabel(xlabel, **kwargs)', '    ax.set_ylabel(ylabel, **kwargs)']}, {'name': 'remove_na', 'start_line': 260, 'end_line': 274, 'text': ['def remove_na(vector):', '    \"\"\"Helper method for removing null values from data vectors.', '', '    Parameters', '    ----------', '    vector : vector object', '        Must implement boolean masking with [] subscript syntax.', '', '    Returns', '    -------', '    clean_clean : same type as ``vector``', '        Vector of data with null values removed. May be a copy or a view.', '', '    \"\"\"', '    return vector[pd.notnull(vector)]']}, {'name': 'get_color_cycle', 'start_line': 277, 'end_line': 291, 'text': ['def get_color_cycle():', '    \"\"\"Return the list of colors in the current matplotlib color cycle', '', '    Parameters', '    ----------', '    None', '', '    Returns', '    -------', '    colors : list', '        List of matplotlib colors in the current cycle, or dark gray if', '        the current color cycle is empty.', '    \"\"\"', \"    cycler = mpl.rcParams['axes.prop_cycle']\", '    return cycler.by_key()[\\'color\\'] if \\'color\\' in cycler.keys else [\".15\"]']}, {'name': 'despine', 'start_line': 294, 'end_line': 393, 'text': ['def despine(fig=None, ax=None, top=True, right=True, left=False,', '            bottom=False, offset=None, trim=False):', '    \"\"\"Remove the top and right spines from plot(s).', '', '    fig : matplotlib figure, optional', '        Figure to despine all axes of, defaults to the current figure.', '    ax : matplotlib axes, optional', '        Specific axes object to despine. Ignored if fig is provided.', '    top, right, left, bottom : boolean, optional', '        If True, remove that spine.', '    offset : int or dict, optional', '        Absolute distance, in points, spines should be moved away', '        from the axes (negative values move spines inward). A single value', '        applies to all spines; a dict can be used to set offset values per', '        side.', '    trim : bool, optional', '        If True, limit spines to the smallest and largest major tick', '        on each non-despined axis.', '', '    Returns', '    -------', '    None', '', '    \"\"\"', '    # Get references to the axes we want', '    if fig is None and ax is None:', '        axes = plt.gcf().axes', '    elif fig is not None:', '        axes = fig.axes', '    elif ax is not None:', '        axes = [ax]', '', '    for ax_i in axes:', '        for side in [\"top\", \"right\", \"left\", \"bottom\"]:', '            # Toggle the spine objects', '            is_visible = not locals()[side]', '            ax_i.spines[side].set_visible(is_visible)', '            if offset is not None and is_visible:', '                try:', '                    val = offset.get(side, 0)', '                except AttributeError:', '                    val = offset', \"                ax_i.spines[side].set_position(('outward', val))\", '', '        # Potentially move the ticks', '        if left and not right:', '            maj_on = any(', '                t.tick1line.get_visible()', '                for t in ax_i.yaxis.majorTicks', '            )', '            min_on = any(', '                t.tick1line.get_visible()', '                for t in ax_i.yaxis.minorTicks', '            )', '            ax_i.yaxis.set_ticks_position(\"right\")', '            for t in ax_i.yaxis.majorTicks:', '                t.tick2line.set_visible(maj_on)', '            for t in ax_i.yaxis.minorTicks:', '                t.tick2line.set_visible(min_on)', '', '        if bottom and not top:', '            maj_on = any(', '                t.tick1line.get_visible()', '                for t in ax_i.xaxis.majorTicks', '            )', '            min_on = any(', '                t.tick1line.get_visible()', '                for t in ax_i.xaxis.minorTicks', '            )', '            ax_i.xaxis.set_ticks_position(\"top\")', '            for t in ax_i.xaxis.majorTicks:', '                t.tick2line.set_visible(maj_on)', '            for t in ax_i.xaxis.minorTicks:', '                t.tick2line.set_visible(min_on)', '', '        if trim:', '            # clip off the parts of the spines that extend past major ticks', '            xticks = np.asarray(ax_i.get_xticks())', '            if xticks.size:', '                firsttick = np.compress(xticks >= min(ax_i.get_xlim()),', '                                        xticks)[0]', '                lasttick = np.compress(xticks <= max(ax_i.get_xlim()),', '                                       xticks)[-1]', \"                ax_i.spines['bottom'].set_bounds(firsttick, lasttick)\", \"                ax_i.spines['top'].set_bounds(firsttick, lasttick)\", '                newticks = xticks.compress(xticks <= lasttick)', '                newticks = newticks.compress(newticks >= firsttick)', '                ax_i.set_xticks(newticks)', '', '            yticks = np.asarray(ax_i.get_yticks())', '            if yticks.size:', '                firsttick = np.compress(yticks >= min(ax_i.get_ylim()),', '                                        yticks)[0]', '                lasttick = np.compress(yticks <= max(ax_i.get_ylim()),', '                                       yticks)[-1]', \"                ax_i.spines['left'].set_bounds(firsttick, lasttick)\", \"                ax_i.spines['right'].set_bounds(firsttick, lasttick)\", '                newticks = yticks.compress(yticks <= lasttick)', '                newticks = newticks.compress(newticks >= firsttick)', '                ax_i.set_yticks(newticks)']}, {'name': 'move_legend', 'start_line': 396, 'end_line': 483, 'text': ['def move_legend(obj, loc, **kwargs):', '    \"\"\"', \"    Recreate a plot's legend at a new location.\", '', '    The name is a slight misnomer. Matplotlib legends do not expose public', '    control over their position parameters. So this function creates a new legend,', '    copying over the data from the original object, which is then removed.', '', '    Parameters', '    ----------', '    obj : the object with the plot', '        This argument can be either a seaborn or matplotlib object:', '', '        - :class:`seaborn.FacetGrid` or :class:`seaborn.PairGrid`', '        - :class:`matplotlib.axes.Axes` or :class:`matplotlib.figure.Figure`', '', '    loc : str or int', '        Location argument, as in :meth:`matplotlib.axes.Axes.legend`.', '', '    kwargs', '        Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.legend`.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/move_legend.rst', '', '    \"\"\"', '    # This is a somewhat hackish solution that will hopefully be obviated by', '    # upstream improvements to matplotlib legends that make them easier to', '    # modify after creation.', '', '    from seaborn.axisgrid import Grid  # Avoid circular import', '', '    # Locate the legend object and a method to recreate the legend', '    if isinstance(obj, Grid):', '        old_legend = obj.legend', '        legend_func = obj.figure.legend', '    elif isinstance(obj, mpl.axes.Axes):', '        old_legend = obj.legend_', '        legend_func = obj.legend', '    elif isinstance(obj, mpl.figure.Figure):', '        if obj.legends:', '            old_legend = obj.legends[-1]', '        else:', '            old_legend = None', '        legend_func = obj.legend', '    else:', '        err = \"`obj` must be a seaborn Grid or matplotlib Axes or Figure instance.\"', '        raise TypeError(err)', '', '    if old_legend is None:', '        err = f\"{obj} has no legend attached.\"', '        raise ValueError(err)', '', '    # Extract the components of the legend we need to reuse', '    handles = old_legend.legendHandles', '    labels = [t.get_text() for t in old_legend.get_texts()]', '', '    # Extract legend properties that can be passed to the recreation method', \"    # (Vexingly, these don't all round-trip)\", '    legend_kws = inspect.signature(mpl.legend.Legend).parameters', '    props = {k: v for k, v in old_legend.properties().items() if k in legend_kws}', '', '    # Delegate default bbox_to_anchor rules to matplotlib', '    props.pop(\"bbox_to_anchor\")', '', '    # Try to propagate the existing title and font properties; respect new ones too', '    title = props.pop(\"title\")', '    if \"title\" in kwargs:', '        title.set_text(kwargs.pop(\"title\"))', '    title_kwargs = {k: v for k, v in kwargs.items() if k.startswith(\"title_\")}', '    for key, val in title_kwargs.items():', '        title.set(**{key[6:]: val})', '        kwargs.pop(key)', '', '    # Try to respect the frame visibility', '    kwargs.setdefault(\"frameon\", old_legend.legendPatch.get_visible())', '', '    # Remove the old legend and create the new one', '    props.update(kwargs)', '    old_legend.remove()', '    new_legend = legend_func(handles, labels, loc=loc, **props)', '    new_legend.set_title(title.get_text(), title.get_fontproperties())', '', '    # Let the Grid object continue to track the correct legend object', '    if isinstance(obj, Grid):', '        obj._legend = new_legend']}, {'name': '_kde_support', 'start_line': 486, 'end_line': 492, 'text': ['def _kde_support(data, bw, gridsize, cut, clip):', '    \"\"\"Establish support for a kernel density estimate.\"\"\"', '    support_min = max(data.min() - bw * cut, clip[0])', '    support_max = min(data.max() + bw * cut, clip[1])', '    support = np.linspace(support_min, support_max, gridsize)', '', '    return support']}, {'name': 'ci', 'start_line': 495, 'end_line': 498, 'text': ['def ci(a, which=95, axis=None):', '    \"\"\"Return a percentile range from an array of values.\"\"\"', '    p = 50 - which / 2, 50 + which / 2', '    return np.nanpercentile(a, p, axis)']}, {'name': 'get_dataset_names', 'start_line': 501, 'end_line': 513, 'text': ['def get_dataset_names():', '    \"\"\"Report available example datasets, useful for reporting issues.', '', '    Requires an internet connection.', '', '    \"\"\"', '    url = \"https://github.com/mwaskom/seaborn-data\"', '    with urlopen(url) as resp:', '        html = resp.read()', '', '    pat = r\"/mwaskom/seaborn-data/blob/master/(\\\\w*).csv\"', '    datasets = re.findall(pat, html.decode())', '    return datasets']}, {'name': 'get_data_home', 'start_line': 516, 'end_line': 531, 'text': ['def get_data_home(data_home=None):', '    \"\"\"Return a path to the cache directory for example datasets.', '', '    This directory is used by :func:`load_dataset`.', '', '    If the ``data_home`` argument is not provided, it will use a directory', '    specified by the `SEABORN_DATA` environment variable (if it exists)', '    or otherwise default to an OS-appropriate user cache location.', '', '    \"\"\"', '    if data_home is None:', '        data_home = os.environ.get(\"SEABORN_DATA\", user_cache_dir(\"seaborn\"))', '    data_home = os.path.expanduser(data_home)', '    if not os.path.exists(data_home):', '        os.makedirs(data_home)', '    return data_home']}, {'name': 'load_dataset', 'start_line': 534, 'end_line': 639, 'text': ['def load_dataset(name, cache=True, data_home=None, **kws):', '    \"\"\"Load an example dataset from the online repository (requires internet).', '', '    This function provides quick access to a small number of example datasets', '    that are useful for documenting seaborn or generating reproducible examples', '    for bug reports. It is not necessary for normal usage.', '', '    Note that some of the datasets have a small amount of preprocessing applied', '    to define a proper ordering for categorical variables.', '', '    Use :func:`get_dataset_names` to see a list of available datasets.', '', '    Parameters', '    ----------', '    name : str', '        Name of the dataset (``{name}.csv`` on', '        https://github.com/mwaskom/seaborn-data).', '    cache : boolean, optional', '        If True, try to load from the local cache first, and save to the cache', '        if a download is required.', '    data_home : string, optional', '        The directory in which to cache data; see :func:`get_data_home`.', '    kws : keys and values, optional', '        Additional keyword arguments are passed to passed through to', '        :func:`pandas.read_csv`.', '', '    Returns', '    -------', '    df : :class:`pandas.DataFrame`', '        Tabular data, possibly with some preprocessing applied.', '', '    \"\"\"', \"    # A common beginner mistake is to assume that one's personal data needs\", '    # to be passed through this function to be usable with seaborn.', \"    # Let's provide a more helpful error than you would otherwise get.\", '    if isinstance(name, pd.DataFrame):', '        err = (', '            \"This function accepts only strings (the name of an example dataset). \"', '            \"You passed a pandas DataFrame. If you have your own dataset, \"', '            \"it is not necessary to use this function before plotting.\"', '        )', '        raise TypeError(err)', '', '    url = f\"https://raw.githubusercontent.com/mwaskom/seaborn-data/master/{name}.csv\"', '', '    if cache:', '        cache_path = os.path.join(get_data_home(data_home), os.path.basename(url))', '        if not os.path.exists(cache_path):', '            if name not in get_dataset_names():', '                raise ValueError(f\"\\'{name}\\' is not one of the example datasets.\")', '            urlretrieve(url, cache_path)', '        full_path = cache_path', '    else:', '        full_path = url', '', '    df = pd.read_csv(full_path, **kws)', '', '    if df.iloc[-1].isnull().all():', '        df = df.iloc[:-1]', '', '    # Set some columns as a categorical type with ordered levels', '', '    if name == \"tips\":', '        df[\"day\"] = pd.Categorical(df[\"day\"], [\"Thur\", \"Fri\", \"Sat\", \"Sun\"])', '        df[\"sex\"] = pd.Categorical(df[\"sex\"], [\"Male\", \"Female\"])', '        df[\"time\"] = pd.Categorical(df[\"time\"], [\"Lunch\", \"Dinner\"])', '        df[\"smoker\"] = pd.Categorical(df[\"smoker\"], [\"Yes\", \"No\"])', '', '    elif name == \"flights\":', '        months = df[\"month\"].str[:3]', '        df[\"month\"] = pd.Categorical(months, months.unique())', '', '    elif name == \"exercise\":', '        df[\"time\"] = pd.Categorical(df[\"time\"], [\"1 min\", \"15 min\", \"30 min\"])', '        df[\"kind\"] = pd.Categorical(df[\"kind\"], [\"rest\", \"walking\", \"running\"])', '        df[\"diet\"] = pd.Categorical(df[\"diet\"], [\"no fat\", \"low fat\"])', '', '    elif name == \"titanic\":', '        df[\"class\"] = pd.Categorical(df[\"class\"], [\"First\", \"Second\", \"Third\"])', '        df[\"deck\"] = pd.Categorical(df[\"deck\"], list(\"ABCDEFG\"))', '', '    elif name == \"penguins\":', '        df[\"sex\"] = df[\"sex\"].str.title()', '', '    elif name == \"diamonds\":', '        df[\"color\"] = pd.Categorical(', '            df[\"color\"], [\"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"],', '        )', '        df[\"clarity\"] = pd.Categorical(', '            df[\"clarity\"], [\"IF\", \"VVS1\", \"VVS2\", \"VS1\", \"VS2\", \"SI1\", \"SI2\", \"I1\"],', '        )', '        df[\"cut\"] = pd.Categorical(', '            df[\"cut\"], [\"Ideal\", \"Premium\", \"Very Good\", \"Good\", \"Fair\"],', '        )', '', '    elif name == \"taxis\":', '        df[\"pickup\"] = pd.to_datetime(df[\"pickup\"])', '        df[\"dropoff\"] = pd.to_datetime(df[\"dropoff\"])', '', '    elif name == \"seaice\":', '        df[\"Date\"] = pd.to_datetime(df[\"Date\"])', '', '    elif name == \"dowjones\":', '        df[\"Date\"] = pd.to_datetime(df[\"Date\"])', '', '    return df']}, {'name': 'axis_ticklabels_overlap', 'start_line': 642, 'end_line': 663, 'text': ['def axis_ticklabels_overlap(labels):', '    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.', '', '    Parameters', '    ----------', '    labels : list of matplotlib ticklabels', '', '    Returns', '    -------', '    overlap : boolean', '        True if any of the labels overlap.', '', '    \"\"\"', '    if not labels:', '        return False', '    try:', '        bboxes = [l.get_window_extent() for l in labels]', '        overlaps = [b.count_overlaps(bboxes) for b in bboxes]', '        return max(overlaps) > 1', '    except RuntimeError:', '        # Issue on macos backend raises an error in the above code', '        return False']}, {'name': 'axes_ticklabels_overlap', 'start_line': 666, 'end_line': 680, 'text': ['def axes_ticklabels_overlap(ax):', '    \"\"\"Return booleans for whether the x and y ticklabels on an Axes overlap.', '', '    Parameters', '    ----------', '    ax : matplotlib Axes', '', '    Returns', '    -------', '    x_overlap, y_overlap : booleans', '        True when the labels on that axis overlap.', '', '    \"\"\"', '    return (axis_ticklabels_overlap(ax.get_xticklabels()),', '            axis_ticklabels_overlap(ax.get_yticklabels()))']}, {'name': 'locator_to_legend_entries', 'start_line': 683, 'end_line': 706, 'text': ['def locator_to_legend_entries(locator, limits, dtype):', '    \"\"\"Return levels and formatted levels for brief numeric legends.\"\"\"', '    raw_levels = locator.tick_values(*limits).astype(dtype)', '', '    # The locator can return ticks outside the limits, clip them here', '    raw_levels = [l for l in raw_levels if l >= limits[0] and l <= limits[1]]', '', '    class dummy_axis:', '        def get_view_interval(self):', '            return limits', '', '    if isinstance(locator, mpl.ticker.LogLocator):', '        formatter = mpl.ticker.LogFormatter()', '    else:', '        formatter = mpl.ticker.ScalarFormatter()', '    formatter.axis = dummy_axis()', '', '    # TODO: The following two lines should be replaced', '    # once pinned matplotlib>=3.1.0 with:', '    # formatted_levels = formatter.format_ticks(raw_levels)', '    formatter.set_locs(raw_levels)', '    formatted_levels = [formatter(x) for x in raw_levels]', '', '    return raw_levels, formatted_levels']}, {'name': 'relative_luminance', 'start_line': 709, 'end_line': 728, 'text': ['def relative_luminance(color):', '    \"\"\"Calculate the relative luminance of a color according to W3C standards', '', '    Parameters', '    ----------', '    color : matplotlib color or sequence of matplotlib colors', '        Hex code, rgb-tuple, or html color name.', '', '    Returns', '    -------', '    luminance : float(s) between 0 and 1', '', '    \"\"\"', '    rgb = mpl.colors.colorConverter.to_rgba_array(color)[:, :3]', '    rgb = np.where(rgb <= .03928, rgb / 12.92, ((rgb + .055) / 1.055) ** 2.4)', '    lum = rgb.dot([.2126, .7152, .0722])', '    try:', '        return lum.item()', '    except ValueError:', '        return lum']}, {'name': 'to_utf8', 'start_line': 731, 'end_line': 757, 'text': ['def to_utf8(obj):', '    \"\"\"Return a string representing a Python object.', '', '    Strings (i.e. type ``str``) are returned unchanged.', '', '    Byte strings (i.e. type ``bytes``) are returned as UTF-8-decoded strings.', '', '    For other objects, the method ``__str__()`` is called, and the result is', '    returned as a string.', '', '    Parameters', '    ----------', '    obj : object', '        Any Python object', '', '    Returns', '    -------', '    s : str', '        UTF-8-decoded string representation of ``obj``', '', '    \"\"\"', '    if isinstance(obj, str):', '        return obj', '    try:', '        return obj.decode(encoding=\"utf-8\")', '    except AttributeError:  # obj is not bytes-like', '        return str(obj)']}, {'name': '_normalize_kwargs', 'start_line': 760, 'end_line': 777, 'text': ['def _normalize_kwargs(kws, artist):', '    \"\"\"Wrapper for mpl.cbook.normalize_kwargs that supports <= 3.2.1.\"\"\"', '    _alias_map = {', \"        'color': ['c'],\", \"        'linewidth': ['lw'],\", \"        'linestyle': ['ls'],\", \"        'facecolor': ['fc'],\", \"        'edgecolor': ['ec'],\", \"        'markerfacecolor': ['mfc'],\", \"        'markeredgecolor': ['mec'],\", \"        'markeredgewidth': ['mew'],\", \"        'markersize': ['ms']\", '    }', '    try:', '        kws = normalize_kwargs(kws, artist)', '    except AttributeError:', '        kws = normalize_kwargs(kws, _alias_map)', '    return kws']}, {'name': '_check_argument', 'start_line': 780, 'end_line': 785, 'text': ['def _check_argument(param, options, value):', '    \"\"\"Raise if value for param is not in options.\"\"\"', '    if value not in options:', '        raise ValueError(', '            f\"`{param}` must be one of {options}, but {repr(value)} was passed.\"', '        )']}, {'name': '_assign_default_kwargs', 'start_line': 788, 'end_line': 804, 'text': ['def _assign_default_kwargs(kws, call_func, source_func):', '    \"\"\"Assign default kwargs for call_func using values from source_func.\"\"\"', '    # This exists so that axes-level functions and figure-level functions can', '    # both call a Plotter method while having the default kwargs be defined in', '    # the signature of the axes-level function.', '    # An alternative would be to have a decorator on the method that sets its', '    # defaults based on those defined in the axes-level function.', '    # Then the figure-level function would not need to worry about defaults.', '    # I am not sure which is better.', '    needed = inspect.signature(call_func).parameters', '    defaults = inspect.signature(source_func).parameters', '', '    for param in needed:', '        if param in defaults and param not in kws:', '            kws[param] = defaults[param].default', '', '    return kws']}, {'name': 'adjust_legend_subtitles', 'start_line': 807, 'end_line': 824, 'text': ['def adjust_legend_subtitles(legend):', '    \"\"\"', '    Make invisible-handle \"subtitles\" entries look more like titles.', '', '    Note: This function is not part of the public API and may be changed or removed.', '', '    \"\"\"', '    # Legend title not in rcParams until 3.0', '    font_size = plt.rcParams.get(\"legend.title_fontsize\", None)', '    hpackers = legend.findobj(mpl.offsetbox.VPacker)[0].get_children()', '    for hpack in hpackers:', '        draw_area, text_area = hpack.get_children()', '        handles = draw_area.get_children()', '        if not all(artist.get_visible() for artist in handles):', '            draw_area.set_width(0)', '            for text in text_area.get_children():', '                if font_size is not None:', '                    text.set_size(font_size)']}, {'name': '_deprecate_ci', 'start_line': 827, 'end_line': 849, 'text': ['def _deprecate_ci(errorbar, ci):', '    \"\"\"', '    Warn on usage of ci= and convert to appropriate errorbar= arg.', '', '    ci was deprecated when errorbar was added in 0.12. It should not be removed', '    completely for some time, but it can be moved out of function definitions', '    (and extracted from kwargs) after one cycle.', '', '    \"\"\"', '    if ci != \"deprecated\":', '        if ci is None:', '            errorbar = None', '        elif ci == \"sd\":', '            errorbar = \"sd\"', '        else:', '            errorbar = (\"ci\", ci)', '        msg = (', '            \"\\\\n\\\\nThe `ci` parameter is deprecated. \"', '            f\"Use `errorbar={repr(errorbar)}` for the same effect.\\\\n\"', '        )', '        warnings.warn(msg, FutureWarning, stacklevel=3)', '', '    return errorbar']}, {'name': '_disable_autolayout', 'start_line': 853, 'end_line': 868, 'text': ['def _disable_autolayout():', '    \"\"\"Context manager for preventing rc-controlled auto-layout behavior.\"\"\"', '    # This is a workaround for an issue in matplotlib, for details see', '    # https://github.com/mwaskom/seaborn/issues/2914', '    # The only affect of this rcParam is to set the default value for', '    # layout= in plt.figure, so we could just do that instead.', '    # But then we would need to own the complexity of the transition', '    # from tight_layout=True -> layout=\"tight\". This seems easier,', '    # but can be removed when (if) that is simpler on the matplotlib side,', '    # or if the layout algorithms are improved to handle figure legends.', '    orig_val = mpl.rcParams[\"figure.autolayout\"]', '    try:', '        mpl.rcParams[\"figure.autolayout\"] = False', '        yield', '    finally:', '        mpl.rcParams[\"figure.autolayout\"] = orig_val']}], 'text': ['\"\"\"Utility functions, mostly for internal use.\"\"\"', 'import os', 'import re', 'import inspect', 'import warnings', 'import colorsys', 'from contextlib import contextmanager', 'from urllib.request import urlopen, urlretrieve', '', 'import numpy as np', 'import pandas as pd', 'import matplotlib as mpl', 'from matplotlib.colors import to_rgb', 'import matplotlib.pyplot as plt', 'from matplotlib.cbook import normalize_kwargs', '', 'from .external.version import Version', 'from .external.appdirs import user_cache_dir', '', '__all__ = [\"desaturate\", \"saturate\", \"set_hls_values\", \"move_legend\",', '           \"despine\", \"get_dataset_names\", \"get_data_home\", \"load_dataset\"]', '', '', 'def ci_to_errsize(cis, heights):', '    \"\"\"Convert intervals to error arguments relative to plot heights.', '', '    Parameters', '    ----------', '    cis : 2 x n sequence', '        sequence of confidence interval limits', '    heights : n sequence', '        sequence of plot heights', '', '    Returns', '    -------', '    errsize : 2 x n array', '        sequence of error size relative to height values in correct', '        format as argument for plt.bar', '', '    \"\"\"', '    cis = np.atleast_2d(cis).reshape(2, -1)', '    heights = np.atleast_1d(heights)', '    errsize = []', '    for i, (low, high) in enumerate(np.transpose(cis)):', '        h = heights[i]', '        elow = h - low', '        ehigh = high - h', '        errsize.append([elow, ehigh])', '', '    errsize = np.asarray(errsize).T', '    return errsize', '', '', 'def _normal_quantile_func(q):', '    \"\"\"', '    Compute the quantile function of the standard normal distribution.', '', '    This wrapper exists because we are dropping scipy as a mandatory dependency', '    but statistics.NormalDist was added to the standard library in 3.8.', '', '    \"\"\"', '    try:', '        from statistics import NormalDist', '        qf = np.vectorize(NormalDist().inv_cdf)', '    except ImportError:', '        try:', '            from scipy.stats import norm', '            qf = norm.ppf', '        except ImportError:', '            msg = (', '                \"Standard normal quantile functions require either Python>=3.8 or scipy\"', '            )', '            raise RuntimeError(msg)', '    return qf(q)', '', '', 'def _draw_figure(fig):', '    \"\"\"Force draw of a matplotlib figure, accounting for back-compat.\"\"\"', '    # See https://github.com/matplotlib/matplotlib/issues/19197 for context', '    fig.canvas.draw()', '    if fig.stale:', '        try:', '            fig.draw(fig.canvas.get_renderer())', '        except AttributeError:', '            pass', '', '', 'def _default_color(method, hue, color, kws):', '    \"\"\"If needed, get a default color by using the matplotlib property cycle.\"\"\"', '    if hue is not None:', \"        # This warning is probably user-friendly, but it's currently triggered\", \"        # in a FacetGrid context and I don't want to mess with that logic right now\", '        #  if color is not None:', '        #      msg = \"`color` is ignored when `hue` is assigned.\"', '        #      warnings.warn(msg)', '        return None', '', '    if color is not None:', '        return color', '', '    elif method.__name__ == \"plot\":', '', '        color = _normalize_kwargs(kws, mpl.lines.Line2D).get(\"color\")', '        scout, = method([], [], scalex=False, scaley=False, color=color)', '        color = scout.get_color()', '        scout.remove()', '', '    elif method.__name__ == \"scatter\":', '', \"        # Matplotlib will raise if the size of x/y don't match s/c,\", '        # and the latter might be in the kws dict', '        scout_size = max(', '            np.atleast_1d(kws.get(key, [])).shape[0]', '            for key in [\"s\", \"c\", \"fc\", \"facecolor\", \"facecolors\"]', '        )', '        scout_x = scout_y = np.full(scout_size, np.nan)', '', '        scout = method(scout_x, scout_y, **kws)', '        facecolors = scout.get_facecolors()', '', '        if not len(facecolors):', '            # Handle bug in matplotlib <= 3.2 (I think)', '            # This will limit the ability to use non color= kwargs to specify', '            # a color in versions of matplotlib with the bug, but trying to', '            # work out what the user wanted by re-implementing the broken logic', '            # of inspecting the kwargs is probably too brittle.', '            single_color = False', '        else:', '            single_color = np.unique(facecolors, axis=0).shape[0] == 1', '', '        # Allow the user to specify an array of colors through various kwargs', '        if \"c\" not in kws and single_color:', '            color = to_rgb(facecolors[0])', '', '        scout.remove()', '', '    elif method.__name__ == \"bar\":', '', '        # bar() needs masked, not empty data, to generate a patch', '        scout, = method([np.nan], [np.nan], **kws)', '        color = to_rgb(scout.get_facecolor())', '        scout.remove()', '', '    elif method.__name__ == \"fill_between\":', '', '        # There is a bug on matplotlib < 3.3 where fill_between with', '        # datetime units and empty data will set incorrect autoscale limits', \"        # To workaround it, we'll always return the first color in the cycle.\", '        # https://github.com/matplotlib/matplotlib/issues/17586', '        ax = method.__self__', '        datetime_axis = any([', '            isinstance(ax.xaxis.converter, mpl.dates.DateConverter),', '            isinstance(ax.yaxis.converter, mpl.dates.DateConverter),', '        ])', '        if Version(mpl.__version__) < Version(\"3.3\") and datetime_axis:', '            return \"C0\"', '', '        kws = _normalize_kwargs(kws, mpl.collections.PolyCollection)', '', '        scout = method([], [], **kws)', '        facecolor = scout.get_facecolor()', '        color = to_rgb(facecolor[0])', '        scout.remove()', '', '    return color', '', '', 'def desaturate(color, prop):', '    \"\"\"Decrease the saturation channel of a color by some percent.', '', '    Parameters', '    ----------', '    color : matplotlib color', '        hex, rgb-tuple, or html color name', '    prop : float', '        saturation channel of color will be multiplied by this value', '', '    Returns', '    -------', '    new_color : rgb tuple', '        desaturated color code in RGB tuple representation', '', '    \"\"\"', '    # Check inputs', '    if not 0 <= prop <= 1:', '        raise ValueError(\"prop must be between 0 and 1\")', '', '    # Get rgb tuple rep', '    rgb = to_rgb(color)', '', '    # Convert to hls', '    h, l, s = colorsys.rgb_to_hls(*rgb)', '', '    # Desaturate the saturation channel', '    s *= prop', '', '    # Convert back to rgb', '    new_color = colorsys.hls_to_rgb(h, l, s)', '', '    return new_color', '', '', 'def saturate(color):', '    \"\"\"Return a fully saturated color with the same hue.', '', '    Parameters', '    ----------', '    color : matplotlib color', '        hex, rgb-tuple, or html color name', '', '    Returns', '    -------', '    new_color : rgb tuple', '        saturated color code in RGB tuple representation', '', '    \"\"\"', '    return set_hls_values(color, s=1)', '', '', 'def set_hls_values(color, h=None, l=None, s=None):  # noqa', '    \"\"\"Independently manipulate the h, l, or s channels of a color.', '', '    Parameters', '    ----------', '    color : matplotlib color', '        hex, rgb-tuple, or html color name', '    h, l, s : floats between 0 and 1, or None', '        new values for each channel in hls space', '', '    Returns', '    -------', '    new_color : rgb tuple', '        new color code in RGB tuple representation', '', '    \"\"\"', '    # Get an RGB tuple representation', '    rgb = to_rgb(color)', '    vals = list(colorsys.rgb_to_hls(*rgb))', '    for i, val in enumerate([h, l, s]):', '        if val is not None:', '            vals[i] = val', '', '    rgb = colorsys.hls_to_rgb(*vals)', '    return rgb', '', '', 'def axlabel(xlabel, ylabel, **kwargs):', '    \"\"\"Grab current axis and label it.', '', '    DEPRECATED: will be removed in a future version.', '', '    \"\"\"', '    msg = \"This function is deprecated and will be removed in a future version\"', '    warnings.warn(msg, FutureWarning)', '    ax = plt.gca()', '    ax.set_xlabel(xlabel, **kwargs)', '    ax.set_ylabel(ylabel, **kwargs)', '', '', 'def remove_na(vector):', '    \"\"\"Helper method for removing null values from data vectors.', '', '    Parameters', '    ----------', '    vector : vector object', '        Must implement boolean masking with [] subscript syntax.', '', '    Returns', '    -------', '    clean_clean : same type as ``vector``', '        Vector of data with null values removed. May be a copy or a view.', '', '    \"\"\"', '    return vector[pd.notnull(vector)]', '', '', 'def get_color_cycle():', '    \"\"\"Return the list of colors in the current matplotlib color cycle', '', '    Parameters', '    ----------', '    None', '', '    Returns', '    -------', '    colors : list', '        List of matplotlib colors in the current cycle, or dark gray if', '        the current color cycle is empty.', '    \"\"\"', \"    cycler = mpl.rcParams['axes.prop_cycle']\", '    return cycler.by_key()[\\'color\\'] if \\'color\\' in cycler.keys else [\".15\"]', '', '', 'def despine(fig=None, ax=None, top=True, right=True, left=False,', '            bottom=False, offset=None, trim=False):', '    \"\"\"Remove the top and right spines from plot(s).', '', '    fig : matplotlib figure, optional', '        Figure to despine all axes of, defaults to the current figure.', '    ax : matplotlib axes, optional', '        Specific axes object to despine. Ignored if fig is provided.', '    top, right, left, bottom : boolean, optional', '        If True, remove that spine.', '    offset : int or dict, optional', '        Absolute distance, in points, spines should be moved away', '        from the axes (negative values move spines inward). A single value', '        applies to all spines; a dict can be used to set offset values per', '        side.', '    trim : bool, optional', '        If True, limit spines to the smallest and largest major tick', '        on each non-despined axis.', '', '    Returns', '    -------', '    None', '', '    \"\"\"', '    # Get references to the axes we want', '    if fig is None and ax is None:', '        axes = plt.gcf().axes', '    elif fig is not None:', '        axes = fig.axes', '    elif ax is not None:', '        axes = [ax]', '', '    for ax_i in axes:', '        for side in [\"top\", \"right\", \"left\", \"bottom\"]:', '            # Toggle the spine objects', '            is_visible = not locals()[side]', '            ax_i.spines[side].set_visible(is_visible)', '            if offset is not None and is_visible:', '                try:', '                    val = offset.get(side, 0)', '                except AttributeError:', '                    val = offset', \"                ax_i.spines[side].set_position(('outward', val))\", '', '        # Potentially move the ticks', '        if left and not right:', '            maj_on = any(', '                t.tick1line.get_visible()', '                for t in ax_i.yaxis.majorTicks', '            )', '            min_on = any(', '                t.tick1line.get_visible()', '                for t in ax_i.yaxis.minorTicks', '            )', '            ax_i.yaxis.set_ticks_position(\"right\")', '            for t in ax_i.yaxis.majorTicks:', '                t.tick2line.set_visible(maj_on)', '            for t in ax_i.yaxis.minorTicks:', '                t.tick2line.set_visible(min_on)', '', '        if bottom and not top:', '            maj_on = any(', '                t.tick1line.get_visible()', '                for t in ax_i.xaxis.majorTicks', '            )', '            min_on = any(', '                t.tick1line.get_visible()', '                for t in ax_i.xaxis.minorTicks', '            )', '            ax_i.xaxis.set_ticks_position(\"top\")', '            for t in ax_i.xaxis.majorTicks:', '                t.tick2line.set_visible(maj_on)', '            for t in ax_i.xaxis.minorTicks:', '                t.tick2line.set_visible(min_on)', '', '        if trim:', '            # clip off the parts of the spines that extend past major ticks', '            xticks = np.asarray(ax_i.get_xticks())', '            if xticks.size:', '                firsttick = np.compress(xticks >= min(ax_i.get_xlim()),', '                                        xticks)[0]', '                lasttick = np.compress(xticks <= max(ax_i.get_xlim()),', '                                       xticks)[-1]', \"                ax_i.spines['bottom'].set_bounds(firsttick, lasttick)\", \"                ax_i.spines['top'].set_bounds(firsttick, lasttick)\", '                newticks = xticks.compress(xticks <= lasttick)', '                newticks = newticks.compress(newticks >= firsttick)', '                ax_i.set_xticks(newticks)', '', '            yticks = np.asarray(ax_i.get_yticks())', '            if yticks.size:', '                firsttick = np.compress(yticks >= min(ax_i.get_ylim()),', '                                        yticks)[0]', '                lasttick = np.compress(yticks <= max(ax_i.get_ylim()),', '                                       yticks)[-1]', \"                ax_i.spines['left'].set_bounds(firsttick, lasttick)\", \"                ax_i.spines['right'].set_bounds(firsttick, lasttick)\", '                newticks = yticks.compress(yticks <= lasttick)', '                newticks = newticks.compress(newticks >= firsttick)', '                ax_i.set_yticks(newticks)', '', '', 'def move_legend(obj, loc, **kwargs):', '    \"\"\"', \"    Recreate a plot's legend at a new location.\", '', '    The name is a slight misnomer. Matplotlib legends do not expose public', '    control over their position parameters. So this function creates a new legend,', '    copying over the data from the original object, which is then removed.', '', '    Parameters', '    ----------', '    obj : the object with the plot', '        This argument can be either a seaborn or matplotlib object:', '', '        - :class:`seaborn.FacetGrid` or :class:`seaborn.PairGrid`', '        - :class:`matplotlib.axes.Axes` or :class:`matplotlib.figure.Figure`', '', '    loc : str or int', '        Location argument, as in :meth:`matplotlib.axes.Axes.legend`.', '', '    kwargs', '        Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.legend`.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/move_legend.rst', '', '    \"\"\"', '    # This is a somewhat hackish solution that will hopefully be obviated by', '    # upstream improvements to matplotlib legends that make them easier to', '    # modify after creation.', '', '    from seaborn.axisgrid import Grid  # Avoid circular import', '', '    # Locate the legend object and a method to recreate the legend', '    if isinstance(obj, Grid):', '        old_legend = obj.legend', '        legend_func = obj.figure.legend', '    elif isinstance(obj, mpl.axes.Axes):', '        old_legend = obj.legend_', '        legend_func = obj.legend', '    elif isinstance(obj, mpl.figure.Figure):', '        if obj.legends:', '            old_legend = obj.legends[-1]', '        else:', '            old_legend = None', '        legend_func = obj.legend', '    else:', '        err = \"`obj` must be a seaborn Grid or matplotlib Axes or Figure instance.\"', '        raise TypeError(err)', '', '    if old_legend is None:', '        err = f\"{obj} has no legend attached.\"', '        raise ValueError(err)', '', '    # Extract the components of the legend we need to reuse', '    handles = old_legend.legendHandles', '    labels = [t.get_text() for t in old_legend.get_texts()]', '', '    # Extract legend properties that can be passed to the recreation method', \"    # (Vexingly, these don't all round-trip)\", '    legend_kws = inspect.signature(mpl.legend.Legend).parameters', '    props = {k: v for k, v in old_legend.properties().items() if k in legend_kws}', '', '    # Delegate default bbox_to_anchor rules to matplotlib', '    props.pop(\"bbox_to_anchor\")', '', '    # Try to propagate the existing title and font properties; respect new ones too', '    title = props.pop(\"title\")', '    if \"title\" in kwargs:', '        title.set_text(kwargs.pop(\"title\"))', '    title_kwargs = {k: v for k, v in kwargs.items() if k.startswith(\"title_\")}', '    for key, val in title_kwargs.items():', '        title.set(**{key[6:]: val})', '        kwargs.pop(key)', '', '    # Try to respect the frame visibility', '    kwargs.setdefault(\"frameon\", old_legend.legendPatch.get_visible())', '', '    # Remove the old legend and create the new one', '    props.update(kwargs)', '    old_legend.remove()', '    new_legend = legend_func(handles, labels, loc=loc, **props)', '    new_legend.set_title(title.get_text(), title.get_fontproperties())', '', '    # Let the Grid object continue to track the correct legend object', '    if isinstance(obj, Grid):', '        obj._legend = new_legend', '', '', 'def _kde_support(data, bw, gridsize, cut, clip):', '    \"\"\"Establish support for a kernel density estimate.\"\"\"', '    support_min = max(data.min() - bw * cut, clip[0])', '    support_max = min(data.max() + bw * cut, clip[1])', '    support = np.linspace(support_min, support_max, gridsize)', '', '    return support', '', '', 'def ci(a, which=95, axis=None):', '    \"\"\"Return a percentile range from an array of values.\"\"\"', '    p = 50 - which / 2, 50 + which / 2', '    return np.nanpercentile(a, p, axis)', '', '', 'def get_dataset_names():', '    \"\"\"Report available example datasets, useful for reporting issues.', '', '    Requires an internet connection.', '', '    \"\"\"', '    url = \"https://github.com/mwaskom/seaborn-data\"', '    with urlopen(url) as resp:', '        html = resp.read()', '', '    pat = r\"/mwaskom/seaborn-data/blob/master/(\\\\w*).csv\"', '    datasets = re.findall(pat, html.decode())', '    return datasets', '', '', 'def get_data_home(data_home=None):', '    \"\"\"Return a path to the cache directory for example datasets.', '', '    This directory is used by :func:`load_dataset`.', '', '    If the ``data_home`` argument is not provided, it will use a directory', '    specified by the `SEABORN_DATA` environment variable (if it exists)', '    or otherwise default to an OS-appropriate user cache location.', '', '    \"\"\"', '    if data_home is None:', '        data_home = os.environ.get(\"SEABORN_DATA\", user_cache_dir(\"seaborn\"))', '    data_home = os.path.expanduser(data_home)', '    if not os.path.exists(data_home):', '        os.makedirs(data_home)', '    return data_home', '', '', 'def load_dataset(name, cache=True, data_home=None, **kws):', '    \"\"\"Load an example dataset from the online repository (requires internet).', '', '    This function provides quick access to a small number of example datasets', '    that are useful for documenting seaborn or generating reproducible examples', '    for bug reports. It is not necessary for normal usage.', '', '    Note that some of the datasets have a small amount of preprocessing applied', '    to define a proper ordering for categorical variables.', '', '    Use :func:`get_dataset_names` to see a list of available datasets.', '', '    Parameters', '    ----------', '    name : str', '        Name of the dataset (``{name}.csv`` on', '        https://github.com/mwaskom/seaborn-data).', '    cache : boolean, optional', '        If True, try to load from the local cache first, and save to the cache', '        if a download is required.', '    data_home : string, optional', '        The directory in which to cache data; see :func:`get_data_home`.', '    kws : keys and values, optional', '        Additional keyword arguments are passed to passed through to', '        :func:`pandas.read_csv`.', '', '    Returns', '    -------', '    df : :class:`pandas.DataFrame`', '        Tabular data, possibly with some preprocessing applied.', '', '    \"\"\"', \"    # A common beginner mistake is to assume that one's personal data needs\", '    # to be passed through this function to be usable with seaborn.', \"    # Let's provide a more helpful error than you would otherwise get.\", '    if isinstance(name, pd.DataFrame):', '        err = (', '            \"This function accepts only strings (the name of an example dataset). \"', '            \"You passed a pandas DataFrame. If you have your own dataset, \"', '            \"it is not necessary to use this function before plotting.\"', '        )', '        raise TypeError(err)', '', '    url = f\"https://raw.githubusercontent.com/mwaskom/seaborn-data/master/{name}.csv\"', '', '    if cache:', '        cache_path = os.path.join(get_data_home(data_home), os.path.basename(url))', '        if not os.path.exists(cache_path):', '            if name not in get_dataset_names():', '                raise ValueError(f\"\\'{name}\\' is not one of the example datasets.\")', '            urlretrieve(url, cache_path)', '        full_path = cache_path', '    else:', '        full_path = url', '', '    df = pd.read_csv(full_path, **kws)', '', '    if df.iloc[-1].isnull().all():', '        df = df.iloc[:-1]', '', '    # Set some columns as a categorical type with ordered levels', '', '    if name == \"tips\":', '        df[\"day\"] = pd.Categorical(df[\"day\"], [\"Thur\", \"Fri\", \"Sat\", \"Sun\"])', '        df[\"sex\"] = pd.Categorical(df[\"sex\"], [\"Male\", \"Female\"])', '        df[\"time\"] = pd.Categorical(df[\"time\"], [\"Lunch\", \"Dinner\"])', '        df[\"smoker\"] = pd.Categorical(df[\"smoker\"], [\"Yes\", \"No\"])', '', '    elif name == \"flights\":', '        months = df[\"month\"].str[:3]', '        df[\"month\"] = pd.Categorical(months, months.unique())', '', '    elif name == \"exercise\":', '        df[\"time\"] = pd.Categorical(df[\"time\"], [\"1 min\", \"15 min\", \"30 min\"])', '        df[\"kind\"] = pd.Categorical(df[\"kind\"], [\"rest\", \"walking\", \"running\"])', '        df[\"diet\"] = pd.Categorical(df[\"diet\"], [\"no fat\", \"low fat\"])', '', '    elif name == \"titanic\":', '        df[\"class\"] = pd.Categorical(df[\"class\"], [\"First\", \"Second\", \"Third\"])', '        df[\"deck\"] = pd.Categorical(df[\"deck\"], list(\"ABCDEFG\"))', '', '    elif name == \"penguins\":', '        df[\"sex\"] = df[\"sex\"].str.title()', '', '    elif name == \"diamonds\":', '        df[\"color\"] = pd.Categorical(', '            df[\"color\"], [\"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"],', '        )', '        df[\"clarity\"] = pd.Categorical(', '            df[\"clarity\"], [\"IF\", \"VVS1\", \"VVS2\", \"VS1\", \"VS2\", \"SI1\", \"SI2\", \"I1\"],', '        )', '        df[\"cut\"] = pd.Categorical(', '            df[\"cut\"], [\"Ideal\", \"Premium\", \"Very Good\", \"Good\", \"Fair\"],', '        )', '', '    elif name == \"taxis\":', '        df[\"pickup\"] = pd.to_datetime(df[\"pickup\"])', '        df[\"dropoff\"] = pd.to_datetime(df[\"dropoff\"])', '', '    elif name == \"seaice\":', '        df[\"Date\"] = pd.to_datetime(df[\"Date\"])', '', '    elif name == \"dowjones\":', '        df[\"Date\"] = pd.to_datetime(df[\"Date\"])', '', '    return df', '', '', 'def axis_ticklabels_overlap(labels):', '    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.', '', '    Parameters', '    ----------', '    labels : list of matplotlib ticklabels', '', '    Returns', '    -------', '    overlap : boolean', '        True if any of the labels overlap.', '', '    \"\"\"', '    if not labels:', '        return False', '    try:', '        bboxes = [l.get_window_extent() for l in labels]', '        overlaps = [b.count_overlaps(bboxes) for b in bboxes]', '        return max(overlaps) > 1', '    except RuntimeError:', '        # Issue on macos backend raises an error in the above code', '        return False', '', '', 'def axes_ticklabels_overlap(ax):', '    \"\"\"Return booleans for whether the x and y ticklabels on an Axes overlap.', '', '    Parameters', '    ----------', '    ax : matplotlib Axes', '', '    Returns', '    -------', '    x_overlap, y_overlap : booleans', '        True when the labels on that axis overlap.', '', '    \"\"\"', '    return (axis_ticklabels_overlap(ax.get_xticklabels()),', '            axis_ticklabels_overlap(ax.get_yticklabels()))', '', '', 'def locator_to_legend_entries(locator, limits, dtype):', '    \"\"\"Return levels and formatted levels for brief numeric legends.\"\"\"', '    raw_levels = locator.tick_values(*limits).astype(dtype)', '', '    # The locator can return ticks outside the limits, clip them here', '    raw_levels = [l for l in raw_levels if l >= limits[0] and l <= limits[1]]', '', '    class dummy_axis:', '        def get_view_interval(self):', '            return limits', '', '    if isinstance(locator, mpl.ticker.LogLocator):', '        formatter = mpl.ticker.LogFormatter()', '    else:', '        formatter = mpl.ticker.ScalarFormatter()', '    formatter.axis = dummy_axis()', '', '    # TODO: The following two lines should be replaced', '    # once pinned matplotlib>=3.1.0 with:', '    # formatted_levels = formatter.format_ticks(raw_levels)', '    formatter.set_locs(raw_levels)', '    formatted_levels = [formatter(x) for x in raw_levels]', '', '    return raw_levels, formatted_levels', '', '', 'def relative_luminance(color):', '    \"\"\"Calculate the relative luminance of a color according to W3C standards', '', '    Parameters', '    ----------', '    color : matplotlib color or sequence of matplotlib colors', '        Hex code, rgb-tuple, or html color name.', '', '    Returns', '    -------', '    luminance : float(s) between 0 and 1', '', '    \"\"\"', '    rgb = mpl.colors.colorConverter.to_rgba_array(color)[:, :3]', '    rgb = np.where(rgb <= .03928, rgb / 12.92, ((rgb + .055) / 1.055) ** 2.4)', '    lum = rgb.dot([.2126, .7152, .0722])', '    try:', '        return lum.item()', '    except ValueError:', '        return lum', '', '', 'def to_utf8(obj):', '    \"\"\"Return a string representing a Python object.', '', '    Strings (i.e. type ``str``) are returned unchanged.', '', '    Byte strings (i.e. type ``bytes``) are returned as UTF-8-decoded strings.', '', '    For other objects, the method ``__str__()`` is called, and the result is', '    returned as a string.', '', '    Parameters', '    ----------', '    obj : object', '        Any Python object', '', '    Returns', '    -------', '    s : str', '        UTF-8-decoded string representation of ``obj``', '', '    \"\"\"', '    if isinstance(obj, str):', '        return obj', '    try:', '        return obj.decode(encoding=\"utf-8\")', '    except AttributeError:  # obj is not bytes-like', '        return str(obj)', '', '', 'def _normalize_kwargs(kws, artist):', '    \"\"\"Wrapper for mpl.cbook.normalize_kwargs that supports <= 3.2.1.\"\"\"', '    _alias_map = {', \"        'color': ['c'],\", \"        'linewidth': ['lw'],\", \"        'linestyle': ['ls'],\", \"        'facecolor': ['fc'],\", \"        'edgecolor': ['ec'],\", \"        'markerfacecolor': ['mfc'],\", \"        'markeredgecolor': ['mec'],\", \"        'markeredgewidth': ['mew'],\", \"        'markersize': ['ms']\", '    }', '    try:', '        kws = normalize_kwargs(kws, artist)', '    except AttributeError:', '        kws = normalize_kwargs(kws, _alias_map)', '    return kws', '', '', 'def _check_argument(param, options, value):', '    \"\"\"Raise if value for param is not in options.\"\"\"', '    if value not in options:', '        raise ValueError(', '            f\"`{param}` must be one of {options}, but {repr(value)} was passed.\"', '        )', '', '', 'def _assign_default_kwargs(kws, call_func, source_func):', '    \"\"\"Assign default kwargs for call_func using values from source_func.\"\"\"', '    # This exists so that axes-level functions and figure-level functions can', '    # both call a Plotter method while having the default kwargs be defined in', '    # the signature of the axes-level function.', '    # An alternative would be to have a decorator on the method that sets its', '    # defaults based on those defined in the axes-level function.', '    # Then the figure-level function would not need to worry about defaults.', '    # I am not sure which is better.', '    needed = inspect.signature(call_func).parameters', '    defaults = inspect.signature(source_func).parameters', '', '    for param in needed:', '        if param in defaults and param not in kws:', '            kws[param] = defaults[param].default', '', '    return kws', '', '', 'def adjust_legend_subtitles(legend):', '    \"\"\"', '    Make invisible-handle \"subtitles\" entries look more like titles.', '', '    Note: This function is not part of the public API and may be changed or removed.', '', '    \"\"\"', '    # Legend title not in rcParams until 3.0', '    font_size = plt.rcParams.get(\"legend.title_fontsize\", None)', '    hpackers = legend.findobj(mpl.offsetbox.VPacker)[0].get_children()', '    for hpack in hpackers:', '        draw_area, text_area = hpack.get_children()', '        handles = draw_area.get_children()', '        if not all(artist.get_visible() for artist in handles):', '            draw_area.set_width(0)', '            for text in text_area.get_children():', '                if font_size is not None:', '                    text.set_size(font_size)', '', '', 'def _deprecate_ci(errorbar, ci):', '    \"\"\"', '    Warn on usage of ci= and convert to appropriate errorbar= arg.', '', '    ci was deprecated when errorbar was added in 0.12. It should not be removed', '    completely for some time, but it can be moved out of function definitions', '    (and extracted from kwargs) after one cycle.', '', '    \"\"\"', '    if ci != \"deprecated\":', '        if ci is None:', '            errorbar = None', '        elif ci == \"sd\":', '            errorbar = \"sd\"', '        else:', '            errorbar = (\"ci\", ci)', '        msg = (', '            \"\\\\n\\\\nThe `ci` parameter is deprecated. \"', '            f\"Use `errorbar={repr(errorbar)}` for the same effect.\\\\n\"', '        )', '        warnings.warn(msg, FutureWarning, stacklevel=3)', '', '    return errorbar', '', '', '@contextmanager', 'def _disable_autolayout():', '    \"\"\"Context manager for preventing rc-controlled auto-layout behavior.\"\"\"', '    # This is a workaround for an issue in matplotlib, for details see', '    # https://github.com/mwaskom/seaborn/issues/2914', '    # The only affect of this rcParam is to set the default value for', '    # layout= in plt.figure, so we could just do that instead.', '    # But then we would need to own the complexity of the transition', '    # from tight_layout=True -> layout=\"tight\". This seems easier,', '    # but can be removed when (if) that is simpler on the matplotlib side,', '    # or if the layout algorithms are improved to handle figure legends.', '    orig_val = mpl.rcParams[\"figure.autolayout\"]', '    try:', '        mpl.rcParams[\"figure.autolayout\"] = False', '        yield', '    finally:', '        mpl.rcParams[\"figure.autolayout\"] = orig_val']}, 'distributions.py': {'classes': [{'name': '_DistributionPlotter', 'start_line': 100, 'end_line': 1362, 'text': ['class _DistributionPlotter(VectorPlotter):', '', '    semantics = \"x\", \"y\", \"hue\", \"weights\"', '', '    wide_structure = {\"x\": \"@values\", \"hue\": \"@columns\"}', '    flat_structure = {\"x\": \"@values\"}', '', '    def __init__(', '        self,', '        data=None,', '        variables={},', '    ):', '', '        super().__init__(data=data, variables=variables)', '', '    @property', '    def univariate(self):', '        \"\"\"Return True if only x or y are used.\"\"\"', '        # TODO this could go down to core, but putting it here now.', \"        # We'd want to be conceptually clear that univariate only applies\", '        # to x/y and not to other semantics, which can exist.', \"        # We haven't settled on a good conceptual name for x/y.\", '        return bool({\"x\", \"y\"} - set(self.variables))', '', '    @property', '    def data_variable(self):', '        \"\"\"Return the variable with data for univariate plots.\"\"\"', '        # TODO This could also be in core, but it should have a better name.', '        if not self.univariate:', '            raise AttributeError(\"This is not a univariate plot\")', '        return {\"x\", \"y\"}.intersection(self.variables).pop()', '', '    @property', '    def has_xy_data(self):', '        \"\"\"Return True at least one of x or y is defined.\"\"\"', '        # TODO see above points about where this should go', '        return bool({\"x\", \"y\"} & set(self.variables))', '', '    def _add_legend(', '        self,', '        ax_obj, artist, fill, element, multiple, alpha, artist_kws, legend_kws,', '    ):', '        \"\"\"Add artists that reflect semantic mappings and put then in a legend.\"\"\"', \"        # TODO note that this doesn't handle numeric mappings like the relational plots\", '        handles = []', '        labels = []', '        for level in self._hue_map.levels:', '            color = self._hue_map(level)', '', '            kws = self._artist_kws(', '                artist_kws, fill, element, multiple, color, alpha', '            )', '', \"            # color gets added to the kws to workaround an issue with barplot's color\", '            # cycle integration but it causes problems in this context where we are', '            # setting artist properties directly, so pop it off here', '            if \"facecolor\" in kws:', '                kws.pop(\"color\", None)', '', '            handles.append(artist(**kws))', '            labels.append(level)', '', '        if isinstance(ax_obj, mpl.axes.Axes):', '            ax_obj.legend(handles, labels, title=self.variables[\"hue\"], **legend_kws)', '        else:  # i.e. a FacetGrid. TODO make this better', '            legend_data = dict(zip(labels, handles))', '            ax_obj.add_legend(', '                legend_data,', '                title=self.variables[\"hue\"],', '                label_order=self.var_levels[\"hue\"],', '                **legend_kws', '            )', '', '    def _artist_kws(self, kws, fill, element, multiple, color, alpha):', '        \"\"\"Handle differences between artists in filled/unfilled plots.\"\"\"', '        kws = kws.copy()', '        if fill:', '            kws = _normalize_kwargs(kws, mpl.collections.PolyCollection)', '            kws.setdefault(\"facecolor\", to_rgba(color, alpha))', '', '            if element == \"bars\":', '                # Make bar() interface with property cycle correctly', '                # https://github.com/matplotlib/matplotlib/issues/19385', '                kws[\"color\"] = \"none\"', '', '            if multiple in [\"stack\", \"fill\"] or element == \"bars\":', '                kws.setdefault(\"edgecolor\", mpl.rcParams[\"patch.edgecolor\"])', '            else:', '                kws.setdefault(\"edgecolor\", to_rgba(color, 1))', '        elif element == \"bars\":', '            kws[\"facecolor\"] = \"none\"', '            kws[\"edgecolor\"] = to_rgba(color, alpha)', '        else:', '            kws[\"color\"] = to_rgba(color, alpha)', '        return kws', '', '    def _quantile_to_level(self, data, quantile):', '        \"\"\"Return data levels corresponding to quantile cuts of mass.\"\"\"', '        isoprop = np.asarray(quantile)', '        values = np.ravel(data)', '        sorted_values = np.sort(values)[::-1]', '        normalized_values = np.cumsum(sorted_values) / values.sum()', '        idx = np.searchsorted(normalized_values, 1 - isoprop)', '        levels = np.take(sorted_values, idx, mode=\"clip\")', '        return levels', '', '    def _cmap_from_color(self, color):', '        \"\"\"Return a sequential colormap given a color seed.\"\"\"', '        # Like so much else here, this is broadly useful, but keeping it', \"        # in this class to signify that I haven't thought overly hard about it...\", '        r, g, b, _ = to_rgba(color)', '        h, s, _ = husl.rgb_to_husl(r, g, b)', '        xx = np.linspace(-1, 1, int(1.15 * 256))[:256]', '        ramp = np.zeros((256, 3))', '        ramp[:, 0] = h', '        ramp[:, 1] = s * np.cos(xx)', '        ramp[:, 2] = np.linspace(35, 80, 256)', '        colors = np.clip([husl.husl_to_rgb(*hsl) for hsl in ramp], 0, 1)', '        return mpl.colors.ListedColormap(colors[::-1])', '', '    def _default_discrete(self):', '        \"\"\"Find default values for discrete hist estimation based on variable type.\"\"\"', '        if self.univariate:', '            discrete = self.var_types[self.data_variable] == \"categorical\"', '        else:', '            discrete_x = self.var_types[\"x\"] == \"categorical\"', '            discrete_y = self.var_types[\"y\"] == \"categorical\"', '            discrete = discrete_x, discrete_y', '        return discrete', '', '    def _resolve_multiple(self, curves, multiple):', '        \"\"\"Modify the density data structure to handle multiple densities.\"\"\"', '', '        # Default baselines have all densities starting at 0', '        baselines = {k: np.zeros_like(v) for k, v in curves.items()}', '', '        # TODO we should have some central clearinghouse for checking if any', '        # \"grouping\" (terminnology?) semantics have been assigned', '        if \"hue\" not in self.variables:', '            return curves, baselines', '', '        if multiple in (\"stack\", \"fill\"):', '', '            # Setting stack or fill means that the curves share a', '            # support grid / set of bin edges, so we can make a dataframe', '            # Reverse the column order to plot from top to bottom', '            curves = pd.DataFrame(curves).iloc[:, ::-1]', '', '            # Find column groups that are nested within col/row variables', '            column_groups = {}', '            for i, keyd in enumerate(map(dict, curves.columns)):', '                facet_key = keyd.get(\"col\", None), keyd.get(\"row\", None)', '                column_groups.setdefault(facet_key, [])', '                column_groups[facet_key].append(i)', '', '            baselines = curves.copy()', '            for col_idxs in column_groups.values():', '                cols = curves.columns[col_idxs]', '', '                norm_constant = curves[cols].sum(axis=\"columns\")', '', '                # Take the cumulative sum to stack', '                curves[cols] = curves[cols].cumsum(axis=\"columns\")', '', '                # Normalize by row sum to fill', '                if multiple == \"fill\":', '                    curves[cols] = curves[cols].div(norm_constant, axis=\"index\")', '', '                # Define where each segment starts', '                baselines[cols] = curves[cols].shift(1, axis=1).fillna(0)', '', '        if multiple == \"dodge\":', '', '            # Account for the unique semantic (non-faceting) levels', '            # This will require rethiniking if we add other semantics!', '            hue_levels = self.var_levels[\"hue\"]', '            n = len(hue_levels)', '            for key in curves:', '                level = dict(key)[\"hue\"]', '                hist = curves[key].reset_index(name=\"heights\")', '                level_idx = hue_levels.index(level)', '                if self._log_scaled(self.data_variable):', '                    log_min = np.log10(hist[\"edges\"])', '                    log_max = np.log10(hist[\"edges\"] + hist[\"widths\"])', '                    log_width = (log_max - log_min) / n', '                    new_min = np.power(10, log_min + level_idx * log_width)', '                    new_max = np.power(10, log_min + (level_idx + 1) * log_width)', '                    hist[\"widths\"] = new_max - new_min', '                    hist[\"edges\"] = new_min', '                else:', '                    hist[\"widths\"] /= n', '                    hist[\"edges\"] += level_idx * hist[\"widths\"]', '', '                curves[key] = hist.set_index([\"edges\", \"widths\"])[\"heights\"]', '', '        return curves, baselines', '', '    # -------------------------------------------------------------------------------- #', '    # Computation', '    # -------------------------------------------------------------------------------- #', '', '    def _compute_univariate_density(', '        self,', '        data_variable,', '        common_norm,', '        common_grid,', '        estimate_kws,', '        log_scale,', '        warn_singular=True,', '    ):', '', '        # Initialize the estimator object', '        estimator = KDE(**estimate_kws)', '', '        if set(self.variables) - {\"x\", \"y\"}:', '            if common_grid:', '                all_observations = self.comp_data.dropna()', '                estimator.define_support(all_observations[data_variable])', '        else:', '            common_norm = False', '', '        all_data = self.plot_data.dropna()', '        if common_norm and \"weights\" in all_data:', '            whole_weight = all_data[\"weights\"].sum()', '        else:', '            whole_weight = len(all_data)', '', '        densities = {}', '', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Extract the data points from this sub set and remove nulls', '            observations = sub_data[data_variable]', '', '            # Extract the weights for this subset of observations', '            if \"weights\" in self.variables:', '                weights = sub_data[\"weights\"]', '                part_weight = weights.sum()', '            else:', '                weights = None', '                part_weight = len(sub_data)', '', '            # Estimate the density of observations at this level', '            variance = np.nan_to_num(observations.var())', '            singular = len(observations) < 2 or math.isclose(variance, 0)', '            try:', '                if not singular:', '                    # Convoluted approach needed because numerical failures', '                    # can manifest in a few different ways.', '                    density, support = estimator(observations, weights=weights)', '            except np.linalg.LinAlgError:', '                singular = True', '', '            if singular:', '                msg = (', '                    \"Dataset has 0 variance; skipping density estimate. \"', '                    \"Pass `warn_singular=False` to disable this warning.\"', '                )', '                if warn_singular:', '                    warnings.warn(msg, UserWarning, stacklevel=4)', '                continue', '', '            if log_scale:', '                support = np.power(10, support)', '', '            # Apply a scaling factor so that the integral over all subsets is 1', '            if common_norm:', '                density *= part_weight / whole_weight', '', '            # Store the density for this level', '            key = tuple(sub_vars.items())', '            densities[key] = pd.Series(density, index=support)', '', '        return densities', '', '    # -------------------------------------------------------------------------------- #', '    # Plotting', '    # -------------------------------------------------------------------------------- #', '', '    def plot_univariate_histogram(', '        self,', '        multiple,', '        element,', '        fill,', '        common_norm,', '        common_bins,', '        shrink,', '        kde,', '        kde_kws,', '        color,', '        legend,', '        line_kws,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # -- Default keyword dicts', '        kde_kws = {} if kde_kws is None else kde_kws.copy()', '        line_kws = {} if line_kws is None else line_kws.copy()', '        estimate_kws = {} if estimate_kws is None else estimate_kws.copy()', '', '        # --  Input checking', '        _check_argument(\"multiple\", [\"layer\", \"stack\", \"fill\", \"dodge\"], multiple)', '        _check_argument(\"element\", [\"bars\", \"step\", \"poly\"], element)', '', '        auto_bins_with_weights = (', '            \"weights\" in self.variables', '            and estimate_kws[\"bins\"] == \"auto\"', '            and estimate_kws[\"binwidth\"] is None', '            and not estimate_kws[\"discrete\"]', '        )', '        if auto_bins_with_weights:', '            msg = (', '                \"`bins` cannot be \\'auto\\' when using weights. \"', '                \"Setting `bins=10`, but you will likely want to adjust.\"', '            )', '            warnings.warn(msg, UserWarning)', '            estimate_kws[\"bins\"] = 10', '', '        # Simplify downstream code if we are not normalizing', '        if estimate_kws[\"stat\"] == \"count\":', '            common_norm = False', '', '        orient = self.data_variable', '', '        # Now initialize the Histogram estimator', '        estimator = Hist(**estimate_kws)', '        histograms = {}', '', '        # Do pre-compute housekeeping related to multiple groups', '        all_data = self.comp_data.dropna()', '        all_weights = all_data.get(\"weights\", None)', '', '        multiple_histograms = set(self.variables) - {\"x\", \"y\"}', '        if multiple_histograms:', '            if common_bins:', '                bin_kws = estimator._define_bin_params(all_data, orient, None)', '        else:', '            common_norm = False', '', '        if common_norm and all_weights is not None:', '            whole_weight = all_weights.sum()', '        else:', '            whole_weight = len(all_data)', '', '        # Estimate the smoothed kernel densities, for use later', '        if kde:', '            # TODO alternatively, clip at min/max bins?', '            kde_kws.setdefault(\"cut\", 0)', '            kde_kws[\"cumulative\"] = estimate_kws[\"cumulative\"]', '            log_scale = self._log_scaled(self.data_variable)', '            densities = self._compute_univariate_density(', '                self.data_variable,', '                common_norm,', '                common_bins,', '                kde_kws,', '                log_scale,', '                warn_singular=False,', '            )', '', '        # First pass through the data to compute the histograms', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Prepare the relevant data', '            key = tuple(sub_vars.items())', '            orient = self.data_variable', '', '            if \"weights\" in self.variables:', '                sub_data[\"weight\"] = sub_data.pop(\"weights\")', '                part_weight = sub_data[\"weight\"].sum()', '            else:', '                part_weight = len(sub_data)', '', '            # Do the histogram computation', '            if not (multiple_histograms and common_bins):', '                bin_kws = estimator._define_bin_params(sub_data, orient, None)', '            res = estimator._normalize(estimator._eval(sub_data, orient, bin_kws))', '            heights = res[estimator.stat].to_numpy()', '            widths = res[\"space\"].to_numpy()', '            edges = res[orient].to_numpy() - widths / 2', '', '            # Convert edges back to original units for plotting', '            if self._log_scaled(self.data_variable):', '                widths = np.power(10, edges + widths) - np.power(10, edges)', '                edges = np.power(10, edges)', '', '            # Rescale the smoothed curve to match the histogram', '            if kde and key in densities:', '                density = densities[key]', '                if estimator.cumulative:', '                    hist_norm = heights.max()', '                else:', '                    hist_norm = (heights * widths).sum()', '                densities[key] *= hist_norm', '', '            # Pack the histogram data and metadata together', '            edges = edges + (1 - shrink) / 2 * widths', '            widths *= shrink', '            index = pd.MultiIndex.from_arrays([', '                pd.Index(edges, name=\"edges\"),', '                pd.Index(widths, name=\"widths\"),', '            ])', '            hist = pd.Series(heights, index=index, name=\"heights\")', '', '            # Apply scaling to normalize across groups', '            if common_norm:', '                hist *= part_weight / whole_weight', '', '            # Store the finalized histogram data for future plotting', '            histograms[key] = hist', '', '        # Modify the histogram and density data to resolve multiple groups', '        histograms, baselines = self._resolve_multiple(histograms, multiple)', '        if kde:', '            densities, _ = self._resolve_multiple(', '                densities, None if multiple == \"dodge\" else multiple', '            )', '', '        # Set autoscaling-related meta', '        sticky_stat = (0, 1) if multiple == \"fill\" else (0, np.inf)', '        if multiple == \"fill\":', '            # Filled plots should not have any margins', '            bin_vals = histograms.index.to_frame()', '            edges = bin_vals[\"edges\"]', '            widths = bin_vals[\"widths\"]', '            sticky_data = (', '                edges.min(),', '                edges.max() + widths.loc[edges.idxmax()]', '            )', '        else:', '            sticky_data = []', '', '        # --- Handle default visual attributes', '', '        # Note: default linewidth is determined after plotting', '', '        # Default alpha should depend on other parameters', '        if fill:', '            # Note: will need to account for other grouping semantics if added', '            if \"hue\" in self.variables and multiple == \"layer\":', '                default_alpha = .5 if element == \"bars\" else .25', '            elif kde:', '                default_alpha = .5', '            else:', '                default_alpha = .75', '        else:', '            default_alpha = 1', '        alpha = plot_kws.pop(\"alpha\", default_alpha)  # TODO make parameter?', '', '        hist_artists = []', '', '        # Go back through the dataset and draw the plots', '        for sub_vars, _ in self.iter_data(\"hue\", reverse=True):', '', '            key = tuple(sub_vars.items())', '            hist = histograms[key].rename(\"heights\").reset_index()', '            bottom = np.asarray(baselines[key])', '', '            ax = self._get_axes(sub_vars)', '', '            # Define the matplotlib attributes that depend on semantic mapping', '            if \"hue\" in self.variables:', '                sub_color = self._hue_map(sub_vars[\"hue\"])', '            else:', '                sub_color = color', '', '            artist_kws = self._artist_kws(', '                plot_kws, fill, element, multiple, sub_color, alpha', '            )', '', '            if element == \"bars\":', '', '                # Use matplotlib bar plotting', '', '                plot_func = ax.bar if self.data_variable == \"x\" else ax.barh', '                artists = plot_func(', '                    hist[\"edges\"],', '                    hist[\"heights\"] - bottom,', '                    hist[\"widths\"],', '                    bottom,', '                    align=\"edge\",', '                    **artist_kws,', '                )', '', '                for bar in artists:', '                    if self.data_variable == \"x\":', '                        bar.sticky_edges.x[:] = sticky_data', '                        bar.sticky_edges.y[:] = sticky_stat', '                    else:', '                        bar.sticky_edges.x[:] = sticky_stat', '                        bar.sticky_edges.y[:] = sticky_data', '', '                hist_artists.extend(artists)', '', '            else:', '', '                # Use either fill_between or plot to draw hull of histogram', '                if element == \"step\":', '', '                    final = hist.iloc[-1]', '                    x = np.append(hist[\"edges\"], final[\"edges\"] + final[\"widths\"])', '                    y = np.append(hist[\"heights\"], final[\"heights\"])', '                    b = np.append(bottom, bottom[-1])', '', '                    if self.data_variable == \"x\":', '                        step = \"post\"', '                        drawstyle = \"steps-post\"', '                    else:', '                        step = \"post\"  # fillbetweenx handles mapping internally', '                        drawstyle = \"steps-pre\"', '', '                elif element == \"poly\":', '', '                    x = hist[\"edges\"] + hist[\"widths\"] / 2', '                    y = hist[\"heights\"]', '                    b = bottom', '', '                    step = None', '                    drawstyle = None', '', '                if self.data_variable == \"x\":', '                    if fill:', '                        artist = ax.fill_between(x, b, y, step=step, **artist_kws)', '                    else:', '                        artist, = ax.plot(x, y, drawstyle=drawstyle, **artist_kws)', '                    artist.sticky_edges.x[:] = sticky_data', '                    artist.sticky_edges.y[:] = sticky_stat', '                else:', '                    if fill:', '                        artist = ax.fill_betweenx(x, b, y, step=step, **artist_kws)', '                    else:', '                        artist, = ax.plot(y, x, drawstyle=drawstyle, **artist_kws)', '                    artist.sticky_edges.x[:] = sticky_stat', '                    artist.sticky_edges.y[:] = sticky_data', '', '                hist_artists.append(artist)', '', '            if kde:', '', '                # Add in the density curves', '', '                try:', '                    density = densities[key]', '                except KeyError:', '                    continue', '                support = density.index', '', '                if \"x\" in self.variables:', '                    line_args = support, density', '                    sticky_x, sticky_y = None, (0, np.inf)', '                else:', '                    line_args = density, support', '                    sticky_x, sticky_y = (0, np.inf), None', '', '                line_kws[\"color\"] = to_rgba(sub_color, 1)', '                line, = ax.plot(', '                    *line_args, **line_kws,', '                )', '', '                if sticky_x is not None:', '                    line.sticky_edges.x[:] = sticky_x', '                if sticky_y is not None:', '                    line.sticky_edges.y[:] = sticky_y', '', '        if element == \"bars\" and \"linewidth\" not in plot_kws:', '', '            # Now we handle linewidth, which depends on the scaling of the plot', '', '            # We will base everything on the minimum bin width', '            hist_metadata = pd.concat([', '                # Use .items for generality over dict or df', '                h.index.to_frame() for _, h in histograms.items()', '            ]).reset_index(drop=True)', '            thin_bar_idx = hist_metadata[\"widths\"].idxmin()', '            binwidth = hist_metadata.loc[thin_bar_idx, \"widths\"]', '            left_edge = hist_metadata.loc[thin_bar_idx, \"edges\"]', '', '            # Set initial value', '            default_linewidth = math.inf', '', '            # Loop through subsets based only on facet variables', '            for sub_vars, _ in self.iter_data():', '', '                ax = self._get_axes(sub_vars)', '', '                # Needed in some cases to get valid transforms.', '                # Innocuous in other cases?', '                ax.autoscale_view()', '', '                # Convert binwidth from data coordinates to pixels', '                pts_x, pts_y = 72 / ax.figure.dpi * abs(', '                    ax.transData.transform([left_edge + binwidth] * 2)', '                    - ax.transData.transform([left_edge] * 2)', '                )', '                if self.data_variable == \"x\":', '                    binwidth_points = pts_x', '                else:', '                    binwidth_points = pts_y', '', '                # The relative size of the lines depends on the appearance', '                # This is a provisional value and may need more tweaking', '                default_linewidth = min(.1 * binwidth_points, default_linewidth)', '', '            # Set the attributes', '            for bar in hist_artists:', '', \"                # Don't let the lines get too thick\", '                max_linewidth = bar.get_linewidth()', '                if not fill:', '                    max_linewidth *= 1.5', '', '                linewidth = min(default_linewidth, max_linewidth)', '', \"                # If not filling, don't let lines disappear\", '                if not fill:', '                    min_linewidth = .5', '                    linewidth = max(linewidth, min_linewidth)', '', '                bar.set_linewidth(linewidth)', '', '        # --- Finalize the plot ----', '', '        # Axis labels', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = estimator.stat.capitalize()', '        if self.data_variable == \"y\":', '            default_x = estimator.stat.capitalize()', '        self._add_axis_labels(ax, default_x, default_y)', '', '        # Legend for semantic variables', '        if \"hue\" in self.variables and legend:', '', '            if fill or element == \"bars\":', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, element, multiple, alpha, plot_kws, {},', '            )', '', '    def plot_bivariate_histogram(', '        self,', '        common_bins, common_norm,', '        thresh, pthresh, pmax,', '        color, legend,', '        cbar, cbar_ax, cbar_kws,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # Default keyword dicts', '        cbar_kws = {} if cbar_kws is None else cbar_kws.copy()', '', '        # Now initialize the Histogram estimator', '        estimator = Histogram(**estimate_kws)', '', '        # Do pre-compute housekeeping related to multiple groups', '        if set(self.variables) - {\"x\", \"y\"}:', '            all_data = self.comp_data.dropna()', '            if common_bins:', '                estimator.define_bin_params(', '                    all_data[\"x\"],', '                    all_data[\"y\"],', '                    all_data.get(\"weights\", None),', '                )', '        else:', '            common_norm = False', '', '        # -- Determine colormap threshold and norm based on the full data', '', '        full_heights = []', '        for _, sub_data in self.iter_data(from_comp_data=True):', '            sub_heights, _ = estimator(', '                sub_data[\"x\"], sub_data[\"y\"], sub_data.get(\"weights\", None)', '            )', '            full_heights.append(sub_heights)', '', '        common_color_norm = not set(self.variables) - {\"x\", \"y\"} or common_norm', '', '        if pthresh is not None and common_color_norm:', '            thresh = self._quantile_to_level(full_heights, pthresh)', '', '        plot_kws.setdefault(\"vmin\", 0)', '        if common_color_norm:', '            if pmax is not None:', '                vmax = self._quantile_to_level(full_heights, pmax)', '            else:', '                vmax = plot_kws.pop(\"vmax\", max(map(np.max, full_heights)))', '        else:', '            vmax = None', '', '        # Get a default color', \"        # (We won't follow the color cycle here, as multiple plots are unlikely)\", '        if color is None:', '            color = \"C0\"', '', '        # --- Loop over data (subsets) and draw the histograms', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            if sub_data.empty:', '                continue', '', '            # Do the histogram computation', '            heights, (x_edges, y_edges) = estimator(', '                sub_data[\"x\"],', '                sub_data[\"y\"],', '                weights=sub_data.get(\"weights\", None),', '            )', '', '            # Check for log scaling on the data axis', '            if self._log_scaled(\"x\"):', '                x_edges = np.power(10, x_edges)', '            if self._log_scaled(\"y\"):', '                y_edges = np.power(10, y_edges)', '', '            # Apply scaling to normalize across groups', '            if estimator.stat != \"count\" and common_norm:', '                heights *= len(sub_data) / len(all_data)', '', '            # Define the specific kwargs for this artist', '            artist_kws = plot_kws.copy()', '            if \"hue\" in self.variables:', '                color = self._hue_map(sub_vars[\"hue\"])', '                cmap = self._cmap_from_color(color)', '                artist_kws[\"cmap\"] = cmap', '            else:', '                cmap = artist_kws.pop(\"cmap\", None)', '                if isinstance(cmap, str):', '                    cmap = color_palette(cmap, as_cmap=True)', '                elif cmap is None:', '                    cmap = self._cmap_from_color(color)', '                artist_kws[\"cmap\"] = cmap', '', '            # Set the upper norm on the colormap', '            if not common_color_norm and pmax is not None:', '                vmax = self._quantile_to_level(heights, pmax)', '            if vmax is not None:', '                artist_kws[\"vmax\"] = vmax', '', '            # Make cells at or below the threshold transparent', '            if not common_color_norm and pthresh:', '                thresh = self._quantile_to_level(heights, pthresh)', '            if thresh is not None:', '                heights = np.ma.masked_less_equal(heights, thresh)', '', '            # Get the axes for this plot', '            ax = self._get_axes(sub_vars)', '', '            # pcolormesh is going to turn the grid off, but we want to keep it', \"            # I'm not sure if there's a better way to get the grid state\", '            x_grid = any([l.get_visible() for l in ax.xaxis.get_gridlines()])', '            y_grid = any([l.get_visible() for l in ax.yaxis.get_gridlines()])', '', '            mesh = ax.pcolormesh(', '                x_edges,', '                y_edges,', '                heights.T,', '                **artist_kws,', '            )', '', '            # pcolormesh sets sticky edges, but we only want them if not thresholding', '            if thresh is not None:', '                mesh.sticky_edges.x[:] = []', '                mesh.sticky_edges.y[:] = []', '', '            # Add an optional colorbar', '            # Note, we want to improve this. When hue is used, it will stack', '            # multiple colorbars with redundant ticks in an ugly way.', \"            # But it's going to take some work to have multiple colorbars that\", '            # share ticks nicely.', '            if cbar:', '                ax.figure.colorbar(mesh, cbar_ax, ax, **cbar_kws)', '', '            # Reset the grid state', '            if x_grid:', '                ax.grid(True, axis=\"x\")', '            if y_grid:', '                ax.grid(True, axis=\"y\")', '', '        # --- Finalize the plot', '', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        self._add_axis_labels(ax)', '', '        if \"hue\" in self.variables and legend:', '', '            # TODO if possible, I would like to move the contour', '            # intensity information into the legend too and label the', '            # iso proportions rather than the raw density values', '', '            artist_kws = {}', '            artist = partial(mpl.patches.Patch)', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, True, False, \"layer\", 1, artist_kws, {},', '            )', '', '    def plot_univariate_density(', '        self,', '        multiple,', '        common_norm,', '        common_grid,', '        warn_singular,', '        fill,', '        color,', '        legend,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # Handle conditional defaults', '        if fill is None:', '            fill = multiple in (\"stack\", \"fill\")', '', '        # Preprocess the matplotlib keyword dictionaries', '        if fill:', '            artist = mpl.collections.PolyCollection', '        else:', '            artist = mpl.lines.Line2D', '        plot_kws = _normalize_kwargs(plot_kws, artist)', '', '        # Input checking', '        _check_argument(\"multiple\", [\"layer\", \"stack\", \"fill\"], multiple)', '', '        # Always share the evaluation grid when stacking', '        subsets = bool(set(self.variables) - {\"x\", \"y\"})', '        if subsets and multiple in (\"stack\", \"fill\"):', '            common_grid = True', '', '        # Check if the data axis is log scaled', '        log_scale = self._log_scaled(self.data_variable)', '', '        # Do the computation', '        densities = self._compute_univariate_density(', '            self.data_variable,', '            common_norm,', '            common_grid,', '            estimate_kws,', '            log_scale,', '            warn_singular,', '        )', '', '        # Adjust densities based on the `multiple` rule', '        densities, baselines = self._resolve_multiple(densities, multiple)', '', '        # Control the interaction with autoscaling by defining sticky_edges', \"        # i.e. we don't want autoscale margins below the density curve\", '        sticky_density = (0, 1) if multiple == \"fill\" else (0, np.inf)', '', '        if multiple == \"fill\":', '            # Filled plots should not have any margins', '            sticky_support = densities.index.min(), densities.index.max()', '        else:', '            sticky_support = []', '', '        if fill:', '            if multiple == \"layer\":', '                default_alpha = .25', '            else:', '                default_alpha = .75', '        else:', '            default_alpha = 1', '        alpha = plot_kws.pop(\"alpha\", default_alpha)  # TODO make parameter?', '', '        # Now iterate through the subsets and draw the densities', '        # We go backwards so stacked densities read from top-to-bottom', '        for sub_vars, _ in self.iter_data(\"hue\", reverse=True):', '', '            # Extract the support grid and density curve for this level', '            key = tuple(sub_vars.items())', '            try:', '                density = densities[key]', '            except KeyError:', '                continue', '            support = density.index', '            fill_from = baselines[key]', '', '            ax = self._get_axes(sub_vars)', '', '            if \"hue\" in self.variables:', '                sub_color = self._hue_map(sub_vars[\"hue\"])', '            else:', '                sub_color = color', '', '            artist_kws = self._artist_kws(', '                plot_kws, fill, False, multiple, sub_color, alpha', '            )', '', '            # Either plot a curve with observation values on the x axis', '            if \"x\" in self.variables:', '', '                if fill:', '                    artist = ax.fill_between(support, fill_from, density, **artist_kws)', '', '                else:', '                    artist, = ax.plot(support, density, **artist_kws)', '', '                artist.sticky_edges.x[:] = sticky_support', '                artist.sticky_edges.y[:] = sticky_density', '', '            # Or plot a curve with observation values on the y axis', '            else:', '                if fill:', '                    artist = ax.fill_betweenx(support, fill_from, density, **artist_kws)', '                else:', '                    artist, = ax.plot(density, support, **artist_kws)', '', '                artist.sticky_edges.x[:] = sticky_density', '                artist.sticky_edges.y[:] = sticky_support', '', '        # --- Finalize the plot ----', '', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = \"Density\"', '        if self.data_variable == \"y\":', '            default_x = \"Density\"', '        self._add_axis_labels(ax, default_x, default_y)', '', '        if \"hue\" in self.variables and legend:', '', '            if fill:', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, False, multiple, alpha, plot_kws, {},', '            )', '', '    def plot_bivariate_density(', '        self,', '        common_norm,', '        fill,', '        levels,', '        thresh,', '        color,', '        legend,', '        cbar,', '        warn_singular,', '        cbar_ax,', '        cbar_kws,', '        estimate_kws,', '        **contour_kws,', '    ):', '', '        contour_kws = contour_kws.copy()', '', '        estimator = KDE(**estimate_kws)', '', '        if not set(self.variables) - {\"x\", \"y\"}:', '            common_norm = False', '', '        all_data = self.plot_data.dropna()', '', '        # Loop through the subsets and estimate the KDEs', '        densities, supports = {}, {}', '', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Extract the data points from this sub set', '            observations = sub_data[[\"x\", \"y\"]]', '            min_variance = observations.var().fillna(0).min()', '            observations = observations[\"x\"], observations[\"y\"]', '', '            # Extract the weights for this subset of observations', '            if \"weights\" in self.variables:', '                weights = sub_data[\"weights\"]', '            else:', '                weights = None', '', '            # Estimate the density of observations at this level', '            singular = math.isclose(min_variance, 0)', '            try:', '                if not singular:', '                    density, support = estimator(*observations, weights=weights)', '            except np.linalg.LinAlgError:', \"                # Testing for 0 variance doesn't catch all cases where scipy raises,\", '                # but we can also get a ValueError, so we need this convoluted approach', '                singular = True', '', '            if singular:', '                msg = (', '                    \"KDE cannot be estimated (0 variance or perfect covariance). \"', '                    \"Pass `warn_singular=False` to disable this warning.\"', '                )', '                if warn_singular:', '                    warnings.warn(msg, UserWarning, stacklevel=3)', '                continue', '', '            # Transform the support grid back to the original scale', '            xx, yy = support', '            if self._log_scaled(\"x\"):', '                xx = np.power(10, xx)', '            if self._log_scaled(\"y\"):', '                yy = np.power(10, yy)', '            support = xx, yy', '', '            # Apply a scaling factor so that the integral over all subsets is 1', '            if common_norm:', '                density *= len(sub_data) / len(all_data)', '', '            key = tuple(sub_vars.items())', '            densities[key] = density', '            supports[key] = support', '', '        # Define a grid of iso-proportion levels', '        if thresh is None:', '            thresh = 0', '        if isinstance(levels, Number):', '            levels = np.linspace(thresh, 1, levels)', '        else:', '            if min(levels) < 0 or max(levels) > 1:', '                raise ValueError(\"levels must be in [0, 1]\")', '', '        # Transform from iso-proportions to iso-densities', '        if common_norm:', '            common_levels = self._quantile_to_level(', '                list(densities.values()), levels,', '            )', '            draw_levels = {k: common_levels for k in densities}', '        else:', '            draw_levels = {', '                k: self._quantile_to_level(d, levels)', '                for k, d in densities.items()', '            }', '', '        # Define the coloring of the contours', '        if \"hue\" in self.variables:', '            for param in [\"cmap\", \"colors\"]:', '                if param in contour_kws:', '                    msg = f\"{param} parameter ignored when using hue mapping.\"', '                    warnings.warn(msg, UserWarning)', '                    contour_kws.pop(param)', '        else:', '', '            # Work out a default coloring of the contours', '            coloring_given = set(contour_kws) & {\"cmap\", \"colors\"}', '            if fill and not coloring_given:', '                cmap = self._cmap_from_color(color)', '                contour_kws[\"cmap\"] = cmap', '            if not fill and not coloring_given:', '                contour_kws[\"colors\"] = [color]', '', '            # Use our internal colormap lookup', '            cmap = contour_kws.pop(\"cmap\", None)', '            if isinstance(cmap, str):', '                cmap = color_palette(cmap, as_cmap=True)', '            if cmap is not None:', '                contour_kws[\"cmap\"] = cmap', '', '        # Loop through the subsets again and plot the data', '        for sub_vars, _ in self.iter_data(\"hue\"):', '', '            if \"hue\" in sub_vars:', '                color = self._hue_map(sub_vars[\"hue\"])', '                if fill:', '                    contour_kws[\"cmap\"] = self._cmap_from_color(color)', '                else:', '                    contour_kws[\"colors\"] = [color]', '', '            ax = self._get_axes(sub_vars)', '', '            # Choose the function to plot with', '            # TODO could add a pcolormesh based option as well', '            # Which would look something like element=\"raster\"', '            if fill:', '                contour_func = ax.contourf', '            else:', '                contour_func = ax.contour', '', '            key = tuple(sub_vars.items())', '            if key not in densities:', '                continue', '            density = densities[key]', '            xx, yy = supports[key]', '', '            label = contour_kws.pop(\"label\", None)', '', '            cset = contour_func(', '                xx, yy, density,', '                levels=draw_levels[key],', '                **contour_kws,', '            )', '', '            if \"hue\" not in self.variables:', '                cset.collections[0].set_label(label)', '', '            # Add a color bar representing the contour heights', '            # Note: this shows iso densities, not iso proportions', '            # See more notes in histplot about how this could be improved', '            if cbar:', '                cbar_kws = {} if cbar_kws is None else cbar_kws', '                ax.figure.colorbar(cset, cbar_ax, ax, **cbar_kws)', '', '        # --- Finalize the plot', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        self._add_axis_labels(ax)', '', '        if \"hue\" in self.variables and legend:', '', '            # TODO if possible, I would like to move the contour', '            # intensity information into the legend too and label the', '            # iso proportions rather than the raw density values', '', '            artist_kws = {}', '            if fill:', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, False, \"layer\", 1, artist_kws, {},', '            )', '', '    def plot_univariate_ecdf(self, estimate_kws, legend, **plot_kws):', '', '        estimator = ECDF(**estimate_kws)', '', '        # Set the draw style to step the right way for the data variable', '        drawstyles = dict(x=\"steps-post\", y=\"steps-pre\")', '        plot_kws[\"drawstyle\"] = drawstyles[self.data_variable]', '', '        # Loop through the subsets, transform and plot the data', '        for sub_vars, sub_data in self.iter_data(', '            \"hue\", reverse=True, from_comp_data=True,', '        ):', '', '            # Compute the ECDF', '            if sub_data.empty:', '                continue', '', '            observations = sub_data[self.data_variable]', '            weights = sub_data.get(\"weights\", None)', '            stat, vals = estimator(observations, weights=weights)', '', '            # Assign attributes based on semantic mapping', '            artist_kws = plot_kws.copy()', '            if \"hue\" in self.variables:', '                artist_kws[\"color\"] = self._hue_map(sub_vars[\"hue\"])', '', '            # Return the data variable to the linear domain', '            # This needs an automatic solution; see GH2409', '            if self._log_scaled(self.data_variable):', '                vals = np.power(10, vals)', '                vals[0] = -np.inf', '', '            # Work out the orientation of the plot', '            if self.data_variable == \"x\":', '                plot_args = vals, stat', '                stat_variable = \"y\"', '            else:', '                plot_args = stat, vals', '                stat_variable = \"x\"', '', '            if estimator.stat == \"count\":', '                top_edge = len(observations)', '            else:', '                top_edge = 1', '', '            # Draw the line for this subset', '            ax = self._get_axes(sub_vars)', '            artist, = ax.plot(*plot_args, **artist_kws)', '            sticky_edges = getattr(artist.sticky_edges, stat_variable)', '            sticky_edges[:] = 0, top_edge', '', '        # --- Finalize the plot ----', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        stat = estimator.stat.capitalize()', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = stat', '        if self.data_variable == \"y\":', '            default_x = stat', '        self._add_axis_labels(ax, default_x, default_y)', '', '        if \"hue\" in self.variables and legend:', '            artist = partial(mpl.lines.Line2D, [], [])', '            alpha = plot_kws.get(\"alpha\", 1)', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, False, False, None, alpha, plot_kws, {},', '            )', '', '    def plot_rug(self, height, expand_margins, legend, **kws):', '', '        for sub_vars, sub_data, in self.iter_data(from_comp_data=True):', '', '            ax = self._get_axes(sub_vars)', '', '            kws.setdefault(\"linewidth\", 1)', '', '            if expand_margins:', '                xmarg, ymarg = ax.margins()', '                if \"x\" in self.variables:', '                    ymarg += height * 2', '                if \"y\" in self.variables:', '                    xmarg += height * 2', '                ax.margins(x=xmarg, y=ymarg)', '', '            if \"hue\" in self.variables:', '                kws.pop(\"c\", None)', '                kws.pop(\"color\", None)', '', '            if \"x\" in self.variables:', '                self._plot_single_rug(sub_data, \"x\", height, ax, kws)', '            if \"y\" in self.variables:', '                self._plot_single_rug(sub_data, \"y\", height, ax, kws)', '', '            # --- Finalize the plot', '            self._add_axis_labels(ax)', '            if \"hue\" in self.variables and legend:', \"                # TODO ideally i'd like the legend artist to look like a rug\", '                legend_artist = partial(mpl.lines.Line2D, [], [])', '                self._add_legend(', '                    ax, legend_artist, False, False, None, 1, {}, {},', '                )', '', '    def _plot_single_rug(self, sub_data, var, height, ax, kws):', '        \"\"\"Draw a rugplot along one axis of the plot.\"\"\"', '        vector = sub_data[var]', '        n = len(vector)', '', '        # Return data to linear domain', '        # This needs an automatic solution; see GH2409', '        if self._log_scaled(var):', '            vector = np.power(10, vector)', '', \"        # We'll always add a single collection with varying colors\", '        if \"hue\" in self.variables:', '            colors = self._hue_map(sub_data[\"hue\"])', '        else:', '            colors = None', '', '        # Build the array of values for the LineCollection', '        if var == \"x\":', '', '            trans = tx.blended_transform_factory(ax.transData, ax.transAxes)', '            xy_pairs = np.column_stack([', '                np.repeat(vector, 2), np.tile([0, height], n)', '            ])', '', '        if var == \"y\":', '', '            trans = tx.blended_transform_factory(ax.transAxes, ax.transData)', '            xy_pairs = np.column_stack([', '                np.tile([0, height], n), np.repeat(vector, 2)', '            ])', '', '        # Draw the lines on the plot', '        line_segs = xy_pairs.reshape([n, 2, 2])', '        ax.add_collection(LineCollection(', '            line_segs, transform=trans, colors=colors, **kws', '        ))', '', '        ax.autoscale_view(scalex=var == \"x\", scaley=var == \"y\")'], 'methods': [{'name': '__init__', 'start_line': 107, 'end_line': 113, 'text': ['    def __init__(', '        self,', '        data=None,', '        variables={},', '    ):', '', '        super().__init__(data=data, variables=variables)']}, {'name': 'univariate', 'start_line': 116, 'end_line': 122, 'text': ['    def univariate(self):', '        \"\"\"Return True if only x or y are used.\"\"\"', '        # TODO this could go down to core, but putting it here now.', \"        # We'd want to be conceptually clear that univariate only applies\", '        # to x/y and not to other semantics, which can exist.', \"        # We haven't settled on a good conceptual name for x/y.\", '        return bool({\"x\", \"y\"} - set(self.variables))']}, {'name': 'data_variable', 'start_line': 125, 'end_line': 130, 'text': ['    def data_variable(self):', '        \"\"\"Return the variable with data for univariate plots.\"\"\"', '        # TODO This could also be in core, but it should have a better name.', '        if not self.univariate:', '            raise AttributeError(\"This is not a univariate plot\")', '        return {\"x\", \"y\"}.intersection(self.variables).pop()']}, {'name': 'has_xy_data', 'start_line': 133, 'end_line': 136, 'text': ['    def has_xy_data(self):', '        \"\"\"Return True at least one of x or y is defined.\"\"\"', '        # TODO see above points about where this should go', '        return bool({\"x\", \"y\"} & set(self.variables))']}, {'name': '_add_legend', 'start_line': 138, 'end_line': 171, 'text': ['    def _add_legend(', '        self,', '        ax_obj, artist, fill, element, multiple, alpha, artist_kws, legend_kws,', '    ):', '        \"\"\"Add artists that reflect semantic mappings and put then in a legend.\"\"\"', \"        # TODO note that this doesn't handle numeric mappings like the relational plots\", '        handles = []', '        labels = []', '        for level in self._hue_map.levels:', '            color = self._hue_map(level)', '', '            kws = self._artist_kws(', '                artist_kws, fill, element, multiple, color, alpha', '            )', '', \"            # color gets added to the kws to workaround an issue with barplot's color\", '            # cycle integration but it causes problems in this context where we are', '            # setting artist properties directly, so pop it off here', '            if \"facecolor\" in kws:', '                kws.pop(\"color\", None)', '', '            handles.append(artist(**kws))', '            labels.append(level)', '', '        if isinstance(ax_obj, mpl.axes.Axes):', '            ax_obj.legend(handles, labels, title=self.variables[\"hue\"], **legend_kws)', '        else:  # i.e. a FacetGrid. TODO make this better', '            legend_data = dict(zip(labels, handles))', '            ax_obj.add_legend(', '                legend_data,', '                title=self.variables[\"hue\"],', '                label_order=self.var_levels[\"hue\"],', '                **legend_kws', '            )']}, {'name': '_artist_kws', 'start_line': 173, 'end_line': 194, 'text': ['    def _artist_kws(self, kws, fill, element, multiple, color, alpha):', '        \"\"\"Handle differences between artists in filled/unfilled plots.\"\"\"', '        kws = kws.copy()', '        if fill:', '            kws = _normalize_kwargs(kws, mpl.collections.PolyCollection)', '            kws.setdefault(\"facecolor\", to_rgba(color, alpha))', '', '            if element == \"bars\":', '                # Make bar() interface with property cycle correctly', '                # https://github.com/matplotlib/matplotlib/issues/19385', '                kws[\"color\"] = \"none\"', '', '            if multiple in [\"stack\", \"fill\"] or element == \"bars\":', '                kws.setdefault(\"edgecolor\", mpl.rcParams[\"patch.edgecolor\"])', '            else:', '                kws.setdefault(\"edgecolor\", to_rgba(color, 1))', '        elif element == \"bars\":', '            kws[\"facecolor\"] = \"none\"', '            kws[\"edgecolor\"] = to_rgba(color, alpha)', '        else:', '            kws[\"color\"] = to_rgba(color, alpha)', '        return kws']}, {'name': '_quantile_to_level', 'start_line': 196, 'end_line': 204, 'text': ['    def _quantile_to_level(self, data, quantile):', '        \"\"\"Return data levels corresponding to quantile cuts of mass.\"\"\"', '        isoprop = np.asarray(quantile)', '        values = np.ravel(data)', '        sorted_values = np.sort(values)[::-1]', '        normalized_values = np.cumsum(sorted_values) / values.sum()', '        idx = np.searchsorted(normalized_values, 1 - isoprop)', '        levels = np.take(sorted_values, idx, mode=\"clip\")', '        return levels']}, {'name': '_cmap_from_color', 'start_line': 206, 'end_line': 218, 'text': ['    def _cmap_from_color(self, color):', '        \"\"\"Return a sequential colormap given a color seed.\"\"\"', '        # Like so much else here, this is broadly useful, but keeping it', \"        # in this class to signify that I haven't thought overly hard about it...\", '        r, g, b, _ = to_rgba(color)', '        h, s, _ = husl.rgb_to_husl(r, g, b)', '        xx = np.linspace(-1, 1, int(1.15 * 256))[:256]', '        ramp = np.zeros((256, 3))', '        ramp[:, 0] = h', '        ramp[:, 1] = s * np.cos(xx)', '        ramp[:, 2] = np.linspace(35, 80, 256)', '        colors = np.clip([husl.husl_to_rgb(*hsl) for hsl in ramp], 0, 1)', '        return mpl.colors.ListedColormap(colors[::-1])']}, {'name': '_default_discrete', 'start_line': 220, 'end_line': 228, 'text': ['    def _default_discrete(self):', '        \"\"\"Find default values for discrete hist estimation based on variable type.\"\"\"', '        if self.univariate:', '            discrete = self.var_types[self.data_variable] == \"categorical\"', '        else:', '            discrete_x = self.var_types[\"x\"] == \"categorical\"', '            discrete_y = self.var_types[\"y\"] == \"categorical\"', '            discrete = discrete_x, discrete_y', '        return discrete']}, {'name': '_resolve_multiple', 'start_line': 230, 'end_line': 295, 'text': ['    def _resolve_multiple(self, curves, multiple):', '        \"\"\"Modify the density data structure to handle multiple densities.\"\"\"', '', '        # Default baselines have all densities starting at 0', '        baselines = {k: np.zeros_like(v) for k, v in curves.items()}', '', '        # TODO we should have some central clearinghouse for checking if any', '        # \"grouping\" (terminnology?) semantics have been assigned', '        if \"hue\" not in self.variables:', '            return curves, baselines', '', '        if multiple in (\"stack\", \"fill\"):', '', '            # Setting stack or fill means that the curves share a', '            # support grid / set of bin edges, so we can make a dataframe', '            # Reverse the column order to plot from top to bottom', '            curves = pd.DataFrame(curves).iloc[:, ::-1]', '', '            # Find column groups that are nested within col/row variables', '            column_groups = {}', '            for i, keyd in enumerate(map(dict, curves.columns)):', '                facet_key = keyd.get(\"col\", None), keyd.get(\"row\", None)', '                column_groups.setdefault(facet_key, [])', '                column_groups[facet_key].append(i)', '', '            baselines = curves.copy()', '            for col_idxs in column_groups.values():', '                cols = curves.columns[col_idxs]', '', '                norm_constant = curves[cols].sum(axis=\"columns\")', '', '                # Take the cumulative sum to stack', '                curves[cols] = curves[cols].cumsum(axis=\"columns\")', '', '                # Normalize by row sum to fill', '                if multiple == \"fill\":', '                    curves[cols] = curves[cols].div(norm_constant, axis=\"index\")', '', '                # Define where each segment starts', '                baselines[cols] = curves[cols].shift(1, axis=1).fillna(0)', '', '        if multiple == \"dodge\":', '', '            # Account for the unique semantic (non-faceting) levels', '            # This will require rethiniking if we add other semantics!', '            hue_levels = self.var_levels[\"hue\"]', '            n = len(hue_levels)', '            for key in curves:', '                level = dict(key)[\"hue\"]', '                hist = curves[key].reset_index(name=\"heights\")', '                level_idx = hue_levels.index(level)', '                if self._log_scaled(self.data_variable):', '                    log_min = np.log10(hist[\"edges\"])', '                    log_max = np.log10(hist[\"edges\"] + hist[\"widths\"])', '                    log_width = (log_max - log_min) / n', '                    new_min = np.power(10, log_min + level_idx * log_width)', '                    new_max = np.power(10, log_min + (level_idx + 1) * log_width)', '                    hist[\"widths\"] = new_max - new_min', '                    hist[\"edges\"] = new_min', '                else:', '                    hist[\"widths\"] /= n', '                    hist[\"edges\"] += level_idx * hist[\"widths\"]', '', '                curves[key] = hist.set_index([\"edges\", \"widths\"])[\"heights\"]', '', '        return curves, baselines']}, {'name': '_compute_univariate_density', 'start_line': 301, 'end_line': 373, 'text': ['    def _compute_univariate_density(', '        self,', '        data_variable,', '        common_norm,', '        common_grid,', '        estimate_kws,', '        log_scale,', '        warn_singular=True,', '    ):', '', '        # Initialize the estimator object', '        estimator = KDE(**estimate_kws)', '', '        if set(self.variables) - {\"x\", \"y\"}:', '            if common_grid:', '                all_observations = self.comp_data.dropna()', '                estimator.define_support(all_observations[data_variable])', '        else:', '            common_norm = False', '', '        all_data = self.plot_data.dropna()', '        if common_norm and \"weights\" in all_data:', '            whole_weight = all_data[\"weights\"].sum()', '        else:', '            whole_weight = len(all_data)', '', '        densities = {}', '', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Extract the data points from this sub set and remove nulls', '            observations = sub_data[data_variable]', '', '            # Extract the weights for this subset of observations', '            if \"weights\" in self.variables:', '                weights = sub_data[\"weights\"]', '                part_weight = weights.sum()', '            else:', '                weights = None', '                part_weight = len(sub_data)', '', '            # Estimate the density of observations at this level', '            variance = np.nan_to_num(observations.var())', '            singular = len(observations) < 2 or math.isclose(variance, 0)', '            try:', '                if not singular:', '                    # Convoluted approach needed because numerical failures', '                    # can manifest in a few different ways.', '                    density, support = estimator(observations, weights=weights)', '            except np.linalg.LinAlgError:', '                singular = True', '', '            if singular:', '                msg = (', '                    \"Dataset has 0 variance; skipping density estimate. \"', '                    \"Pass `warn_singular=False` to disable this warning.\"', '                )', '                if warn_singular:', '                    warnings.warn(msg, UserWarning, stacklevel=4)', '                continue', '', '            if log_scale:', '                support = np.power(10, support)', '', '            # Apply a scaling factor so that the integral over all subsets is 1', '            if common_norm:', '                density *= part_weight / whole_weight', '', '            # Store the density for this level', '            key = tuple(sub_vars.items())', '            densities[key] = pd.Series(density, index=support)', '', '        return densities']}, {'name': 'plot_univariate_histogram', 'start_line': 379, 'end_line': 742, 'text': ['    def plot_univariate_histogram(', '        self,', '        multiple,', '        element,', '        fill,', '        common_norm,', '        common_bins,', '        shrink,', '        kde,', '        kde_kws,', '        color,', '        legend,', '        line_kws,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # -- Default keyword dicts', '        kde_kws = {} if kde_kws is None else kde_kws.copy()', '        line_kws = {} if line_kws is None else line_kws.copy()', '        estimate_kws = {} if estimate_kws is None else estimate_kws.copy()', '', '        # --  Input checking', '        _check_argument(\"multiple\", [\"layer\", \"stack\", \"fill\", \"dodge\"], multiple)', '        _check_argument(\"element\", [\"bars\", \"step\", \"poly\"], element)', '', '        auto_bins_with_weights = (', '            \"weights\" in self.variables', '            and estimate_kws[\"bins\"] == \"auto\"', '            and estimate_kws[\"binwidth\"] is None', '            and not estimate_kws[\"discrete\"]', '        )', '        if auto_bins_with_weights:', '            msg = (', '                \"`bins` cannot be \\'auto\\' when using weights. \"', '                \"Setting `bins=10`, but you will likely want to adjust.\"', '            )', '            warnings.warn(msg, UserWarning)', '            estimate_kws[\"bins\"] = 10', '', '        # Simplify downstream code if we are not normalizing', '        if estimate_kws[\"stat\"] == \"count\":', '            common_norm = False', '', '        orient = self.data_variable', '', '        # Now initialize the Histogram estimator', '        estimator = Hist(**estimate_kws)', '        histograms = {}', '', '        # Do pre-compute housekeeping related to multiple groups', '        all_data = self.comp_data.dropna()', '        all_weights = all_data.get(\"weights\", None)', '', '        multiple_histograms = set(self.variables) - {\"x\", \"y\"}', '        if multiple_histograms:', '            if common_bins:', '                bin_kws = estimator._define_bin_params(all_data, orient, None)', '        else:', '            common_norm = False', '', '        if common_norm and all_weights is not None:', '            whole_weight = all_weights.sum()', '        else:', '            whole_weight = len(all_data)', '', '        # Estimate the smoothed kernel densities, for use later', '        if kde:', '            # TODO alternatively, clip at min/max bins?', '            kde_kws.setdefault(\"cut\", 0)', '            kde_kws[\"cumulative\"] = estimate_kws[\"cumulative\"]', '            log_scale = self._log_scaled(self.data_variable)', '            densities = self._compute_univariate_density(', '                self.data_variable,', '                common_norm,', '                common_bins,', '                kde_kws,', '                log_scale,', '                warn_singular=False,', '            )', '', '        # First pass through the data to compute the histograms', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Prepare the relevant data', '            key = tuple(sub_vars.items())', '            orient = self.data_variable', '', '            if \"weights\" in self.variables:', '                sub_data[\"weight\"] = sub_data.pop(\"weights\")', '                part_weight = sub_data[\"weight\"].sum()', '            else:', '                part_weight = len(sub_data)', '', '            # Do the histogram computation', '            if not (multiple_histograms and common_bins):', '                bin_kws = estimator._define_bin_params(sub_data, orient, None)', '            res = estimator._normalize(estimator._eval(sub_data, orient, bin_kws))', '            heights = res[estimator.stat].to_numpy()', '            widths = res[\"space\"].to_numpy()', '            edges = res[orient].to_numpy() - widths / 2', '', '            # Convert edges back to original units for plotting', '            if self._log_scaled(self.data_variable):', '                widths = np.power(10, edges + widths) - np.power(10, edges)', '                edges = np.power(10, edges)', '', '            # Rescale the smoothed curve to match the histogram', '            if kde and key in densities:', '                density = densities[key]', '                if estimator.cumulative:', '                    hist_norm = heights.max()', '                else:', '                    hist_norm = (heights * widths).sum()', '                densities[key] *= hist_norm', '', '            # Pack the histogram data and metadata together', '            edges = edges + (1 - shrink) / 2 * widths', '            widths *= shrink', '            index = pd.MultiIndex.from_arrays([', '                pd.Index(edges, name=\"edges\"),', '                pd.Index(widths, name=\"widths\"),', '            ])', '            hist = pd.Series(heights, index=index, name=\"heights\")', '', '            # Apply scaling to normalize across groups', '            if common_norm:', '                hist *= part_weight / whole_weight', '', '            # Store the finalized histogram data for future plotting', '            histograms[key] = hist', '', '        # Modify the histogram and density data to resolve multiple groups', '        histograms, baselines = self._resolve_multiple(histograms, multiple)', '        if kde:', '            densities, _ = self._resolve_multiple(', '                densities, None if multiple == \"dodge\" else multiple', '            )', '', '        # Set autoscaling-related meta', '        sticky_stat = (0, 1) if multiple == \"fill\" else (0, np.inf)', '        if multiple == \"fill\":', '            # Filled plots should not have any margins', '            bin_vals = histograms.index.to_frame()', '            edges = bin_vals[\"edges\"]', '            widths = bin_vals[\"widths\"]', '            sticky_data = (', '                edges.min(),', '                edges.max() + widths.loc[edges.idxmax()]', '            )', '        else:', '            sticky_data = []', '', '        # --- Handle default visual attributes', '', '        # Note: default linewidth is determined after plotting', '', '        # Default alpha should depend on other parameters', '        if fill:', '            # Note: will need to account for other grouping semantics if added', '            if \"hue\" in self.variables and multiple == \"layer\":', '                default_alpha = .5 if element == \"bars\" else .25', '            elif kde:', '                default_alpha = .5', '            else:', '                default_alpha = .75', '        else:', '            default_alpha = 1', '        alpha = plot_kws.pop(\"alpha\", default_alpha)  # TODO make parameter?', '', '        hist_artists = []', '', '        # Go back through the dataset and draw the plots', '        for sub_vars, _ in self.iter_data(\"hue\", reverse=True):', '', '            key = tuple(sub_vars.items())', '            hist = histograms[key].rename(\"heights\").reset_index()', '            bottom = np.asarray(baselines[key])', '', '            ax = self._get_axes(sub_vars)', '', '            # Define the matplotlib attributes that depend on semantic mapping', '            if \"hue\" in self.variables:', '                sub_color = self._hue_map(sub_vars[\"hue\"])', '            else:', '                sub_color = color', '', '            artist_kws = self._artist_kws(', '                plot_kws, fill, element, multiple, sub_color, alpha', '            )', '', '            if element == \"bars\":', '', '                # Use matplotlib bar plotting', '', '                plot_func = ax.bar if self.data_variable == \"x\" else ax.barh', '                artists = plot_func(', '                    hist[\"edges\"],', '                    hist[\"heights\"] - bottom,', '                    hist[\"widths\"],', '                    bottom,', '                    align=\"edge\",', '                    **artist_kws,', '                )', '', '                for bar in artists:', '                    if self.data_variable == \"x\":', '                        bar.sticky_edges.x[:] = sticky_data', '                        bar.sticky_edges.y[:] = sticky_stat', '                    else:', '                        bar.sticky_edges.x[:] = sticky_stat', '                        bar.sticky_edges.y[:] = sticky_data', '', '                hist_artists.extend(artists)', '', '            else:', '', '                # Use either fill_between or plot to draw hull of histogram', '                if element == \"step\":', '', '                    final = hist.iloc[-1]', '                    x = np.append(hist[\"edges\"], final[\"edges\"] + final[\"widths\"])', '                    y = np.append(hist[\"heights\"], final[\"heights\"])', '                    b = np.append(bottom, bottom[-1])', '', '                    if self.data_variable == \"x\":', '                        step = \"post\"', '                        drawstyle = \"steps-post\"', '                    else:', '                        step = \"post\"  # fillbetweenx handles mapping internally', '                        drawstyle = \"steps-pre\"', '', '                elif element == \"poly\":', '', '                    x = hist[\"edges\"] + hist[\"widths\"] / 2', '                    y = hist[\"heights\"]', '                    b = bottom', '', '                    step = None', '                    drawstyle = None', '', '                if self.data_variable == \"x\":', '                    if fill:', '                        artist = ax.fill_between(x, b, y, step=step, **artist_kws)', '                    else:', '                        artist, = ax.plot(x, y, drawstyle=drawstyle, **artist_kws)', '                    artist.sticky_edges.x[:] = sticky_data', '                    artist.sticky_edges.y[:] = sticky_stat', '                else:', '                    if fill:', '                        artist = ax.fill_betweenx(x, b, y, step=step, **artist_kws)', '                    else:', '                        artist, = ax.plot(y, x, drawstyle=drawstyle, **artist_kws)', '                    artist.sticky_edges.x[:] = sticky_stat', '                    artist.sticky_edges.y[:] = sticky_data', '', '                hist_artists.append(artist)', '', '            if kde:', '', '                # Add in the density curves', '', '                try:', '                    density = densities[key]', '                except KeyError:', '                    continue', '                support = density.index', '', '                if \"x\" in self.variables:', '                    line_args = support, density', '                    sticky_x, sticky_y = None, (0, np.inf)', '                else:', '                    line_args = density, support', '                    sticky_x, sticky_y = (0, np.inf), None', '', '                line_kws[\"color\"] = to_rgba(sub_color, 1)', '                line, = ax.plot(', '                    *line_args, **line_kws,', '                )', '', '                if sticky_x is not None:', '                    line.sticky_edges.x[:] = sticky_x', '                if sticky_y is not None:', '                    line.sticky_edges.y[:] = sticky_y', '', '        if element == \"bars\" and \"linewidth\" not in plot_kws:', '', '            # Now we handle linewidth, which depends on the scaling of the plot', '', '            # We will base everything on the minimum bin width', '            hist_metadata = pd.concat([', '                # Use .items for generality over dict or df', '                h.index.to_frame() for _, h in histograms.items()', '            ]).reset_index(drop=True)', '            thin_bar_idx = hist_metadata[\"widths\"].idxmin()', '            binwidth = hist_metadata.loc[thin_bar_idx, \"widths\"]', '            left_edge = hist_metadata.loc[thin_bar_idx, \"edges\"]', '', '            # Set initial value', '            default_linewidth = math.inf', '', '            # Loop through subsets based only on facet variables', '            for sub_vars, _ in self.iter_data():', '', '                ax = self._get_axes(sub_vars)', '', '                # Needed in some cases to get valid transforms.', '                # Innocuous in other cases?', '                ax.autoscale_view()', '', '                # Convert binwidth from data coordinates to pixels', '                pts_x, pts_y = 72 / ax.figure.dpi * abs(', '                    ax.transData.transform([left_edge + binwidth] * 2)', '                    - ax.transData.transform([left_edge] * 2)', '                )', '                if self.data_variable == \"x\":', '                    binwidth_points = pts_x', '                else:', '                    binwidth_points = pts_y', '', '                # The relative size of the lines depends on the appearance', '                # This is a provisional value and may need more tweaking', '                default_linewidth = min(.1 * binwidth_points, default_linewidth)', '', '            # Set the attributes', '            for bar in hist_artists:', '', \"                # Don't let the lines get too thick\", '                max_linewidth = bar.get_linewidth()', '                if not fill:', '                    max_linewidth *= 1.5', '', '                linewidth = min(default_linewidth, max_linewidth)', '', \"                # If not filling, don't let lines disappear\", '                if not fill:', '                    min_linewidth = .5', '                    linewidth = max(linewidth, min_linewidth)', '', '                bar.set_linewidth(linewidth)', '', '        # --- Finalize the plot ----', '', '        # Axis labels', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = estimator.stat.capitalize()', '        if self.data_variable == \"y\":', '            default_x = estimator.stat.capitalize()', '        self._add_axis_labels(ax, default_x, default_y)', '', '        # Legend for semantic variables', '        if \"hue\" in self.variables and legend:', '', '            if fill or element == \"bars\":', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, element, multiple, alpha, plot_kws, {},', '            )']}, {'name': 'plot_bivariate_histogram', 'start_line': 744, 'end_line': 899, 'text': ['    def plot_bivariate_histogram(', '        self,', '        common_bins, common_norm,', '        thresh, pthresh, pmax,', '        color, legend,', '        cbar, cbar_ax, cbar_kws,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # Default keyword dicts', '        cbar_kws = {} if cbar_kws is None else cbar_kws.copy()', '', '        # Now initialize the Histogram estimator', '        estimator = Histogram(**estimate_kws)', '', '        # Do pre-compute housekeeping related to multiple groups', '        if set(self.variables) - {\"x\", \"y\"}:', '            all_data = self.comp_data.dropna()', '            if common_bins:', '                estimator.define_bin_params(', '                    all_data[\"x\"],', '                    all_data[\"y\"],', '                    all_data.get(\"weights\", None),', '                )', '        else:', '            common_norm = False', '', '        # -- Determine colormap threshold and norm based on the full data', '', '        full_heights = []', '        for _, sub_data in self.iter_data(from_comp_data=True):', '            sub_heights, _ = estimator(', '                sub_data[\"x\"], sub_data[\"y\"], sub_data.get(\"weights\", None)', '            )', '            full_heights.append(sub_heights)', '', '        common_color_norm = not set(self.variables) - {\"x\", \"y\"} or common_norm', '', '        if pthresh is not None and common_color_norm:', '            thresh = self._quantile_to_level(full_heights, pthresh)', '', '        plot_kws.setdefault(\"vmin\", 0)', '        if common_color_norm:', '            if pmax is not None:', '                vmax = self._quantile_to_level(full_heights, pmax)', '            else:', '                vmax = plot_kws.pop(\"vmax\", max(map(np.max, full_heights)))', '        else:', '            vmax = None', '', '        # Get a default color', \"        # (We won't follow the color cycle here, as multiple plots are unlikely)\", '        if color is None:', '            color = \"C0\"', '', '        # --- Loop over data (subsets) and draw the histograms', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            if sub_data.empty:', '                continue', '', '            # Do the histogram computation', '            heights, (x_edges, y_edges) = estimator(', '                sub_data[\"x\"],', '                sub_data[\"y\"],', '                weights=sub_data.get(\"weights\", None),', '            )', '', '            # Check for log scaling on the data axis', '            if self._log_scaled(\"x\"):', '                x_edges = np.power(10, x_edges)', '            if self._log_scaled(\"y\"):', '                y_edges = np.power(10, y_edges)', '', '            # Apply scaling to normalize across groups', '            if estimator.stat != \"count\" and common_norm:', '                heights *= len(sub_data) / len(all_data)', '', '            # Define the specific kwargs for this artist', '            artist_kws = plot_kws.copy()', '            if \"hue\" in self.variables:', '                color = self._hue_map(sub_vars[\"hue\"])', '                cmap = self._cmap_from_color(color)', '                artist_kws[\"cmap\"] = cmap', '            else:', '                cmap = artist_kws.pop(\"cmap\", None)', '                if isinstance(cmap, str):', '                    cmap = color_palette(cmap, as_cmap=True)', '                elif cmap is None:', '                    cmap = self._cmap_from_color(color)', '                artist_kws[\"cmap\"] = cmap', '', '            # Set the upper norm on the colormap', '            if not common_color_norm and pmax is not None:', '                vmax = self._quantile_to_level(heights, pmax)', '            if vmax is not None:', '                artist_kws[\"vmax\"] = vmax', '', '            # Make cells at or below the threshold transparent', '            if not common_color_norm and pthresh:', '                thresh = self._quantile_to_level(heights, pthresh)', '            if thresh is not None:', '                heights = np.ma.masked_less_equal(heights, thresh)', '', '            # Get the axes for this plot', '            ax = self._get_axes(sub_vars)', '', '            # pcolormesh is going to turn the grid off, but we want to keep it', \"            # I'm not sure if there's a better way to get the grid state\", '            x_grid = any([l.get_visible() for l in ax.xaxis.get_gridlines()])', '            y_grid = any([l.get_visible() for l in ax.yaxis.get_gridlines()])', '', '            mesh = ax.pcolormesh(', '                x_edges,', '                y_edges,', '                heights.T,', '                **artist_kws,', '            )', '', '            # pcolormesh sets sticky edges, but we only want them if not thresholding', '            if thresh is not None:', '                mesh.sticky_edges.x[:] = []', '                mesh.sticky_edges.y[:] = []', '', '            # Add an optional colorbar', '            # Note, we want to improve this. When hue is used, it will stack', '            # multiple colorbars with redundant ticks in an ugly way.', \"            # But it's going to take some work to have multiple colorbars that\", '            # share ticks nicely.', '            if cbar:', '                ax.figure.colorbar(mesh, cbar_ax, ax, **cbar_kws)', '', '            # Reset the grid state', '            if x_grid:', '                ax.grid(True, axis=\"x\")', '            if y_grid:', '                ax.grid(True, axis=\"y\")', '', '        # --- Finalize the plot', '', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        self._add_axis_labels(ax)', '', '        if \"hue\" in self.variables and legend:', '', '            # TODO if possible, I would like to move the contour', '            # intensity information into the legend too and label the', '            # iso proportions rather than the raw density values', '', '            artist_kws = {}', '            artist = partial(mpl.patches.Patch)', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, True, False, \"layer\", 1, artist_kws, {},', '            )']}, {'name': 'plot_univariate_density', 'start_line': 901, 'end_line': 1034, 'text': ['    def plot_univariate_density(', '        self,', '        multiple,', '        common_norm,', '        common_grid,', '        warn_singular,', '        fill,', '        color,', '        legend,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # Handle conditional defaults', '        if fill is None:', '            fill = multiple in (\"stack\", \"fill\")', '', '        # Preprocess the matplotlib keyword dictionaries', '        if fill:', '            artist = mpl.collections.PolyCollection', '        else:', '            artist = mpl.lines.Line2D', '        plot_kws = _normalize_kwargs(plot_kws, artist)', '', '        # Input checking', '        _check_argument(\"multiple\", [\"layer\", \"stack\", \"fill\"], multiple)', '', '        # Always share the evaluation grid when stacking', '        subsets = bool(set(self.variables) - {\"x\", \"y\"})', '        if subsets and multiple in (\"stack\", \"fill\"):', '            common_grid = True', '', '        # Check if the data axis is log scaled', '        log_scale = self._log_scaled(self.data_variable)', '', '        # Do the computation', '        densities = self._compute_univariate_density(', '            self.data_variable,', '            common_norm,', '            common_grid,', '            estimate_kws,', '            log_scale,', '            warn_singular,', '        )', '', '        # Adjust densities based on the `multiple` rule', '        densities, baselines = self._resolve_multiple(densities, multiple)', '', '        # Control the interaction with autoscaling by defining sticky_edges', \"        # i.e. we don't want autoscale margins below the density curve\", '        sticky_density = (0, 1) if multiple == \"fill\" else (0, np.inf)', '', '        if multiple == \"fill\":', '            # Filled plots should not have any margins', '            sticky_support = densities.index.min(), densities.index.max()', '        else:', '            sticky_support = []', '', '        if fill:', '            if multiple == \"layer\":', '                default_alpha = .25', '            else:', '                default_alpha = .75', '        else:', '            default_alpha = 1', '        alpha = plot_kws.pop(\"alpha\", default_alpha)  # TODO make parameter?', '', '        # Now iterate through the subsets and draw the densities', '        # We go backwards so stacked densities read from top-to-bottom', '        for sub_vars, _ in self.iter_data(\"hue\", reverse=True):', '', '            # Extract the support grid and density curve for this level', '            key = tuple(sub_vars.items())', '            try:', '                density = densities[key]', '            except KeyError:', '                continue', '            support = density.index', '            fill_from = baselines[key]', '', '            ax = self._get_axes(sub_vars)', '', '            if \"hue\" in self.variables:', '                sub_color = self._hue_map(sub_vars[\"hue\"])', '            else:', '                sub_color = color', '', '            artist_kws = self._artist_kws(', '                plot_kws, fill, False, multiple, sub_color, alpha', '            )', '', '            # Either plot a curve with observation values on the x axis', '            if \"x\" in self.variables:', '', '                if fill:', '                    artist = ax.fill_between(support, fill_from, density, **artist_kws)', '', '                else:', '                    artist, = ax.plot(support, density, **artist_kws)', '', '                artist.sticky_edges.x[:] = sticky_support', '                artist.sticky_edges.y[:] = sticky_density', '', '            # Or plot a curve with observation values on the y axis', '            else:', '                if fill:', '                    artist = ax.fill_betweenx(support, fill_from, density, **artist_kws)', '                else:', '                    artist, = ax.plot(density, support, **artist_kws)', '', '                artist.sticky_edges.x[:] = sticky_density', '                artist.sticky_edges.y[:] = sticky_support', '', '        # --- Finalize the plot ----', '', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = \"Density\"', '        if self.data_variable == \"y\":', '            default_x = \"Density\"', '        self._add_axis_labels(ax, default_x, default_y)', '', '        if \"hue\" in self.variables and legend:', '', '            if fill:', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, False, multiple, alpha, plot_kws, {},', '            )']}, {'name': 'plot_bivariate_density', 'start_line': 1036, 'end_line': 1220, 'text': ['    def plot_bivariate_density(', '        self,', '        common_norm,', '        fill,', '        levels,', '        thresh,', '        color,', '        legend,', '        cbar,', '        warn_singular,', '        cbar_ax,', '        cbar_kws,', '        estimate_kws,', '        **contour_kws,', '    ):', '', '        contour_kws = contour_kws.copy()', '', '        estimator = KDE(**estimate_kws)', '', '        if not set(self.variables) - {\"x\", \"y\"}:', '            common_norm = False', '', '        all_data = self.plot_data.dropna()', '', '        # Loop through the subsets and estimate the KDEs', '        densities, supports = {}, {}', '', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Extract the data points from this sub set', '            observations = sub_data[[\"x\", \"y\"]]', '            min_variance = observations.var().fillna(0).min()', '            observations = observations[\"x\"], observations[\"y\"]', '', '            # Extract the weights for this subset of observations', '            if \"weights\" in self.variables:', '                weights = sub_data[\"weights\"]', '            else:', '                weights = None', '', '            # Estimate the density of observations at this level', '            singular = math.isclose(min_variance, 0)', '            try:', '                if not singular:', '                    density, support = estimator(*observations, weights=weights)', '            except np.linalg.LinAlgError:', \"                # Testing for 0 variance doesn't catch all cases where scipy raises,\", '                # but we can also get a ValueError, so we need this convoluted approach', '                singular = True', '', '            if singular:', '                msg = (', '                    \"KDE cannot be estimated (0 variance or perfect covariance). \"', '                    \"Pass `warn_singular=False` to disable this warning.\"', '                )', '                if warn_singular:', '                    warnings.warn(msg, UserWarning, stacklevel=3)', '                continue', '', '            # Transform the support grid back to the original scale', '            xx, yy = support', '            if self._log_scaled(\"x\"):', '                xx = np.power(10, xx)', '            if self._log_scaled(\"y\"):', '                yy = np.power(10, yy)', '            support = xx, yy', '', '            # Apply a scaling factor so that the integral over all subsets is 1', '            if common_norm:', '                density *= len(sub_data) / len(all_data)', '', '            key = tuple(sub_vars.items())', '            densities[key] = density', '            supports[key] = support', '', '        # Define a grid of iso-proportion levels', '        if thresh is None:', '            thresh = 0', '        if isinstance(levels, Number):', '            levels = np.linspace(thresh, 1, levels)', '        else:', '            if min(levels) < 0 or max(levels) > 1:', '                raise ValueError(\"levels must be in [0, 1]\")', '', '        # Transform from iso-proportions to iso-densities', '        if common_norm:', '            common_levels = self._quantile_to_level(', '                list(densities.values()), levels,', '            )', '            draw_levels = {k: common_levels for k in densities}', '        else:', '            draw_levels = {', '                k: self._quantile_to_level(d, levels)', '                for k, d in densities.items()', '            }', '', '        # Define the coloring of the contours', '        if \"hue\" in self.variables:', '            for param in [\"cmap\", \"colors\"]:', '                if param in contour_kws:', '                    msg = f\"{param} parameter ignored when using hue mapping.\"', '                    warnings.warn(msg, UserWarning)', '                    contour_kws.pop(param)', '        else:', '', '            # Work out a default coloring of the contours', '            coloring_given = set(contour_kws) & {\"cmap\", \"colors\"}', '            if fill and not coloring_given:', '                cmap = self._cmap_from_color(color)', '                contour_kws[\"cmap\"] = cmap', '            if not fill and not coloring_given:', '                contour_kws[\"colors\"] = [color]', '', '            # Use our internal colormap lookup', '            cmap = contour_kws.pop(\"cmap\", None)', '            if isinstance(cmap, str):', '                cmap = color_palette(cmap, as_cmap=True)', '            if cmap is not None:', '                contour_kws[\"cmap\"] = cmap', '', '        # Loop through the subsets again and plot the data', '        for sub_vars, _ in self.iter_data(\"hue\"):', '', '            if \"hue\" in sub_vars:', '                color = self._hue_map(sub_vars[\"hue\"])', '                if fill:', '                    contour_kws[\"cmap\"] = self._cmap_from_color(color)', '                else:', '                    contour_kws[\"colors\"] = [color]', '', '            ax = self._get_axes(sub_vars)', '', '            # Choose the function to plot with', '            # TODO could add a pcolormesh based option as well', '            # Which would look something like element=\"raster\"', '            if fill:', '                contour_func = ax.contourf', '            else:', '                contour_func = ax.contour', '', '            key = tuple(sub_vars.items())', '            if key not in densities:', '                continue', '            density = densities[key]', '            xx, yy = supports[key]', '', '            label = contour_kws.pop(\"label\", None)', '', '            cset = contour_func(', '                xx, yy, density,', '                levels=draw_levels[key],', '                **contour_kws,', '            )', '', '            if \"hue\" not in self.variables:', '                cset.collections[0].set_label(label)', '', '            # Add a color bar representing the contour heights', '            # Note: this shows iso densities, not iso proportions', '            # See more notes in histplot about how this could be improved', '            if cbar:', '                cbar_kws = {} if cbar_kws is None else cbar_kws', '                ax.figure.colorbar(cset, cbar_ax, ax, **cbar_kws)', '', '        # --- Finalize the plot', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        self._add_axis_labels(ax)', '', '        if \"hue\" in self.variables and legend:', '', '            # TODO if possible, I would like to move the contour', '            # intensity information into the legend too and label the', '            # iso proportions rather than the raw density values', '', '            artist_kws = {}', '            if fill:', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, False, \"layer\", 1, artist_kws, {},', '            )']}, {'name': 'plot_univariate_ecdf', 'start_line': 1222, 'end_line': 1289, 'text': ['    def plot_univariate_ecdf(self, estimate_kws, legend, **plot_kws):', '', '        estimator = ECDF(**estimate_kws)', '', '        # Set the draw style to step the right way for the data variable', '        drawstyles = dict(x=\"steps-post\", y=\"steps-pre\")', '        plot_kws[\"drawstyle\"] = drawstyles[self.data_variable]', '', '        # Loop through the subsets, transform and plot the data', '        for sub_vars, sub_data in self.iter_data(', '            \"hue\", reverse=True, from_comp_data=True,', '        ):', '', '            # Compute the ECDF', '            if sub_data.empty:', '                continue', '', '            observations = sub_data[self.data_variable]', '            weights = sub_data.get(\"weights\", None)', '            stat, vals = estimator(observations, weights=weights)', '', '            # Assign attributes based on semantic mapping', '            artist_kws = plot_kws.copy()', '            if \"hue\" in self.variables:', '                artist_kws[\"color\"] = self._hue_map(sub_vars[\"hue\"])', '', '            # Return the data variable to the linear domain', '            # This needs an automatic solution; see GH2409', '            if self._log_scaled(self.data_variable):', '                vals = np.power(10, vals)', '                vals[0] = -np.inf', '', '            # Work out the orientation of the plot', '            if self.data_variable == \"x\":', '                plot_args = vals, stat', '                stat_variable = \"y\"', '            else:', '                plot_args = stat, vals', '                stat_variable = \"x\"', '', '            if estimator.stat == \"count\":', '                top_edge = len(observations)', '            else:', '                top_edge = 1', '', '            # Draw the line for this subset', '            ax = self._get_axes(sub_vars)', '            artist, = ax.plot(*plot_args, **artist_kws)', '            sticky_edges = getattr(artist.sticky_edges, stat_variable)', '            sticky_edges[:] = 0, top_edge', '', '        # --- Finalize the plot ----', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        stat = estimator.stat.capitalize()', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = stat', '        if self.data_variable == \"y\":', '            default_x = stat', '        self._add_axis_labels(ax, default_x, default_y)', '', '        if \"hue\" in self.variables and legend:', '            artist = partial(mpl.lines.Line2D, [], [])', '            alpha = plot_kws.get(\"alpha\", 1)', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, False, False, None, alpha, plot_kws, {},', '            )']}, {'name': 'plot_rug', 'start_line': 1291, 'end_line': 1323, 'text': ['    def plot_rug(self, height, expand_margins, legend, **kws):', '', '        for sub_vars, sub_data, in self.iter_data(from_comp_data=True):', '', '            ax = self._get_axes(sub_vars)', '', '            kws.setdefault(\"linewidth\", 1)', '', '            if expand_margins:', '                xmarg, ymarg = ax.margins()', '                if \"x\" in self.variables:', '                    ymarg += height * 2', '                if \"y\" in self.variables:', '                    xmarg += height * 2', '                ax.margins(x=xmarg, y=ymarg)', '', '            if \"hue\" in self.variables:', '                kws.pop(\"c\", None)', '                kws.pop(\"color\", None)', '', '            if \"x\" in self.variables:', '                self._plot_single_rug(sub_data, \"x\", height, ax, kws)', '            if \"y\" in self.variables:', '                self._plot_single_rug(sub_data, \"y\", height, ax, kws)', '', '            # --- Finalize the plot', '            self._add_axis_labels(ax)', '            if \"hue\" in self.variables and legend:', \"                # TODO ideally i'd like the legend artist to look like a rug\", '                legend_artist = partial(mpl.lines.Line2D, [], [])', '                self._add_legend(', '                    ax, legend_artist, False, False, None, 1, {}, {},', '                )']}, {'name': '_plot_single_rug', 'start_line': 1325, 'end_line': 1362, 'text': ['    def _plot_single_rug(self, sub_data, var, height, ax, kws):', '        \"\"\"Draw a rugplot along one axis of the plot.\"\"\"', '        vector = sub_data[var]', '        n = len(vector)', '', '        # Return data to linear domain', '        # This needs an automatic solution; see GH2409', '        if self._log_scaled(var):', '            vector = np.power(10, vector)', '', \"        # We'll always add a single collection with varying colors\", '        if \"hue\" in self.variables:', '            colors = self._hue_map(sub_data[\"hue\"])', '        else:', '            colors = None', '', '        # Build the array of values for the LineCollection', '        if var == \"x\":', '', '            trans = tx.blended_transform_factory(ax.transData, ax.transAxes)', '            xy_pairs = np.column_stack([', '                np.repeat(vector, 2), np.tile([0, height], n)', '            ])', '', '        if var == \"y\":', '', '            trans = tx.blended_transform_factory(ax.transAxes, ax.transData)', '            xy_pairs = np.column_stack([', '                np.tile([0, height], n), np.repeat(vector, 2)', '            ])', '', '        # Draw the lines on the plot', '        line_segs = xy_pairs.reshape([n, 2, 2])', '        ax.add_collection(LineCollection(', '            line_segs, transform=trans, colors=colors, **kws', '        ))', '', '        ax.autoscale_view(scalex=var == \"x\", scaley=var == \"y\")']}]}, {'name': '_DistributionFacetPlotter', 'start_line': 1365, 'end_line': 1367, 'text': ['class _DistributionFacetPlotter(_DistributionPlotter):', '', '    semantics = _DistributionPlotter.semantics + (\"col\", \"row\")'], 'methods': []}], 'functions': [{'name': 'histplot', 'start_line': 1374, 'end_line': 1465, 'text': ['def histplot(', '    data=None, *,', '    # Vector variables', '    x=None, y=None, hue=None, weights=None,', '    # Histogram computation parameters', '    stat=\"count\", bins=\"auto\", binwidth=None, binrange=None,', '    discrete=None, cumulative=False, common_bins=True, common_norm=True,', '    # Histogram appearance parameters', '    multiple=\"layer\", element=\"bars\", fill=True, shrink=1,', '    # Histogram smoothing with a kernel density estimate', '    kde=False, kde_kws=None, line_kws=None,', '    # Bivariate histogram parameters', '    thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None, cbar_kws=None,', '    # Hue mapping parameters', '    palette=None, hue_order=None, hue_norm=None, color=None,', '    # Axes information', '    log_scale=None, legend=True, ax=None,', '    # Other appearance keywords', '    **kwargs,', '):', '', '    p = _DistributionPlotter(', '        data=data,', '        variables=_DistributionPlotter.get_semantics(locals())', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    if ax is None:', '        ax = plt.gca()', '', '    p._attach(ax, log_scale=log_scale)', '', \"    if p.univariate:  # Note, bivariate plots won't cycle\", '        if fill:', '            method = ax.bar if element == \"bars\" else ax.fill_between', '        else:', '            method = ax.plot', '        color = _default_color(method, hue, color, kwargs)', '', '    if not p.has_xy_data:', '        return ax', '', '    # Default to discrete bins for categorical variables', '    if discrete is None:', '        discrete = p._default_discrete()', '', '    estimate_kws = dict(', '        stat=stat,', '        bins=bins,', '        binwidth=binwidth,', '        binrange=binrange,', '        discrete=discrete,', '        cumulative=cumulative,', '    )', '', '    if p.univariate:', '', '        p.plot_univariate_histogram(', '            multiple=multiple,', '            element=element,', '            fill=fill,', '            shrink=shrink,', '            common_norm=common_norm,', '            common_bins=common_bins,', '            kde=kde,', '            kde_kws=kde_kws,', '            color=color,', '            legend=legend,', '            estimate_kws=estimate_kws,', '            line_kws=line_kws,', '            **kwargs,', '        )', '', '    else:', '', '        p.plot_bivariate_histogram(', '            common_bins=common_bins,', '            common_norm=common_norm,', '            thresh=thresh,', '            pthresh=pthresh,', '            pmax=pmax,', '            color=color,', '            legend=legend,', '            cbar=cbar,', '            cbar_ax=cbar_ax,', '            cbar_kws=cbar_kws,', '            estimate_kws=estimate_kws,', '            **kwargs,', '        )', '', '    return ax']}, {'name': 'kdeplot', 'start_line': 1597, 'end_line': 1746, 'text': ['def kdeplot(', '    data=None, *, x=None, y=None, hue=None, weights=None,', '    palette=None, hue_order=None, hue_norm=None, color=None, fill=None,', '    multiple=\"layer\", common_norm=True, common_grid=False, cumulative=False,', '    bw_method=\"scott\", bw_adjust=1, warn_singular=True, log_scale=None,', '    levels=10, thresh=.05, gridsize=200, cut=3, clip=None,', '    legend=True, cbar=False, cbar_ax=None, cbar_kws=None, ax=None,', '    **kwargs,', '):', '', '    # --- Start with backwards compatability for versions < 0.11.0 ----------------', '', '    # Handle (past) deprecation of `data2`', '    if \"data2\" in kwargs:', '        msg = \"`data2` has been removed (replaced by `y`); please update your code.\"', '        TypeError(msg)', '', '    # Handle deprecation of `vertical`', '    vertical = kwargs.pop(\"vertical\", None)', '    if vertical is not None:', '        if vertical:', '            action_taken = \"assigning data to `y`.\"', '            if x is None:', '                data, y = y, data', '            else:', '                x, y = y, x', '        else:', '            action_taken = \"assigning data to `x`.\"', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        The `vertical` parameter is deprecated; {action_taken}', '        This will become an error in seaborn v0.13.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # Handle deprecation of `bw`', '    bw = kwargs.pop(\"bw\", None)', '    if bw is not None:', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        The `bw` parameter is deprecated in favor of `bw_method` and `bw_adjust`.', '        Setting `bw_method={bw}`, but please see the docs for the new parameters', '        and update your code. This will become an error in seaborn v0.13.0.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '        bw_method = bw', '', '    # Handle deprecation of `kernel`', '    if kwargs.pop(\"kernel\", None) is not None:', '        msg = textwrap.dedent(\"\"\"\\\\n', '        Support for alternate kernels has been removed; using Gaussian kernel.', '        This will become an error in seaborn v0.13.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # Handle deprecation of shade_lowest', '    shade_lowest = kwargs.pop(\"shade_lowest\", None)', '    if shade_lowest is not None:', '        if shade_lowest:', '            thresh = 0', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        `shade_lowest` has been replaced by `thresh`; setting `thresh={thresh}.', '        This will become an error in seaborn v0.13.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # Handle \"soft\" deprecation of shade `shade` is not really the right', '    # terminology here, but unlike some of the other deprecated parameters it', '    # is probably very commonly used and much hard to remove. This is therefore', '    # going to be a longer process where, first, `fill` will be introduced and', '    # be used throughout the documentation. In 0.12, when kwarg-only', '    # enforcement hits, we can remove the shade/shade_lowest out of the', '    # function signature all together and pull them out of the kwargs. Then we', '    # can actually fire a FutureWarning, and eventually remove.', '    shade = kwargs.pop(\"shade\", None)', '    if shade is not None:', '        fill = shade', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        `shade` is now deprecated in favor of `fill`; setting `fill={shade}`.', '        This will become an error in seaborn v0.14.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, FutureWarning, stacklevel=2)', '', '    # Handle `n_levels`', '    # This was never in the formal API but it was processed, and appeared in an', '    # example. We can treat as an alias for `levels` now and deprecate later.', '    levels = kwargs.pop(\"n_levels\", levels)', '', '    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #', '', '    p = _DistributionPlotter(', '        data=data,', '        variables=_DistributionPlotter.get_semantics(locals()),', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    if ax is None:', '        ax = plt.gca()', '', '    p._attach(ax, allowed_types=[\"numeric\", \"datetime\"], log_scale=log_scale)', '', '    method = ax.fill_between if fill else ax.plot', '    color = _default_color(method, hue, color, kwargs)', '', '    if not p.has_xy_data:', '        return ax', '', '    # Pack the kwargs for statistics.KDE', '    estimate_kws = dict(', '        bw_method=bw_method,', '        bw_adjust=bw_adjust,', '        gridsize=gridsize,', '        cut=cut,', '        clip=clip,', '        cumulative=cumulative,', '    )', '', '    if p.univariate:', '', '        plot_kws = kwargs.copy()', '', '        p.plot_univariate_density(', '            multiple=multiple,', '            common_norm=common_norm,', '            common_grid=common_grid,', '            fill=fill,', '            color=color,', '            legend=legend,', '            warn_singular=warn_singular,', '            estimate_kws=estimate_kws,', '            **plot_kws,', '        )', '', '    else:', '', '        p.plot_bivariate_density(', '            common_norm=common_norm,', '            fill=fill,', '            levels=levels,', '            thresh=thresh,', '            legend=legend,', '            color=color,', '            warn_singular=warn_singular,', '            cbar=cbar,', '            cbar_ax=cbar_ax,', '            cbar_kws=cbar_kws,', '            estimate_kws=estimate_kws,', '            **kwargs,', '        )', '', '    return ax']}, {'name': 'ecdfplot', 'start_line': 1877, 'end_line': 1930, 'text': ['def ecdfplot(', '    data=None, *,', '    # Vector variables', '    x=None, y=None, hue=None, weights=None,', '    # Computation parameters', '    stat=\"proportion\", complementary=False,', '    # Hue mapping parameters', '    palette=None, hue_order=None, hue_norm=None,', '    # Axes information', '    log_scale=None, legend=True, ax=None,', '    # Other appearance keywords', '    **kwargs,', '):', '', '    p = _DistributionPlotter(', '        data=data,', '        variables=_DistributionPlotter.get_semantics(locals())', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    # We could support other semantics (size, style) here fairly easily', '    # But it would make distplot a bit more complicated.', \"    # It's always possible to add features like that later, so I am going to defer.\", '    # It will be even easier to wait until after there is a more general/abstract', '    # way to go from semantic specs to artist attributes.', '', '    if ax is None:', '        ax = plt.gca()', '', '    p._attach(ax, log_scale=log_scale)', '', '    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))', '    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)', '', '    if not p.has_xy_data:', '        return ax', '', \"    # We could add this one day, but it's of dubious value\", '    if not p.univariate:', '        raise NotImplementedError(\"Bivariate ECDF plots are not implemented\")', '', '    estimate_kws = dict(', '        stat=stat,', '        complementary=complementary,', '    )', '', '    p.plot_univariate_ecdf(', '        estimate_kws=estimate_kws,', '        legend=legend,', '        **kwargs,', '    )', '', '    return ax']}, {'name': 'rugplot', 'start_line': 1989, 'end_line': 2066, 'text': ['def rugplot(', '    data=None, *, x=None, y=None, hue=None, height=.025, expand_margins=True,', '    palette=None, hue_order=None, hue_norm=None, legend=True, ax=None, **kwargs', '):', '', '    # A note: I think it would make sense to add multiple= to rugplot and allow', '    # rugs for different hue variables to be shifted orthogonal to the data axis', '    # But is this stacking, or dodging?', '', '    # A note: if we want to add a style semantic to rugplot,', '    # we could make an option that draws the rug using scatterplot', '', '    # A note, it would also be nice to offer some kind of histogram/density', \"    # rugplot, since alpha blending doesn't work great in the large n regime\", '', '    # --- Start with backwards compatability for versions < 0.11.0 ----------------', '', '    a = kwargs.pop(\"a\", None)', '    axis = kwargs.pop(\"axis\", None)', '', '    if a is not None:', '        data = a', '        msg = textwrap.dedent(\"\"\"\\\\n', '        The `a` parameter has been replaced; use `x`, `y`, and/or `data` instead.', '        Please update your code; This will become an error in seaborn v0.13.0.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    if axis is not None:', '        if axis == \"x\":', '            x = data', '        elif axis == \"y\":', '            y = data', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        The `axis` parameter has been deprecated; use the `{axis}` parameter instead.', '        Please update your code; this will become an error in seaborn v0.13.0.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    vertical = kwargs.pop(\"vertical\", None)', '    if vertical is not None:', '        if vertical:', '            action_taken = \"assigning data to `y`.\"', '            if x is None:', '                data, y = y, data', '            else:', '                x, y = y, x', '        else:', '            action_taken = \"assigning data to `x`.\"', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        The `vertical` parameter is deprecated; {action_taken}', '        This will become an error in seaborn v0.13.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #', '', '    weights = None', '    p = _DistributionPlotter(', '        data=data,', '        variables=_DistributionPlotter.get_semantics(locals()),', '    )', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    if ax is None:', '        ax = plt.gca()', '', '    p._attach(ax)', '', '    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))', '    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)', '', '    if not p.has_xy_data:', '        return ax', '', '    p.plot_rug(height, expand_margins, legend, **kwargs)', '', '    return ax']}, {'name': 'displot', 'start_line': 2111, 'end_line': 2300, 'text': ['def displot(', '    data=None, *,', '    # Vector variables', '    x=None, y=None, hue=None, row=None, col=None, weights=None,', '    # Other plot parameters', '    kind=\"hist\", rug=False, rug_kws=None, log_scale=None, legend=True,', '    # Hue-mapping parameters', '    palette=None, hue_order=None, hue_norm=None, color=None,', '    # Faceting parameters', '    col_wrap=None, row_order=None, col_order=None,', '    height=5, aspect=1, facet_kws=None,', '    **kwargs,', '):', '', '    p = _DistributionFacetPlotter(', '        data=data,', '        variables=_DistributionFacetPlotter.get_semantics(locals())', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    _check_argument(\"kind\", [\"hist\", \"kde\", \"ecdf\"], kind)', '', '    # --- Initialize the FacetGrid object', '', '    # Check for attempt to plot onto specific axes and warn', '    if \"ax\" in kwargs:', '        msg = (', '            \"`displot` is a figure-level function and does not accept \"', '            \"the ax= parameter. You may wish to try {}plot.\".format(kind)', '        )', '        warnings.warn(msg, UserWarning)', '        kwargs.pop(\"ax\")', '', '    for var in [\"row\", \"col\"]:', '        # Handle faceting variables that lack name information', '        if var in p.variables and p.variables[var] is None:', '            p.variables[var] = f\"_{var}_\"', '', '    # Adapt the plot_data dataframe for use with FacetGrid', '    grid_data = p.plot_data.rename(columns=p.variables)', '    grid_data = grid_data.loc[:, ~grid_data.columns.duplicated()]', '', '    col_name = p.variables.get(\"col\")', '    row_name = p.variables.get(\"row\")', '', '    if facet_kws is None:', '        facet_kws = {}', '', '    g = FacetGrid(', '        data=grid_data, row=row_name, col=col_name,', '        col_wrap=col_wrap, row_order=row_order,', '        col_order=col_order, height=height,', '        aspect=aspect,', '        **facet_kws,', '    )', '', '    # Now attach the axes object to the plotter object', '    if kind == \"kde\":', '        allowed_types = [\"numeric\", \"datetime\"]', '    else:', '        allowed_types = None', '    p._attach(g, allowed_types=allowed_types, log_scale=log_scale)', '', '    # Check for a specification that lacks x/y data and return early', '    if not p.has_xy_data:', '        return g', '', '    if color is None and hue is None:', '        color = \"C0\"', '    # XXX else warn if hue is not None?', '', '    kwargs[\"legend\"] = legend', '', '    # --- Draw the plots', '', '    if kind == \"hist\":', '', '        hist_kws = kwargs.copy()', '', '        # Extract the parameters that will go directly to Histogram', '        estimate_defaults = {}', '        _assign_default_kwargs(estimate_defaults, Histogram.__init__, histplot)', '', '        estimate_kws = {}', '        for key, default_val in estimate_defaults.items():', '            estimate_kws[key] = hist_kws.pop(key, default_val)', '', '        # Handle derivative defaults', '        if estimate_kws[\"discrete\"] is None:', '            estimate_kws[\"discrete\"] = p._default_discrete()', '', '        hist_kws[\"estimate_kws\"] = estimate_kws', '', '        hist_kws.setdefault(\"color\", color)', '', '        if p.univariate:', '', '            _assign_default_kwargs(hist_kws, p.plot_univariate_histogram, histplot)', '            p.plot_univariate_histogram(**hist_kws)', '', '        else:', '', '            _assign_default_kwargs(hist_kws, p.plot_bivariate_histogram, histplot)', '            p.plot_bivariate_histogram(**hist_kws)', '', '    elif kind == \"kde\":', '', '        kde_kws = kwargs.copy()', '', '        # Extract the parameters that will go directly to KDE', '        estimate_defaults = {}', '        _assign_default_kwargs(estimate_defaults, KDE.__init__, kdeplot)', '', '        estimate_kws = {}', '        for key, default_val in estimate_defaults.items():', '            estimate_kws[key] = kde_kws.pop(key, default_val)', '', '        kde_kws[\"estimate_kws\"] = estimate_kws', '        kde_kws[\"color\"] = color', '', '        if p.univariate:', '', '            _assign_default_kwargs(kde_kws, p.plot_univariate_density, kdeplot)', '            p.plot_univariate_density(**kde_kws)', '', '        else:', '', '            _assign_default_kwargs(kde_kws, p.plot_bivariate_density, kdeplot)', '            p.plot_bivariate_density(**kde_kws)', '', '    elif kind == \"ecdf\":', '', '        ecdf_kws = kwargs.copy()', '', '        # Extract the parameters that will go directly to the estimator', '        estimate_kws = {}', '        estimate_defaults = {}', '        _assign_default_kwargs(estimate_defaults, ECDF.__init__, ecdfplot)', '        for key, default_val in estimate_defaults.items():', '            estimate_kws[key] = ecdf_kws.pop(key, default_val)', '', '        ecdf_kws[\"estimate_kws\"] = estimate_kws', '        ecdf_kws[\"color\"] = color', '', '        if p.univariate:', '', '            _assign_default_kwargs(ecdf_kws, p.plot_univariate_ecdf, ecdfplot)', '            p.plot_univariate_ecdf(**ecdf_kws)', '', '        else:', '', '            raise NotImplementedError(\"Bivariate ECDF plots are not implemented\")', '', '    # All plot kinds can include a rug', '    if rug:', '        # TODO with expand_margins=True, each facet expands margins... annoying!', '        if rug_kws is None:', '            rug_kws = {}', '        _assign_default_kwargs(rug_kws, p.plot_rug, rugplot)', '        rug_kws[\"legend\"] = False', '        if color is not None:', '            rug_kws[\"color\"] = color', '        p.plot_rug(**rug_kws)', '', '    # Call FacetGrid annotation methods', '    # Note that the legend is currently set inside the plotting method', '    g.set_axis_labels(', '        x_var=p.variables.get(\"x\", g.axes.flat[0].get_xlabel()),', '        y_var=p.variables.get(\"y\", g.axes.flat[0].get_ylabel()),', '    )', '    g.set_titles()', '    g.tight_layout()', '', '    if data is not None and (x is not None or y is not None):', '        if not isinstance(data, pd.DataFrame):', '            data = pd.DataFrame(data)', '        g.data = pd.merge(', '            data,', '            g.data[g.data.columns.difference(data.columns)],', '            left_index=True,', '            right_index=True,', '        )', '    else:', '        wide_cols = {', '            k: f\"_{k}_\" if v is None else v for k, v in p.variables.items()', '        }', '        g.data = p.plot_data.rename(columns=wide_cols)', '', '    return g']}, {'name': '_freedman_diaconis_bins', 'start_line': 2390, 'end_line': 2402, 'text': ['def _freedman_diaconis_bins(a):', '    \"\"\"Calculate number of hist bins using Freedman-Diaconis rule.\"\"\"', '    # From https://stats.stackexchange.com/questions/798/', '    a = np.asarray(a)', '    if len(a) < 2:', '        return 1', '    iqr = np.subtract.reduce(np.nanpercentile(a, [75, 25]))', '    h = 2 * iqr / (len(a) ** (1 / 3))', '    # fall back to sqrt(a) bins if iqr is 0', '    if h == 0:', '        return int(np.sqrt(a.size))', '    else:', '        return int(np.ceil((a.max() - a.min()) / h))']}, {'name': 'distplot', 'start_line': 2405, 'end_line': 2546, 'text': ['def distplot(a=None, bins=None, hist=True, kde=True, rug=False, fit=None,', '             hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None,', '             color=None, vertical=False, norm_hist=False, axlabel=None,', '             label=None, ax=None, x=None):', '    \"\"\"', '    DEPRECATED', '', '    This function has been deprecated and will be removed in seaborn v0.14.0.', '    It has been replaced by :func:`histplot` and :func:`displot`, two functions', '    with a modern API and many more capabilities.', '', '    For a guide to updating, please see this notebook:', '', '    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751', '', '    \"\"\"', '', '    if kde and not hist:', '        axes_level_suggestion = (', '            \"`kdeplot` (an axes-level function for kernel density plots)\"', '        )', '    else:', '        axes_level_suggestion = (', '            \"`histplot` (an axes-level function for histograms)\"', '        )', '', '    msg = textwrap.dedent(f\"\"\"', '', '    `distplot` is a deprecated function and will be removed in seaborn v0.14.0.', '', '    Please adapt your code to use either `displot` (a figure-level function with', '    similar flexibility) or {axes_level_suggestion}.', '', '    For a guide to updating your code to use the new functions, please see', '    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751', '    \"\"\")', '    warnings.warn(msg, UserWarning, stacklevel=2)', '', '    if ax is None:', '        ax = plt.gca()', '', '    # Intelligently label the support axis', '    label_ax = bool(axlabel)', '    if axlabel is None and hasattr(a, \"name\"):', '        axlabel = a.name', '        if axlabel is not None:', '            label_ax = True', '', '    # Support new-style API', '    if x is not None:', '        a = x', '', '    # Make a a 1-d float array', '    a = np.asarray(a, float)', '    if a.ndim > 1:', '        a = a.squeeze()', '', '    # Drop null values from array', '    a = remove_na(a)', '', '    # Decide if the hist is normed', '    norm_hist = norm_hist or kde or (fit is not None)', '', '    # Handle dictionary defaults', '    hist_kws = {} if hist_kws is None else hist_kws.copy()', '    kde_kws = {} if kde_kws is None else kde_kws.copy()', '    rug_kws = {} if rug_kws is None else rug_kws.copy()', '    fit_kws = {} if fit_kws is None else fit_kws.copy()', '', '    # Get the color from the current color cycle', '    if color is None:', '        if vertical:', '            line, = ax.plot(0, a.mean())', '        else:', '            line, = ax.plot(a.mean(), 0)', '        color = line.get_color()', '        line.remove()', '', '    # Plug the label into the right kwarg dictionary', '    if label is not None:', '        if hist:', '            hist_kws[\"label\"] = label', '        elif kde:', '            kde_kws[\"label\"] = label', '        elif rug:', '            rug_kws[\"label\"] = label', '        elif fit:', '            fit_kws[\"label\"] = label', '', '    if hist:', '        if bins is None:', '            bins = min(_freedman_diaconis_bins(a), 50)', '        hist_kws.setdefault(\"alpha\", 0.4)', '        hist_kws.setdefault(\"density\", norm_hist)', '', '        orientation = \"horizontal\" if vertical else \"vertical\"', '        hist_color = hist_kws.pop(\"color\", color)', '        ax.hist(a, bins, orientation=orientation,', '                color=hist_color, **hist_kws)', '        if hist_color != color:', '            hist_kws[\"color\"] = hist_color', '', '    axis = \"y\" if vertical else \"x\"', '', '    if kde:', '        kde_color = kde_kws.pop(\"color\", color)', '        kdeplot(**{axis: a}, ax=ax, color=kde_color, **kde_kws)', '        if kde_color != color:', '            kde_kws[\"color\"] = kde_color', '', '    if rug:', '        rug_color = rug_kws.pop(\"color\", color)', '        rugplot(**{axis: a}, ax=ax, color=rug_color, **rug_kws)', '        if rug_color != color:', '            rug_kws[\"color\"] = rug_color', '', '    if fit is not None:', '', '        def pdf(x):', '            return fit.pdf(x, *params)', '', '        fit_color = fit_kws.pop(\"color\", \"#282828\")', '        gridsize = fit_kws.pop(\"gridsize\", 200)', '        cut = fit_kws.pop(\"cut\", 3)', '        clip = fit_kws.pop(\"clip\", (-np.inf, np.inf))', '        bw = gaussian_kde(a).scotts_factor() * a.std(ddof=1)', '        x = _kde_support(a, bw, gridsize, cut, clip)', '        params = fit.fit(a)', '        y = pdf(x)', '        if vertical:', '            x, y = y, x', '        ax.plot(x, y, color=fit_color, **fit_kws)', '        if fit_color != \"#282828\":', '            fit_kws[\"color\"] = fit_color', '', '    if label_ax:', '        if vertical:', '            ax.set_ylabel(axlabel)', '        else:', '            ax.set_xlabel(axlabel)', '', '    return ax']}, {'name': 'pdf', 'start_line': 2523, 'end_line': 2524, 'text': ['        def pdf(x):', '            return fit.pdf(x, *params)']}], 'text': ['\"\"\"Plotting functions for visualizing distributions.\"\"\"', 'from numbers import Number', 'from functools import partial', 'import math', 'import textwrap', 'import warnings', '', 'import numpy as np', 'import pandas as pd', 'import matplotlib as mpl', 'import matplotlib.pyplot as plt', 'import matplotlib.transforms as tx', 'from matplotlib.colors import to_rgba', 'from matplotlib.collections import LineCollection', '', 'from ._oldcore import (', '    VectorPlotter,', ')', '', '# We have moved univariate histogram computation over to the new Hist class,', '# but still use the older Histogram for bivariate computation.', 'from ._statistics import ECDF, Histogram, KDE', 'from ._stats.histogram import Hist', '', 'from .axisgrid import (', '    FacetGrid,', '    _facet_docs,', ')', 'from .utils import (', '    remove_na,', '    _kde_support,', '    _normalize_kwargs,', '    _check_argument,', '    _assign_default_kwargs,', '    _default_color,', ')', 'from .palettes import color_palette', 'from .external import husl', 'from .external.kde import gaussian_kde', 'from ._docstrings import (', '    DocstringComponents,', '    _core_docs,', ')', '', '', '__all__ = [\"displot\", \"histplot\", \"kdeplot\", \"ecdfplot\", \"rugplot\", \"distplot\"]', '', '# ==================================================================================== #', '# Module documentation', '# ==================================================================================== #', '', '_dist_params = dict(', '', '    multiple=\"\"\"', 'multiple : {{\"layer\", \"stack\", \"fill\"}}', '    Method for drawing multiple elements when semantic mapping creates subsets.', '    Only relevant with univariate data.', '    \"\"\",', '    log_scale=\"\"\"', 'log_scale : bool or number, or pair of bools or numbers', '    Set axis scale(s) to log. A single value sets the data axis for univariate', '    distributions and both axes for bivariate distributions. A pair of values', '    sets each axis independently. Numeric values are interpreted as the desired', '    base (default 10). If `False`, defer to the existing Axes scale.', '    \"\"\",', '    legend=\"\"\"', 'legend : bool', '    If False, suppress the legend for semantic variables.', '    \"\"\",', '    cbar=\"\"\"', 'cbar : bool', '    If True, add a colorbar to annotate the color mapping in a bivariate plot.', '    Note: Does not currently support plots with a ``hue`` variable well.', '    \"\"\",', '    cbar_ax=\"\"\"', 'cbar_ax : :class:`matplotlib.axes.Axes`', '    Pre-existing axes for the colorbar.', '    \"\"\",', '    cbar_kws=\"\"\"', 'cbar_kws : dict', '    Additional parameters passed to :meth:`matplotlib.figure.Figure.colorbar`.', '    \"\"\",', ')', '', '_param_docs = DocstringComponents.from_nested_components(', '    core=_core_docs[\"params\"],', '    facets=DocstringComponents(_facet_docs),', '    dist=DocstringComponents(_dist_params),', '    kde=DocstringComponents.from_function_params(KDE.__init__),', '    hist=DocstringComponents.from_function_params(Histogram.__init__),', '    ecdf=DocstringComponents.from_function_params(ECDF.__init__),', ')', '', '', '# ==================================================================================== #', '# Internal API', '# ==================================================================================== #', '', '', 'class _DistributionPlotter(VectorPlotter):', '', '    semantics = \"x\", \"y\", \"hue\", \"weights\"', '', '    wide_structure = {\"x\": \"@values\", \"hue\": \"@columns\"}', '    flat_structure = {\"x\": \"@values\"}', '', '    def __init__(', '        self,', '        data=None,', '        variables={},', '    ):', '', '        super().__init__(data=data, variables=variables)', '', '    @property', '    def univariate(self):', '        \"\"\"Return True if only x or y are used.\"\"\"', '        # TODO this could go down to core, but putting it here now.', \"        # We'd want to be conceptually clear that univariate only applies\", '        # to x/y and not to other semantics, which can exist.', \"        # We haven't settled on a good conceptual name for x/y.\", '        return bool({\"x\", \"y\"} - set(self.variables))', '', '    @property', '    def data_variable(self):', '        \"\"\"Return the variable with data for univariate plots.\"\"\"', '        # TODO This could also be in core, but it should have a better name.', '        if not self.univariate:', '            raise AttributeError(\"This is not a univariate plot\")', '        return {\"x\", \"y\"}.intersection(self.variables).pop()', '', '    @property', '    def has_xy_data(self):', '        \"\"\"Return True at least one of x or y is defined.\"\"\"', '        # TODO see above points about where this should go', '        return bool({\"x\", \"y\"} & set(self.variables))', '', '    def _add_legend(', '        self,', '        ax_obj, artist, fill, element, multiple, alpha, artist_kws, legend_kws,', '    ):', '        \"\"\"Add artists that reflect semantic mappings and put then in a legend.\"\"\"', \"        # TODO note that this doesn't handle numeric mappings like the relational plots\", '        handles = []', '        labels = []', '        for level in self._hue_map.levels:', '            color = self._hue_map(level)', '', '            kws = self._artist_kws(', '                artist_kws, fill, element, multiple, color, alpha', '            )', '', \"            # color gets added to the kws to workaround an issue with barplot's color\", '            # cycle integration but it causes problems in this context where we are', '            # setting artist properties directly, so pop it off here', '            if \"facecolor\" in kws:', '                kws.pop(\"color\", None)', '', '            handles.append(artist(**kws))', '            labels.append(level)', '', '        if isinstance(ax_obj, mpl.axes.Axes):', '            ax_obj.legend(handles, labels, title=self.variables[\"hue\"], **legend_kws)', '        else:  # i.e. a FacetGrid. TODO make this better', '            legend_data = dict(zip(labels, handles))', '            ax_obj.add_legend(', '                legend_data,', '                title=self.variables[\"hue\"],', '                label_order=self.var_levels[\"hue\"],', '                **legend_kws', '            )', '', '    def _artist_kws(self, kws, fill, element, multiple, color, alpha):', '        \"\"\"Handle differences between artists in filled/unfilled plots.\"\"\"', '        kws = kws.copy()', '        if fill:', '            kws = _normalize_kwargs(kws, mpl.collections.PolyCollection)', '            kws.setdefault(\"facecolor\", to_rgba(color, alpha))', '', '            if element == \"bars\":', '                # Make bar() interface with property cycle correctly', '                # https://github.com/matplotlib/matplotlib/issues/19385', '                kws[\"color\"] = \"none\"', '', '            if multiple in [\"stack\", \"fill\"] or element == \"bars\":', '                kws.setdefault(\"edgecolor\", mpl.rcParams[\"patch.edgecolor\"])', '            else:', '                kws.setdefault(\"edgecolor\", to_rgba(color, 1))', '        elif element == \"bars\":', '            kws[\"facecolor\"] = \"none\"', '            kws[\"edgecolor\"] = to_rgba(color, alpha)', '        else:', '            kws[\"color\"] = to_rgba(color, alpha)', '        return kws', '', '    def _quantile_to_level(self, data, quantile):', '        \"\"\"Return data levels corresponding to quantile cuts of mass.\"\"\"', '        isoprop = np.asarray(quantile)', '        values = np.ravel(data)', '        sorted_values = np.sort(values)[::-1]', '        normalized_values = np.cumsum(sorted_values) / values.sum()', '        idx = np.searchsorted(normalized_values, 1 - isoprop)', '        levels = np.take(sorted_values, idx, mode=\"clip\")', '        return levels', '', '    def _cmap_from_color(self, color):', '        \"\"\"Return a sequential colormap given a color seed.\"\"\"', '        # Like so much else here, this is broadly useful, but keeping it', \"        # in this class to signify that I haven't thought overly hard about it...\", '        r, g, b, _ = to_rgba(color)', '        h, s, _ = husl.rgb_to_husl(r, g, b)', '        xx = np.linspace(-1, 1, int(1.15 * 256))[:256]', '        ramp = np.zeros((256, 3))', '        ramp[:, 0] = h', '        ramp[:, 1] = s * np.cos(xx)', '        ramp[:, 2] = np.linspace(35, 80, 256)', '        colors = np.clip([husl.husl_to_rgb(*hsl) for hsl in ramp], 0, 1)', '        return mpl.colors.ListedColormap(colors[::-1])', '', '    def _default_discrete(self):', '        \"\"\"Find default values for discrete hist estimation based on variable type.\"\"\"', '        if self.univariate:', '            discrete = self.var_types[self.data_variable] == \"categorical\"', '        else:', '            discrete_x = self.var_types[\"x\"] == \"categorical\"', '            discrete_y = self.var_types[\"y\"] == \"categorical\"', '            discrete = discrete_x, discrete_y', '        return discrete', '', '    def _resolve_multiple(self, curves, multiple):', '        \"\"\"Modify the density data structure to handle multiple densities.\"\"\"', '', '        # Default baselines have all densities starting at 0', '        baselines = {k: np.zeros_like(v) for k, v in curves.items()}', '', '        # TODO we should have some central clearinghouse for checking if any', '        # \"grouping\" (terminnology?) semantics have been assigned', '        if \"hue\" not in self.variables:', '            return curves, baselines', '', '        if multiple in (\"stack\", \"fill\"):', '', '            # Setting stack or fill means that the curves share a', '            # support grid / set of bin edges, so we can make a dataframe', '            # Reverse the column order to plot from top to bottom', '            curves = pd.DataFrame(curves).iloc[:, ::-1]', '', '            # Find column groups that are nested within col/row variables', '            column_groups = {}', '            for i, keyd in enumerate(map(dict, curves.columns)):', '                facet_key = keyd.get(\"col\", None), keyd.get(\"row\", None)', '                column_groups.setdefault(facet_key, [])', '                column_groups[facet_key].append(i)', '', '            baselines = curves.copy()', '            for col_idxs in column_groups.values():', '                cols = curves.columns[col_idxs]', '', '                norm_constant = curves[cols].sum(axis=\"columns\")', '', '                # Take the cumulative sum to stack', '                curves[cols] = curves[cols].cumsum(axis=\"columns\")', '', '                # Normalize by row sum to fill', '                if multiple == \"fill\":', '                    curves[cols] = curves[cols].div(norm_constant, axis=\"index\")', '', '                # Define where each segment starts', '                baselines[cols] = curves[cols].shift(1, axis=1).fillna(0)', '', '        if multiple == \"dodge\":', '', '            # Account for the unique semantic (non-faceting) levels', '            # This will require rethiniking if we add other semantics!', '            hue_levels = self.var_levels[\"hue\"]', '            n = len(hue_levels)', '            for key in curves:', '                level = dict(key)[\"hue\"]', '                hist = curves[key].reset_index(name=\"heights\")', '                level_idx = hue_levels.index(level)', '                if self._log_scaled(self.data_variable):', '                    log_min = np.log10(hist[\"edges\"])', '                    log_max = np.log10(hist[\"edges\"] + hist[\"widths\"])', '                    log_width = (log_max - log_min) / n', '                    new_min = np.power(10, log_min + level_idx * log_width)', '                    new_max = np.power(10, log_min + (level_idx + 1) * log_width)', '                    hist[\"widths\"] = new_max - new_min', '                    hist[\"edges\"] = new_min', '                else:', '                    hist[\"widths\"] /= n', '                    hist[\"edges\"] += level_idx * hist[\"widths\"]', '', '                curves[key] = hist.set_index([\"edges\", \"widths\"])[\"heights\"]', '', '        return curves, baselines', '', '    # -------------------------------------------------------------------------------- #', '    # Computation', '    # -------------------------------------------------------------------------------- #', '', '    def _compute_univariate_density(', '        self,', '        data_variable,', '        common_norm,', '        common_grid,', '        estimate_kws,', '        log_scale,', '        warn_singular=True,', '    ):', '', '        # Initialize the estimator object', '        estimator = KDE(**estimate_kws)', '', '        if set(self.variables) - {\"x\", \"y\"}:', '            if common_grid:', '                all_observations = self.comp_data.dropna()', '                estimator.define_support(all_observations[data_variable])', '        else:', '            common_norm = False', '', '        all_data = self.plot_data.dropna()', '        if common_norm and \"weights\" in all_data:', '            whole_weight = all_data[\"weights\"].sum()', '        else:', '            whole_weight = len(all_data)', '', '        densities = {}', '', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Extract the data points from this sub set and remove nulls', '            observations = sub_data[data_variable]', '', '            # Extract the weights for this subset of observations', '            if \"weights\" in self.variables:', '                weights = sub_data[\"weights\"]', '                part_weight = weights.sum()', '            else:', '                weights = None', '                part_weight = len(sub_data)', '', '            # Estimate the density of observations at this level', '            variance = np.nan_to_num(observations.var())', '            singular = len(observations) < 2 or math.isclose(variance, 0)', '            try:', '                if not singular:', '                    # Convoluted approach needed because numerical failures', '                    # can manifest in a few different ways.', '                    density, support = estimator(observations, weights=weights)', '            except np.linalg.LinAlgError:', '                singular = True', '', '            if singular:', '                msg = (', '                    \"Dataset has 0 variance; skipping density estimate. \"', '                    \"Pass `warn_singular=False` to disable this warning.\"', '                )', '                if warn_singular:', '                    warnings.warn(msg, UserWarning, stacklevel=4)', '                continue', '', '            if log_scale:', '                support = np.power(10, support)', '', '            # Apply a scaling factor so that the integral over all subsets is 1', '            if common_norm:', '                density *= part_weight / whole_weight', '', '            # Store the density for this level', '            key = tuple(sub_vars.items())', '            densities[key] = pd.Series(density, index=support)', '', '        return densities', '', '    # -------------------------------------------------------------------------------- #', '    # Plotting', '    # -------------------------------------------------------------------------------- #', '', '    def plot_univariate_histogram(', '        self,', '        multiple,', '        element,', '        fill,', '        common_norm,', '        common_bins,', '        shrink,', '        kde,', '        kde_kws,', '        color,', '        legend,', '        line_kws,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # -- Default keyword dicts', '        kde_kws = {} if kde_kws is None else kde_kws.copy()', '        line_kws = {} if line_kws is None else line_kws.copy()', '        estimate_kws = {} if estimate_kws is None else estimate_kws.copy()', '', '        # --  Input checking', '        _check_argument(\"multiple\", [\"layer\", \"stack\", \"fill\", \"dodge\"], multiple)', '        _check_argument(\"element\", [\"bars\", \"step\", \"poly\"], element)', '', '        auto_bins_with_weights = (', '            \"weights\" in self.variables', '            and estimate_kws[\"bins\"] == \"auto\"', '            and estimate_kws[\"binwidth\"] is None', '            and not estimate_kws[\"discrete\"]', '        )', '        if auto_bins_with_weights:', '            msg = (', '                \"`bins` cannot be \\'auto\\' when using weights. \"', '                \"Setting `bins=10`, but you will likely want to adjust.\"', '            )', '            warnings.warn(msg, UserWarning)', '            estimate_kws[\"bins\"] = 10', '', '        # Simplify downstream code if we are not normalizing', '        if estimate_kws[\"stat\"] == \"count\":', '            common_norm = False', '', '        orient = self.data_variable', '', '        # Now initialize the Histogram estimator', '        estimator = Hist(**estimate_kws)', '        histograms = {}', '', '        # Do pre-compute housekeeping related to multiple groups', '        all_data = self.comp_data.dropna()', '        all_weights = all_data.get(\"weights\", None)', '', '        multiple_histograms = set(self.variables) - {\"x\", \"y\"}', '        if multiple_histograms:', '            if common_bins:', '                bin_kws = estimator._define_bin_params(all_data, orient, None)', '        else:', '            common_norm = False', '', '        if common_norm and all_weights is not None:', '            whole_weight = all_weights.sum()', '        else:', '            whole_weight = len(all_data)', '', '        # Estimate the smoothed kernel densities, for use later', '        if kde:', '            # TODO alternatively, clip at min/max bins?', '            kde_kws.setdefault(\"cut\", 0)', '            kde_kws[\"cumulative\"] = estimate_kws[\"cumulative\"]', '            log_scale = self._log_scaled(self.data_variable)', '            densities = self._compute_univariate_density(', '                self.data_variable,', '                common_norm,', '                common_bins,', '                kde_kws,', '                log_scale,', '                warn_singular=False,', '            )', '', '        # First pass through the data to compute the histograms', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Prepare the relevant data', '            key = tuple(sub_vars.items())', '            orient = self.data_variable', '', '            if \"weights\" in self.variables:', '                sub_data[\"weight\"] = sub_data.pop(\"weights\")', '                part_weight = sub_data[\"weight\"].sum()', '            else:', '                part_weight = len(sub_data)', '', '            # Do the histogram computation', '            if not (multiple_histograms and common_bins):', '                bin_kws = estimator._define_bin_params(sub_data, orient, None)', '            res = estimator._normalize(estimator._eval(sub_data, orient, bin_kws))', '            heights = res[estimator.stat].to_numpy()', '            widths = res[\"space\"].to_numpy()', '            edges = res[orient].to_numpy() - widths / 2', '', '            # Convert edges back to original units for plotting', '            if self._log_scaled(self.data_variable):', '                widths = np.power(10, edges + widths) - np.power(10, edges)', '                edges = np.power(10, edges)', '', '            # Rescale the smoothed curve to match the histogram', '            if kde and key in densities:', '                density = densities[key]', '                if estimator.cumulative:', '                    hist_norm = heights.max()', '                else:', '                    hist_norm = (heights * widths).sum()', '                densities[key] *= hist_norm', '', '            # Pack the histogram data and metadata together', '            edges = edges + (1 - shrink) / 2 * widths', '            widths *= shrink', '            index = pd.MultiIndex.from_arrays([', '                pd.Index(edges, name=\"edges\"),', '                pd.Index(widths, name=\"widths\"),', '            ])', '            hist = pd.Series(heights, index=index, name=\"heights\")', '', '            # Apply scaling to normalize across groups', '            if common_norm:', '                hist *= part_weight / whole_weight', '', '            # Store the finalized histogram data for future plotting', '            histograms[key] = hist', '', '        # Modify the histogram and density data to resolve multiple groups', '        histograms, baselines = self._resolve_multiple(histograms, multiple)', '        if kde:', '            densities, _ = self._resolve_multiple(', '                densities, None if multiple == \"dodge\" else multiple', '            )', '', '        # Set autoscaling-related meta', '        sticky_stat = (0, 1) if multiple == \"fill\" else (0, np.inf)', '        if multiple == \"fill\":', '            # Filled plots should not have any margins', '            bin_vals = histograms.index.to_frame()', '            edges = bin_vals[\"edges\"]', '            widths = bin_vals[\"widths\"]', '            sticky_data = (', '                edges.min(),', '                edges.max() + widths.loc[edges.idxmax()]', '            )', '        else:', '            sticky_data = []', '', '        # --- Handle default visual attributes', '', '        # Note: default linewidth is determined after plotting', '', '        # Default alpha should depend on other parameters', '        if fill:', '            # Note: will need to account for other grouping semantics if added', '            if \"hue\" in self.variables and multiple == \"layer\":', '                default_alpha = .5 if element == \"bars\" else .25', '            elif kde:', '                default_alpha = .5', '            else:', '                default_alpha = .75', '        else:', '            default_alpha = 1', '        alpha = plot_kws.pop(\"alpha\", default_alpha)  # TODO make parameter?', '', '        hist_artists = []', '', '        # Go back through the dataset and draw the plots', '        for sub_vars, _ in self.iter_data(\"hue\", reverse=True):', '', '            key = tuple(sub_vars.items())', '            hist = histograms[key].rename(\"heights\").reset_index()', '            bottom = np.asarray(baselines[key])', '', '            ax = self._get_axes(sub_vars)', '', '            # Define the matplotlib attributes that depend on semantic mapping', '            if \"hue\" in self.variables:', '                sub_color = self._hue_map(sub_vars[\"hue\"])', '            else:', '                sub_color = color', '', '            artist_kws = self._artist_kws(', '                plot_kws, fill, element, multiple, sub_color, alpha', '            )', '', '            if element == \"bars\":', '', '                # Use matplotlib bar plotting', '', '                plot_func = ax.bar if self.data_variable == \"x\" else ax.barh', '                artists = plot_func(', '                    hist[\"edges\"],', '                    hist[\"heights\"] - bottom,', '                    hist[\"widths\"],', '                    bottom,', '                    align=\"edge\",', '                    **artist_kws,', '                )', '', '                for bar in artists:', '                    if self.data_variable == \"x\":', '                        bar.sticky_edges.x[:] = sticky_data', '                        bar.sticky_edges.y[:] = sticky_stat', '                    else:', '                        bar.sticky_edges.x[:] = sticky_stat', '                        bar.sticky_edges.y[:] = sticky_data', '', '                hist_artists.extend(artists)', '', '            else:', '', '                # Use either fill_between or plot to draw hull of histogram', '                if element == \"step\":', '', '                    final = hist.iloc[-1]', '                    x = np.append(hist[\"edges\"], final[\"edges\"] + final[\"widths\"])', '                    y = np.append(hist[\"heights\"], final[\"heights\"])', '                    b = np.append(bottom, bottom[-1])', '', '                    if self.data_variable == \"x\":', '                        step = \"post\"', '                        drawstyle = \"steps-post\"', '                    else:', '                        step = \"post\"  # fillbetweenx handles mapping internally', '                        drawstyle = \"steps-pre\"', '', '                elif element == \"poly\":', '', '                    x = hist[\"edges\"] + hist[\"widths\"] / 2', '                    y = hist[\"heights\"]', '                    b = bottom', '', '                    step = None', '                    drawstyle = None', '', '                if self.data_variable == \"x\":', '                    if fill:', '                        artist = ax.fill_between(x, b, y, step=step, **artist_kws)', '                    else:', '                        artist, = ax.plot(x, y, drawstyle=drawstyle, **artist_kws)', '                    artist.sticky_edges.x[:] = sticky_data', '                    artist.sticky_edges.y[:] = sticky_stat', '                else:', '                    if fill:', '                        artist = ax.fill_betweenx(x, b, y, step=step, **artist_kws)', '                    else:', '                        artist, = ax.plot(y, x, drawstyle=drawstyle, **artist_kws)', '                    artist.sticky_edges.x[:] = sticky_stat', '                    artist.sticky_edges.y[:] = sticky_data', '', '                hist_artists.append(artist)', '', '            if kde:', '', '                # Add in the density curves', '', '                try:', '                    density = densities[key]', '                except KeyError:', '                    continue', '                support = density.index', '', '                if \"x\" in self.variables:', '                    line_args = support, density', '                    sticky_x, sticky_y = None, (0, np.inf)', '                else:', '                    line_args = density, support', '                    sticky_x, sticky_y = (0, np.inf), None', '', '                line_kws[\"color\"] = to_rgba(sub_color, 1)', '                line, = ax.plot(', '                    *line_args, **line_kws,', '                )', '', '                if sticky_x is not None:', '                    line.sticky_edges.x[:] = sticky_x', '                if sticky_y is not None:', '                    line.sticky_edges.y[:] = sticky_y', '', '        if element == \"bars\" and \"linewidth\" not in plot_kws:', '', '            # Now we handle linewidth, which depends on the scaling of the plot', '', '            # We will base everything on the minimum bin width', '            hist_metadata = pd.concat([', '                # Use .items for generality over dict or df', '                h.index.to_frame() for _, h in histograms.items()', '            ]).reset_index(drop=True)', '            thin_bar_idx = hist_metadata[\"widths\"].idxmin()', '            binwidth = hist_metadata.loc[thin_bar_idx, \"widths\"]', '            left_edge = hist_metadata.loc[thin_bar_idx, \"edges\"]', '', '            # Set initial value', '            default_linewidth = math.inf', '', '            # Loop through subsets based only on facet variables', '            for sub_vars, _ in self.iter_data():', '', '                ax = self._get_axes(sub_vars)', '', '                # Needed in some cases to get valid transforms.', '                # Innocuous in other cases?', '                ax.autoscale_view()', '', '                # Convert binwidth from data coordinates to pixels', '                pts_x, pts_y = 72 / ax.figure.dpi * abs(', '                    ax.transData.transform([left_edge + binwidth] * 2)', '                    - ax.transData.transform([left_edge] * 2)', '                )', '                if self.data_variable == \"x\":', '                    binwidth_points = pts_x', '                else:', '                    binwidth_points = pts_y', '', '                # The relative size of the lines depends on the appearance', '                # This is a provisional value and may need more tweaking', '                default_linewidth = min(.1 * binwidth_points, default_linewidth)', '', '            # Set the attributes', '            for bar in hist_artists:', '', \"                # Don't let the lines get too thick\", '                max_linewidth = bar.get_linewidth()', '                if not fill:', '                    max_linewidth *= 1.5', '', '                linewidth = min(default_linewidth, max_linewidth)', '', \"                # If not filling, don't let lines disappear\", '                if not fill:', '                    min_linewidth = .5', '                    linewidth = max(linewidth, min_linewidth)', '', '                bar.set_linewidth(linewidth)', '', '        # --- Finalize the plot ----', '', '        # Axis labels', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = estimator.stat.capitalize()', '        if self.data_variable == \"y\":', '            default_x = estimator.stat.capitalize()', '        self._add_axis_labels(ax, default_x, default_y)', '', '        # Legend for semantic variables', '        if \"hue\" in self.variables and legend:', '', '            if fill or element == \"bars\":', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, element, multiple, alpha, plot_kws, {},', '            )', '', '    def plot_bivariate_histogram(', '        self,', '        common_bins, common_norm,', '        thresh, pthresh, pmax,', '        color, legend,', '        cbar, cbar_ax, cbar_kws,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # Default keyword dicts', '        cbar_kws = {} if cbar_kws is None else cbar_kws.copy()', '', '        # Now initialize the Histogram estimator', '        estimator = Histogram(**estimate_kws)', '', '        # Do pre-compute housekeeping related to multiple groups', '        if set(self.variables) - {\"x\", \"y\"}:', '            all_data = self.comp_data.dropna()', '            if common_bins:', '                estimator.define_bin_params(', '                    all_data[\"x\"],', '                    all_data[\"y\"],', '                    all_data.get(\"weights\", None),', '                )', '        else:', '            common_norm = False', '', '        # -- Determine colormap threshold and norm based on the full data', '', '        full_heights = []', '        for _, sub_data in self.iter_data(from_comp_data=True):', '            sub_heights, _ = estimator(', '                sub_data[\"x\"], sub_data[\"y\"], sub_data.get(\"weights\", None)', '            )', '            full_heights.append(sub_heights)', '', '        common_color_norm = not set(self.variables) - {\"x\", \"y\"} or common_norm', '', '        if pthresh is not None and common_color_norm:', '            thresh = self._quantile_to_level(full_heights, pthresh)', '', '        plot_kws.setdefault(\"vmin\", 0)', '        if common_color_norm:', '            if pmax is not None:', '                vmax = self._quantile_to_level(full_heights, pmax)', '            else:', '                vmax = plot_kws.pop(\"vmax\", max(map(np.max, full_heights)))', '        else:', '            vmax = None', '', '        # Get a default color', \"        # (We won't follow the color cycle here, as multiple plots are unlikely)\", '        if color is None:', '            color = \"C0\"', '', '        # --- Loop over data (subsets) and draw the histograms', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            if sub_data.empty:', '                continue', '', '            # Do the histogram computation', '            heights, (x_edges, y_edges) = estimator(', '                sub_data[\"x\"],', '                sub_data[\"y\"],', '                weights=sub_data.get(\"weights\", None),', '            )', '', '            # Check for log scaling on the data axis', '            if self._log_scaled(\"x\"):', '                x_edges = np.power(10, x_edges)', '            if self._log_scaled(\"y\"):', '                y_edges = np.power(10, y_edges)', '', '            # Apply scaling to normalize across groups', '            if estimator.stat != \"count\" and common_norm:', '                heights *= len(sub_data) / len(all_data)', '', '            # Define the specific kwargs for this artist', '            artist_kws = plot_kws.copy()', '            if \"hue\" in self.variables:', '                color = self._hue_map(sub_vars[\"hue\"])', '                cmap = self._cmap_from_color(color)', '                artist_kws[\"cmap\"] = cmap', '            else:', '                cmap = artist_kws.pop(\"cmap\", None)', '                if isinstance(cmap, str):', '                    cmap = color_palette(cmap, as_cmap=True)', '                elif cmap is None:', '                    cmap = self._cmap_from_color(color)', '                artist_kws[\"cmap\"] = cmap', '', '            # Set the upper norm on the colormap', '            if not common_color_norm and pmax is not None:', '                vmax = self._quantile_to_level(heights, pmax)', '            if vmax is not None:', '                artist_kws[\"vmax\"] = vmax', '', '            # Make cells at or below the threshold transparent', '            if not common_color_norm and pthresh:', '                thresh = self._quantile_to_level(heights, pthresh)', '            if thresh is not None:', '                heights = np.ma.masked_less_equal(heights, thresh)', '', '            # Get the axes for this plot', '            ax = self._get_axes(sub_vars)', '', '            # pcolormesh is going to turn the grid off, but we want to keep it', \"            # I'm not sure if there's a better way to get the grid state\", '            x_grid = any([l.get_visible() for l in ax.xaxis.get_gridlines()])', '            y_grid = any([l.get_visible() for l in ax.yaxis.get_gridlines()])', '', '            mesh = ax.pcolormesh(', '                x_edges,', '                y_edges,', '                heights.T,', '                **artist_kws,', '            )', '', '            # pcolormesh sets sticky edges, but we only want them if not thresholding', '            if thresh is not None:', '                mesh.sticky_edges.x[:] = []', '                mesh.sticky_edges.y[:] = []', '', '            # Add an optional colorbar', '            # Note, we want to improve this. When hue is used, it will stack', '            # multiple colorbars with redundant ticks in an ugly way.', \"            # But it's going to take some work to have multiple colorbars that\", '            # share ticks nicely.', '            if cbar:', '                ax.figure.colorbar(mesh, cbar_ax, ax, **cbar_kws)', '', '            # Reset the grid state', '            if x_grid:', '                ax.grid(True, axis=\"x\")', '            if y_grid:', '                ax.grid(True, axis=\"y\")', '', '        # --- Finalize the plot', '', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        self._add_axis_labels(ax)', '', '        if \"hue\" in self.variables and legend:', '', '            # TODO if possible, I would like to move the contour', '            # intensity information into the legend too and label the', '            # iso proportions rather than the raw density values', '', '            artist_kws = {}', '            artist = partial(mpl.patches.Patch)', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, True, False, \"layer\", 1, artist_kws, {},', '            )', '', '    def plot_univariate_density(', '        self,', '        multiple,', '        common_norm,', '        common_grid,', '        warn_singular,', '        fill,', '        color,', '        legend,', '        estimate_kws,', '        **plot_kws,', '    ):', '', '        # Handle conditional defaults', '        if fill is None:', '            fill = multiple in (\"stack\", \"fill\")', '', '        # Preprocess the matplotlib keyword dictionaries', '        if fill:', '            artist = mpl.collections.PolyCollection', '        else:', '            artist = mpl.lines.Line2D', '        plot_kws = _normalize_kwargs(plot_kws, artist)', '', '        # Input checking', '        _check_argument(\"multiple\", [\"layer\", \"stack\", \"fill\"], multiple)', '', '        # Always share the evaluation grid when stacking', '        subsets = bool(set(self.variables) - {\"x\", \"y\"})', '        if subsets and multiple in (\"stack\", \"fill\"):', '            common_grid = True', '', '        # Check if the data axis is log scaled', '        log_scale = self._log_scaled(self.data_variable)', '', '        # Do the computation', '        densities = self._compute_univariate_density(', '            self.data_variable,', '            common_norm,', '            common_grid,', '            estimate_kws,', '            log_scale,', '            warn_singular,', '        )', '', '        # Adjust densities based on the `multiple` rule', '        densities, baselines = self._resolve_multiple(densities, multiple)', '', '        # Control the interaction with autoscaling by defining sticky_edges', \"        # i.e. we don't want autoscale margins below the density curve\", '        sticky_density = (0, 1) if multiple == \"fill\" else (0, np.inf)', '', '        if multiple == \"fill\":', '            # Filled plots should not have any margins', '            sticky_support = densities.index.min(), densities.index.max()', '        else:', '            sticky_support = []', '', '        if fill:', '            if multiple == \"layer\":', '                default_alpha = .25', '            else:', '                default_alpha = .75', '        else:', '            default_alpha = 1', '        alpha = plot_kws.pop(\"alpha\", default_alpha)  # TODO make parameter?', '', '        # Now iterate through the subsets and draw the densities', '        # We go backwards so stacked densities read from top-to-bottom', '        for sub_vars, _ in self.iter_data(\"hue\", reverse=True):', '', '            # Extract the support grid and density curve for this level', '            key = tuple(sub_vars.items())', '            try:', '                density = densities[key]', '            except KeyError:', '                continue', '            support = density.index', '            fill_from = baselines[key]', '', '            ax = self._get_axes(sub_vars)', '', '            if \"hue\" in self.variables:', '                sub_color = self._hue_map(sub_vars[\"hue\"])', '            else:', '                sub_color = color', '', '            artist_kws = self._artist_kws(', '                plot_kws, fill, False, multiple, sub_color, alpha', '            )', '', '            # Either plot a curve with observation values on the x axis', '            if \"x\" in self.variables:', '', '                if fill:', '                    artist = ax.fill_between(support, fill_from, density, **artist_kws)', '', '                else:', '                    artist, = ax.plot(support, density, **artist_kws)', '', '                artist.sticky_edges.x[:] = sticky_support', '                artist.sticky_edges.y[:] = sticky_density', '', '            # Or plot a curve with observation values on the y axis', '            else:', '                if fill:', '                    artist = ax.fill_betweenx(support, fill_from, density, **artist_kws)', '                else:', '                    artist, = ax.plot(density, support, **artist_kws)', '', '                artist.sticky_edges.x[:] = sticky_density', '                artist.sticky_edges.y[:] = sticky_support', '', '        # --- Finalize the plot ----', '', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = \"Density\"', '        if self.data_variable == \"y\":', '            default_x = \"Density\"', '        self._add_axis_labels(ax, default_x, default_y)', '', '        if \"hue\" in self.variables and legend:', '', '            if fill:', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, False, multiple, alpha, plot_kws, {},', '            )', '', '    def plot_bivariate_density(', '        self,', '        common_norm,', '        fill,', '        levels,', '        thresh,', '        color,', '        legend,', '        cbar,', '        warn_singular,', '        cbar_ax,', '        cbar_kws,', '        estimate_kws,', '        **contour_kws,', '    ):', '', '        contour_kws = contour_kws.copy()', '', '        estimator = KDE(**estimate_kws)', '', '        if not set(self.variables) - {\"x\", \"y\"}:', '            common_norm = False', '', '        all_data = self.plot_data.dropna()', '', '        # Loop through the subsets and estimate the KDEs', '        densities, supports = {}, {}', '', '        for sub_vars, sub_data in self.iter_data(\"hue\", from_comp_data=True):', '', '            # Extract the data points from this sub set', '            observations = sub_data[[\"x\", \"y\"]]', '            min_variance = observations.var().fillna(0).min()', '            observations = observations[\"x\"], observations[\"y\"]', '', '            # Extract the weights for this subset of observations', '            if \"weights\" in self.variables:', '                weights = sub_data[\"weights\"]', '            else:', '                weights = None', '', '            # Estimate the density of observations at this level', '            singular = math.isclose(min_variance, 0)', '            try:', '                if not singular:', '                    density, support = estimator(*observations, weights=weights)', '            except np.linalg.LinAlgError:', \"                # Testing for 0 variance doesn't catch all cases where scipy raises,\", '                # but we can also get a ValueError, so we need this convoluted approach', '                singular = True', '', '            if singular:', '                msg = (', '                    \"KDE cannot be estimated (0 variance or perfect covariance). \"', '                    \"Pass `warn_singular=False` to disable this warning.\"', '                )', '                if warn_singular:', '                    warnings.warn(msg, UserWarning, stacklevel=3)', '                continue', '', '            # Transform the support grid back to the original scale', '            xx, yy = support', '            if self._log_scaled(\"x\"):', '                xx = np.power(10, xx)', '            if self._log_scaled(\"y\"):', '                yy = np.power(10, yy)', '            support = xx, yy', '', '            # Apply a scaling factor so that the integral over all subsets is 1', '            if common_norm:', '                density *= len(sub_data) / len(all_data)', '', '            key = tuple(sub_vars.items())', '            densities[key] = density', '            supports[key] = support', '', '        # Define a grid of iso-proportion levels', '        if thresh is None:', '            thresh = 0', '        if isinstance(levels, Number):', '            levels = np.linspace(thresh, 1, levels)', '        else:', '            if min(levels) < 0 or max(levels) > 1:', '                raise ValueError(\"levels must be in [0, 1]\")', '', '        # Transform from iso-proportions to iso-densities', '        if common_norm:', '            common_levels = self._quantile_to_level(', '                list(densities.values()), levels,', '            )', '            draw_levels = {k: common_levels for k in densities}', '        else:', '            draw_levels = {', '                k: self._quantile_to_level(d, levels)', '                for k, d in densities.items()', '            }', '', '        # Define the coloring of the contours', '        if \"hue\" in self.variables:', '            for param in [\"cmap\", \"colors\"]:', '                if param in contour_kws:', '                    msg = f\"{param} parameter ignored when using hue mapping.\"', '                    warnings.warn(msg, UserWarning)', '                    contour_kws.pop(param)', '        else:', '', '            # Work out a default coloring of the contours', '            coloring_given = set(contour_kws) & {\"cmap\", \"colors\"}', '            if fill and not coloring_given:', '                cmap = self._cmap_from_color(color)', '                contour_kws[\"cmap\"] = cmap', '            if not fill and not coloring_given:', '                contour_kws[\"colors\"] = [color]', '', '            # Use our internal colormap lookup', '            cmap = contour_kws.pop(\"cmap\", None)', '            if isinstance(cmap, str):', '                cmap = color_palette(cmap, as_cmap=True)', '            if cmap is not None:', '                contour_kws[\"cmap\"] = cmap', '', '        # Loop through the subsets again and plot the data', '        for sub_vars, _ in self.iter_data(\"hue\"):', '', '            if \"hue\" in sub_vars:', '                color = self._hue_map(sub_vars[\"hue\"])', '                if fill:', '                    contour_kws[\"cmap\"] = self._cmap_from_color(color)', '                else:', '                    contour_kws[\"colors\"] = [color]', '', '            ax = self._get_axes(sub_vars)', '', '            # Choose the function to plot with', '            # TODO could add a pcolormesh based option as well', '            # Which would look something like element=\"raster\"', '            if fill:', '                contour_func = ax.contourf', '            else:', '                contour_func = ax.contour', '', '            key = tuple(sub_vars.items())', '            if key not in densities:', '                continue', '            density = densities[key]', '            xx, yy = supports[key]', '', '            label = contour_kws.pop(\"label\", None)', '', '            cset = contour_func(', '                xx, yy, density,', '                levels=draw_levels[key],', '                **contour_kws,', '            )', '', '            if \"hue\" not in self.variables:', '                cset.collections[0].set_label(label)', '', '            # Add a color bar representing the contour heights', '            # Note: this shows iso densities, not iso proportions', '            # See more notes in histplot about how this could be improved', '            if cbar:', '                cbar_kws = {} if cbar_kws is None else cbar_kws', '                ax.figure.colorbar(cset, cbar_ax, ax, **cbar_kws)', '', '        # --- Finalize the plot', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        self._add_axis_labels(ax)', '', '        if \"hue\" in self.variables and legend:', '', '            # TODO if possible, I would like to move the contour', '            # intensity information into the legend too and label the', '            # iso proportions rather than the raw density values', '', '            artist_kws = {}', '            if fill:', '                artist = partial(mpl.patches.Patch)', '            else:', '                artist = partial(mpl.lines.Line2D, [], [])', '', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, fill, False, \"layer\", 1, artist_kws, {},', '            )', '', '    def plot_univariate_ecdf(self, estimate_kws, legend, **plot_kws):', '', '        estimator = ECDF(**estimate_kws)', '', '        # Set the draw style to step the right way for the data variable', '        drawstyles = dict(x=\"steps-post\", y=\"steps-pre\")', '        plot_kws[\"drawstyle\"] = drawstyles[self.data_variable]', '', '        # Loop through the subsets, transform and plot the data', '        for sub_vars, sub_data in self.iter_data(', '            \"hue\", reverse=True, from_comp_data=True,', '        ):', '', '            # Compute the ECDF', '            if sub_data.empty:', '                continue', '', '            observations = sub_data[self.data_variable]', '            weights = sub_data.get(\"weights\", None)', '            stat, vals = estimator(observations, weights=weights)', '', '            # Assign attributes based on semantic mapping', '            artist_kws = plot_kws.copy()', '            if \"hue\" in self.variables:', '                artist_kws[\"color\"] = self._hue_map(sub_vars[\"hue\"])', '', '            # Return the data variable to the linear domain', '            # This needs an automatic solution; see GH2409', '            if self._log_scaled(self.data_variable):', '                vals = np.power(10, vals)', '                vals[0] = -np.inf', '', '            # Work out the orientation of the plot', '            if self.data_variable == \"x\":', '                plot_args = vals, stat', '                stat_variable = \"y\"', '            else:', '                plot_args = stat, vals', '                stat_variable = \"x\"', '', '            if estimator.stat == \"count\":', '                top_edge = len(observations)', '            else:', '                top_edge = 1', '', '            # Draw the line for this subset', '            ax = self._get_axes(sub_vars)', '            artist, = ax.plot(*plot_args, **artist_kws)', '            sticky_edges = getattr(artist.sticky_edges, stat_variable)', '            sticky_edges[:] = 0, top_edge', '', '        # --- Finalize the plot ----', '        ax = self.ax if self.ax is not None else self.facets.axes.flat[0]', '        stat = estimator.stat.capitalize()', '        default_x = default_y = \"\"', '        if self.data_variable == \"x\":', '            default_y = stat', '        if self.data_variable == \"y\":', '            default_x = stat', '        self._add_axis_labels(ax, default_x, default_y)', '', '        if \"hue\" in self.variables and legend:', '            artist = partial(mpl.lines.Line2D, [], [])', '            alpha = plot_kws.get(\"alpha\", 1)', '            ax_obj = self.ax if self.ax is not None else self.facets', '            self._add_legend(', '                ax_obj, artist, False, False, None, alpha, plot_kws, {},', '            )', '', '    def plot_rug(self, height, expand_margins, legend, **kws):', '', '        for sub_vars, sub_data, in self.iter_data(from_comp_data=True):', '', '            ax = self._get_axes(sub_vars)', '', '            kws.setdefault(\"linewidth\", 1)', '', '            if expand_margins:', '                xmarg, ymarg = ax.margins()', '                if \"x\" in self.variables:', '                    ymarg += height * 2', '                if \"y\" in self.variables:', '                    xmarg += height * 2', '                ax.margins(x=xmarg, y=ymarg)', '', '            if \"hue\" in self.variables:', '                kws.pop(\"c\", None)', '                kws.pop(\"color\", None)', '', '            if \"x\" in self.variables:', '                self._plot_single_rug(sub_data, \"x\", height, ax, kws)', '            if \"y\" in self.variables:', '                self._plot_single_rug(sub_data, \"y\", height, ax, kws)', '', '            # --- Finalize the plot', '            self._add_axis_labels(ax)', '            if \"hue\" in self.variables and legend:', \"                # TODO ideally i'd like the legend artist to look like a rug\", '                legend_artist = partial(mpl.lines.Line2D, [], [])', '                self._add_legend(', '                    ax, legend_artist, False, False, None, 1, {}, {},', '                )', '', '    def _plot_single_rug(self, sub_data, var, height, ax, kws):', '        \"\"\"Draw a rugplot along one axis of the plot.\"\"\"', '        vector = sub_data[var]', '        n = len(vector)', '', '        # Return data to linear domain', '        # This needs an automatic solution; see GH2409', '        if self._log_scaled(var):', '            vector = np.power(10, vector)', '', \"        # We'll always add a single collection with varying colors\", '        if \"hue\" in self.variables:', '            colors = self._hue_map(sub_data[\"hue\"])', '        else:', '            colors = None', '', '        # Build the array of values for the LineCollection', '        if var == \"x\":', '', '            trans = tx.blended_transform_factory(ax.transData, ax.transAxes)', '            xy_pairs = np.column_stack([', '                np.repeat(vector, 2), np.tile([0, height], n)', '            ])', '', '        if var == \"y\":', '', '            trans = tx.blended_transform_factory(ax.transAxes, ax.transData)', '            xy_pairs = np.column_stack([', '                np.tile([0, height], n), np.repeat(vector, 2)', '            ])', '', '        # Draw the lines on the plot', '        line_segs = xy_pairs.reshape([n, 2, 2])', '        ax.add_collection(LineCollection(', '            line_segs, transform=trans, colors=colors, **kws', '        ))', '', '        ax.autoscale_view(scalex=var == \"x\", scaley=var == \"y\")', '', '', 'class _DistributionFacetPlotter(_DistributionPlotter):', '', '    semantics = _DistributionPlotter.semantics + (\"col\", \"row\")', '', '', '# ==================================================================================== #', '# External API', '# ==================================================================================== #', '', 'def histplot(', '    data=None, *,', '    # Vector variables', '    x=None, y=None, hue=None, weights=None,', '    # Histogram computation parameters', '    stat=\"count\", bins=\"auto\", binwidth=None, binrange=None,', '    discrete=None, cumulative=False, common_bins=True, common_norm=True,', '    # Histogram appearance parameters', '    multiple=\"layer\", element=\"bars\", fill=True, shrink=1,', '    # Histogram smoothing with a kernel density estimate', '    kde=False, kde_kws=None, line_kws=None,', '    # Bivariate histogram parameters', '    thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None, cbar_kws=None,', '    # Hue mapping parameters', '    palette=None, hue_order=None, hue_norm=None, color=None,', '    # Axes information', '    log_scale=None, legend=True, ax=None,', '    # Other appearance keywords', '    **kwargs,', '):', '', '    p = _DistributionPlotter(', '        data=data,', '        variables=_DistributionPlotter.get_semantics(locals())', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    if ax is None:', '        ax = plt.gca()', '', '    p._attach(ax, log_scale=log_scale)', '', \"    if p.univariate:  # Note, bivariate plots won't cycle\", '        if fill:', '            method = ax.bar if element == \"bars\" else ax.fill_between', '        else:', '            method = ax.plot', '        color = _default_color(method, hue, color, kwargs)', '', '    if not p.has_xy_data:', '        return ax', '', '    # Default to discrete bins for categorical variables', '    if discrete is None:', '        discrete = p._default_discrete()', '', '    estimate_kws = dict(', '        stat=stat,', '        bins=bins,', '        binwidth=binwidth,', '        binrange=binrange,', '        discrete=discrete,', '        cumulative=cumulative,', '    )', '', '    if p.univariate:', '', '        p.plot_univariate_histogram(', '            multiple=multiple,', '            element=element,', '            fill=fill,', '            shrink=shrink,', '            common_norm=common_norm,', '            common_bins=common_bins,', '            kde=kde,', '            kde_kws=kde_kws,', '            color=color,', '            legend=legend,', '            estimate_kws=estimate_kws,', '            line_kws=line_kws,', '            **kwargs,', '        )', '', '    else:', '', '        p.plot_bivariate_histogram(', '            common_bins=common_bins,', '            common_norm=common_norm,', '            thresh=thresh,', '            pthresh=pthresh,', '            pmax=pmax,', '            color=color,', '            legend=legend,', '            cbar=cbar,', '            cbar_ax=cbar_ax,', '            cbar_kws=cbar_kws,', '            estimate_kws=estimate_kws,', '            **kwargs,', '        )', '', '    return ax', '', '', 'histplot.__doc__ = \"\"\"\\\\', 'Plot univariate or bivariate histograms to show distributions of datasets.', '', 'A histogram is a classic visualization tool that represents the distribution', 'of one or more variables by counting the number of observations that fall within', 'discrete bins.', '', 'This function can normalize the statistic computed within each bin to estimate', 'frequency, density or probability mass, and it can add a smooth curve obtained', 'using a kernel density estimate, similar to :func:`kdeplot`.', '', 'More information is provided in the :ref:`user guide <tutorial_hist>`.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', '{params.core.hue}', 'weights : vector or key in ``data``', '    If provided, weight the contribution of the corresponding data points', '    towards the count in each bin by these factors.', '{params.hist.stat}', '{params.hist.bins}', '{params.hist.binwidth}', '{params.hist.binrange}', 'discrete : bool', '    If True, default to ``binwidth=1`` and draw the bars so that they are', '    centered on their corresponding data points. This avoids \"gaps\" that may', '    otherwise appear when using discrete (integer) data.', 'cumulative : bool', '    If True, plot the cumulative counts as bins increase.', 'common_bins : bool', '    If True, use the same bins when semantic variables produce multiple', '    plots. If using a reference rule to determine the bins, it will be computed', '    with the full dataset.', 'common_norm : bool', '    If True and using a normalized statistic, the normalization will apply over', '    the full dataset. Otherwise, normalize each histogram independently.', 'multiple : {{\"layer\", \"dodge\", \"stack\", \"fill\"}}', '    Approach to resolving multiple elements when semantic mapping creates subsets.', '    Only relevant with univariate data.', 'element : {{\"bars\", \"step\", \"poly\"}}', '    Visual representation of the histogram statistic.', '    Only relevant with univariate data.', 'fill : bool', '    If True, fill in the space under the histogram.', '    Only relevant with univariate data.', 'shrink : number', '    Scale the width of each bar relative to the binwidth by this factor.', '    Only relevant with univariate data.', 'kde : bool', '    If True, compute a kernel density estimate to smooth the distribution', '    and show on the plot as (one or more) line(s).', '    Only relevant with univariate data.', 'kde_kws : dict', '    Parameters that control the KDE computation, as in :func:`kdeplot`.', 'line_kws : dict', '    Parameters that control the KDE visualization, passed to', '    :meth:`matplotlib.axes.Axes.plot`.', 'thresh : number or None', '    Cells with a statistic less than or equal to this value will be transparent.', '    Only relevant with bivariate data.', 'pthresh : number or None', '    Like ``thresh``, but a value in [0, 1] such that cells with aggregate counts', '    (or other statistics, when used) up to this proportion of the total will be', '    transparent.', 'pmax : number or None', '    A value in [0, 1] that sets that saturation point for the colormap at a value', '    such that cells below constitute this proportion of the total count (or', '    other statistic, when used).', '{params.dist.cbar}', '{params.dist.cbar_ax}', '{params.dist.cbar_kws}', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', '{params.core.color}', '{params.dist.log_scale}', '{params.dist.legend}', '{params.core.ax}', 'kwargs', '    Other keyword arguments are passed to one of the following matplotlib', '    functions:', '', '    - :meth:`matplotlib.axes.Axes.bar` (univariate, element=\"bars\")', '    - :meth:`matplotlib.axes.Axes.fill_between` (univariate, other element, fill=True)', '    - :meth:`matplotlib.axes.Axes.plot` (univariate, other element, fill=False)', '    - :meth:`matplotlib.axes.Axes.pcolormesh` (bivariate)', '', 'Returns', '-------', '{returns.ax}', '', 'See Also', '--------', '{seealso.displot}', '{seealso.kdeplot}', '{seealso.rugplot}', '{seealso.ecdfplot}', '{seealso.jointplot}', '', 'Notes', '-----', '', 'The choice of bins for computing and plotting a histogram can exert', 'substantial influence on the insights that one is able to draw from the', 'visualization. If the bins are too large, they may erase important features.', 'On the other hand, bins that are too small may be dominated by random', 'variability, obscuring the shape of the true underlying distribution. The', 'default bin size is determined using a reference rule that depends on the', 'sample size and variance. This works well in many cases, (i.e., with', '\"well-behaved\" data) but it fails in others. It is always a good to try', 'different bin sizes to be sure that you are not missing something important.', 'This function allows you to specify bins in several different ways, such as', 'by setting the total number of bins to use, the width of each bin, or the', 'specific locations where the bins should break.', '', 'Examples', '--------', '', '.. include:: ../docstrings/histplot.rst', '', '\"\"\".format(', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')', '', '', 'def kdeplot(', '    data=None, *, x=None, y=None, hue=None, weights=None,', '    palette=None, hue_order=None, hue_norm=None, color=None, fill=None,', '    multiple=\"layer\", common_norm=True, common_grid=False, cumulative=False,', '    bw_method=\"scott\", bw_adjust=1, warn_singular=True, log_scale=None,', '    levels=10, thresh=.05, gridsize=200, cut=3, clip=None,', '    legend=True, cbar=False, cbar_ax=None, cbar_kws=None, ax=None,', '    **kwargs,', '):', '', '    # --- Start with backwards compatability for versions < 0.11.0 ----------------', '', '    # Handle (past) deprecation of `data2`', '    if \"data2\" in kwargs:', '        msg = \"`data2` has been removed (replaced by `y`); please update your code.\"', '        TypeError(msg)', '', '    # Handle deprecation of `vertical`', '    vertical = kwargs.pop(\"vertical\", None)', '    if vertical is not None:', '        if vertical:', '            action_taken = \"assigning data to `y`.\"', '            if x is None:', '                data, y = y, data', '            else:', '                x, y = y, x', '        else:', '            action_taken = \"assigning data to `x`.\"', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        The `vertical` parameter is deprecated; {action_taken}', '        This will become an error in seaborn v0.13.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # Handle deprecation of `bw`', '    bw = kwargs.pop(\"bw\", None)', '    if bw is not None:', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        The `bw` parameter is deprecated in favor of `bw_method` and `bw_adjust`.', '        Setting `bw_method={bw}`, but please see the docs for the new parameters', '        and update your code. This will become an error in seaborn v0.13.0.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '        bw_method = bw', '', '    # Handle deprecation of `kernel`', '    if kwargs.pop(\"kernel\", None) is not None:', '        msg = textwrap.dedent(\"\"\"\\\\n', '        Support for alternate kernels has been removed; using Gaussian kernel.', '        This will become an error in seaborn v0.13.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # Handle deprecation of shade_lowest', '    shade_lowest = kwargs.pop(\"shade_lowest\", None)', '    if shade_lowest is not None:', '        if shade_lowest:', '            thresh = 0', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        `shade_lowest` has been replaced by `thresh`; setting `thresh={thresh}.', '        This will become an error in seaborn v0.13.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # Handle \"soft\" deprecation of shade `shade` is not really the right', '    # terminology here, but unlike some of the other deprecated parameters it', '    # is probably very commonly used and much hard to remove. This is therefore', '    # going to be a longer process where, first, `fill` will be introduced and', '    # be used throughout the documentation. In 0.12, when kwarg-only', '    # enforcement hits, we can remove the shade/shade_lowest out of the', '    # function signature all together and pull them out of the kwargs. Then we', '    # can actually fire a FutureWarning, and eventually remove.', '    shade = kwargs.pop(\"shade\", None)', '    if shade is not None:', '        fill = shade', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        `shade` is now deprecated in favor of `fill`; setting `fill={shade}`.', '        This will become an error in seaborn v0.14.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, FutureWarning, stacklevel=2)', '', '    # Handle `n_levels`', '    # This was never in the formal API but it was processed, and appeared in an', '    # example. We can treat as an alias for `levels` now and deprecate later.', '    levels = kwargs.pop(\"n_levels\", levels)', '', '    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #', '', '    p = _DistributionPlotter(', '        data=data,', '        variables=_DistributionPlotter.get_semantics(locals()),', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    if ax is None:', '        ax = plt.gca()', '', '    p._attach(ax, allowed_types=[\"numeric\", \"datetime\"], log_scale=log_scale)', '', '    method = ax.fill_between if fill else ax.plot', '    color = _default_color(method, hue, color, kwargs)', '', '    if not p.has_xy_data:', '        return ax', '', '    # Pack the kwargs for statistics.KDE', '    estimate_kws = dict(', '        bw_method=bw_method,', '        bw_adjust=bw_adjust,', '        gridsize=gridsize,', '        cut=cut,', '        clip=clip,', '        cumulative=cumulative,', '    )', '', '    if p.univariate:', '', '        plot_kws = kwargs.copy()', '', '        p.plot_univariate_density(', '            multiple=multiple,', '            common_norm=common_norm,', '            common_grid=common_grid,', '            fill=fill,', '            color=color,', '            legend=legend,', '            warn_singular=warn_singular,', '            estimate_kws=estimate_kws,', '            **plot_kws,', '        )', '', '    else:', '', '        p.plot_bivariate_density(', '            common_norm=common_norm,', '            fill=fill,', '            levels=levels,', '            thresh=thresh,', '            legend=legend,', '            color=color,', '            warn_singular=warn_singular,', '            cbar=cbar,', '            cbar_ax=cbar_ax,', '            cbar_kws=cbar_kws,', '            estimate_kws=estimate_kws,', '            **kwargs,', '        )', '', '    return ax', '', '', 'kdeplot.__doc__ = \"\"\"\\\\', 'Plot univariate or bivariate distributions using kernel density estimation.', '', 'A kernel density estimate (KDE) plot is a method for visualizing the', 'distribution of observations in a dataset, analogous to a histogram. KDE', 'represents the data using a continuous probability density curve in one or', 'more dimensions.', '', 'The approach is explained further in the :ref:`user guide <tutorial_kde>`.', '', 'Relative to a histogram, KDE can produce a plot that is less cluttered and', 'more interpretable, especially when drawing multiple distributions. But it', 'has the potential to introduce distortions if the underlying distribution is', 'bounded or not smooth. Like a histogram, the quality of the representation', 'also depends on the selection of good smoothing parameters.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', '{params.core.hue}', 'weights : vector or key in ``data``', '    If provided, weight the kernel density estimation using these values.', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', '{params.core.color}', 'fill : bool or None', '    If True, fill in the area under univariate density curves or between', '    bivariate contours. If None, the default depends on ``multiple``.', '{params.dist.multiple}', 'common_norm : bool', '    If True, scale each conditional density by the number of observations', '    such that the total area under all densities sums to 1. Otherwise,', '    normalize each density independently.', 'common_grid : bool', '    If True, use the same evaluation grid for each kernel density estimate.', '    Only relevant with univariate data.', '{params.kde.cumulative}', '{params.kde.bw_method}', '{params.kde.bw_adjust}', 'warn_singular : bool', '    If True, issue a warning when trying to estimate the density of data', '    with zero variance.', '{params.dist.log_scale}', 'levels : int or vector', '    Number of contour levels or values to draw contours at. A vector argument', '    must have increasing values in [0, 1]. Levels correspond to iso-proportions', '    of the density: e.g., 20% of the probability mass will lie below the', '    contour drawn for 0.2. Only relevant with bivariate data.', 'thresh : number in [0, 1]', '    Lowest iso-proportion level at which to draw a contour line. Ignored when', '    ``levels`` is a vector. Only relevant with bivariate data.', 'gridsize : int', '    Number of points on each dimension of the evaluation grid.', '{params.kde.cut}', '{params.kde.clip}', '{params.dist.legend}', '{params.dist.cbar}', '{params.dist.cbar_ax}', '{params.dist.cbar_kws}', '{params.core.ax}', 'kwargs', '    Other keyword arguments are passed to one of the following matplotlib', '    functions:', '', '    - :meth:`matplotlib.axes.Axes.plot` (univariate, ``fill=False``),', '    - :meth:`matplotlib.axes.Axes.fill_between` (univariate, ``fill=True``),', '    - :meth:`matplotlib.axes.Axes.contour` (bivariate, ``fill=False``),', '    - :meth:`matplotlib.axes.contourf` (bivariate, ``fill=True``).', '', 'Returns', '-------', '{returns.ax}', '', 'See Also', '--------', '{seealso.displot}', '{seealso.histplot}', '{seealso.ecdfplot}', '{seealso.jointplot}', '{seealso.violinplot}', '', 'Notes', '-----', '', 'The *bandwidth*, or standard deviation of the smoothing kernel, is an', 'important parameter. Misspecification of the bandwidth can produce a', 'distorted representation of the data. Much like the choice of bin width in a', 'histogram, an over-smoothed curve can erase true features of a', 'distribution, while an under-smoothed curve can create false features out of', 'random variability. The rule-of-thumb that sets the default bandwidth works', 'best when the true distribution is smooth, unimodal, and roughly bell-shaped.', 'It is always a good idea to check the default behavior by using ``bw_adjust``', 'to increase or decrease the amount of smoothing.', '', 'Because the smoothing algorithm uses a Gaussian kernel, the estimated density', 'curve can extend to values that do not make sense for a particular dataset.', 'For example, the curve may be drawn over negative values when smoothing data', 'that are naturally positive. The ``cut`` and ``clip`` parameters can be used', 'to control the extent of the curve, but datasets that have many observations', 'close to a natural boundary may be better served by a different visualization', 'method.', '', 'Similar considerations apply when a dataset is naturally discrete or \"spiky\"', '(containing many repeated observations of the same value). Kernel density', 'estimation will always produce a smooth curve, which would be misleading', 'in these situations.', '', 'The units on the density axis are a common source of confusion. While kernel', 'density estimation produces a probability distribution, the height of the curve', 'at each point gives a density, not a probability. A probability can be obtained', 'only by integrating the density across a range. The curve is normalized so', 'that the integral over all possible values is 1, meaning that the scale of', 'the density axis depends on the data values.', '', 'Examples', '--------', '', '.. include:: ../docstrings/kdeplot.rst', '', '\"\"\".format(', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')', '', '', 'def ecdfplot(', '    data=None, *,', '    # Vector variables', '    x=None, y=None, hue=None, weights=None,', '    # Computation parameters', '    stat=\"proportion\", complementary=False,', '    # Hue mapping parameters', '    palette=None, hue_order=None, hue_norm=None,', '    # Axes information', '    log_scale=None, legend=True, ax=None,', '    # Other appearance keywords', '    **kwargs,', '):', '', '    p = _DistributionPlotter(', '        data=data,', '        variables=_DistributionPlotter.get_semantics(locals())', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    # We could support other semantics (size, style) here fairly easily', '    # But it would make distplot a bit more complicated.', \"    # It's always possible to add features like that later, so I am going to defer.\", '    # It will be even easier to wait until after there is a more general/abstract', '    # way to go from semantic specs to artist attributes.', '', '    if ax is None:', '        ax = plt.gca()', '', '    p._attach(ax, log_scale=log_scale)', '', '    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))', '    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)', '', '    if not p.has_xy_data:', '        return ax', '', \"    # We could add this one day, but it's of dubious value\", '    if not p.univariate:', '        raise NotImplementedError(\"Bivariate ECDF plots are not implemented\")', '', '    estimate_kws = dict(', '        stat=stat,', '        complementary=complementary,', '    )', '', '    p.plot_univariate_ecdf(', '        estimate_kws=estimate_kws,', '        legend=legend,', '        **kwargs,', '    )', '', '    return ax', '', '', 'ecdfplot.__doc__ = \"\"\"\\\\', 'Plot empirical cumulative distribution functions.', '', 'An ECDF represents the proportion or count of observations falling below each', 'unique value in a dataset. Compared to a histogram or density plot, it has the', 'advantage that each observation is visualized directly, meaning that there are', 'no binning or smoothing parameters that need to be adjusted. It also aids direct', 'comparisons between multiple distributions. A downside is that the relationship', 'between the appearance of the plot and the basic properties of the distribution', '(such as its central tendency, variance, and the presence of any bimodality)', 'may not be as intuitive.', '', 'More information is provided in the :ref:`user guide <tutorial_ecdf>`.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', '{params.core.hue}', 'weights : vector or key in ``data``', '    If provided, weight the contribution of the corresponding data points', '    towards the cumulative distribution using these values.', '{params.ecdf.stat}', '{params.ecdf.complementary}', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', '{params.dist.log_scale}', '{params.dist.legend}', '{params.core.ax}', 'kwargs', '    Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.plot`.', '', 'Returns', '-------', '{returns.ax}', '', 'See Also', '--------', '{seealso.displot}', '{seealso.histplot}', '{seealso.kdeplot}', '{seealso.rugplot}', '', 'Examples', '--------', '', '.. include:: ../docstrings/ecdfplot.rst', '', '\"\"\".format(', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')', '', '', 'def rugplot(', '    data=None, *, x=None, y=None, hue=None, height=.025, expand_margins=True,', '    palette=None, hue_order=None, hue_norm=None, legend=True, ax=None, **kwargs', '):', '', '    # A note: I think it would make sense to add multiple= to rugplot and allow', '    # rugs for different hue variables to be shifted orthogonal to the data axis', '    # But is this stacking, or dodging?', '', '    # A note: if we want to add a style semantic to rugplot,', '    # we could make an option that draws the rug using scatterplot', '', '    # A note, it would also be nice to offer some kind of histogram/density', \"    # rugplot, since alpha blending doesn't work great in the large n regime\", '', '    # --- Start with backwards compatability for versions < 0.11.0 ----------------', '', '    a = kwargs.pop(\"a\", None)', '    axis = kwargs.pop(\"axis\", None)', '', '    if a is not None:', '        data = a', '        msg = textwrap.dedent(\"\"\"\\\\n', '        The `a` parameter has been replaced; use `x`, `y`, and/or `data` instead.', '        Please update your code; This will become an error in seaborn v0.13.0.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    if axis is not None:', '        if axis == \"x\":', '            x = data', '        elif axis == \"y\":', '            y = data', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        The `axis` parameter has been deprecated; use the `{axis}` parameter instead.', '        Please update your code; this will become an error in seaborn v0.13.0.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    vertical = kwargs.pop(\"vertical\", None)', '    if vertical is not None:', '        if vertical:', '            action_taken = \"assigning data to `y`.\"', '            if x is None:', '                data, y = y, data', '            else:', '                x, y = y, x', '        else:', '            action_taken = \"assigning data to `x`.\"', '        msg = textwrap.dedent(f\"\"\"\\\\n', '        The `vertical` parameter is deprecated; {action_taken}', '        This will become an error in seaborn v0.13.0; please update your code.', '        \"\"\")', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #', '', '    weights = None', '    p = _DistributionPlotter(', '        data=data,', '        variables=_DistributionPlotter.get_semantics(locals()),', '    )', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    if ax is None:', '        ax = plt.gca()', '', '    p._attach(ax)', '', '    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))', '    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)', '', '    if not p.has_xy_data:', '        return ax', '', '    p.plot_rug(height, expand_margins, legend, **kwargs)', '', '    return ax', '', '', 'rugplot.__doc__ = \"\"\"\\\\', 'Plot marginal distributions by drawing ticks along the x and y axes.', '', 'This function is intended to complement other plots by showing the location', 'of individual observations in an unobtrusive way.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', '{params.core.hue}', 'height : float', '    Proportion of axes extent covered by each rug element. Can be negative.', 'expand_margins : bool', '    If True, increase the axes margins by the height of the rug to avoid', '    overlap with other elements.', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', 'legend : bool', '    If False, do not add a legend for semantic variables.', '{params.core.ax}', 'kwargs', '    Other keyword arguments are passed to', '    :meth:`matplotlib.collections.LineCollection`', '', 'Returns', '-------', '{returns.ax}', '', 'Examples', '--------', '', '.. include:: ../docstrings/rugplot.rst', '', '\"\"\".format(', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')', '', '', 'def displot(', '    data=None, *,', '    # Vector variables', '    x=None, y=None, hue=None, row=None, col=None, weights=None,', '    # Other plot parameters', '    kind=\"hist\", rug=False, rug_kws=None, log_scale=None, legend=True,', '    # Hue-mapping parameters', '    palette=None, hue_order=None, hue_norm=None, color=None,', '    # Faceting parameters', '    col_wrap=None, row_order=None, col_order=None,', '    height=5, aspect=1, facet_kws=None,', '    **kwargs,', '):', '', '    p = _DistributionFacetPlotter(', '        data=data,', '        variables=_DistributionFacetPlotter.get_semantics(locals())', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    _check_argument(\"kind\", [\"hist\", \"kde\", \"ecdf\"], kind)', '', '    # --- Initialize the FacetGrid object', '', '    # Check for attempt to plot onto specific axes and warn', '    if \"ax\" in kwargs:', '        msg = (', '            \"`displot` is a figure-level function and does not accept \"', '            \"the ax= parameter. You may wish to try {}plot.\".format(kind)', '        )', '        warnings.warn(msg, UserWarning)', '        kwargs.pop(\"ax\")', '', '    for var in [\"row\", \"col\"]:', '        # Handle faceting variables that lack name information', '        if var in p.variables and p.variables[var] is None:', '            p.variables[var] = f\"_{var}_\"', '', '    # Adapt the plot_data dataframe for use with FacetGrid', '    grid_data = p.plot_data.rename(columns=p.variables)', '    grid_data = grid_data.loc[:, ~grid_data.columns.duplicated()]', '', '    col_name = p.variables.get(\"col\")', '    row_name = p.variables.get(\"row\")', '', '    if facet_kws is None:', '        facet_kws = {}', '', '    g = FacetGrid(', '        data=grid_data, row=row_name, col=col_name,', '        col_wrap=col_wrap, row_order=row_order,', '        col_order=col_order, height=height,', '        aspect=aspect,', '        **facet_kws,', '    )', '', '    # Now attach the axes object to the plotter object', '    if kind == \"kde\":', '        allowed_types = [\"numeric\", \"datetime\"]', '    else:', '        allowed_types = None', '    p._attach(g, allowed_types=allowed_types, log_scale=log_scale)', '', '    # Check for a specification that lacks x/y data and return early', '    if not p.has_xy_data:', '        return g', '', '    if color is None and hue is None:', '        color = \"C0\"', '    # XXX else warn if hue is not None?', '', '    kwargs[\"legend\"] = legend', '', '    # --- Draw the plots', '', '    if kind == \"hist\":', '', '        hist_kws = kwargs.copy()', '', '        # Extract the parameters that will go directly to Histogram', '        estimate_defaults = {}', '        _assign_default_kwargs(estimate_defaults, Histogram.__init__, histplot)', '', '        estimate_kws = {}', '        for key, default_val in estimate_defaults.items():', '            estimate_kws[key] = hist_kws.pop(key, default_val)', '', '        # Handle derivative defaults', '        if estimate_kws[\"discrete\"] is None:', '            estimate_kws[\"discrete\"] = p._default_discrete()', '', '        hist_kws[\"estimate_kws\"] = estimate_kws', '', '        hist_kws.setdefault(\"color\", color)', '', '        if p.univariate:', '', '            _assign_default_kwargs(hist_kws, p.plot_univariate_histogram, histplot)', '            p.plot_univariate_histogram(**hist_kws)', '', '        else:', '', '            _assign_default_kwargs(hist_kws, p.plot_bivariate_histogram, histplot)', '            p.plot_bivariate_histogram(**hist_kws)', '', '    elif kind == \"kde\":', '', '        kde_kws = kwargs.copy()', '', '        # Extract the parameters that will go directly to KDE', '        estimate_defaults = {}', '        _assign_default_kwargs(estimate_defaults, KDE.__init__, kdeplot)', '', '        estimate_kws = {}', '        for key, default_val in estimate_defaults.items():', '            estimate_kws[key] = kde_kws.pop(key, default_val)', '', '        kde_kws[\"estimate_kws\"] = estimate_kws', '        kde_kws[\"color\"] = color', '', '        if p.univariate:', '', '            _assign_default_kwargs(kde_kws, p.plot_univariate_density, kdeplot)', '            p.plot_univariate_density(**kde_kws)', '', '        else:', '', '            _assign_default_kwargs(kde_kws, p.plot_bivariate_density, kdeplot)', '            p.plot_bivariate_density(**kde_kws)', '', '    elif kind == \"ecdf\":', '', '        ecdf_kws = kwargs.copy()', '', '        # Extract the parameters that will go directly to the estimator', '        estimate_kws = {}', '        estimate_defaults = {}', '        _assign_default_kwargs(estimate_defaults, ECDF.__init__, ecdfplot)', '        for key, default_val in estimate_defaults.items():', '            estimate_kws[key] = ecdf_kws.pop(key, default_val)', '', '        ecdf_kws[\"estimate_kws\"] = estimate_kws', '        ecdf_kws[\"color\"] = color', '', '        if p.univariate:', '', '            _assign_default_kwargs(ecdf_kws, p.plot_univariate_ecdf, ecdfplot)', '            p.plot_univariate_ecdf(**ecdf_kws)', '', '        else:', '', '            raise NotImplementedError(\"Bivariate ECDF plots are not implemented\")', '', '    # All plot kinds can include a rug', '    if rug:', '        # TODO with expand_margins=True, each facet expands margins... annoying!', '        if rug_kws is None:', '            rug_kws = {}', '        _assign_default_kwargs(rug_kws, p.plot_rug, rugplot)', '        rug_kws[\"legend\"] = False', '        if color is not None:', '            rug_kws[\"color\"] = color', '        p.plot_rug(**rug_kws)', '', '    # Call FacetGrid annotation methods', '    # Note that the legend is currently set inside the plotting method', '    g.set_axis_labels(', '        x_var=p.variables.get(\"x\", g.axes.flat[0].get_xlabel()),', '        y_var=p.variables.get(\"y\", g.axes.flat[0].get_ylabel()),', '    )', '    g.set_titles()', '    g.tight_layout()', '', '    if data is not None and (x is not None or y is not None):', '        if not isinstance(data, pd.DataFrame):', '            data = pd.DataFrame(data)', '        g.data = pd.merge(', '            data,', '            g.data[g.data.columns.difference(data.columns)],', '            left_index=True,', '            right_index=True,', '        )', '    else:', '        wide_cols = {', '            k: f\"_{k}_\" if v is None else v for k, v in p.variables.items()', '        }', '        g.data = p.plot_data.rename(columns=wide_cols)', '', '    return g', '', '', 'displot.__doc__ = \"\"\"\\\\', 'Figure-level interface for drawing distribution plots onto a FacetGrid.', '', 'This function provides access to several approaches for visualizing the', 'univariate or bivariate distribution of data, including subsets of data', 'defined by semantic mapping and faceting across multiple subplots. The', '``kind`` parameter selects the approach to use:', '', '- :func:`histplot` (with ``kind=\"hist\"``; the default)', '- :func:`kdeplot` (with ``kind=\"kde\"``)', '- :func:`ecdfplot` (with ``kind=\"ecdf\"``; univariate-only)', '', 'Additionally, a :func:`rugplot` can be added to any kind of plot to show', 'individual observations.', '', 'Extra keyword arguments are passed to the underlying function, so you should', 'refer to the documentation for each to understand the complete set of options', 'for making plots with this interface.', '', 'See the :doc:`distribution plots tutorial <../tutorial/distributions>` for a more', 'in-depth discussion of the relative strengths and weaknesses of each approach.', 'The distinction between figure-level and axes-level functions is explained', 'further in the :doc:`user guide <../tutorial/function_overview>`.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', '{params.core.hue}', '{params.facets.rowcol}', 'kind : {{\"hist\", \"kde\", \"ecdf\"}}', '    Approach for visualizing the data. Selects the underlying plotting function', '    and determines the additional set of valid parameters.', 'rug : bool', '    If True, show each observation with marginal ticks (as in :func:`rugplot`).', 'rug_kws : dict', '    Parameters to control the appearance of the rug plot.', '{params.dist.log_scale}', '{params.dist.legend}', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', '{params.core.color}', '{params.facets.col_wrap}', '{params.facets.rowcol_order}', '{params.facets.height}', '{params.facets.aspect}', '{params.facets.facet_kws}', 'kwargs', '    Other keyword arguments are documented with the relevant axes-level function:', '', '    - :func:`histplot` (with ``kind=\"hist\"``)', '    - :func:`kdeplot` (with ``kind=\"kde\"``)', '    - :func:`ecdfplot` (with ``kind=\"ecdf\"``)', '', 'Returns', '-------', '{returns.facetgrid}', '', 'See Also', '--------', '{seealso.histplot}', '{seealso.kdeplot}', '{seealso.rugplot}', '{seealso.ecdfplot}', '{seealso.jointplot}', '', 'Examples', '--------', '', 'See the API documentation for the axes-level functions for more details', 'about the breadth of options available for each plot kind.', '', '.. include:: ../docstrings/displot.rst', '', '\"\"\".format(', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')', '', '', '# =========================================================================== #', '# DEPRECATED FUNCTIONS LIVE BELOW HERE', '# =========================================================================== #', '', '', 'def _freedman_diaconis_bins(a):', '    \"\"\"Calculate number of hist bins using Freedman-Diaconis rule.\"\"\"', '    # From https://stats.stackexchange.com/questions/798/', '    a = np.asarray(a)', '    if len(a) < 2:', '        return 1', '    iqr = np.subtract.reduce(np.nanpercentile(a, [75, 25]))', '    h = 2 * iqr / (len(a) ** (1 / 3))', '    # fall back to sqrt(a) bins if iqr is 0', '    if h == 0:', '        return int(np.sqrt(a.size))', '    else:', '        return int(np.ceil((a.max() - a.min()) / h))', '', '', 'def distplot(a=None, bins=None, hist=True, kde=True, rug=False, fit=None,', '             hist_kws=None, kde_kws=None, rug_kws=None, fit_kws=None,', '             color=None, vertical=False, norm_hist=False, axlabel=None,', '             label=None, ax=None, x=None):', '    \"\"\"', '    DEPRECATED', '', '    This function has been deprecated and will be removed in seaborn v0.14.0.', '    It has been replaced by :func:`histplot` and :func:`displot`, two functions', '    with a modern API and many more capabilities.', '', '    For a guide to updating, please see this notebook:', '', '    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751', '', '    \"\"\"', '', '    if kde and not hist:', '        axes_level_suggestion = (', '            \"`kdeplot` (an axes-level function for kernel density plots)\"', '        )', '    else:', '        axes_level_suggestion = (', '            \"`histplot` (an axes-level function for histograms)\"', '        )', '', '    msg = textwrap.dedent(f\"\"\"', '', '    `distplot` is a deprecated function and will be removed in seaborn v0.14.0.', '', '    Please adapt your code to use either `displot` (a figure-level function with', '    similar flexibility) or {axes_level_suggestion}.', '', '    For a guide to updating your code to use the new functions, please see', '    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751', '    \"\"\")', '    warnings.warn(msg, UserWarning, stacklevel=2)', '', '    if ax is None:', '        ax = plt.gca()', '', '    # Intelligently label the support axis', '    label_ax = bool(axlabel)', '    if axlabel is None and hasattr(a, \"name\"):', '        axlabel = a.name', '        if axlabel is not None:', '            label_ax = True', '', '    # Support new-style API', '    if x is not None:', '        a = x', '', '    # Make a a 1-d float array', '    a = np.asarray(a, float)', '    if a.ndim > 1:', '        a = a.squeeze()', '', '    # Drop null values from array', '    a = remove_na(a)', '', '    # Decide if the hist is normed', '    norm_hist = norm_hist or kde or (fit is not None)', '', '    # Handle dictionary defaults', '    hist_kws = {} if hist_kws is None else hist_kws.copy()', '    kde_kws = {} if kde_kws is None else kde_kws.copy()', '    rug_kws = {} if rug_kws is None else rug_kws.copy()', '    fit_kws = {} if fit_kws is None else fit_kws.copy()', '', '    # Get the color from the current color cycle', '    if color is None:', '        if vertical:', '            line, = ax.plot(0, a.mean())', '        else:', '            line, = ax.plot(a.mean(), 0)', '        color = line.get_color()', '        line.remove()', '', '    # Plug the label into the right kwarg dictionary', '    if label is not None:', '        if hist:', '            hist_kws[\"label\"] = label', '        elif kde:', '            kde_kws[\"label\"] = label', '        elif rug:', '            rug_kws[\"label\"] = label', '        elif fit:', '            fit_kws[\"label\"] = label', '', '    if hist:', '        if bins is None:', '            bins = min(_freedman_diaconis_bins(a), 50)', '        hist_kws.setdefault(\"alpha\", 0.4)', '        hist_kws.setdefault(\"density\", norm_hist)', '', '        orientation = \"horizontal\" if vertical else \"vertical\"', '        hist_color = hist_kws.pop(\"color\", color)', '        ax.hist(a, bins, orientation=orientation,', '                color=hist_color, **hist_kws)', '        if hist_color != color:', '            hist_kws[\"color\"] = hist_color', '', '    axis = \"y\" if vertical else \"x\"', '', '    if kde:', '        kde_color = kde_kws.pop(\"color\", color)', '        kdeplot(**{axis: a}, ax=ax, color=kde_color, **kde_kws)', '        if kde_color != color:', '            kde_kws[\"color\"] = kde_color', '', '    if rug:', '        rug_color = rug_kws.pop(\"color\", color)', '        rugplot(**{axis: a}, ax=ax, color=rug_color, **rug_kws)', '        if rug_color != color:', '            rug_kws[\"color\"] = rug_color', '', '    if fit is not None:', '', '        def pdf(x):', '            return fit.pdf(x, *params)', '', '        fit_color = fit_kws.pop(\"color\", \"#282828\")', '        gridsize = fit_kws.pop(\"gridsize\", 200)', '        cut = fit_kws.pop(\"cut\", 3)', '        clip = fit_kws.pop(\"clip\", (-np.inf, np.inf))', '        bw = gaussian_kde(a).scotts_factor() * a.std(ddof=1)', '        x = _kde_support(a, bw, gridsize, cut, clip)', '        params = fit.fit(a)', '        y = pdf(x)', '        if vertical:', '            x, y = y, x', '        ax.plot(x, y, color=fit_color, **fit_kws)', '        if fit_color != \"#282828\":', '            fit_kws[\"color\"] = fit_color', '', '    if label_ax:', '        if vertical:', '            ax.set_ylabel(axlabel)', '        else:', '            ax.set_xlabel(axlabel)', '', '    return ax']}, '_docstrings.py': {'classes': [{'name': 'DocstringComponents', 'start_line': 6, 'end_line': 59, 'text': ['class DocstringComponents:', '', '    regexp = re.compile(r\"\\\\n((\\\\n|.)+)\\\\n\\\\s*\", re.MULTILINE)', '', '    def __init__(self, comp_dict, strip_whitespace=True):', '        \"\"\"Read entries from a dict, optionally stripping outer whitespace.\"\"\"', '        if strip_whitespace:', '            entries = {}', '            for key, val in comp_dict.items():', '                m = re.match(self.regexp, val)', '                if m is None:', '                    entries[key] = val', '                else:', '                    entries[key] = m.group(1)', '        else:', '            entries = comp_dict.copy()', '', '        self.entries = entries', '', '    def __getattr__(self, attr):', '        \"\"\"Provide dot access to entries for clean raw docstrings.\"\"\"', '        if attr in self.entries:', '            return self.entries[attr]', '        else:', '            try:', '                return self.__getattribute__(attr)', '            except AttributeError as err:', '                # If Python is run with -OO, it will strip docstrings and our lookup', '                # from self.entries will fail. We check for __debug__, which is actually', '                # set to False by -O (it is True for normal execution).', '                # But we only want to see an error when building the docs;', '                # not something users should see, so this slight inconsistency is fine.', '                if __debug__:', '                    raise err', '                else:', '                    pass', '', '    @classmethod', '    def from_nested_components(cls, **kwargs):', '        \"\"\"Add multiple sub-sets of components.\"\"\"', '        return cls(kwargs, strip_whitespace=False)', '', '    @classmethod', '    def from_function_params(cls, func):', '        \"\"\"Use the numpydoc parser to extract components from existing func.\"\"\"', '        params = NumpyDocString(pydoc.getdoc(func))[\"Parameters\"]', '        comp_dict = {}', '        for p in params:', '            name = p.name', '            type = p.type', '            desc = \"\\\\n    \".join(p.desc)', '            comp_dict[name] = f\"{name} : {type}\\\\n    {desc}\"', '', '        return cls(comp_dict)'], 'methods': [{'name': '__init__', 'start_line': 10, 'end_line': 23, 'text': ['    def __init__(self, comp_dict, strip_whitespace=True):', '        \"\"\"Read entries from a dict, optionally stripping outer whitespace.\"\"\"', '        if strip_whitespace:', '            entries = {}', '            for key, val in comp_dict.items():', '                m = re.match(self.regexp, val)', '                if m is None:', '                    entries[key] = val', '                else:', '                    entries[key] = m.group(1)', '        else:', '            entries = comp_dict.copy()', '', '        self.entries = entries']}, {'name': '__getattr__', 'start_line': 25, 'end_line': 41, 'text': ['    def __getattr__(self, attr):', '        \"\"\"Provide dot access to entries for clean raw docstrings.\"\"\"', '        if attr in self.entries:', '            return self.entries[attr]', '        else:', '            try:', '                return self.__getattribute__(attr)', '            except AttributeError as err:', '                # If Python is run with -OO, it will strip docstrings and our lookup', '                # from self.entries will fail. We check for __debug__, which is actually', '                # set to False by -O (it is True for normal execution).', '                # But we only want to see an error when building the docs;', '                # not something users should see, so this slight inconsistency is fine.', '                if __debug__:', '                    raise err', '                else:', '                    pass']}, {'name': 'from_nested_components', 'start_line': 44, 'end_line': 46, 'text': ['    def from_nested_components(cls, **kwargs):', '        \"\"\"Add multiple sub-sets of components.\"\"\"', '        return cls(kwargs, strip_whitespace=False)']}, {'name': 'from_function_params', 'start_line': 49, 'end_line': 59, 'text': ['    def from_function_params(cls, func):', '        \"\"\"Use the numpydoc parser to extract components from existing func.\"\"\"', '        params = NumpyDocString(pydoc.getdoc(func))[\"Parameters\"]', '        comp_dict = {}', '        for p in params:', '            name = p.name', '            type = p.type', '            desc = \"\\\\n    \".join(p.desc)', '            comp_dict[name] = f\"{name} : {type}\\\\n    {desc}\"', '', '        return cls(comp_dict)']}]}], 'functions': [], 'text': ['import re', 'import pydoc', 'from .external.docscrape import NumpyDocString', '', '', 'class DocstringComponents:', '', '    regexp = re.compile(r\"\\\\n((\\\\n|.)+)\\\\n\\\\s*\", re.MULTILINE)', '', '    def __init__(self, comp_dict, strip_whitespace=True):', '        \"\"\"Read entries from a dict, optionally stripping outer whitespace.\"\"\"', '        if strip_whitespace:', '            entries = {}', '            for key, val in comp_dict.items():', '                m = re.match(self.regexp, val)', '                if m is None:', '                    entries[key] = val', '                else:', '                    entries[key] = m.group(1)', '        else:', '            entries = comp_dict.copy()', '', '        self.entries = entries', '', '    def __getattr__(self, attr):', '        \"\"\"Provide dot access to entries for clean raw docstrings.\"\"\"', '        if attr in self.entries:', '            return self.entries[attr]', '        else:', '            try:', '                return self.__getattribute__(attr)', '            except AttributeError as err:', '                # If Python is run with -OO, it will strip docstrings and our lookup', '                # from self.entries will fail. We check for __debug__, which is actually', '                # set to False by -O (it is True for normal execution).', '                # But we only want to see an error when building the docs;', '                # not something users should see, so this slight inconsistency is fine.', '                if __debug__:', '                    raise err', '                else:', '                    pass', '', '    @classmethod', '    def from_nested_components(cls, **kwargs):', '        \"\"\"Add multiple sub-sets of components.\"\"\"', '        return cls(kwargs, strip_whitespace=False)', '', '    @classmethod', '    def from_function_params(cls, func):', '        \"\"\"Use the numpydoc parser to extract components from existing func.\"\"\"', '        params = NumpyDocString(pydoc.getdoc(func))[\"Parameters\"]', '        comp_dict = {}', '        for p in params:', '            name = p.name', '            type = p.type', '            desc = \"\\\\n    \".join(p.desc)', '            comp_dict[name] = f\"{name} : {type}\\\\n    {desc}\"', '', '        return cls(comp_dict)', '', '', '# TODO is \"vector\" the best term here? We mean to imply 1D data with a variety', '# of types?', '', '# TODO now that we can parse numpydoc style strings, do we need to define dicts', '# of docstring components, or just write out a docstring?', '', '', '_core_params = dict(', '    data=\"\"\"', 'data : :class:`pandas.DataFrame`, :class:`numpy.ndarray`, mapping, or sequence', '    Input data structure. Either a long-form collection of vectors that can be', '    assigned to named variables or a wide-form dataset that will be internally', '    reshaped.', '    \"\"\",  # TODO add link to user guide narrative when exists', '    xy=\"\"\"', 'x, y : vectors or keys in ``data``', '    Variables that specify positions on the x and y axes.', '    \"\"\",', '    hue=\"\"\"', 'hue : vector or key in ``data``', '    Semantic variable that is mapped to determine the color of plot elements.', '    \"\"\",', '    palette=\"\"\"', 'palette : string, list, dict, or :class:`matplotlib.colors.Colormap`', '    Method for choosing the colors to use when mapping the ``hue`` semantic.', '    String values are passed to :func:`color_palette`. List or dict values', '    imply categorical mapping, while a colormap object implies numeric mapping.', '    \"\"\",  # noqa: E501', '    hue_order=\"\"\"', 'hue_order : vector of strings', '    Specify the order of processing and plotting for categorical levels of the', '    ``hue`` semantic.', '    \"\"\",', '    hue_norm=\"\"\"', 'hue_norm : tuple or :class:`matplotlib.colors.Normalize`', '    Either a pair of values that set the normalization range in data units', '    or an object that will map from data units into a [0, 1] interval. Usage', '    implies numeric mapping.', '    \"\"\",', '    color=\"\"\"', 'color : :mod:`matplotlib color <matplotlib.colors>`', '    Single color specification for when hue mapping is not used. Otherwise, the', '    plot will try to hook into the matplotlib property cycle.', '    \"\"\",', '    ax=\"\"\"', 'ax : :class:`matplotlib.axes.Axes`', '    Pre-existing axes for the plot. Otherwise, call :func:`matplotlib.pyplot.gca`', '    internally.', '    \"\"\",  # noqa: E501', ')', '', '', '_core_returns = dict(', '    ax=\"\"\"', ':class:`matplotlib.axes.Axes`', '    The matplotlib axes containing the plot.', '    \"\"\",', '    facetgrid=\"\"\"', ':class:`FacetGrid`', '    An object managing one or more subplots that correspond to conditional data', '    subsets with convenient methods for batch-setting of axes attributes.', '    \"\"\",', '    jointgrid=\"\"\"', ':class:`JointGrid`', '    An object managing multiple subplots that correspond to joint and marginal axes', '    for plotting a bivariate relationship or distribution.', '    \"\"\",', '    pairgrid=\"\"\"', ':class:`PairGrid`', '    An object managing multiple subplots that correspond to joint and marginal axes', '    for pairwise combinations of multiple variables in a dataset.', '    \"\"\",', ')', '', '', '_seealso_blurbs = dict(', '', '    # Relational plots', '    scatterplot=\"\"\"', 'scatterplot : Plot data using points.', '    \"\"\",', '    lineplot=\"\"\"', 'lineplot : Plot data using lines.', '    \"\"\",', '', '    # Distribution plots', '    displot=\"\"\"', 'displot : Figure-level interface to distribution plot functions.', '    \"\"\",', '    histplot=\"\"\"', 'histplot : Plot a histogram of binned counts with optional normalization or smoothing.', '    \"\"\",', '    kdeplot=\"\"\"', 'kdeplot : Plot univariate or bivariate distributions using kernel density estimation.', '    \"\"\",', '    ecdfplot=\"\"\"', 'ecdfplot : Plot empirical cumulative distribution functions.', '    \"\"\",', '    rugplot=\"\"\"', 'rugplot : Plot a tick at each observation value along the x and/or y axes.', '    \"\"\",', '', '    # Categorical plots', '    stripplot=\"\"\"', 'stripplot : Plot a categorical scatter with jitter.', '    \"\"\",', '    swarmplot=\"\"\"', 'swarmplot : Plot a categorical scatter with non-overlapping points.', '    \"\"\",', '    violinplot=\"\"\"', 'violinplot : Draw an enhanced boxplot using kernel density estimation.', '    \"\"\",', '    pointplot=\"\"\"', 'pointplot : Plot point estimates and CIs using markers and lines.', '    \"\"\",', '', '    # Multiples', '    jointplot=\"\"\"', 'jointplot : Draw a bivariate plot with univariate marginal distributions.', '    \"\"\",', '    pairplot=\"\"\"', 'jointplot : Draw multiple bivariate plots with univariate marginal distributions.', '    \"\"\",', '    jointgrid=\"\"\"', 'JointGrid : Set up a figure with joint and marginal views on bivariate data.', '    \"\"\",', '    pairgrid=\"\"\"', 'PairGrid : Set up a figure with joint and marginal views on multiple variables.', '    \"\"\",', ')', '', '', '_core_docs = dict(', '    params=DocstringComponents(_core_params),', '    returns=DocstringComponents(_core_returns),', '    seealso=DocstringComponents(_seealso_blurbs),', ')']}, 'objects.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'A declarative, object-oriented interface for creating statistical graphics.', '', 'The seaborn.objects namespace contains a number of classes that can be composed', 'together to build a customized visualization.', '', 'The main object is :class:`Plot`, which is the starting point for all figures.', 'Pass :class:`Plot` a dataset and specify assignments from its variables to', 'roles in the plot. Build up the visualization by calling its methods.', '', 'There are four other general types of objects in this interface:', '', '- :class:`Mark` subclasses, which create matplotlib artists for visualization', '- :class:`Stat` subclasses, which apply statistical transforms before plotting', '- :class:`Move` subclasses, which make further adjustments to reduce overplotting', '', 'These classes are passed to :meth:`Plot.add` to define a layer in the plot.', 'Each layer has a :class:`Mark` and optional :class:`Stat` and/or :class:`Move`.', 'Plots can have multiple layers.', '', 'The other general type of object is a :class:`Scale` subclass, which provide an', 'interface for controlling the mappings between data values and visual properties.', 'Pass :class:`Scale` objects to :meth:`Plot.scale`.', '', 'See the documentation for other :class:`Plot` methods to learn about the many', 'ways that a plot can be enhanced and customized.', '', '\"\"\"', 'from seaborn._core.plot import Plot  # noqa: F401', '', 'from seaborn._marks.base import Mark  # noqa: F401', 'from seaborn._marks.area import Area, Band  # noqa: F401', 'from seaborn._marks.bar import Bar, Bars  # noqa: F401', 'from seaborn._marks.dot import Dot, Dots  # noqa: F401', 'from seaborn._marks.line import Line, Lines, Path, Paths, Range  # noqa: F401', 'from seaborn._marks.text import Text  # noqa: F401', '', 'from seaborn._stats.base import Stat  # noqa: F401', 'from seaborn._stats.aggregation import Agg, Est  # noqa: F401', 'from seaborn._stats.histogram import Hist  # noqa: F401', 'from seaborn._stats.order import Perc  # noqa: F401', 'from seaborn._stats.regression import PolyFit  # noqa: F401', '', 'from seaborn._core.moves import Dodge, Jitter, Norm, Shift, Stack, Move  # noqa: F401', '', 'from seaborn._core.scales import Nominal, Continuous, Temporal, Scale  # noqa: F401']}, 'relational.py': {'classes': [{'name': '_RelationalPlotter', 'start_line': 184, 'end_line': 343, 'text': ['class _RelationalPlotter(VectorPlotter):', '', '    wide_structure = {', '        \"x\": \"@index\", \"y\": \"@values\", \"hue\": \"@columns\", \"style\": \"@columns\",', '    }', '', '    # TODO where best to define default parameters?', '    sort = True', '', '    def add_legend_data(self, ax):', '        \"\"\"Add labeled artists to represent the different plot semantics.\"\"\"', '        verbosity = self.legend', '        if isinstance(verbosity, str) and verbosity not in [\"auto\", \"brief\", \"full\"]:', '            err = \"`legend` must be \\'auto\\', \\'brief\\', \\'full\\', or a boolean.\"', '            raise ValueError(err)', '        elif verbosity is True:', '            verbosity = \"auto\"', '', '        legend_kwargs = {}', '        keys = []', '', '        # Assign a legend title if there is only going to be one sub-legend,', '        # otherwise, subtitles will be inserted into the texts list with an', '        # invisible handle (which is a hack)', '        titles = {', '            title for title in', '            (self.variables.get(v, None) for v in [\"hue\", \"size\", \"style\"])', '            if title is not None', '        }', '        if len(titles) == 1:', '            legend_title = titles.pop()', '        else:', '            legend_title = \"\"', '', '        title_kws = dict(', '            visible=False, color=\"w\", s=0, linewidth=0, marker=\"\", dashes=\"\"', '        )', '', '        def update(var_name, val_name, **kws):', '', '            key = var_name, val_name', '            if key in legend_kwargs:', '                legend_kwargs[key].update(**kws)', '            else:', '                keys.append(key)', '', '                legend_kwargs[key] = dict(**kws)', '', '        # Define the maximum number of ticks to use for \"brief\" legends', '        brief_ticks = 6', '', '        # -- Add a legend for hue semantics', '        brief_hue = self._hue_map.map_type == \"numeric\" and (', '            verbosity == \"brief\"', '            or (verbosity == \"auto\" and len(self._hue_map.levels) > brief_ticks)', '        )', '        if brief_hue:', '            if isinstance(self._hue_map.norm, mpl.colors.LogNorm):', '                locator = mpl.ticker.LogLocator(numticks=brief_ticks)', '            else:', '                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)', '            limits = min(self._hue_map.levels), max(self._hue_map.levels)', '            hue_levels, hue_formatted_levels = locator_to_legend_entries(', '                locator, limits, self.plot_data[\"hue\"].infer_objects().dtype', '            )', '        elif self._hue_map.levels is None:', '            hue_levels = hue_formatted_levels = []', '        else:', '            hue_levels = hue_formatted_levels = self._hue_map.levels', '', '        # Add the hue semantic subtitle', '        if not legend_title and self.variables.get(\"hue\", None) is not None:', '            update((self.variables[\"hue\"], \"title\"),', '                   self.variables[\"hue\"], **title_kws)', '', '        # Add the hue semantic labels', '        for level, formatted_level in zip(hue_levels, hue_formatted_levels):', '            if level is not None:', '                color = self._hue_map(level)', '                update(self.variables[\"hue\"], formatted_level, color=color)', '', '        # -- Add a legend for size semantics', '        brief_size = self._size_map.map_type == \"numeric\" and (', '            verbosity == \"brief\"', '            or (verbosity == \"auto\" and len(self._size_map.levels) > brief_ticks)', '        )', '        if brief_size:', '            # Define how ticks will interpolate between the min/max data values', '            if isinstance(self._size_map.norm, mpl.colors.LogNorm):', '                locator = mpl.ticker.LogLocator(numticks=brief_ticks)', '            else:', '                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)', '            # Define the min/max data values', '            limits = min(self._size_map.levels), max(self._size_map.levels)', '            size_levels, size_formatted_levels = locator_to_legend_entries(', '                locator, limits, self.plot_data[\"size\"].infer_objects().dtype', '            )', '        elif self._size_map.levels is None:', '            size_levels = size_formatted_levels = []', '        else:', '            size_levels = size_formatted_levels = self._size_map.levels', '', '        # Add the size semantic subtitle', '        if not legend_title and self.variables.get(\"size\", None) is not None:', '            update((self.variables[\"size\"], \"title\"),', '                   self.variables[\"size\"], **title_kws)', '', '        # Add the size semantic labels', '        for level, formatted_level in zip(size_levels, size_formatted_levels):', '            if level is not None:', '                size = self._size_map(level)', '                update(', '                    self.variables[\"size\"],', '                    formatted_level,', '                    linewidth=size,', '                    s=size,', '                )', '', '        # -- Add a legend for style semantics', '', '        # Add the style semantic title', '        if not legend_title and self.variables.get(\"style\", None) is not None:', '            update((self.variables[\"style\"], \"title\"),', '                   self.variables[\"style\"], **title_kws)', '', '        # Add the style semantic labels', '        if self._style_map.levels is not None:', '            for level in self._style_map.levels:', '                if level is not None:', '                    attrs = self._style_map(level)', '                    update(', '                        self.variables[\"style\"],', '                        level,', '                        marker=attrs.get(\"marker\", \"\"),', '                        dashes=attrs.get(\"dashes\", \"\"),', '                    )', '', '        func = getattr(ax, self._legend_func)', '', '        legend_data = {}', '        legend_order = []', '', '        for key in keys:', '', '            _, label = key', '            kws = legend_kwargs[key]', '            kws.setdefault(\"color\", \".2\")', '            use_kws = {}', '            for attr in self._legend_attributes + [\"visible\"]:', '                if attr in kws:', '                    use_kws[attr] = kws[attr]', '            artist = func([], [], label=label, **use_kws)', '            if self._legend_func == \"plot\":', '                artist = artist[0]', '            legend_data[key] = artist', '            legend_order.append(key)', '', '        self.legend_title = legend_title', '        self.legend_data = legend_data', '        self.legend_order = legend_order'], 'methods': [{'name': 'add_legend_data', 'start_line': 193, 'end_line': 343, 'text': ['    def add_legend_data(self, ax):', '        \"\"\"Add labeled artists to represent the different plot semantics.\"\"\"', '        verbosity = self.legend', '        if isinstance(verbosity, str) and verbosity not in [\"auto\", \"brief\", \"full\"]:', '            err = \"`legend` must be \\'auto\\', \\'brief\\', \\'full\\', or a boolean.\"', '            raise ValueError(err)', '        elif verbosity is True:', '            verbosity = \"auto\"', '', '        legend_kwargs = {}', '        keys = []', '', '        # Assign a legend title if there is only going to be one sub-legend,', '        # otherwise, subtitles will be inserted into the texts list with an', '        # invisible handle (which is a hack)', '        titles = {', '            title for title in', '            (self.variables.get(v, None) for v in [\"hue\", \"size\", \"style\"])', '            if title is not None', '        }', '        if len(titles) == 1:', '            legend_title = titles.pop()', '        else:', '            legend_title = \"\"', '', '        title_kws = dict(', '            visible=False, color=\"w\", s=0, linewidth=0, marker=\"\", dashes=\"\"', '        )', '', '        def update(var_name, val_name, **kws):', '', '            key = var_name, val_name', '            if key in legend_kwargs:', '                legend_kwargs[key].update(**kws)', '            else:', '                keys.append(key)', '', '                legend_kwargs[key] = dict(**kws)', '', '        # Define the maximum number of ticks to use for \"brief\" legends', '        brief_ticks = 6', '', '        # -- Add a legend for hue semantics', '        brief_hue = self._hue_map.map_type == \"numeric\" and (', '            verbosity == \"brief\"', '            or (verbosity == \"auto\" and len(self._hue_map.levels) > brief_ticks)', '        )', '        if brief_hue:', '            if isinstance(self._hue_map.norm, mpl.colors.LogNorm):', '                locator = mpl.ticker.LogLocator(numticks=brief_ticks)', '            else:', '                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)', '            limits = min(self._hue_map.levels), max(self._hue_map.levels)', '            hue_levels, hue_formatted_levels = locator_to_legend_entries(', '                locator, limits, self.plot_data[\"hue\"].infer_objects().dtype', '            )', '        elif self._hue_map.levels is None:', '            hue_levels = hue_formatted_levels = []', '        else:', '            hue_levels = hue_formatted_levels = self._hue_map.levels', '', '        # Add the hue semantic subtitle', '        if not legend_title and self.variables.get(\"hue\", None) is not None:', '            update((self.variables[\"hue\"], \"title\"),', '                   self.variables[\"hue\"], **title_kws)', '', '        # Add the hue semantic labels', '        for level, formatted_level in zip(hue_levels, hue_formatted_levels):', '            if level is not None:', '                color = self._hue_map(level)', '                update(self.variables[\"hue\"], formatted_level, color=color)', '', '        # -- Add a legend for size semantics', '        brief_size = self._size_map.map_type == \"numeric\" and (', '            verbosity == \"brief\"', '            or (verbosity == \"auto\" and len(self._size_map.levels) > brief_ticks)', '        )', '        if brief_size:', '            # Define how ticks will interpolate between the min/max data values', '            if isinstance(self._size_map.norm, mpl.colors.LogNorm):', '                locator = mpl.ticker.LogLocator(numticks=brief_ticks)', '            else:', '                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)', '            # Define the min/max data values', '            limits = min(self._size_map.levels), max(self._size_map.levels)', '            size_levels, size_formatted_levels = locator_to_legend_entries(', '                locator, limits, self.plot_data[\"size\"].infer_objects().dtype', '            )', '        elif self._size_map.levels is None:', '            size_levels = size_formatted_levels = []', '        else:', '            size_levels = size_formatted_levels = self._size_map.levels', '', '        # Add the size semantic subtitle', '        if not legend_title and self.variables.get(\"size\", None) is not None:', '            update((self.variables[\"size\"], \"title\"),', '                   self.variables[\"size\"], **title_kws)', '', '        # Add the size semantic labels', '        for level, formatted_level in zip(size_levels, size_formatted_levels):', '            if level is not None:', '                size = self._size_map(level)', '                update(', '                    self.variables[\"size\"],', '                    formatted_level,', '                    linewidth=size,', '                    s=size,', '                )', '', '        # -- Add a legend for style semantics', '', '        # Add the style semantic title', '        if not legend_title and self.variables.get(\"style\", None) is not None:', '            update((self.variables[\"style\"], \"title\"),', '                   self.variables[\"style\"], **title_kws)', '', '        # Add the style semantic labels', '        if self._style_map.levels is not None:', '            for level in self._style_map.levels:', '                if level is not None:', '                    attrs = self._style_map(level)', '                    update(', '                        self.variables[\"style\"],', '                        level,', '                        marker=attrs.get(\"marker\", \"\"),', '                        dashes=attrs.get(\"dashes\", \"\"),', '                    )', '', '        func = getattr(ax, self._legend_func)', '', '        legend_data = {}', '        legend_order = []', '', '        for key in keys:', '', '            _, label = key', '            kws = legend_kwargs[key]', '            kws.setdefault(\"color\", \".2\")', '            use_kws = {}', '            for attr in self._legend_attributes + [\"visible\"]:', '                if attr in kws:', '                    use_kws[attr] = kws[attr]', '            artist = func([], [], label=label, **use_kws)', '            if self._legend_func == \"plot\":', '                artist = artist[0]', '            legend_data[key] = artist', '            legend_order.append(key)', '', '        self.legend_title = legend_title', '        self.legend_data = legend_data', '        self.legend_order = legend_order']}]}, {'name': '_LinePlotter', 'start_line': 346, 'end_line': 515, 'text': ['class _LinePlotter(_RelationalPlotter):', '', '    _legend_attributes = [\"color\", \"linewidth\", \"marker\", \"dashes\"]', '    _legend_func = \"plot\"', '', '    def __init__(', '        self, *,', '        data=None, variables={},', '        estimator=None, n_boot=None, seed=None, errorbar=None,', '        sort=True, orient=\"x\", err_style=None, err_kws=None, legend=None', '    ):', '', '        # TODO this is messy, we want the mapping to be agnostic about', '        # the kind of plot to draw, but for the time being we need to set', '        # this information so the SizeMapping can use it', '        self._default_size_range = (', '            np.r_[.5, 2] * mpl.rcParams[\"lines.linewidth\"]', '        )', '', '        super().__init__(data=data, variables=variables)', '', '        self.estimator = estimator', '        self.errorbar = errorbar', '        self.n_boot = n_boot', '        self.seed = seed', '        self.sort = sort', '        self.orient = orient', '        self.err_style = err_style', '        self.err_kws = {} if err_kws is None else err_kws', '', '        self.legend = legend', '', '    def plot(self, ax, kws):', '        \"\"\"Draw the plot onto an axes, passing matplotlib kwargs.\"\"\"', '', '        # Draw a test plot, using the passed in kwargs. The goal here is to', '        # honor both (a) the current state of the plot cycler and (b) the', '        # specified kwargs on all the lines we will draw, overriding when', \"        # relevant with the data semantics. Note that we won't cycle\", '        # internally; in other words, if `hue` is not used, all elements will', '        # have the same color, but they will have the color that you would have', '        # gotten from the corresponding matplotlib function, and calling the', '        # function will advance the axes property cycle.', '', '        kws.setdefault(\"markeredgewidth\", kws.pop(\"mew\", .75))', '        kws.setdefault(\"markeredgecolor\", kws.pop(\"mec\", \"w\"))', '', '        # Set default error kwargs', '        err_kws = self.err_kws.copy()', '        if self.err_style == \"band\":', '            err_kws.setdefault(\"alpha\", .2)', '        elif self.err_style == \"bars\":', '            pass', '        elif self.err_style is not None:', '            err = \"`err_style` must be \\'band\\' or \\'bars\\', not {}\"', '            raise ValueError(err.format(self.err_style))', '', '        # Initialize the aggregation object', '        agg = EstimateAggregator(', '            self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,', '        )', '', '        # TODO abstract variable to aggregate over here-ish. Better name?', '        orient = self.orient', '        if orient not in {\"x\", \"y\"}:', '            err = f\"`orient` must be either \\'x\\' or \\'y\\', not {orient!r}.\"', '            raise ValueError(err)', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '', \"        # TODO How to handle NA? We don't want NA to propagate through to the\", '        # estimate/CI when some values are present, but we would also like', '        # matplotlib to show \"gaps\" in the line when all values are missing.', '        # This is straightforward absent aggregation, but complicated with it.', '        # If we want to use nas, we need to conditionalize dropna in iter_data.', '', '        # Loop over the semantic subsets and add to the plot', '        grouping_vars = \"hue\", \"size\", \"style\"', '        for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):', '', '            if self.sort:', '                sort_vars = [\"units\", orient, other]', '                sort_cols = [var for var in sort_vars if var in self.variables]', '                sub_data = sub_data.sort_values(sort_cols)', '', '            if self.estimator is not None:', '                if \"units\" in self.variables:', '                    # TODO eventually relax this constraint', '                    err = \"estimator must be None when specifying units\"', '                    raise ValueError(err)', '                grouped = sub_data.groupby(orient, sort=self.sort)', '                # Could pass as_index=False instead of reset_index,', '                # but that fails on a corner case with older pandas.', '                sub_data = grouped.apply(agg, other).reset_index()', '', '            # TODO this is pretty ad hoc ; see GH2409', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    for col in sub_data.filter(regex=f\"^{var}\"):', '                        sub_data[col] = np.power(10, sub_data[col])', '', '            # --- Draw the main line(s)', '', '            if \"units\" in self.variables:   # XXX why not add to grouping variables?', '                lines = []', '                for _, unit_data in sub_data.groupby(\"units\"):', '                    lines.extend(ax.plot(unit_data[\"x\"], unit_data[\"y\"], **kws))', '            else:', '                lines = ax.plot(sub_data[\"x\"], sub_data[\"y\"], **kws)', '', '            for line in lines:', '', '                if \"hue\" in sub_vars:', '                    line.set_color(self._hue_map(sub_vars[\"hue\"]))', '', '                if \"size\" in sub_vars:', '                    line.set_linewidth(self._size_map(sub_vars[\"size\"]))', '', '                if \"style\" in sub_vars:', '                    attributes = self._style_map(sub_vars[\"style\"])', '                    if \"dashes\" in attributes:', '                        line.set_dashes(attributes[\"dashes\"])', '                    if \"marker\" in attributes:', '                        line.set_marker(attributes[\"marker\"])', '', '            line_color = line.get_color()', '            line_alpha = line.get_alpha()', '            line_capstyle = line.get_solid_capstyle()', '', '            # --- Draw the confidence intervals', '', '            if self.estimator is not None and self.errorbar is not None:', '', '                # TODO handling of orientation will need to happen here', '', '                if self.err_style == \"band\":', '', '                    func = {\"x\": ax.fill_between, \"y\": ax.fill_betweenx}[orient]', '                    func(', '                        sub_data[orient],', '                        sub_data[f\"{other}min\"], sub_data[f\"{other}max\"],', '                        color=line_color, **err_kws', '                    )', '', '                elif self.err_style == \"bars\":', '', '                    error_param = {', '                        f\"{other}err\": (', '                            sub_data[other] - sub_data[f\"{other}min\"],', '                            sub_data[f\"{other}max\"] - sub_data[other],', '                        )', '                    }', '                    ebars = ax.errorbar(', '                        sub_data[\"x\"], sub_data[\"y\"], **error_param,', '                        linestyle=\"\", color=line_color, alpha=line_alpha,', '                        **err_kws', '                    )', '', '                    # Set the capstyle properly on the error bars', '                    for obj in ebars.get_children():', '                        if isinstance(obj, mpl.collections.LineCollection):', '                            obj.set_capstyle(line_capstyle)', '', '        # Finalize the axes details', '        self._add_axis_labels(ax)', '        if self.legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                legend = ax.legend(title=self.legend_title)', '                adjust_legend_subtitles(legend)'], 'methods': [{'name': '__init__', 'start_line': 351, 'end_line': 376, 'text': ['    def __init__(', '        self, *,', '        data=None, variables={},', '        estimator=None, n_boot=None, seed=None, errorbar=None,', '        sort=True, orient=\"x\", err_style=None, err_kws=None, legend=None', '    ):', '', '        # TODO this is messy, we want the mapping to be agnostic about', '        # the kind of plot to draw, but for the time being we need to set', '        # this information so the SizeMapping can use it', '        self._default_size_range = (', '            np.r_[.5, 2] * mpl.rcParams[\"lines.linewidth\"]', '        )', '', '        super().__init__(data=data, variables=variables)', '', '        self.estimator = estimator', '        self.errorbar = errorbar', '        self.n_boot = n_boot', '        self.seed = seed', '        self.sort = sort', '        self.orient = orient', '        self.err_style = err_style', '        self.err_kws = {} if err_kws is None else err_kws', '', '        self.legend = legend']}, {'name': 'plot', 'start_line': 378, 'end_line': 515, 'text': ['    def plot(self, ax, kws):', '        \"\"\"Draw the plot onto an axes, passing matplotlib kwargs.\"\"\"', '', '        # Draw a test plot, using the passed in kwargs. The goal here is to', '        # honor both (a) the current state of the plot cycler and (b) the', '        # specified kwargs on all the lines we will draw, overriding when', \"        # relevant with the data semantics. Note that we won't cycle\", '        # internally; in other words, if `hue` is not used, all elements will', '        # have the same color, but they will have the color that you would have', '        # gotten from the corresponding matplotlib function, and calling the', '        # function will advance the axes property cycle.', '', '        kws.setdefault(\"markeredgewidth\", kws.pop(\"mew\", .75))', '        kws.setdefault(\"markeredgecolor\", kws.pop(\"mec\", \"w\"))', '', '        # Set default error kwargs', '        err_kws = self.err_kws.copy()', '        if self.err_style == \"band\":', '            err_kws.setdefault(\"alpha\", .2)', '        elif self.err_style == \"bars\":', '            pass', '        elif self.err_style is not None:', '            err = \"`err_style` must be \\'band\\' or \\'bars\\', not {}\"', '            raise ValueError(err.format(self.err_style))', '', '        # Initialize the aggregation object', '        agg = EstimateAggregator(', '            self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,', '        )', '', '        # TODO abstract variable to aggregate over here-ish. Better name?', '        orient = self.orient', '        if orient not in {\"x\", \"y\"}:', '            err = f\"`orient` must be either \\'x\\' or \\'y\\', not {orient!r}.\"', '            raise ValueError(err)', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '', \"        # TODO How to handle NA? We don't want NA to propagate through to the\", '        # estimate/CI when some values are present, but we would also like', '        # matplotlib to show \"gaps\" in the line when all values are missing.', '        # This is straightforward absent aggregation, but complicated with it.', '        # If we want to use nas, we need to conditionalize dropna in iter_data.', '', '        # Loop over the semantic subsets and add to the plot', '        grouping_vars = \"hue\", \"size\", \"style\"', '        for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):', '', '            if self.sort:', '                sort_vars = [\"units\", orient, other]', '                sort_cols = [var for var in sort_vars if var in self.variables]', '                sub_data = sub_data.sort_values(sort_cols)', '', '            if self.estimator is not None:', '                if \"units\" in self.variables:', '                    # TODO eventually relax this constraint', '                    err = \"estimator must be None when specifying units\"', '                    raise ValueError(err)', '                grouped = sub_data.groupby(orient, sort=self.sort)', '                # Could pass as_index=False instead of reset_index,', '                # but that fails on a corner case with older pandas.', '                sub_data = grouped.apply(agg, other).reset_index()', '', '            # TODO this is pretty ad hoc ; see GH2409', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    for col in sub_data.filter(regex=f\"^{var}\"):', '                        sub_data[col] = np.power(10, sub_data[col])', '', '            # --- Draw the main line(s)', '', '            if \"units\" in self.variables:   # XXX why not add to grouping variables?', '                lines = []', '                for _, unit_data in sub_data.groupby(\"units\"):', '                    lines.extend(ax.plot(unit_data[\"x\"], unit_data[\"y\"], **kws))', '            else:', '                lines = ax.plot(sub_data[\"x\"], sub_data[\"y\"], **kws)', '', '            for line in lines:', '', '                if \"hue\" in sub_vars:', '                    line.set_color(self._hue_map(sub_vars[\"hue\"]))', '', '                if \"size\" in sub_vars:', '                    line.set_linewidth(self._size_map(sub_vars[\"size\"]))', '', '                if \"style\" in sub_vars:', '                    attributes = self._style_map(sub_vars[\"style\"])', '                    if \"dashes\" in attributes:', '                        line.set_dashes(attributes[\"dashes\"])', '                    if \"marker\" in attributes:', '                        line.set_marker(attributes[\"marker\"])', '', '            line_color = line.get_color()', '            line_alpha = line.get_alpha()', '            line_capstyle = line.get_solid_capstyle()', '', '            # --- Draw the confidence intervals', '', '            if self.estimator is not None and self.errorbar is not None:', '', '                # TODO handling of orientation will need to happen here', '', '                if self.err_style == \"band\":', '', '                    func = {\"x\": ax.fill_between, \"y\": ax.fill_betweenx}[orient]', '                    func(', '                        sub_data[orient],', '                        sub_data[f\"{other}min\"], sub_data[f\"{other}max\"],', '                        color=line_color, **err_kws', '                    )', '', '                elif self.err_style == \"bars\":', '', '                    error_param = {', '                        f\"{other}err\": (', '                            sub_data[other] - sub_data[f\"{other}min\"],', '                            sub_data[f\"{other}max\"] - sub_data[other],', '                        )', '                    }', '                    ebars = ax.errorbar(', '                        sub_data[\"x\"], sub_data[\"y\"], **error_param,', '                        linestyle=\"\", color=line_color, alpha=line_alpha,', '                        **err_kws', '                    )', '', '                    # Set the capstyle properly on the error bars', '                    for obj in ebars.get_children():', '                        if isinstance(obj, mpl.collections.LineCollection):', '                            obj.set_capstyle(line_capstyle)', '', '        # Finalize the axes details', '        self._add_axis_labels(ax)', '        if self.legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                legend = ax.legend(title=self.legend_title)', '                adjust_legend_subtitles(legend)']}]}, {'name': '_ScatterPlotter', 'start_line': 518, 'end_line': 594, 'text': ['class _ScatterPlotter(_RelationalPlotter):', '', '    _legend_attributes = [\"color\", \"s\", \"marker\"]', '    _legend_func = \"scatter\"', '', '    def __init__(self, *, data=None, variables={}, legend=None):', '', '        # TODO this is messy, we want the mapping to be agnostic about', '        # the kind of plot to draw, but for the time being we need to set', '        # this information so the SizeMapping can use it', '        self._default_size_range = (', '            np.r_[.5, 2] * np.square(mpl.rcParams[\"lines.markersize\"])', '        )', '', '        super().__init__(data=data, variables=variables)', '', '        self.legend = legend', '', '    def plot(self, ax, kws):', '', '        # --- Determine the visual attributes of the plot', '', '        data = self.plot_data.dropna()', '        if data.empty:', '            return', '', '        # Define the vectors of x and y positions', '        empty = np.full(len(data), np.nan)', '        x = data.get(\"x\", empty)', '        y = data.get(\"y\", empty)', '', '        if \"style\" in self.variables:', '            # Use a representative marker so scatter sets the edgecolor', '            # properly for line art markers. We currently enforce either', '            # all or none line art so this works.', '            example_level = self._style_map.levels[0]', '            example_marker = self._style_map(example_level, \"marker\")', '            kws.setdefault(\"marker\", example_marker)', '', '        # Conditionally set the marker edgecolor based on whether the marker is \"filled\"', '        # See https://github.com/matplotlib/matplotlib/issues/17849 for context', '        m = kws.get(\"marker\", mpl.rcParams.get(\"marker\", \"o\"))', '        if not isinstance(m, mpl.markers.MarkerStyle):', '            # TODO in more recent matplotlib (which?) can pass a MarkerStyle here', '            m = mpl.markers.MarkerStyle(m)', '        if m.is_filled():', '            kws.setdefault(\"edgecolor\", \"w\")', '', '        # Draw the scatter plot', '        points = ax.scatter(x=x, y=y, **kws)', '', '        # Apply the mapping from semantic variables to artist attributes', '', '        if \"hue\" in self.variables:', '            points.set_facecolors(self._hue_map(data[\"hue\"]))', '', '        if \"size\" in self.variables:', '            points.set_sizes(self._size_map(data[\"size\"]))', '', '        if \"style\" in self.variables:', '            p = [self._style_map(val, \"path\") for val in data[\"style\"]]', '            points.set_paths(p)', '', '        # Apply dependent default attributes', '', '        if \"linewidth\" not in kws:', '            sizes = points.get_sizes()', '            points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))', '', '        # Finalize the axes details', '        self._add_axis_labels(ax)', '        if self.legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                legend = ax.legend(title=self.legend_title)', '                adjust_legend_subtitles(legend)'], 'methods': [{'name': '__init__', 'start_line': 523, 'end_line': 534, 'text': ['    def __init__(self, *, data=None, variables={}, legend=None):', '', '        # TODO this is messy, we want the mapping to be agnostic about', '        # the kind of plot to draw, but for the time being we need to set', '        # this information so the SizeMapping can use it', '        self._default_size_range = (', '            np.r_[.5, 2] * np.square(mpl.rcParams[\"lines.markersize\"])', '        )', '', '        super().__init__(data=data, variables=variables)', '', '        self.legend = legend']}, {'name': 'plot', 'start_line': 536, 'end_line': 594, 'text': ['    def plot(self, ax, kws):', '', '        # --- Determine the visual attributes of the plot', '', '        data = self.plot_data.dropna()', '        if data.empty:', '            return', '', '        # Define the vectors of x and y positions', '        empty = np.full(len(data), np.nan)', '        x = data.get(\"x\", empty)', '        y = data.get(\"y\", empty)', '', '        if \"style\" in self.variables:', '            # Use a representative marker so scatter sets the edgecolor', '            # properly for line art markers. We currently enforce either', '            # all or none line art so this works.', '            example_level = self._style_map.levels[0]', '            example_marker = self._style_map(example_level, \"marker\")', '            kws.setdefault(\"marker\", example_marker)', '', '        # Conditionally set the marker edgecolor based on whether the marker is \"filled\"', '        # See https://github.com/matplotlib/matplotlib/issues/17849 for context', '        m = kws.get(\"marker\", mpl.rcParams.get(\"marker\", \"o\"))', '        if not isinstance(m, mpl.markers.MarkerStyle):', '            # TODO in more recent matplotlib (which?) can pass a MarkerStyle here', '            m = mpl.markers.MarkerStyle(m)', '        if m.is_filled():', '            kws.setdefault(\"edgecolor\", \"w\")', '', '        # Draw the scatter plot', '        points = ax.scatter(x=x, y=y, **kws)', '', '        # Apply the mapping from semantic variables to artist attributes', '', '        if \"hue\" in self.variables:', '            points.set_facecolors(self._hue_map(data[\"hue\"]))', '', '        if \"size\" in self.variables:', '            points.set_sizes(self._size_map(data[\"size\"]))', '', '        if \"style\" in self.variables:', '            p = [self._style_map(val, \"path\") for val in data[\"style\"]]', '            points.set_paths(p)', '', '        # Apply dependent default attributes', '', '        if \"linewidth\" not in kws:', '            sizes = points.get_sizes()', '            points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))', '', '        # Finalize the axes details', '        self._add_axis_labels(ax)', '        if self.legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                legend = ax.legend(title=self.legend_title)', '                adjust_legend_subtitles(legend)']}]}], 'functions': [{'name': 'lineplot', 'start_line': 597, 'end_line': 640, 'text': ['def lineplot(', '    data=None, *,', '    x=None, y=None, hue=None, size=None, style=None, units=None,', '    palette=None, hue_order=None, hue_norm=None,', '    sizes=None, size_order=None, size_norm=None,', '    dashes=True, markers=None, style_order=None,', '    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None,', '    orient=\"x\", sort=True, err_style=\"band\", err_kws=None,', '    legend=\"auto\", ci=\"deprecated\", ax=None, **kwargs', '):', '', '    # Handle deprecation of ci parameter', '    errorbar = _deprecate_ci(errorbar, ci)', '', '    variables = _LinePlotter.get_semantics(locals())', '    p = _LinePlotter(', '        data=data, variables=variables,', '        estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,', '        sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,', '        legend=legend,', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '    p.map_size(sizes=sizes, order=size_order, norm=size_norm)', '    p.map_style(markers=markers, dashes=dashes, order=style_order)', '', '    if ax is None:', '        ax = plt.gca()', '', '    if style is None and not {\"ls\", \"linestyle\"} & set(kwargs):  # XXX', '        kwargs[\"dashes\"] = \"\" if dashes is None or isinstance(dashes, bool) else dashes', '', '    if not p.has_xy_data:', '        return ax', '', '    p._attach(ax)', '', '    # Other functions have color as an explicit param,', '    # and we should probably do that here too', '    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))', '    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)', '', '    p.plot(ax, kwargs)', '    return ax']}, {'name': 'scatterplot', 'start_line': 726, 'end_line': 757, 'text': ['def scatterplot(', '    data=None, *,', '    x=None, y=None, hue=None, size=None, style=None,', '    palette=None, hue_order=None, hue_norm=None,', '    sizes=None, size_order=None, size_norm=None,', '    markers=True, style_order=None, legend=\"auto\", ax=None,', '    **kwargs', '):', '', '    variables = _ScatterPlotter.get_semantics(locals())', '    p = _ScatterPlotter(data=data, variables=variables, legend=legend)', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '    p.map_size(sizes=sizes, order=size_order, norm=size_norm)', '    p.map_style(markers=markers, order=style_order)', '', '    if ax is None:', '        ax = plt.gca()', '', '    if not p.has_xy_data:', '        return ax', '', '    p._attach(ax)', '', '    # Other functions have color as an explicit param,', '    # and we should probably do that here too', '    color = kwargs.pop(\"color\", None)', '    kwargs[\"color\"] = _default_color(ax.scatter, hue, color, kwargs)', '', '    p.plot(ax, kwargs)', '', '    return ax']}, {'name': 'relplot', 'start_line': 819, 'end_line': 984, 'text': ['def relplot(', '    data=None, *,', '    x=None, y=None, hue=None, size=None, style=None, units=None,', '    row=None, col=None, col_wrap=None, row_order=None, col_order=None,', '    palette=None, hue_order=None, hue_norm=None,', '    sizes=None, size_order=None, size_norm=None,', '    markers=None, dashes=None, style_order=None,', '    legend=\"auto\", kind=\"scatter\", height=5, aspect=1, facet_kws=None,', '    **kwargs', '):', '', '    if kind == \"scatter\":', '', '        plotter = _ScatterPlotter', '        func = scatterplot', '        markers = True if markers is None else markers', '', '    elif kind == \"line\":', '', '        plotter = _LinePlotter', '        func = lineplot', '        dashes = True if dashes is None else dashes', '', '    else:', '        err = f\"Plot kind {kind} not recognized\"', '        raise ValueError(err)', '', '    # Check for attempt to plot onto specific axes and warn', '    if \"ax\" in kwargs:', '        msg = (', '            \"relplot is a figure-level function and does not accept \"', '            \"the `ax` parameter. You may wish to try {}\".format(kind + \"plot\")', '        )', '        warnings.warn(msg, UserWarning)', '        kwargs.pop(\"ax\")', '', '    # Use the full dataset to map the semantics', '    p = plotter(', '        data=data,', '        variables=plotter.get_semantics(locals()),', '        legend=legend,', '    )', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '    p.map_size(sizes=sizes, order=size_order, norm=size_norm)', '    p.map_style(markers=markers, dashes=dashes, order=style_order)', '', '    # Extract the semantic mappings', '    if \"hue\" in p.variables:', '        palette = p._hue_map.lookup_table', '        hue_order = p._hue_map.levels', '        hue_norm = p._hue_map.norm', '    else:', '        palette = hue_order = hue_norm = None', '', '    if \"size\" in p.variables:', '        sizes = p._size_map.lookup_table', '        size_order = p._size_map.levels', '        size_norm = p._size_map.norm', '', '    if \"style\" in p.variables:', '        style_order = p._style_map.levels', '        if markers:', '            markers = {k: p._style_map(k, \"marker\") for k in style_order}', '        else:', '            markers = None', '        if dashes:', '            dashes = {k: p._style_map(k, \"dashes\") for k in style_order}', '        else:', '            dashes = None', '    else:', '        markers = dashes = style_order = None', '', '    # Now extract the data that would be used to draw a single plot', '    variables = p.variables', '    plot_data = p.plot_data', '    plot_semantics = p.semantics', '', '    # Define the common plotting parameters', '    plot_kws = dict(', '        palette=palette, hue_order=hue_order, hue_norm=hue_norm,', '        sizes=sizes, size_order=size_order, size_norm=size_norm,', '        markers=markers, dashes=dashes, style_order=style_order,', '        legend=False,', '    )', '    plot_kws.update(kwargs)', '    if kind == \"scatter\":', '        plot_kws.pop(\"dashes\")', '', '    # Add the grid semantics onto the plotter', '    grid_semantics = \"row\", \"col\"', '    p.semantics = plot_semantics + grid_semantics', '    p.assign_variables(', '        data=data,', '        variables=dict(', '            x=x, y=y,', '            hue=hue, size=size, style=style, units=units,', '            row=row, col=col,', '        ),', '    )', '', '    # Define the named variables for plotting on each facet', '    # Rename the variables with a leading underscore to avoid', '    # collisions with faceting variable names', '    plot_variables = {v: f\"_{v}\" for v in variables}', '    plot_kws.update(plot_variables)', '', '    # Pass the row/col variables to FacetGrid with their original', '    # names so that the axes titles render correctly', '    for var in [\"row\", \"col\"]:', '        # Handle faceting variables that lack name information', '        if var in p.variables and p.variables[var] is None:', '            p.variables[var] = f\"_{var}_\"', '    grid_kws = {v: p.variables.get(v) for v in grid_semantics}', '', '    # Rename the columns of the plot_data structure appropriately', '    new_cols = plot_variables.copy()', '    new_cols.update(grid_kws)', '    full_data = p.plot_data.rename(columns=new_cols)', '', '    # Set up the FacetGrid object', '    facet_kws = {} if facet_kws is None else facet_kws.copy()', '    g = FacetGrid(', '        data=full_data.dropna(axis=1, how=\"all\"),', '        **grid_kws,', '        col_wrap=col_wrap, row_order=row_order, col_order=col_order,', '        height=height, aspect=aspect, dropna=False,', '        **facet_kws', '    )', '', '    # Draw the plot', '    g.map_dataframe(func, **plot_kws)', '', '    # Label the axes, using the original variables', '    g.set(xlabel=variables.get(\"x\"), ylabel=variables.get(\"y\"))', '', '    # Show the legend', '    if legend:', '        # Replace the original plot data so the legend uses', '        # numeric data with the correct type', '        p.plot_data = plot_data', '        p.add_legend_data(g.axes.flat[0])', '        if p.legend_data:', '            g.add_legend(legend_data=p.legend_data,', '                         label_order=p.legend_order,', '                         title=p.legend_title,', '                         adjust_subtitles=True)', '', \"    # Rename the columns of the FacetGrid's `data` attribute\", '    # to match the original column names', '    orig_cols = {', '        f\"_{k}\": f\"_{k}_\" if v is None else v for k, v in variables.items()', '    }', '    grid_data = g.data.rename(columns=orig_cols)', '    if data is not None and (x is not None or y is not None):', '        if not isinstance(data, pd.DataFrame):', '            data = pd.DataFrame(data)', '        g.data = pd.merge(', '            data,', '            grid_data[grid_data.columns.difference(data.columns)],', '            left_index=True,', '            right_index=True,', '        )', '    else:', '        g.data = grid_data', '', '    return g']}, {'name': 'update', 'start_line': 222, 'end_line': 230, 'text': ['        def update(var_name, val_name, **kws):', '', '            key = var_name, val_name', '            if key in legend_kwargs:', '                legend_kwargs[key].update(**kws)', '            else:', '                keys.append(key)', '', '                legend_kwargs[key] = dict(**kws)']}], 'text': ['import warnings', '', 'import numpy as np', 'import pandas as pd', 'import matplotlib as mpl', 'import matplotlib.pyplot as plt', '', 'from ._oldcore import (', '    VectorPlotter,', ')', 'from .utils import (', '    locator_to_legend_entries,', '    adjust_legend_subtitles,', '    _default_color,', '    _deprecate_ci,', ')', 'from ._statistics import EstimateAggregator', 'from .axisgrid import FacetGrid, _facet_docs', 'from ._docstrings import DocstringComponents, _core_docs', '', '', '__all__ = [\"relplot\", \"scatterplot\", \"lineplot\"]', '', '', '_relational_narrative = DocstringComponents(dict(', '', '    # ---  Introductory prose', '    main_api=\"\"\"', 'The relationship between `x` and `y` can be shown for different subsets', 'of the data using the `hue`, `size`, and `style` parameters. These', 'parameters control what visual semantics are used to identify the different', 'subsets. It is possible to show up to three dimensions independently by', 'using all three semantic types, but this style of plot can be hard to', 'interpret and is often ineffective. Using redundant semantics (i.e. both', '`hue` and `style` for the same variable) can be helpful for making', 'graphics more accessible.', '', 'See the :ref:`tutorial <relational_tutorial>` for more information.', '    \"\"\",', '', '    relational_semantic=\"\"\"', 'The default treatment of the `hue` (and to a lesser extent, `size`)', 'semantic, if present, depends on whether the variable is inferred to', 'represent \"numeric\" or \"categorical\" data. In particular, numeric variables', 'are represented with a sequential colormap by default, and the legend', 'entries show regular \"ticks\" with values that may or may not exist in the', 'data. This behavior can be controlled through various parameters, as', 'described and illustrated below.', '    \"\"\",', '))', '', '_relational_docs = dict(', '', '    # --- Shared function parameters', '    data_vars=\"\"\"', 'x, y : names of variables in `data` or vector data', '    Input data variables; must be numeric. Can pass data directly or', '    reference columns in `data`.', '    \"\"\",', '    data=\"\"\"', 'data : DataFrame, array, or list of arrays', '    Input data structure. If `x` and `y` are specified as names, this', '    should be a \"long-form\" DataFrame containing those columns. Otherwise', '    it is treated as \"wide-form\" data and grouping variables are ignored.', '    See the examples for the various ways this parameter can be specified', '    and the different effects of each.', '    \"\"\",', '    palette=\"\"\"', 'palette : string, list, dict, or matplotlib colormap', '    An object that determines how colors are chosen when `hue` is used.', '    It can be the name of a seaborn palette or matplotlib colormap, a list', '    of colors (anything matplotlib understands), a dict mapping levels', '    of the `hue` variable to colors, or a matplotlib colormap object.', '    \"\"\",', '    hue_order=\"\"\"', 'hue_order : list', '    Specified order for the appearance of the `hue` variable levels,', '    otherwise they are determined from the data. Not relevant when the', '    `hue` variable is numeric.', '    \"\"\",', '    hue_norm=\"\"\"', 'hue_norm : tuple or :class:`matplotlib.colors.Normalize` object', '    Normalization in data units for colormap applied to the `hue`', '    variable when it is numeric. Not relevant if `hue` is categorical.', '    \"\"\",', '    sizes=\"\"\"', 'sizes : list, dict, or tuple', '    An object that determines how sizes are chosen when `size` is used.', '    List or dict arguments should provide a size for each unique data value,', '    which forces a categorical interpretation. The argument may also be a', '    min, max tuple.', '    \"\"\",', '    size_order=\"\"\"', 'size_order : list', '    Specified order for appearance of the `size` variable levels,', '    otherwise they are determined from the data. Not relevant when the', '    `size` variable is numeric.', '    \"\"\",', '    size_norm=\"\"\"', 'size_norm : tuple or Normalize object', '    Normalization in data units for scaling plot objects when the', '    `size` variable is numeric.', '    \"\"\",', '    dashes=\"\"\"', 'dashes : boolean, list, or dictionary', '    Object determining how to draw the lines for different levels of the', '    `style` variable. Setting to `True` will use default dash codes, or', '    you can pass a list of dash codes or a dictionary mapping levels of the', '    `style` variable to dash codes. Setting to `False` will use solid', '    lines for all subsets. Dashes are specified as in matplotlib: a tuple', '    of `(segment, gap)` lengths, or an empty string to draw a solid line.', '    \"\"\",', '    markers=\"\"\"', 'markers : boolean, list, or dictionary', '    Object determining how to draw the markers for different levels of the', '    `style` variable. Setting to `True` will use default markers, or', '    you can pass a list of markers or a dictionary mapping levels of the', '    `style` variable to markers. Setting to `False` will draw', '    marker-less lines.  Markers are specified as in matplotlib.', '    \"\"\",', '    style_order=\"\"\"', 'style_order : list', '    Specified order for appearance of the `style` variable levels', '    otherwise they are determined from the data. Not relevant when the', '    `style` variable is numeric.', '    \"\"\",', '    units=\"\"\"', 'units : vector or key in `data`', '    Grouping variable identifying sampling units. When used, a separate', '    line will be drawn for each unit with appropriate semantics, but no', '    legend entry will be added. Useful for showing distribution of', '    experimental replicates when exact identities are not needed.', '    \"\"\",', '    estimator=\"\"\"', 'estimator : name of pandas method or callable or None', '    Method for aggregating across multiple observations of the `y`', '    variable at the same `x` level. If `None`, all observations will', '    be drawn.', '    \"\"\",', '    ci=\"\"\"', 'ci : int or \"sd\" or None', '    Size of the confidence interval to draw when aggregating.', '', '    .. deprecated:: 0.12.0', '        Use the new `errorbar` parameter for more flexibility.', '', '    \"\"\",', '    n_boot=\"\"\"', 'n_boot : int', '    Number of bootstraps to use for computing the confidence interval.', '    \"\"\",', '    seed=\"\"\"', 'seed : int, numpy.random.Generator, or numpy.random.RandomState', '    Seed or random number generator for reproducible bootstrapping.', '    \"\"\",', '    legend=\"\"\"', 'legend : \"auto\", \"brief\", \"full\", or False', '    How to draw the legend. If \"brief\", numeric `hue` and `size`', '    variables will be represented with a sample of evenly spaced values.', '    If \"full\", every group will get an entry in the legend. If \"auto\",', '    choose between brief or full representation based on number of levels.', '    If `False`, no legend data is added and no legend is drawn.', '    \"\"\",', '    ax_in=\"\"\"', 'ax : matplotlib Axes', '    Axes object to draw the plot onto, otherwise uses the current Axes.', '    \"\"\",', '    ax_out=\"\"\"', 'ax : matplotlib Axes', '    Returns the Axes object with the plot drawn onto it.', '    \"\"\",', '', ')', '', '', '_param_docs = DocstringComponents.from_nested_components(', '    core=_core_docs[\"params\"],', '    facets=DocstringComponents(_facet_docs),', '    rel=DocstringComponents(_relational_docs),', '    stat=DocstringComponents.from_function_params(EstimateAggregator.__init__),', ')', '', '', 'class _RelationalPlotter(VectorPlotter):', '', '    wide_structure = {', '        \"x\": \"@index\", \"y\": \"@values\", \"hue\": \"@columns\", \"style\": \"@columns\",', '    }', '', '    # TODO where best to define default parameters?', '    sort = True', '', '    def add_legend_data(self, ax):', '        \"\"\"Add labeled artists to represent the different plot semantics.\"\"\"', '        verbosity = self.legend', '        if isinstance(verbosity, str) and verbosity not in [\"auto\", \"brief\", \"full\"]:', '            err = \"`legend` must be \\'auto\\', \\'brief\\', \\'full\\', or a boolean.\"', '            raise ValueError(err)', '        elif verbosity is True:', '            verbosity = \"auto\"', '', '        legend_kwargs = {}', '        keys = []', '', '        # Assign a legend title if there is only going to be one sub-legend,', '        # otherwise, subtitles will be inserted into the texts list with an', '        # invisible handle (which is a hack)', '        titles = {', '            title for title in', '            (self.variables.get(v, None) for v in [\"hue\", \"size\", \"style\"])', '            if title is not None', '        }', '        if len(titles) == 1:', '            legend_title = titles.pop()', '        else:', '            legend_title = \"\"', '', '        title_kws = dict(', '            visible=False, color=\"w\", s=0, linewidth=0, marker=\"\", dashes=\"\"', '        )', '', '        def update(var_name, val_name, **kws):', '', '            key = var_name, val_name', '            if key in legend_kwargs:', '                legend_kwargs[key].update(**kws)', '            else:', '                keys.append(key)', '', '                legend_kwargs[key] = dict(**kws)', '', '        # Define the maximum number of ticks to use for \"brief\" legends', '        brief_ticks = 6', '', '        # -- Add a legend for hue semantics', '        brief_hue = self._hue_map.map_type == \"numeric\" and (', '            verbosity == \"brief\"', '            or (verbosity == \"auto\" and len(self._hue_map.levels) > brief_ticks)', '        )', '        if brief_hue:', '            if isinstance(self._hue_map.norm, mpl.colors.LogNorm):', '                locator = mpl.ticker.LogLocator(numticks=brief_ticks)', '            else:', '                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)', '            limits = min(self._hue_map.levels), max(self._hue_map.levels)', '            hue_levels, hue_formatted_levels = locator_to_legend_entries(', '                locator, limits, self.plot_data[\"hue\"].infer_objects().dtype', '            )', '        elif self._hue_map.levels is None:', '            hue_levels = hue_formatted_levels = []', '        else:', '            hue_levels = hue_formatted_levels = self._hue_map.levels', '', '        # Add the hue semantic subtitle', '        if not legend_title and self.variables.get(\"hue\", None) is not None:', '            update((self.variables[\"hue\"], \"title\"),', '                   self.variables[\"hue\"], **title_kws)', '', '        # Add the hue semantic labels', '        for level, formatted_level in zip(hue_levels, hue_formatted_levels):', '            if level is not None:', '                color = self._hue_map(level)', '                update(self.variables[\"hue\"], formatted_level, color=color)', '', '        # -- Add a legend for size semantics', '        brief_size = self._size_map.map_type == \"numeric\" and (', '            verbosity == \"brief\"', '            or (verbosity == \"auto\" and len(self._size_map.levels) > brief_ticks)', '        )', '        if brief_size:', '            # Define how ticks will interpolate between the min/max data values', '            if isinstance(self._size_map.norm, mpl.colors.LogNorm):', '                locator = mpl.ticker.LogLocator(numticks=brief_ticks)', '            else:', '                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)', '            # Define the min/max data values', '            limits = min(self._size_map.levels), max(self._size_map.levels)', '            size_levels, size_formatted_levels = locator_to_legend_entries(', '                locator, limits, self.plot_data[\"size\"].infer_objects().dtype', '            )', '        elif self._size_map.levels is None:', '            size_levels = size_formatted_levels = []', '        else:', '            size_levels = size_formatted_levels = self._size_map.levels', '', '        # Add the size semantic subtitle', '        if not legend_title and self.variables.get(\"size\", None) is not None:', '            update((self.variables[\"size\"], \"title\"),', '                   self.variables[\"size\"], **title_kws)', '', '        # Add the size semantic labels', '        for level, formatted_level in zip(size_levels, size_formatted_levels):', '            if level is not None:', '                size = self._size_map(level)', '                update(', '                    self.variables[\"size\"],', '                    formatted_level,', '                    linewidth=size,', '                    s=size,', '                )', '', '        # -- Add a legend for style semantics', '', '        # Add the style semantic title', '        if not legend_title and self.variables.get(\"style\", None) is not None:', '            update((self.variables[\"style\"], \"title\"),', '                   self.variables[\"style\"], **title_kws)', '', '        # Add the style semantic labels', '        if self._style_map.levels is not None:', '            for level in self._style_map.levels:', '                if level is not None:', '                    attrs = self._style_map(level)', '                    update(', '                        self.variables[\"style\"],', '                        level,', '                        marker=attrs.get(\"marker\", \"\"),', '                        dashes=attrs.get(\"dashes\", \"\"),', '                    )', '', '        func = getattr(ax, self._legend_func)', '', '        legend_data = {}', '        legend_order = []', '', '        for key in keys:', '', '            _, label = key', '            kws = legend_kwargs[key]', '            kws.setdefault(\"color\", \".2\")', '            use_kws = {}', '            for attr in self._legend_attributes + [\"visible\"]:', '                if attr in kws:', '                    use_kws[attr] = kws[attr]', '            artist = func([], [], label=label, **use_kws)', '            if self._legend_func == \"plot\":', '                artist = artist[0]', '            legend_data[key] = artist', '            legend_order.append(key)', '', '        self.legend_title = legend_title', '        self.legend_data = legend_data', '        self.legend_order = legend_order', '', '', 'class _LinePlotter(_RelationalPlotter):', '', '    _legend_attributes = [\"color\", \"linewidth\", \"marker\", \"dashes\"]', '    _legend_func = \"plot\"', '', '    def __init__(', '        self, *,', '        data=None, variables={},', '        estimator=None, n_boot=None, seed=None, errorbar=None,', '        sort=True, orient=\"x\", err_style=None, err_kws=None, legend=None', '    ):', '', '        # TODO this is messy, we want the mapping to be agnostic about', '        # the kind of plot to draw, but for the time being we need to set', '        # this information so the SizeMapping can use it', '        self._default_size_range = (', '            np.r_[.5, 2] * mpl.rcParams[\"lines.linewidth\"]', '        )', '', '        super().__init__(data=data, variables=variables)', '', '        self.estimator = estimator', '        self.errorbar = errorbar', '        self.n_boot = n_boot', '        self.seed = seed', '        self.sort = sort', '        self.orient = orient', '        self.err_style = err_style', '        self.err_kws = {} if err_kws is None else err_kws', '', '        self.legend = legend', '', '    def plot(self, ax, kws):', '        \"\"\"Draw the plot onto an axes, passing matplotlib kwargs.\"\"\"', '', '        # Draw a test plot, using the passed in kwargs. The goal here is to', '        # honor both (a) the current state of the plot cycler and (b) the', '        # specified kwargs on all the lines we will draw, overriding when', \"        # relevant with the data semantics. Note that we won't cycle\", '        # internally; in other words, if `hue` is not used, all elements will', '        # have the same color, but they will have the color that you would have', '        # gotten from the corresponding matplotlib function, and calling the', '        # function will advance the axes property cycle.', '', '        kws.setdefault(\"markeredgewidth\", kws.pop(\"mew\", .75))', '        kws.setdefault(\"markeredgecolor\", kws.pop(\"mec\", \"w\"))', '', '        # Set default error kwargs', '        err_kws = self.err_kws.copy()', '        if self.err_style == \"band\":', '            err_kws.setdefault(\"alpha\", .2)', '        elif self.err_style == \"bars\":', '            pass', '        elif self.err_style is not None:', '            err = \"`err_style` must be \\'band\\' or \\'bars\\', not {}\"', '            raise ValueError(err.format(self.err_style))', '', '        # Initialize the aggregation object', '        agg = EstimateAggregator(', '            self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,', '        )', '', '        # TODO abstract variable to aggregate over here-ish. Better name?', '        orient = self.orient', '        if orient not in {\"x\", \"y\"}:', '            err = f\"`orient` must be either \\'x\\' or \\'y\\', not {orient!r}.\"', '            raise ValueError(err)', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '', \"        # TODO How to handle NA? We don't want NA to propagate through to the\", '        # estimate/CI when some values are present, but we would also like', '        # matplotlib to show \"gaps\" in the line when all values are missing.', '        # This is straightforward absent aggregation, but complicated with it.', '        # If we want to use nas, we need to conditionalize dropna in iter_data.', '', '        # Loop over the semantic subsets and add to the plot', '        grouping_vars = \"hue\", \"size\", \"style\"', '        for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):', '', '            if self.sort:', '                sort_vars = [\"units\", orient, other]', '                sort_cols = [var for var in sort_vars if var in self.variables]', '                sub_data = sub_data.sort_values(sort_cols)', '', '            if self.estimator is not None:', '                if \"units\" in self.variables:', '                    # TODO eventually relax this constraint', '                    err = \"estimator must be None when specifying units\"', '                    raise ValueError(err)', '                grouped = sub_data.groupby(orient, sort=self.sort)', '                # Could pass as_index=False instead of reset_index,', '                # but that fails on a corner case with older pandas.', '                sub_data = grouped.apply(agg, other).reset_index()', '', '            # TODO this is pretty ad hoc ; see GH2409', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    for col in sub_data.filter(regex=f\"^{var}\"):', '                        sub_data[col] = np.power(10, sub_data[col])', '', '            # --- Draw the main line(s)', '', '            if \"units\" in self.variables:   # XXX why not add to grouping variables?', '                lines = []', '                for _, unit_data in sub_data.groupby(\"units\"):', '                    lines.extend(ax.plot(unit_data[\"x\"], unit_data[\"y\"], **kws))', '            else:', '                lines = ax.plot(sub_data[\"x\"], sub_data[\"y\"], **kws)', '', '            for line in lines:', '', '                if \"hue\" in sub_vars:', '                    line.set_color(self._hue_map(sub_vars[\"hue\"]))', '', '                if \"size\" in sub_vars:', '                    line.set_linewidth(self._size_map(sub_vars[\"size\"]))', '', '                if \"style\" in sub_vars:', '                    attributes = self._style_map(sub_vars[\"style\"])', '                    if \"dashes\" in attributes:', '                        line.set_dashes(attributes[\"dashes\"])', '                    if \"marker\" in attributes:', '                        line.set_marker(attributes[\"marker\"])', '', '            line_color = line.get_color()', '            line_alpha = line.get_alpha()', '            line_capstyle = line.get_solid_capstyle()', '', '            # --- Draw the confidence intervals', '', '            if self.estimator is not None and self.errorbar is not None:', '', '                # TODO handling of orientation will need to happen here', '', '                if self.err_style == \"band\":', '', '                    func = {\"x\": ax.fill_between, \"y\": ax.fill_betweenx}[orient]', '                    func(', '                        sub_data[orient],', '                        sub_data[f\"{other}min\"], sub_data[f\"{other}max\"],', '                        color=line_color, **err_kws', '                    )', '', '                elif self.err_style == \"bars\":', '', '                    error_param = {', '                        f\"{other}err\": (', '                            sub_data[other] - sub_data[f\"{other}min\"],', '                            sub_data[f\"{other}max\"] - sub_data[other],', '                        )', '                    }', '                    ebars = ax.errorbar(', '                        sub_data[\"x\"], sub_data[\"y\"], **error_param,', '                        linestyle=\"\", color=line_color, alpha=line_alpha,', '                        **err_kws', '                    )', '', '                    # Set the capstyle properly on the error bars', '                    for obj in ebars.get_children():', '                        if isinstance(obj, mpl.collections.LineCollection):', '                            obj.set_capstyle(line_capstyle)', '', '        # Finalize the axes details', '        self._add_axis_labels(ax)', '        if self.legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                legend = ax.legend(title=self.legend_title)', '                adjust_legend_subtitles(legend)', '', '', 'class _ScatterPlotter(_RelationalPlotter):', '', '    _legend_attributes = [\"color\", \"s\", \"marker\"]', '    _legend_func = \"scatter\"', '', '    def __init__(self, *, data=None, variables={}, legend=None):', '', '        # TODO this is messy, we want the mapping to be agnostic about', '        # the kind of plot to draw, but for the time being we need to set', '        # this information so the SizeMapping can use it', '        self._default_size_range = (', '            np.r_[.5, 2] * np.square(mpl.rcParams[\"lines.markersize\"])', '        )', '', '        super().__init__(data=data, variables=variables)', '', '        self.legend = legend', '', '    def plot(self, ax, kws):', '', '        # --- Determine the visual attributes of the plot', '', '        data = self.plot_data.dropna()', '        if data.empty:', '            return', '', '        # Define the vectors of x and y positions', '        empty = np.full(len(data), np.nan)', '        x = data.get(\"x\", empty)', '        y = data.get(\"y\", empty)', '', '        if \"style\" in self.variables:', '            # Use a representative marker so scatter sets the edgecolor', '            # properly for line art markers. We currently enforce either', '            # all or none line art so this works.', '            example_level = self._style_map.levels[0]', '            example_marker = self._style_map(example_level, \"marker\")', '            kws.setdefault(\"marker\", example_marker)', '', '        # Conditionally set the marker edgecolor based on whether the marker is \"filled\"', '        # See https://github.com/matplotlib/matplotlib/issues/17849 for context', '        m = kws.get(\"marker\", mpl.rcParams.get(\"marker\", \"o\"))', '        if not isinstance(m, mpl.markers.MarkerStyle):', '            # TODO in more recent matplotlib (which?) can pass a MarkerStyle here', '            m = mpl.markers.MarkerStyle(m)', '        if m.is_filled():', '            kws.setdefault(\"edgecolor\", \"w\")', '', '        # Draw the scatter plot', '        points = ax.scatter(x=x, y=y, **kws)', '', '        # Apply the mapping from semantic variables to artist attributes', '', '        if \"hue\" in self.variables:', '            points.set_facecolors(self._hue_map(data[\"hue\"]))', '', '        if \"size\" in self.variables:', '            points.set_sizes(self._size_map(data[\"size\"]))', '', '        if \"style\" in self.variables:', '            p = [self._style_map(val, \"path\") for val in data[\"style\"]]', '            points.set_paths(p)', '', '        # Apply dependent default attributes', '', '        if \"linewidth\" not in kws:', '            sizes = points.get_sizes()', '            points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))', '', '        # Finalize the axes details', '        self._add_axis_labels(ax)', '        if self.legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                legend = ax.legend(title=self.legend_title)', '                adjust_legend_subtitles(legend)', '', '', 'def lineplot(', '    data=None, *,', '    x=None, y=None, hue=None, size=None, style=None, units=None,', '    palette=None, hue_order=None, hue_norm=None,', '    sizes=None, size_order=None, size_norm=None,', '    dashes=True, markers=None, style_order=None,', '    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None,', '    orient=\"x\", sort=True, err_style=\"band\", err_kws=None,', '    legend=\"auto\", ci=\"deprecated\", ax=None, **kwargs', '):', '', '    # Handle deprecation of ci parameter', '    errorbar = _deprecate_ci(errorbar, ci)', '', '    variables = _LinePlotter.get_semantics(locals())', '    p = _LinePlotter(', '        data=data, variables=variables,', '        estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,', '        sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,', '        legend=legend,', '    )', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '    p.map_size(sizes=sizes, order=size_order, norm=size_norm)', '    p.map_style(markers=markers, dashes=dashes, order=style_order)', '', '    if ax is None:', '        ax = plt.gca()', '', '    if style is None and not {\"ls\", \"linestyle\"} & set(kwargs):  # XXX', '        kwargs[\"dashes\"] = \"\" if dashes is None or isinstance(dashes, bool) else dashes', '', '    if not p.has_xy_data:', '        return ax', '', '    p._attach(ax)', '', '    # Other functions have color as an explicit param,', '    # and we should probably do that here too', '    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))', '    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)', '', '    p.plot(ax, kwargs)', '    return ax', '', '', 'lineplot.__doc__ = \"\"\"\\\\', 'Draw a line plot with possibility of several semantic groupings.', '', '{narrative.main_api}', '', '{narrative.relational_semantic}', '', 'By default, the plot aggregates over multiple `y` values at each value of', '`x` and shows an estimate of the central tendency and a confidence', 'interval for that estimate.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', 'hue : vector or key in `data`', '    Grouping variable that will produce lines with different colors.', '    Can be either categorical or numeric, although color mapping will', '    behave differently in latter case.', 'size : vector or key in `data`', '    Grouping variable that will produce lines with different widths.', '    Can be either categorical or numeric, although size mapping will', '    behave differently in latter case.', 'style : vector or key in `data`', '    Grouping variable that will produce lines with different dashes', '    and/or markers. Can have a numeric dtype but will always be treated', '    as categorical.', '{params.rel.units}', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', '{params.rel.sizes}', '{params.rel.size_order}', '{params.rel.size_norm}', '{params.rel.dashes}', '{params.rel.markers}', '{params.rel.style_order}', '{params.rel.estimator}', '{params.stat.errorbar}', '{params.rel.n_boot}', '{params.rel.seed}', 'orient : \"x\" or \"y\"', '    Dimension along which the data are sorted / aggregated. Equivalently,', '    the \"independent variable\" of the resulting function.', 'sort : boolean', '    If True, the data will be sorted by the x and y variables, otherwise', '    lines will connect points in the order they appear in the dataset.', 'err_style : \"band\" or \"bars\"', '    Whether to draw the confidence intervals with translucent error bands', '    or discrete error bars.', 'err_kws : dict of keyword arguments', '    Additional parameters to control the aesthetics of the error bars. The', '    kwargs are passed either to :meth:`matplotlib.axes.Axes.fill_between`', '    or :meth:`matplotlib.axes.Axes.errorbar`, depending on `err_style`.', '{params.rel.legend}', '{params.rel.ci}', '{params.core.ax}', 'kwargs : key, value mappings', '    Other keyword arguments are passed down to', '    :meth:`matplotlib.axes.Axes.plot`.', '', 'Returns', '-------', '{returns.ax}', '', 'See Also', '--------', '{seealso.scatterplot}', '{seealso.pointplot}', '', 'Examples', '--------', '', '.. include:: ../docstrings/lineplot.rst', '', '\"\"\".format(', '    narrative=_relational_narrative,', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')', '', '', 'def scatterplot(', '    data=None, *,', '    x=None, y=None, hue=None, size=None, style=None,', '    palette=None, hue_order=None, hue_norm=None,', '    sizes=None, size_order=None, size_norm=None,', '    markers=True, style_order=None, legend=\"auto\", ax=None,', '    **kwargs', '):', '', '    variables = _ScatterPlotter.get_semantics(locals())', '    p = _ScatterPlotter(data=data, variables=variables, legend=legend)', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '    p.map_size(sizes=sizes, order=size_order, norm=size_norm)', '    p.map_style(markers=markers, order=style_order)', '', '    if ax is None:', '        ax = plt.gca()', '', '    if not p.has_xy_data:', '        return ax', '', '    p._attach(ax)', '', '    # Other functions have color as an explicit param,', '    # and we should probably do that here too', '    color = kwargs.pop(\"color\", None)', '    kwargs[\"color\"] = _default_color(ax.scatter, hue, color, kwargs)', '', '    p.plot(ax, kwargs)', '', '    return ax', '', '', 'scatterplot.__doc__ = \"\"\"\\\\', 'Draw a scatter plot with possibility of several semantic groupings.', '', '{narrative.main_api}', '', '{narrative.relational_semantic}', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', 'hue : vector or key in `data`', '    Grouping variable that will produce points with different colors.', '    Can be either categorical or numeric, although color mapping will', '    behave differently in latter case.', 'size : vector or key in `data`', '    Grouping variable that will produce points with different sizes.', '    Can be either categorical or numeric, although size mapping will', '    behave differently in latter case.', 'style : vector or key in `data`', '    Grouping variable that will produce points with different markers.', '    Can have a numeric dtype but will always be treated as categorical.', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', '{params.rel.sizes}', '{params.rel.size_order}', '{params.rel.size_norm}', '{params.rel.markers}', '{params.rel.style_order}', '{params.rel.legend}', '{params.core.ax}', 'kwargs : key, value mappings', '    Other keyword arguments are passed down to', '    :meth:`matplotlib.axes.Axes.scatter`.', '', 'Returns', '-------', '{returns.ax}', '', 'See Also', '--------', '{seealso.lineplot}', '{seealso.stripplot}', '{seealso.swarmplot}', '', 'Examples', '--------', '', '.. include:: ../docstrings/scatterplot.rst', '', '\"\"\".format(', '    narrative=_relational_narrative,', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')', '', '', 'def relplot(', '    data=None, *,', '    x=None, y=None, hue=None, size=None, style=None, units=None,', '    row=None, col=None, col_wrap=None, row_order=None, col_order=None,', '    palette=None, hue_order=None, hue_norm=None,', '    sizes=None, size_order=None, size_norm=None,', '    markers=None, dashes=None, style_order=None,', '    legend=\"auto\", kind=\"scatter\", height=5, aspect=1, facet_kws=None,', '    **kwargs', '):', '', '    if kind == \"scatter\":', '', '        plotter = _ScatterPlotter', '        func = scatterplot', '        markers = True if markers is None else markers', '', '    elif kind == \"line\":', '', '        plotter = _LinePlotter', '        func = lineplot', '        dashes = True if dashes is None else dashes', '', '    else:', '        err = f\"Plot kind {kind} not recognized\"', '        raise ValueError(err)', '', '    # Check for attempt to plot onto specific axes and warn', '    if \"ax\" in kwargs:', '        msg = (', '            \"relplot is a figure-level function and does not accept \"', '            \"the `ax` parameter. You may wish to try {}\".format(kind + \"plot\")', '        )', '        warnings.warn(msg, UserWarning)', '        kwargs.pop(\"ax\")', '', '    # Use the full dataset to map the semantics', '    p = plotter(', '        data=data,', '        variables=plotter.get_semantics(locals()),', '        legend=legend,', '    )', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '    p.map_size(sizes=sizes, order=size_order, norm=size_norm)', '    p.map_style(markers=markers, dashes=dashes, order=style_order)', '', '    # Extract the semantic mappings', '    if \"hue\" in p.variables:', '        palette = p._hue_map.lookup_table', '        hue_order = p._hue_map.levels', '        hue_norm = p._hue_map.norm', '    else:', '        palette = hue_order = hue_norm = None', '', '    if \"size\" in p.variables:', '        sizes = p._size_map.lookup_table', '        size_order = p._size_map.levels', '        size_norm = p._size_map.norm', '', '    if \"style\" in p.variables:', '        style_order = p._style_map.levels', '        if markers:', '            markers = {k: p._style_map(k, \"marker\") for k in style_order}', '        else:', '            markers = None', '        if dashes:', '            dashes = {k: p._style_map(k, \"dashes\") for k in style_order}', '        else:', '            dashes = None', '    else:', '        markers = dashes = style_order = None', '', '    # Now extract the data that would be used to draw a single plot', '    variables = p.variables', '    plot_data = p.plot_data', '    plot_semantics = p.semantics', '', '    # Define the common plotting parameters', '    plot_kws = dict(', '        palette=palette, hue_order=hue_order, hue_norm=hue_norm,', '        sizes=sizes, size_order=size_order, size_norm=size_norm,', '        markers=markers, dashes=dashes, style_order=style_order,', '        legend=False,', '    )', '    plot_kws.update(kwargs)', '    if kind == \"scatter\":', '        plot_kws.pop(\"dashes\")', '', '    # Add the grid semantics onto the plotter', '    grid_semantics = \"row\", \"col\"', '    p.semantics = plot_semantics + grid_semantics', '    p.assign_variables(', '        data=data,', '        variables=dict(', '            x=x, y=y,', '            hue=hue, size=size, style=style, units=units,', '            row=row, col=col,', '        ),', '    )', '', '    # Define the named variables for plotting on each facet', '    # Rename the variables with a leading underscore to avoid', '    # collisions with faceting variable names', '    plot_variables = {v: f\"_{v}\" for v in variables}', '    plot_kws.update(plot_variables)', '', '    # Pass the row/col variables to FacetGrid with their original', '    # names so that the axes titles render correctly', '    for var in [\"row\", \"col\"]:', '        # Handle faceting variables that lack name information', '        if var in p.variables and p.variables[var] is None:', '            p.variables[var] = f\"_{var}_\"', '    grid_kws = {v: p.variables.get(v) for v in grid_semantics}', '', '    # Rename the columns of the plot_data structure appropriately', '    new_cols = plot_variables.copy()', '    new_cols.update(grid_kws)', '    full_data = p.plot_data.rename(columns=new_cols)', '', '    # Set up the FacetGrid object', '    facet_kws = {} if facet_kws is None else facet_kws.copy()', '    g = FacetGrid(', '        data=full_data.dropna(axis=1, how=\"all\"),', '        **grid_kws,', '        col_wrap=col_wrap, row_order=row_order, col_order=col_order,', '        height=height, aspect=aspect, dropna=False,', '        **facet_kws', '    )', '', '    # Draw the plot', '    g.map_dataframe(func, **plot_kws)', '', '    # Label the axes, using the original variables', '    g.set(xlabel=variables.get(\"x\"), ylabel=variables.get(\"y\"))', '', '    # Show the legend', '    if legend:', '        # Replace the original plot data so the legend uses', '        # numeric data with the correct type', '        p.plot_data = plot_data', '        p.add_legend_data(g.axes.flat[0])', '        if p.legend_data:', '            g.add_legend(legend_data=p.legend_data,', '                         label_order=p.legend_order,', '                         title=p.legend_title,', '                         adjust_subtitles=True)', '', \"    # Rename the columns of the FacetGrid's `data` attribute\", '    # to match the original column names', '    orig_cols = {', '        f\"_{k}\": f\"_{k}_\" if v is None else v for k, v in variables.items()', '    }', '    grid_data = g.data.rename(columns=orig_cols)', '    if data is not None and (x is not None or y is not None):', '        if not isinstance(data, pd.DataFrame):', '            data = pd.DataFrame(data)', '        g.data = pd.merge(', '            data,', '            grid_data[grid_data.columns.difference(data.columns)],', '            left_index=True,', '            right_index=True,', '        )', '    else:', '        g.data = grid_data', '', '    return g', '', '', 'relplot.__doc__ = \"\"\"\\\\', 'Figure-level interface for drawing relational plots onto a FacetGrid.', '', 'This function provides access to several different axes-level functions', 'that show the relationship between two variables with semantic mappings', 'of subsets. The `kind` parameter selects the underlying axes-level', 'function to use:', '', '- :func:`scatterplot` (with `kind=\"scatter\"`; the default)', '- :func:`lineplot` (with `kind=\"line\"`)', '', 'Extra keyword arguments are passed to the underlying function, so you', 'should refer to the documentation for each to see kind-specific options.', '', '{narrative.main_api}', '', '{narrative.relational_semantic}', '', 'After plotting, the :class:`FacetGrid` with the plot is returned and can', 'be used directly to tweak supporting plot details or add other layers.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', 'hue : vector or key in `data`', '    Grouping variable that will produce elements with different colors.', '    Can be either categorical or numeric, although color mapping will', '    behave differently in latter case.', 'size : vector or key in `data`', '    Grouping variable that will produce elements with different sizes.', '    Can be either categorical or numeric, although size mapping will', '    behave differently in latter case.', 'style : vector or key in `data`', '    Grouping variable that will produce elements with different styles.', '    Can have a numeric dtype but will always be treated as categorical.', '{params.rel.units}', '{params.facets.rowcol}', '{params.facets.col_wrap}', 'row_order, col_order : lists of strings', '    Order to organize the rows and/or columns of the grid in, otherwise the', '    orders are inferred from the data objects.', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', '{params.rel.sizes}', '{params.rel.size_order}', '{params.rel.size_norm}', '{params.rel.style_order}', '{params.rel.dashes}', '{params.rel.markers}', '{params.rel.legend}', 'kind : string', '    Kind of plot to draw, corresponding to a seaborn relational plot.', '    Options are `\"scatter\"` or `\"line\"`.', '{params.facets.height}', '{params.facets.aspect}', 'facet_kws : dict', '    Dictionary of other keyword arguments to pass to :class:`FacetGrid`.', 'kwargs : key, value pairings', '    Other keyword arguments are passed through to the underlying plotting', '    function.', '', 'Returns', '-------', '{returns.facetgrid}', '', 'Examples', '--------', '', '.. include:: ../docstrings/relplot.rst', '', '\"\"\".format(', '    narrative=_relational_narrative,', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')']}, 'cm.py': {'classes': [], 'functions': [], 'text': ['from matplotlib import colors', 'from seaborn._compat import register_colormap', '', '', '_rocket_lut = [', '    [ 0.01060815, 0.01808215, 0.10018654],', '    [ 0.01428972, 0.02048237, 0.10374486],', '    [ 0.01831941, 0.0229766 , 0.10738511],', '    [ 0.02275049, 0.02554464, 0.11108639],', '    [ 0.02759119, 0.02818316, 0.11483751],', '    [ 0.03285175, 0.03088792, 0.11863035],', '    [ 0.03853466, 0.03365771, 0.12245873],', '    [ 0.04447016, 0.03648425, 0.12631831],', '    [ 0.05032105, 0.03936808, 0.13020508],', '    [ 0.05611171, 0.04224835, 0.13411624],', '    [ 0.0618531 , 0.04504866, 0.13804929],', '    [ 0.06755457, 0.04778179, 0.14200206],', '    [ 0.0732236 , 0.05045047, 0.14597263],', '    [ 0.0788708 , 0.05305461, 0.14995981],', '    [ 0.08450105, 0.05559631, 0.15396203],', '    [ 0.09011319, 0.05808059, 0.15797687],', '    [ 0.09572396, 0.06050127, 0.16200507],', '    [ 0.10132312, 0.06286782, 0.16604287],', '    [ 0.10692823, 0.06517224, 0.17009175],', '    [ 0.1125315 , 0.06742194, 0.17414848],', '    [ 0.11813947, 0.06961499, 0.17821272],', '    [ 0.12375803, 0.07174938, 0.18228425],', '    [ 0.12938228, 0.07383015, 0.18636053],', '    [ 0.13501631, 0.07585609, 0.19044109],', '    [ 0.14066867, 0.0778224 , 0.19452676],', '    [ 0.14633406, 0.07973393, 0.1986151 ],', '    [ 0.15201338, 0.08159108, 0.20270523],', '    [ 0.15770877, 0.08339312, 0.20679668],', '    [ 0.16342174, 0.0851396 , 0.21088893],', '    [ 0.16915387, 0.08682996, 0.21498104],', '    [ 0.17489524, 0.08848235, 0.2190294 ],', '    [ 0.18065495, 0.09009031, 0.22303512],', '    [ 0.18643324, 0.09165431, 0.22699705],', '    [ 0.19223028, 0.09317479, 0.23091409],', '    [ 0.19804623, 0.09465217, 0.23478512],', '    [ 0.20388117, 0.09608689, 0.23860907],', '    [ 0.20973515, 0.09747934, 0.24238489],', '    [ 0.21560818, 0.09882993, 0.24611154],', '    [ 0.22150014, 0.10013944, 0.2497868 ],', '    [ 0.22741085, 0.10140876, 0.25340813],', '    [ 0.23334047, 0.10263737, 0.25697736],', '    [ 0.23928891, 0.10382562, 0.2604936 ],', '    [ 0.24525608, 0.10497384, 0.26395596],', '    [ 0.25124182, 0.10608236, 0.26736359],', '    [ 0.25724602, 0.10715148, 0.27071569],', '    [ 0.26326851, 0.1081815 , 0.27401148],', '    [ 0.26930915, 0.1091727 , 0.2772502 ],', '    [ 0.27536766, 0.11012568, 0.28043021],', '    [ 0.28144375, 0.11104133, 0.2835489 ],', '    [ 0.2875374 , 0.11191896, 0.28660853],', '    [ 0.29364846, 0.11275876, 0.2896085 ],', '    [ 0.29977678, 0.11356089, 0.29254823],', '    [ 0.30592213, 0.11432553, 0.29542718],', '    [ 0.31208435, 0.11505284, 0.29824485],', '    [ 0.31826327, 0.1157429 , 0.30100076],', '    [ 0.32445869, 0.11639585, 0.30369448],', '    [ 0.33067031, 0.11701189, 0.30632563],', '    [ 0.33689808, 0.11759095, 0.3088938 ],', '    [ 0.34314168, 0.11813362, 0.31139721],', '    [ 0.34940101, 0.11863987, 0.3138355 ],', '    [ 0.355676  , 0.11910909, 0.31620996],', '    [ 0.36196644, 0.1195413 , 0.31852037],', '    [ 0.36827206, 0.11993653, 0.32076656],', '    [ 0.37459292, 0.12029443, 0.32294825],', '    [ 0.38092887, 0.12061482, 0.32506528],', '    [ 0.38727975, 0.12089756, 0.3271175 ],', '    [ 0.39364518, 0.12114272, 0.32910494],', '    [ 0.40002537, 0.12134964, 0.33102734],', '    [ 0.40642019, 0.12151801, 0.33288464],', '    [ 0.41282936, 0.12164769, 0.33467689],', '    [ 0.41925278, 0.12173833, 0.33640407],', '    [ 0.42569057, 0.12178916, 0.33806605],', '    [ 0.43214263, 0.12179973, 0.33966284],', '    [ 0.43860848, 0.12177004, 0.34119475],', '    [ 0.44508855, 0.12169883, 0.34266151],', '    [ 0.45158266, 0.12158557, 0.34406324],', '    [ 0.45809049, 0.12142996, 0.34540024],', '    [ 0.46461238, 0.12123063, 0.34667231],', '    [ 0.47114798, 0.12098721, 0.34787978],', '    [ 0.47769736, 0.12069864, 0.34902273],', '    [ 0.48426077, 0.12036349, 0.35010104],', '    [ 0.49083761, 0.11998161, 0.35111537],', '    [ 0.49742847, 0.11955087, 0.35206533],', '    [ 0.50403286, 0.11907081, 0.35295152],', '    [ 0.51065109, 0.11853959, 0.35377385],', '    [ 0.51728314, 0.1179558 , 0.35453252],', '    [ 0.52392883, 0.11731817, 0.35522789],', '    [ 0.53058853, 0.11662445, 0.35585982],', '    [ 0.53726173, 0.11587369, 0.35642903],', '    [ 0.54394898, 0.11506307, 0.35693521],', '    [ 0.5506426 , 0.11420757, 0.35737863],', '    [ 0.55734473, 0.11330456, 0.35775059],', '    [ 0.56405586, 0.11235265, 0.35804813],', '    [ 0.57077365, 0.11135597, 0.35827146],', '    [ 0.5774991 , 0.11031233, 0.35841679],', '    [ 0.58422945, 0.10922707, 0.35848469],', '    [ 0.59096382, 0.10810205, 0.35847347],', '    [ 0.59770215, 0.10693774, 0.35838029],', '    [ 0.60444226, 0.10573912, 0.35820487],', '    [ 0.61118304, 0.10450943, 0.35794557],', '    [ 0.61792306, 0.10325288, 0.35760108],', '    [ 0.62466162, 0.10197244, 0.35716891],', '    [ 0.63139686, 0.10067417, 0.35664819],', '    [ 0.63812122, 0.09938212, 0.35603757],', '    [ 0.64483795, 0.0980891 , 0.35533555],', '    [ 0.65154562, 0.09680192, 0.35454107],', '    [ 0.65824241, 0.09552918, 0.3536529 ],', '    [ 0.66492652, 0.09428017, 0.3526697 ],', '    [ 0.67159578, 0.09306598, 0.35159077],', '    [ 0.67824099, 0.09192342, 0.3504148 ],', '    [ 0.684863  , 0.09085633, 0.34914061],', '    [ 0.69146268, 0.0898675 , 0.34776864],', '    [ 0.69803757, 0.08897226, 0.3462986 ],', '    [ 0.70457834, 0.0882129 , 0.34473046],', '    [ 0.71108138, 0.08761223, 0.3430635 ],', '    [ 0.7175507 , 0.08716212, 0.34129974],', '    [ 0.72398193, 0.08688725, 0.33943958],', '    [ 0.73035829, 0.0868623 , 0.33748452],', '    [ 0.73669146, 0.08704683, 0.33543669],', '    [ 0.74297501, 0.08747196, 0.33329799],', '    [ 0.74919318, 0.08820542, 0.33107204],', '    [ 0.75535825, 0.08919792, 0.32876184],', '    [ 0.76145589, 0.09050716, 0.32637117],', '    [ 0.76748424, 0.09213602, 0.32390525],', '    [ 0.77344838, 0.09405684, 0.32136808],', '    [ 0.77932641, 0.09634794, 0.31876642],', '    [ 0.78513609, 0.09892473, 0.31610488],', '    [ 0.79085854, 0.10184672, 0.313391  ],', '    [ 0.7965014 , 0.10506637, 0.31063031],', '    [ 0.80205987, 0.10858333, 0.30783   ],', '    [ 0.80752799, 0.11239964, 0.30499738],', '    [ 0.81291606, 0.11645784, 0.30213802],', '    [ 0.81820481, 0.12080606, 0.29926105],', '    [ 0.82341472, 0.12535343, 0.2963705 ],', '    [ 0.82852822, 0.13014118, 0.29347474],', '    [ 0.83355779, 0.13511035, 0.29057852],', '    [ 0.83850183, 0.14025098, 0.2876878 ],', '    [ 0.84335441, 0.14556683, 0.28480819],', '    [ 0.84813096, 0.15099892, 0.281943  ],', '    [ 0.85281737, 0.15657772, 0.27909826],', '    [ 0.85742602, 0.1622583 , 0.27627462],', '    [ 0.86196552, 0.16801239, 0.27346473],', '    [ 0.86641628, 0.17387796, 0.27070818],', '    [ 0.87079129, 0.17982114, 0.26797378],', '    [ 0.87507281, 0.18587368, 0.26529697],', '    [ 0.87925878, 0.19203259, 0.26268136],', '    [ 0.8833417 , 0.19830556, 0.26014181],', '    [ 0.88731387, 0.20469941, 0.25769539],', '    [ 0.89116859, 0.21121788, 0.2553592 ],', '    [ 0.89490337, 0.21785614, 0.25314362],', '    [ 0.8985026 , 0.22463251, 0.25108745],', '    [ 0.90197527, 0.23152063, 0.24918223],', '    [ 0.90530097, 0.23854541, 0.24748098],', '    [ 0.90848638, 0.24568473, 0.24598324],', '    [ 0.911533  , 0.25292623, 0.24470258],', '    [ 0.9144225 , 0.26028902, 0.24369359],', '    [ 0.91717106, 0.26773821, 0.24294137],', '    [ 0.91978131, 0.27526191, 0.24245973],', '    [ 0.92223947, 0.28287251, 0.24229568],', '    [ 0.92456587, 0.29053388, 0.24242622],', '    [ 0.92676657, 0.29823282, 0.24285536],', '    [ 0.92882964, 0.30598085, 0.24362274],', '    [ 0.93078135, 0.31373977, 0.24468803],', '    [ 0.93262051, 0.3215093 , 0.24606461],', '    [ 0.93435067, 0.32928362, 0.24775328],', '    [ 0.93599076, 0.33703942, 0.24972157],', '    [ 0.93752831, 0.34479177, 0.25199928],', '    [ 0.93899289, 0.35250734, 0.25452808],', '    [ 0.94036561, 0.36020899, 0.25734661],', '    [ 0.94167588, 0.36786594, 0.2603949 ],', '    [ 0.94291042, 0.37549479, 0.26369821],', '    [ 0.94408513, 0.3830811 , 0.26722004],', '    [ 0.94520419, 0.39062329, 0.27094924],', '    [ 0.94625977, 0.39813168, 0.27489742],', '    [ 0.94727016, 0.4055909 , 0.27902322],', '    [ 0.94823505, 0.41300424, 0.28332283],', '    [ 0.94914549, 0.42038251, 0.28780969],', '    [ 0.95001704, 0.42771398, 0.29244728],', '    [ 0.95085121, 0.43500005, 0.29722817],', '    [ 0.95165009, 0.44224144, 0.30214494],', '    [ 0.9524044 , 0.44944853, 0.3072105 ],', '    [ 0.95312556, 0.45661389, 0.31239776],', '    [ 0.95381595, 0.46373781, 0.31769923],', '    [ 0.95447591, 0.47082238, 0.32310953],', '    [ 0.95510255, 0.47787236, 0.32862553],', '    [ 0.95569679, 0.48489115, 0.33421404],', '    [ 0.95626788, 0.49187351, 0.33985601],', '    [ 0.95681685, 0.49882008, 0.34555431],', '    [ 0.9573439 , 0.50573243, 0.35130912],', '    [ 0.95784842, 0.51261283, 0.35711942],', '    [ 0.95833051, 0.51946267, 0.36298589],', '    [ 0.95879054, 0.52628305, 0.36890904],', '    [ 0.95922872, 0.53307513, 0.3748895 ],', '    [ 0.95964538, 0.53983991, 0.38092784],', '    [ 0.96004345, 0.54657593, 0.3870292 ],', '    [ 0.96042097, 0.55328624, 0.39319057],', '    [ 0.96077819, 0.55997184, 0.39941173],', '    [ 0.9611152 , 0.5666337 , 0.40569343],', '    [ 0.96143273, 0.57327231, 0.41203603],', '    [ 0.96173392, 0.57988594, 0.41844491],', '    [ 0.96201757, 0.58647675, 0.42491751],', '    [ 0.96228344, 0.59304598, 0.43145271],', '    [ 0.96253168, 0.5995944 , 0.43805131],', '    [ 0.96276513, 0.60612062, 0.44471698],', '    [ 0.96298491, 0.6126247 , 0.45145074],', '    [ 0.96318967, 0.61910879, 0.45824902],', '    [ 0.96337949, 0.6255736 , 0.46511271],', '    [ 0.96355923, 0.63201624, 0.47204746],', '    [ 0.96372785, 0.63843852, 0.47905028],', '    [ 0.96388426, 0.64484214, 0.4861196 ],', '    [ 0.96403203, 0.65122535, 0.4932578 ],', '    [ 0.96417332, 0.65758729, 0.50046894],', '    [ 0.9643063 , 0.66393045, 0.5077467 ],', '    [ 0.96443322, 0.67025402, 0.51509334],', '    [ 0.96455845, 0.67655564, 0.52251447],', '    [ 0.96467922, 0.68283846, 0.53000231],', '    [ 0.96479861, 0.68910113, 0.53756026],', '    [ 0.96492035, 0.69534192, 0.5451917 ],', '    [ 0.96504223, 0.7015636 , 0.5528892 ],', '    [ 0.96516917, 0.70776351, 0.5606593 ],', '    [ 0.96530224, 0.71394212, 0.56849894],', '    [ 0.96544032, 0.72010124, 0.57640375],', '    [ 0.96559206, 0.72623592, 0.58438387],', '    [ 0.96575293, 0.73235058, 0.59242739],', '    [ 0.96592829, 0.73844258, 0.60053991],', '    [ 0.96612013, 0.74451182, 0.60871954],', '    [ 0.96632832, 0.75055966, 0.61696136],', '    [ 0.96656022, 0.75658231, 0.62527295],', '    [ 0.96681185, 0.76258381, 0.63364277],', '    [ 0.96709183, 0.76855969, 0.64207921],', '    [ 0.96739773, 0.77451297, 0.65057302],', '    [ 0.96773482, 0.78044149, 0.65912731],', '    [ 0.96810471, 0.78634563, 0.66773889],', '    [ 0.96850919, 0.79222565, 0.6764046 ],', '    [ 0.96893132, 0.79809112, 0.68512266],', '    [ 0.96935926, 0.80395415, 0.69383201],', '    [ 0.9698028 , 0.80981139, 0.70252255],', '    [ 0.97025511, 0.81566605, 0.71120296],', '    [ 0.97071849, 0.82151775, 0.71987163],', '    [ 0.97120159, 0.82736371, 0.72851999],', '    [ 0.97169389, 0.83320847, 0.73716071],', '    [ 0.97220061, 0.83905052, 0.74578903],', '    [ 0.97272597, 0.84488881, 0.75440141],', '    [ 0.97327085, 0.85072354, 0.76299805],', '    [ 0.97383206, 0.85655639, 0.77158353],', '    [ 0.97441222, 0.86238689, 0.78015619],', '    [ 0.97501782, 0.86821321, 0.78871034],', '    [ 0.97564391, 0.87403763, 0.79725261],', '    [ 0.97628674, 0.87986189, 0.8057883 ],', '    [ 0.97696114, 0.88568129, 0.81430324],', '    [ 0.97765722, 0.89149971, 0.82280948],', '    [ 0.97837585, 0.89731727, 0.83130786],', '    [ 0.97912374, 0.90313207, 0.83979337],', '    [ 0.979891  , 0.90894778, 0.84827858],', '    [ 0.98067764, 0.91476465, 0.85676611],', '    [ 0.98137749, 0.92061729, 0.86536915]', ']', '', '', '_mako_lut = [', '    [ 0.04503935, 0.01482344, 0.02092227],', '    [ 0.04933018, 0.01709292, 0.02535719],', '    [ 0.05356262, 0.01950702, 0.03018802],', '    [ 0.05774337, 0.02205989, 0.03545515],', '    [ 0.06188095, 0.02474764, 0.04115287],', '    [ 0.06598247, 0.0275665 , 0.04691409],', '    [ 0.07005374, 0.03051278, 0.05264306],', '    [ 0.07409947, 0.03358324, 0.05834631],', '    [ 0.07812339, 0.03677446, 0.06403249],', '    [ 0.08212852, 0.0400833 , 0.06970862],', '    [ 0.08611731, 0.04339148, 0.07538208],', '    [ 0.09009161, 0.04664706, 0.08105568],', '    [ 0.09405308, 0.04985685, 0.08673591],', '    [ 0.09800301, 0.05302279, 0.09242646],', '    [ 0.10194255, 0.05614641, 0.09813162],', '    [ 0.10587261, 0.05922941, 0.103854  ],', '    [ 0.1097942 , 0.06227277, 0.10959847],', '    [ 0.11370826, 0.06527747, 0.11536893],', '    [ 0.11761516, 0.06824548, 0.12116393],', '    [ 0.12151575, 0.07117741, 0.12698763],', '    [ 0.12541095, 0.07407363, 0.1328442 ],', '    [ 0.12930083, 0.07693611, 0.13873064],', '    [ 0.13317849, 0.07976988, 0.14465095],', '    [ 0.13701138, 0.08259683, 0.15060265],', '    [ 0.14079223, 0.08542126, 0.15659379],', '    [ 0.14452486, 0.08824175, 0.16262484],', '    [ 0.14820351, 0.09106304, 0.16869476],', '    [ 0.15183185, 0.09388372, 0.17480366],', '    [ 0.15540398, 0.09670855, 0.18094993],', '    [ 0.15892417, 0.09953561, 0.18713384],', '    [ 0.16238588, 0.10236998, 0.19335329],', '    [ 0.16579435, 0.10520905, 0.19960847],', '    [ 0.16914226, 0.10805832, 0.20589698],', '    [ 0.17243586, 0.11091443, 0.21221911],', '    [ 0.17566717, 0.11378321, 0.21857219],', '    [ 0.17884322, 0.11666074, 0.2249565 ],', '    [ 0.18195582, 0.11955283, 0.23136943],', '    [ 0.18501213, 0.12245547, 0.23781116],', '    [ 0.18800459, 0.12537395, 0.24427914],', '    [ 0.19093944, 0.1283047 , 0.25077369],', '    [ 0.19381092, 0.13125179, 0.25729255],', '    [ 0.19662307, 0.13421303, 0.26383543],', '    [ 0.19937337, 0.13719028, 0.27040111],', '    [ 0.20206187, 0.14018372, 0.27698891],', '    [ 0.20469116, 0.14319196, 0.28359861],', '    [ 0.20725547, 0.14621882, 0.29022775],', '    [ 0.20976258, 0.14925954, 0.29687795],', '    [ 0.21220409, 0.15231929, 0.30354703],', '    [ 0.21458611, 0.15539445, 0.31023563],', '    [ 0.21690827, 0.15848519, 0.31694355],', '    [ 0.21916481, 0.16159489, 0.32366939],', '    [ 0.2213631 , 0.16471913, 0.33041431],', '    [ 0.22349947, 0.1678599 , 0.33717781],', '    [ 0.2255714 , 0.1710185 , 0.34395925],', '    [ 0.22758415, 0.17419169, 0.35075983],', '    [ 0.22953569, 0.17738041, 0.35757941],', '    [ 0.23142077, 0.18058733, 0.3644173 ],', '    [ 0.2332454 , 0.18380872, 0.37127514],', '    [ 0.2350092 , 0.18704459, 0.3781528 ],', '    [ 0.23670785, 0.190297  , 0.38504973],', '    [ 0.23834119, 0.19356547, 0.39196711],', '    [ 0.23991189, 0.19684817, 0.39890581],', '    [ 0.24141903, 0.20014508, 0.4058667 ],', '    [ 0.24286214, 0.20345642, 0.4128484 ],', '    [ 0.24423453, 0.20678459, 0.41985299],', '    [ 0.24554109, 0.21012669, 0.42688124],', '    [ 0.2467815 , 0.21348266, 0.43393244],', '    [ 0.24795393, 0.21685249, 0.4410088 ],', '    [ 0.24905614, 0.22023618, 0.448113  ],', '    [ 0.25007383, 0.22365053, 0.45519562],', '    [ 0.25098926, 0.22710664, 0.46223892],', '    [ 0.25179696, 0.23060342, 0.46925447],', '    [ 0.25249346, 0.23414353, 0.47623196],', '    [ 0.25307401, 0.23772973, 0.48316271],', '    [ 0.25353152, 0.24136961, 0.49001976],', '    [ 0.25386167, 0.24506548, 0.49679407],', '    [ 0.25406082, 0.2488164 , 0.50348932],', '    [ 0.25412435, 0.25262843, 0.51007843],', '    [ 0.25404842, 0.25650743, 0.51653282],', '    [ 0.25383134, 0.26044852, 0.52286845],', '    [ 0.2534705 , 0.26446165, 0.52903422],', '    [ 0.25296722, 0.2685428 , 0.53503572],', '    [ 0.2523226 , 0.27269346, 0.54085315],', '    [ 0.25153974, 0.27691629, 0.54645752],', '    [ 0.25062402, 0.28120467, 0.55185939],', '    [ 0.24958205, 0.28556371, 0.55701246],', '    [ 0.24842386, 0.28998148, 0.56194601],', '    [ 0.24715928, 0.29446327, 0.56660884],', '    [ 0.24580099, 0.29899398, 0.57104399],', '    [ 0.24436202, 0.30357852, 0.57519929],', '    [ 0.24285591, 0.30819938, 0.57913247],', '    [ 0.24129828, 0.31286235, 0.58278615],', '    [ 0.23970131, 0.3175495 , 0.5862272 ],', '    [ 0.23807973, 0.32226344, 0.58941872],', '    [ 0.23644557, 0.32699241, 0.59240198],', '    [ 0.2348113 , 0.33173196, 0.59518282],', '    [ 0.23318874, 0.33648036, 0.59775543],', '    [ 0.2315855 , 0.34122763, 0.60016456],', '    [ 0.23001121, 0.34597357, 0.60240251],', '    [ 0.2284748 , 0.35071512, 0.6044784 ],', '    [ 0.22698081, 0.35544612, 0.60642528],', '    [ 0.22553305, 0.36016515, 0.60825252],', '    [ 0.22413977, 0.36487341, 0.60994938],', '    [ 0.22280246, 0.36956728, 0.61154118],', '    [ 0.22152555, 0.37424409, 0.61304472],', '    [ 0.22030752, 0.37890437, 0.61446646],', '    [ 0.2191538 , 0.38354668, 0.61581561],', '    [ 0.21806257, 0.38817169, 0.61709794],', '    [ 0.21703799, 0.39277882, 0.61831922],', '    [ 0.21607792, 0.39736958, 0.61948028],', '    [ 0.21518463, 0.40194196, 0.62059763],', '    [ 0.21435467, 0.40649717, 0.62167507],', '    [ 0.21358663, 0.41103579, 0.62271724],', '    [ 0.21288172, 0.41555771, 0.62373011],', '    [ 0.21223835, 0.42006355, 0.62471794],', '    [ 0.21165312, 0.42455441, 0.62568371],', '    [ 0.21112526, 0.42903064, 0.6266318 ],', '    [ 0.21065161, 0.43349321, 0.62756504],', '    [ 0.21023306, 0.43794288, 0.62848279],', '    [ 0.20985996, 0.44238227, 0.62938329],', '    [ 0.20951045, 0.44680966, 0.63030696],', '    [ 0.20916709, 0.45122981, 0.63124483],', '    [ 0.20882976, 0.45564335, 0.63219599],', '    [ 0.20849798, 0.46005094, 0.63315928],', '    [ 0.20817199, 0.46445309, 0.63413391],', '    [ 0.20785149, 0.46885041, 0.63511876],', '    [ 0.20753716, 0.47324327, 0.63611321],', '    [ 0.20722876, 0.47763224, 0.63711608],', '    [ 0.20692679, 0.48201774, 0.63812656],', '    [ 0.20663156, 0.48640018, 0.63914367],', '    [ 0.20634336, 0.49078002, 0.64016638],', '    [ 0.20606303, 0.49515755, 0.6411939 ],', '    [ 0.20578999, 0.49953341, 0.64222457],', '    [ 0.20552612, 0.50390766, 0.64325811],', '    [ 0.20527189, 0.50828072, 0.64429331],', '    [ 0.20502868, 0.51265277, 0.64532947],', '    [ 0.20479718, 0.51702417, 0.64636539],', '    [ 0.20457804, 0.52139527, 0.64739979],', '    [ 0.20437304, 0.52576622, 0.64843198],', '    [ 0.20418396, 0.53013715, 0.64946117],', '    [ 0.20401238, 0.53450825, 0.65048638],', '    [ 0.20385896, 0.53887991, 0.65150606],', '    [ 0.20372653, 0.54325208, 0.65251978],', '    [ 0.20361709, 0.5476249 , 0.6535266 ],', '    [ 0.20353258, 0.55199854, 0.65452542],', '    [ 0.20347472, 0.55637318, 0.655515  ],', '    [ 0.20344718, 0.56074869, 0.65649508],', '    [ 0.20345161, 0.56512531, 0.65746419],', '    [ 0.20349089, 0.56950304, 0.65842151],', '    [ 0.20356842, 0.57388184, 0.65936642],', '    [ 0.20368663, 0.57826181, 0.66029768],', '    [ 0.20384884, 0.58264293, 0.6612145 ],', '    [ 0.20405904, 0.58702506, 0.66211645],', '    [ 0.20431921, 0.59140842, 0.66300179],', '    [ 0.20463464, 0.59579264, 0.66387079],', '    [ 0.20500731, 0.60017798, 0.66472159],', '    [ 0.20544449, 0.60456387, 0.66555409],', '    [ 0.20596097, 0.60894927, 0.66636568],', '    [ 0.20654832, 0.61333521, 0.66715744],', '    [ 0.20721003, 0.61772167, 0.66792838],', '    [ 0.20795035, 0.62210845, 0.66867802],', '    [ 0.20877302, 0.62649546, 0.66940555],', '    [ 0.20968223, 0.63088252, 0.6701105 ],', '    [ 0.21068163, 0.63526951, 0.67079211],', '    [ 0.21177544, 0.63965621, 0.67145005],', '    [ 0.21298582, 0.64404072, 0.67208182],', '    [ 0.21430361, 0.64842404, 0.67268861],', '    [ 0.21572716, 0.65280655, 0.67326978],', '    [ 0.21726052, 0.65718791, 0.6738255 ],', '    [ 0.21890636, 0.66156803, 0.67435491],', '    [ 0.220668  , 0.66594665, 0.67485792],', '    [ 0.22255447, 0.67032297, 0.67533374],', '    [ 0.22458372, 0.67469531, 0.67578061],', '    [ 0.22673713, 0.67906542, 0.67620044],', '    [ 0.22901625, 0.6834332 , 0.67659251],', '    [ 0.23142316, 0.68779836, 0.67695703],', '    [ 0.23395924, 0.69216072, 0.67729378],', '    [ 0.23663857, 0.69651881, 0.67760151],', '    [ 0.23946645, 0.70087194, 0.67788018],', '    [ 0.24242624, 0.70522162, 0.67813088],', '    [ 0.24549008, 0.70957083, 0.67835215],', '    [ 0.24863372, 0.71392166, 0.67854868],', '    [ 0.25187832, 0.71827158, 0.67872193],', '    [ 0.25524083, 0.72261873, 0.67887024],', '    [ 0.25870947, 0.72696469, 0.67898912],', '    [ 0.26229238, 0.73130855, 0.67907645],', '    [ 0.26604085, 0.73564353, 0.67914062],', '    [ 0.26993099, 0.73997282, 0.67917264],', '    [ 0.27397488, 0.74429484, 0.67917096],', '    [ 0.27822463, 0.74860229, 0.67914468],', '    [ 0.28264201, 0.75290034, 0.67907959],', '    [ 0.2873016 , 0.75717817, 0.67899164],', '    [ 0.29215894, 0.76144162, 0.67886578],', '    [ 0.29729823, 0.76567816, 0.67871894],', '    [ 0.30268199, 0.76989232, 0.67853896],', '    [ 0.30835665, 0.77407636, 0.67833512],', '    [ 0.31435139, 0.77822478, 0.67811118],', '    [ 0.3206671 , 0.78233575, 0.67786729],', '    [ 0.32733158, 0.78640315, 0.67761027],', '    [ 0.33437168, 0.79042043, 0.67734882],', '    [ 0.34182112, 0.79437948, 0.67709394],', '    [ 0.34968889, 0.79827511, 0.67685638],', '    [ 0.35799244, 0.80210037, 0.67664969],', '    [ 0.36675371, 0.80584651, 0.67649539],', '    [ 0.3759816 , 0.80950627, 0.67641393],', '    [ 0.38566792, 0.81307432, 0.67642947],', '    [ 0.39579804, 0.81654592, 0.67656899],', '    [ 0.40634556, 0.81991799, 0.67686215],', '    [ 0.41730243, 0.82318339, 0.67735255],', '    [ 0.4285828 , 0.82635051, 0.6780564 ],', '    [ 0.44012728, 0.82942353, 0.67900049],', '    [ 0.45189421, 0.83240398, 0.68021733],', '    [ 0.46378379, 0.83530763, 0.6817062 ],', '    [ 0.47573199, 0.83814472, 0.68347352],', '    [ 0.48769865, 0.84092197, 0.68552698],', '    [ 0.49962354, 0.84365379, 0.68783929],', '    [ 0.5114027 , 0.8463718 , 0.69029789],', '    [ 0.52301693, 0.84908401, 0.69288545],', '    [ 0.53447549, 0.85179048, 0.69561066],', '    [ 0.54578602, 0.8544913 , 0.69848331],', '    [ 0.55695565, 0.85718723, 0.70150427],', '    [ 0.56798832, 0.85987893, 0.70468261],', '    [ 0.57888639, 0.86256715, 0.70802931],', '    [ 0.5896541 , 0.8652532 , 0.71154204],', '    [ 0.60028928, 0.86793835, 0.71523675],', '    [ 0.61079441, 0.87062438, 0.71910895],', '    [ 0.62116633, 0.87331311, 0.72317003],', '    [ 0.63140509, 0.87600675, 0.72741689],', '    [ 0.64150735, 0.87870746, 0.73185717],', '    [ 0.65147219, 0.8814179 , 0.73648495],', '    [ 0.66129632, 0.8841403 , 0.74130658],', '    [ 0.67097934, 0.88687758, 0.74631123],', '    [ 0.68051833, 0.88963189, 0.75150483],', '    [ 0.68991419, 0.89240612, 0.75687187],', '    [ 0.69916533, 0.89520211, 0.76241714],', '    [ 0.70827373, 0.89802257, 0.76812286],', '    [ 0.71723995, 0.90086891, 0.77399039],', '    [ 0.72606665, 0.90374337, 0.7800041 ],', '    [ 0.73475675, 0.90664718, 0.78615802],', '    [ 0.74331358, 0.90958151, 0.79244474],', '    [ 0.75174143, 0.91254787, 0.79884925],', '    [ 0.76004473, 0.91554656, 0.80536823],', '    [ 0.76827704, 0.91856549, 0.81196513],', '    [ 0.77647029, 0.921603  , 0.81855729],', '    [ 0.78462009, 0.92466151, 0.82514119],', '    [ 0.79273542, 0.92773848, 0.83172131],', '    [ 0.8008109 , 0.93083672, 0.83829355],', '    [ 0.80885107, 0.93395528, 0.84485982],', '    [ 0.81685878, 0.9370938 , 0.85142101],', '    [ 0.82483206, 0.94025378, 0.8579751 ],', '    [ 0.83277661, 0.94343371, 0.86452477],', '    [ 0.84069127, 0.94663473, 0.87106853],', '    [ 0.84857662, 0.9498573 , 0.8776059 ],', '    [ 0.8564431 , 0.95309792, 0.88414253],', '    [ 0.86429066, 0.95635719, 0.89067759],', '    [ 0.87218969, 0.95960708, 0.89725384]', ']', '', '', '_vlag_lut = [', '    [ 0.13850039, 0.41331206, 0.74052025],', '    [ 0.15077609, 0.41762684, 0.73970427],', '    [ 0.16235219, 0.4219191 , 0.7389667 ],', '    [ 0.1733322 , 0.42619024, 0.73832537],', '    [ 0.18382538, 0.43044226, 0.73776764],', '    [ 0.19394034, 0.4346772 , 0.73725867],', '    [ 0.20367115, 0.43889576, 0.73685314],', '    [ 0.21313625, 0.44310003, 0.73648045],', '    [ 0.22231173, 0.44729079, 0.73619681],', '    [ 0.23125148, 0.45146945, 0.73597803],', '    [ 0.23998101, 0.45563715, 0.7358223 ],', '    [ 0.24853358, 0.45979489, 0.73571524],', '    [ 0.25691416, 0.4639437 , 0.73566943],', '    [ 0.26513894, 0.46808455, 0.73568319],', '    [ 0.27322194, 0.47221835, 0.73575497],', '    [ 0.28117543, 0.47634598, 0.73588332],', '    [ 0.28901021, 0.48046826, 0.73606686],', '    [ 0.2967358 , 0.48458597, 0.73630433],', '    [ 0.30436071, 0.48869986, 0.73659451],', '    [ 0.3118955 , 0.49281055, 0.73693255],', '    [ 0.31935389, 0.49691847, 0.73730851],', '    [ 0.32672701, 0.5010247 , 0.73774013],', '    [ 0.33402607, 0.50512971, 0.73821941],', '    [ 0.34125337, 0.50923419, 0.73874905],', '    [ 0.34840921, 0.51333892, 0.73933402],', '    [ 0.35551826, 0.51744353, 0.73994642],', '    [ 0.3625676 , 0.52154929, 0.74060763],', '    [ 0.36956356, 0.52565656, 0.74131327],', '    [ 0.37649902, 0.52976642, 0.74207698],', '    [ 0.38340273, 0.53387791, 0.74286286],', '    [ 0.39025859, 0.53799253, 0.7436962 ],', '    [ 0.39706821, 0.54211081, 0.744578  ],', '    [ 0.40384046, 0.54623277, 0.74549872],', '    [ 0.41058241, 0.55035849, 0.74645094],', '    [ 0.41728385, 0.55448919, 0.74745174],', '    [ 0.42395178, 0.55862494, 0.74849357],', '    [ 0.4305964 , 0.56276546, 0.74956387],', '    [ 0.4372044 , 0.56691228, 0.75068412],', '    [ 0.4437909 , 0.57106468, 0.75183427],', '    [ 0.45035117, 0.5752235 , 0.75302312],', '    [ 0.45687824, 0.57938983, 0.75426297],', '    [ 0.46339713, 0.58356191, 0.75551816],', '    [ 0.46988778, 0.58774195, 0.75682037],', '    [ 0.47635605, 0.59192986, 0.75816245],', '    [ 0.48281101, 0.5961252 , 0.75953212],', '    [ 0.4892374 , 0.60032986, 0.76095418],', '    [ 0.49566225, 0.60454154, 0.76238852],', '    [ 0.50206137, 0.60876307, 0.76387371],', '    [ 0.50845128, 0.61299312, 0.76538551],', '    [ 0.5148258 , 0.61723272, 0.76693475],', '    [ 0.52118385, 0.62148236, 0.76852436],', '    [ 0.52753571, 0.62574126, 0.77013939],', '    [ 0.53386831, 0.63001125, 0.77180152],', '    [ 0.54020159, 0.63429038, 0.7734803 ],', '    [ 0.54651272, 0.63858165, 0.77521306],', '    [ 0.55282975, 0.64288207, 0.77695608],', '    [ 0.55912585, 0.64719519, 0.77875327],', '    [ 0.56542599, 0.65151828, 0.78056551],', '    [ 0.57170924, 0.65585426, 0.78242747],', '    [ 0.57799572, 0.6602009 , 0.78430751],', '    [ 0.58426817, 0.66456073, 0.78623458],', '    [ 0.590544  , 0.66893178, 0.78818117],', '    [ 0.59680758, 0.67331643, 0.79017369],', '    [ 0.60307553, 0.67771273, 0.79218572],', '    [ 0.60934065, 0.68212194, 0.79422987],', '    [ 0.61559495, 0.68654548, 0.7963202 ],', '    [ 0.62185554, 0.69098125, 0.79842918],', '    [ 0.62810662, 0.69543176, 0.80058381],', '    [ 0.63436425, 0.69989499, 0.80275812],', '    [ 0.64061445, 0.70437326, 0.80497621],', '    [ 0.6468706 , 0.70886488, 0.80721641],', '    [ 0.65312213, 0.7133717 , 0.80949719],', '    [ 0.65937818, 0.71789261, 0.81180392],', '    [ 0.66563334, 0.72242871, 0.81414642],', '    [ 0.67189155, 0.72697967, 0.81651872],', '    [ 0.67815314, 0.73154569, 0.81892097],', '    [ 0.68441395, 0.73612771, 0.82136094],', '    [ 0.69068321, 0.74072452, 0.82382353],', '    [ 0.69694776, 0.7453385 , 0.82633199],', '    [ 0.70322431, 0.74996721, 0.8288583 ],', '    [ 0.70949595, 0.75461368, 0.83143221],', '    [ 0.7157774 , 0.75927574, 0.83402904],', '    [ 0.72206299, 0.76395461, 0.83665922],', '    [ 0.72835227, 0.76865061, 0.8393242 ],', '    [ 0.73465238, 0.7733628 , 0.84201224],', '    [ 0.74094862, 0.77809393, 0.84474951],', '    [ 0.74725683, 0.78284158, 0.84750915],', '    [ 0.75357103, 0.78760701, 0.85030217],', '    [ 0.75988961, 0.79239077, 0.85313207],', '    [ 0.76621987, 0.79719185, 0.85598668],', '    [ 0.77255045, 0.8020125 , 0.85888658],', '    [ 0.77889241, 0.80685102, 0.86181298],', '    [ 0.78524572, 0.81170768, 0.86476656],', '    [ 0.79159841, 0.81658489, 0.86776906],', '    [ 0.79796459, 0.82148036, 0.8707962 ],', '    [ 0.80434168, 0.82639479, 0.87385315],', '    [ 0.8107221 , 0.83132983, 0.87695392],', '    [ 0.81711301, 0.8362844 , 0.88008641],', '    [ 0.82351479, 0.84125863, 0.88325045],', '    [ 0.82992772, 0.84625263, 0.88644594],', '    [ 0.83634359, 0.85126806, 0.8896878 ],', '    [ 0.84277295, 0.85630293, 0.89295721],', '    [ 0.84921192, 0.86135782, 0.89626076],', '    [ 0.85566206, 0.866432  , 0.89959467],', '    [ 0.86211514, 0.87152627, 0.90297183],', '    [ 0.86857483, 0.87663856, 0.90638248],', '    [ 0.87504231, 0.88176648, 0.90981938],', '    [ 0.88151194, 0.88690782, 0.91328493],', '    [ 0.88797938, 0.89205857, 0.91677544],', '    [ 0.89443865, 0.89721298, 0.9202854 ],', '    [ 0.90088204, 0.90236294, 0.92380601],', '    [ 0.90729768, 0.90749778, 0.92732797],', '    [ 0.91367037, 0.91260329, 0.93083814],', '    [ 0.91998105, 0.91766106, 0.93431861],', '    [ 0.92620596, 0.92264789, 0.93774647],', '    [ 0.93231683, 0.9275351 , 0.94109192],', '    [ 0.93827772, 0.9322888 , 0.94432312],', '    [ 0.94404755, 0.93686925, 0.94740137],', '    [ 0.94958284, 0.94123072, 0.95027696],', '    [ 0.95482682, 0.9453245 , 0.95291103],', '    [ 0.9597248 , 0.94909728, 0.95525103],', '    [ 0.96422552, 0.95249273, 0.95723271],', '    [ 0.96826161, 0.95545812, 0.95882188],', '    [ 0.97178458, 0.95793984, 0.95995705],', '    [ 0.97474105, 0.95989142, 0.96059997],', '    [ 0.97708604, 0.96127366, 0.96071853],', '    [ 0.97877855, 0.96205832, 0.96030095],', '    [ 0.97978484, 0.96222949, 0.95935496],', '    [ 0.9805997 , 0.96155216, 0.95813083],', '    [ 0.98152619, 0.95993719, 0.95639322],', '    [ 0.9819726 , 0.95766608, 0.95399269],', '    [ 0.98191855, 0.9547873 , 0.95098107],', '    [ 0.98138514, 0.95134771, 0.94740644],', '    [ 0.98040845, 0.94739906, 0.94332125],', '    [ 0.97902107, 0.94300131, 0.93878672],', '    [ 0.97729348, 0.93820409, 0.93385135],', '    [ 0.9752533 , 0.933073  , 0.92858252],', '    [ 0.97297834, 0.92765261, 0.92302309],', '    [ 0.97049104, 0.92200317, 0.91723505],', '    [ 0.96784372, 0.91616744, 0.91126063],', '    [ 0.96507281, 0.91018664, 0.90514124],', '    [ 0.96222034, 0.90409203, 0.89890756],', '    [ 0.9593079 , 0.89791478, 0.89259122],', '    [ 0.95635626, 0.89167908, 0.88621654],', '    [ 0.95338303, 0.88540373, 0.87980238],', '    [ 0.95040174, 0.87910333, 0.87336339],', '    [ 0.94742246, 0.87278899, 0.86691076],', '    [ 0.94445249, 0.86646893, 0.86045277],', '    [ 0.94150476, 0.86014606, 0.85399191],', '    [ 0.93857394, 0.85382798, 0.84753642],', '    [ 0.93566206, 0.84751766, 0.84108935],', '    [ 0.93277194, 0.8412164 , 0.83465197],', '    [ 0.92990106, 0.83492672, 0.82822708],', '    [ 0.92704736, 0.82865028, 0.82181656],', '    [ 0.92422703, 0.82238092, 0.81541333],', '    [ 0.92142581, 0.81612448, 0.80902415],', '    [ 0.91864501, 0.80988032, 0.80264838],', '    [ 0.91587578, 0.80365187, 0.79629001],', '    [ 0.9131367 , 0.79743115, 0.78994   ],', '    [ 0.91041602, 0.79122265, 0.78360361],', '    [ 0.90771071, 0.78502727, 0.77728196],', '    [ 0.90501581, 0.77884674, 0.7709771 ],', '    [ 0.90235365, 0.77267117, 0.76467793],', '    [ 0.8997019 , 0.76650962, 0.75839484],', '    [ 0.89705346, 0.76036481, 0.752131  ],', '    [ 0.89444021, 0.75422253, 0.74587047],', '    [ 0.89183355, 0.74809474, 0.73962689],', '    [ 0.88923216, 0.74198168, 0.73340061],', '    [ 0.88665892, 0.73587283, 0.72717995],', '    [ 0.88408839, 0.72977904, 0.72097718],', '    [ 0.88153537, 0.72369332, 0.71478461],', '    [ 0.87899389, 0.7176179 , 0.70860487],', '    [ 0.87645157, 0.71155805, 0.7024439 ],', '    [ 0.8739399 , 0.70549893, 0.6962854 ],', '    [ 0.87142626, 0.6994551 , 0.69014561],', '    [ 0.8689268 , 0.69341868, 0.68401597],', '    [ 0.86643562, 0.687392  , 0.67789917],', '    [ 0.86394434, 0.68137863, 0.67179927],', '    [ 0.86147586, 0.67536728, 0.665704  ],', '    [ 0.85899928, 0.66937226, 0.6596292 ],', '    [ 0.85654668, 0.66337773, 0.6535577 ],', '    [ 0.85408818, 0.65739772, 0.64750494],', '    [ 0.85164413, 0.65142189, 0.64145983],', '    [ 0.84920091, 0.6454565 , 0.63542932],', '    [ 0.84676427, 0.63949827, 0.62941   ],', '    [ 0.84433231, 0.63354773, 0.62340261],', '    [ 0.84190106, 0.62760645, 0.61740899],', '    [ 0.83947935, 0.62166951, 0.61142404],', '    [ 0.8370538 , 0.61574332, 0.60545478],', '    [ 0.83463975, 0.60981951, 0.59949247],', '    [ 0.83221877, 0.60390724, 0.593547  ],', '    [ 0.82980985, 0.59799607, 0.58760751],', '    [ 0.82740268, 0.59209095, 0.58167944],', '    [ 0.82498638, 0.5861973 , 0.57576866],', '    [ 0.82258181, 0.5803034 , 0.56986307],', '    [ 0.82016611, 0.57442123, 0.56397539],', '    [ 0.81776305, 0.56853725, 0.55809173],', '    [ 0.81534551, 0.56266602, 0.55222741],', '    [ 0.81294293, 0.55679056, 0.5463651 ],', '    [ 0.81052113, 0.55092973, 0.54052443],', '    [ 0.80811509, 0.54506305, 0.53468464],', '    [ 0.80568952, 0.53921036, 0.52886622],', '    [ 0.80327506, 0.53335335, 0.52305077],', '    [ 0.80084727, 0.52750583, 0.51725256],', '    [ 0.79842217, 0.5216578 , 0.51146173],', '    [ 0.79599382, 0.51581223, 0.50568155],', '    [ 0.79355781, 0.50997127, 0.49991444],', '    [ 0.79112596, 0.50412707, 0.49415289],', '    [ 0.78867442, 0.49829386, 0.48841129],', '    [ 0.7862306 , 0.49245398, 0.48267247],', '    [ 0.7837687 , 0.48662309, 0.47695216],', '    [ 0.78130809, 0.4807883 , 0.47123805],', '    [ 0.77884467, 0.47495151, 0.46553236],', '    [ 0.77636283, 0.46912235, 0.45984473],', '    [ 0.77388383, 0.46328617, 0.45416141],', '    [ 0.77138912, 0.45745466, 0.44849398],', '    [ 0.76888874, 0.45162042, 0.44283573],', '    [ 0.76638802, 0.44577901, 0.43718292],', '    [ 0.76386116, 0.43994762, 0.43155211],', '    [ 0.76133542, 0.43410655, 0.42592523],', '    [ 0.75880631, 0.42825801, 0.42030488],', '    [ 0.75624913, 0.42241905, 0.41470727],', '    [ 0.7536919 , 0.41656866, 0.40911347],', '    [ 0.75112748, 0.41071104, 0.40352792],', '    [ 0.74854331, 0.40485474, 0.3979589 ],', '    [ 0.74594723, 0.39899309, 0.39240088],', '    [ 0.74334332, 0.39312199, 0.38685075],', '    [ 0.74073277, 0.38723941, 0.3813074 ],', '    [ 0.73809409, 0.38136133, 0.37578553],', '    [ 0.73544692, 0.37547129, 0.37027123],', '    [ 0.73278943, 0.36956954, 0.36476549],', '    [ 0.73011829, 0.36365761, 0.35927038],', '    [ 0.72743485, 0.35773314, 0.35378465],', '    [ 0.72472722, 0.35180504, 0.34831662],', '    [ 0.72200473, 0.34586421, 0.34285937],', '    [ 0.71927052, 0.33990649, 0.33741033],', '    [ 0.71652049, 0.33393396, 0.33197219],', '    [ 0.71375362, 0.32794602, 0.32654545],', '    [ 0.71096951, 0.32194148, 0.32113016],', '    [ 0.70816772, 0.31591904, 0.31572637],', '    [ 0.70534784, 0.30987734, 0.31033414],', '    [ 0.70250944, 0.30381489, 0.30495353],', '    [ 0.69965211, 0.2977301 , 0.2995846 ],', '    [ 0.6967754 , 0.29162126, 0.29422741],', '    [ 0.69388446, 0.28548074, 0.28887769],', '    [ 0.69097561, 0.2793096 , 0.28353795],', '    [ 0.68803513, 0.27311993, 0.27821876],', '    [ 0.6850794 , 0.26689144, 0.27290694],', '    [ 0.682108  , 0.26062114, 0.26760246],', '    [ 0.67911013, 0.2543177 , 0.26231367],', '    [ 0.67609393, 0.24796818, 0.25703372],', '    [ 0.67305921, 0.24156846, 0.25176238],', '    [ 0.67000176, 0.23511902, 0.24650278],', '    [ 0.66693423, 0.22859879, 0.24124404],', '    [ 0.6638441 , 0.22201742, 0.2359961 ],', '    [ 0.66080672, 0.21526712, 0.23069468]', ']', '', '', '_icefire_lut = [', '    [ 0.73936227, 0.90443867, 0.85757238],', '    [ 0.72888063, 0.89639109, 0.85488394],', '    [ 0.71834255, 0.88842162, 0.8521605 ],', '    [ 0.70773866, 0.88052939, 0.849422  ],', '    [ 0.69706215, 0.87271313, 0.84668315],', '    [ 0.68629021, 0.86497329, 0.84398721],', '    [ 0.67543654, 0.85730617, 0.84130969],', '    [ 0.66448539, 0.84971123, 0.83868005],', '    [ 0.65342679, 0.84218728, 0.83611512],', '    [ 0.64231804, 0.83471867, 0.83358584],', '    [ 0.63117745, 0.827294  , 0.83113431],', '    [ 0.62000484, 0.81991069, 0.82876741],', '    [ 0.60879435, 0.81256797, 0.82648905],', '    [ 0.59754118, 0.80526458, 0.82430414],', '    [ 0.58624247, 0.79799884, 0.82221573],', '    [ 0.57489525, 0.7907688 , 0.82022901],', '    [ 0.56349779, 0.78357215, 0.81834861],', '    [ 0.55204294, 0.77640827, 0.81657563],', '    [ 0.54052516, 0.76927562, 0.81491462],', '    [ 0.52894085, 0.76217215, 0.81336913],', '    [ 0.51728854, 0.75509528, 0.81194156],', '    [ 0.50555676, 0.74804469, 0.81063503],', '    [ 0.49373871, 0.7410187 , 0.80945242],', '    [ 0.48183174, 0.73401449, 0.80839675],', '    [ 0.46982587, 0.72703075, 0.80747097],', '    [ 0.45770893, 0.72006648, 0.80667756],', '    [ 0.44547249, 0.71311941, 0.80601991],', '    [ 0.43318643, 0.70617126, 0.80549278],', '    [ 0.42110294, 0.69916972, 0.80506683],', '    [ 0.40925101, 0.69211059, 0.80473246],', '    [ 0.3976693 , 0.68498786, 0.80448272],', '    [ 0.38632002, 0.67781125, 0.80431024],', '    [ 0.37523981, 0.67057537, 0.80420832],', '    [ 0.36442578, 0.66328229, 0.80417474],', '    [ 0.35385939, 0.65593699, 0.80420591],', '    [ 0.34358916, 0.64853177, 0.8043    ],', '    [ 0.33355526, 0.64107876, 0.80445484],', '    [ 0.32383062, 0.63356578, 0.80467091],', '    [ 0.31434372, 0.62600624, 0.8049475 ],', '    [ 0.30516161, 0.618389  , 0.80528692],', '    [ 0.29623491, 0.61072284, 0.80569021],', '    [ 0.28759072, 0.60300319, 0.80616055],', '    [ 0.27923924, 0.59522877, 0.80669803],', '    [ 0.27114651, 0.5874047 , 0.80730545],', '    [ 0.26337153, 0.57952055, 0.80799113],', '    [ 0.25588696, 0.57157984, 0.80875922],', '    [ 0.248686  , 0.56358255, 0.80961366],', '    [ 0.24180668, 0.55552289, 0.81055123],', '    [ 0.23526251, 0.54739477, 0.8115939 ],', '    [ 0.22921445, 0.53918506, 0.81267292],', '    [ 0.22397687, 0.53086094, 0.8137141 ],', '    [ 0.21977058, 0.52241482, 0.81457651],', '    [ 0.21658989, 0.51384321, 0.81528511],', '    [ 0.21452772, 0.50514155, 0.81577278],', '    [ 0.21372783, 0.49630865, 0.81589566],', '    [ 0.21409503, 0.48734861, 0.81566163],', '    [ 0.2157176 , 0.47827123, 0.81487615],', '    [ 0.21842857, 0.46909168, 0.81351614],', '    [ 0.22211705, 0.45983212, 0.81146983],', '    [ 0.22665681, 0.45052233, 0.80860217],', '    [ 0.23176013, 0.44119137, 0.80494325],', '    [ 0.23727775, 0.43187704, 0.80038017],', '    [ 0.24298285, 0.42261123, 0.79493267],', '    [ 0.24865068, 0.41341842, 0.78869164],', '    [ 0.25423116, 0.40433127, 0.78155831],', '    [ 0.25950239, 0.39535521, 0.77376848],', '    [ 0.2644736 , 0.38651212, 0.76524809],', '    [ 0.26901584, 0.37779582, 0.75621942],', '    [ 0.27318141, 0.36922056, 0.746605  ],', '    [ 0.27690355, 0.3607736 , 0.73659374],', '    [ 0.28023585, 0.35244234, 0.72622103],', '    [ 0.28306009, 0.34438449, 0.71500731],', '    [ 0.28535896, 0.33660243, 0.70303975],', '    [ 0.28708711, 0.32912157, 0.69034504],', '    [ 0.28816354, 0.32200604, 0.67684067],', '    [ 0.28862749, 0.31519824, 0.66278813],', '    [ 0.28847904, 0.30869064, 0.6482815 ],', '    [ 0.28770912, 0.30250126, 0.63331265],', '    [ 0.28640325, 0.29655509, 0.61811374],', '    [ 0.28458943, 0.29082155, 0.60280913],', '    [ 0.28233561, 0.28527482, 0.58742866],', '    [ 0.27967038, 0.2798938 , 0.57204225],', '    [ 0.27665361, 0.27465357, 0.55667809],', '    [ 0.27332564, 0.2695165 , 0.54145387],', '    [ 0.26973851, 0.26447054, 0.52634916],', '    [ 0.2659204 , 0.25949691, 0.511417  ],', '    [ 0.26190145, 0.25458123, 0.49668768],', '    [ 0.2577151 , 0.24971691, 0.48214874],', '    [ 0.25337618, 0.24490494, 0.46778758],', '    [ 0.24890842, 0.24013332, 0.45363816],', '    [ 0.24433654, 0.23539226, 0.4397245 ],', '    [ 0.23967922, 0.23067729, 0.4260591 ],', '    [ 0.23495608, 0.22598894, 0.41262952],', '    [ 0.23018113, 0.22132414, 0.39945577],', '    [ 0.22534609, 0.21670847, 0.38645794],', '    [ 0.22048761, 0.21211723, 0.37372555],', '    [ 0.2156198 , 0.20755389, 0.36125301],', '    [ 0.21074637, 0.20302717, 0.34903192],', '    [ 0.20586893, 0.19855368, 0.33701661],', '    [ 0.20101757, 0.19411573, 0.32529173],', '    [ 0.19619947, 0.18972425, 0.31383846],', '    [ 0.19140726, 0.18540157, 0.30260777],', '    [ 0.1866769 , 0.1811332 , 0.29166583],', '    [ 0.18201285, 0.17694992, 0.28088776],', '    [ 0.17745228, 0.17282141, 0.27044211],', '    [ 0.17300684, 0.16876921, 0.26024893],', '    [ 0.16868273, 0.16479861, 0.25034479],', '    [ 0.16448691, 0.16091728, 0.24075373],', '    [ 0.16043195, 0.15714351, 0.23141745],', '    [ 0.15652427, 0.15348248, 0.22238175],', '    [ 0.15277065, 0.14994111, 0.21368395],', '    [ 0.14918274, 0.14653431, 0.20529486],', '    [ 0.14577095, 0.14327403, 0.19720829],', '    [ 0.14254381, 0.14016944, 0.18944326],', '    [ 0.13951035, 0.13723063, 0.18201072],', '    [ 0.13667798, 0.13446606, 0.17493774],', '    [ 0.13405762, 0.13188822, 0.16820842],', '    [ 0.13165767, 0.12950667, 0.16183275],', '    [ 0.12948748, 0.12733187, 0.15580631],', '    [ 0.12755435, 0.1253723 , 0.15014098],', '    [ 0.12586516, 0.12363617, 0.1448459 ],', '    [ 0.12442647, 0.12213143, 0.13992571],', '    [ 0.12324241, 0.12086419, 0.13539995],', '    [ 0.12232067, 0.11984278, 0.13124644],', '    [ 0.12166209, 0.11907077, 0.12749671],', '    [ 0.12126982, 0.11855309, 0.12415079],', '    [ 0.12114244, 0.11829179, 0.1212385 ],', '    [ 0.12127766, 0.11828837, 0.11878534],', '    [ 0.12284806, 0.1179729 , 0.11772022],', '    [ 0.12619498, 0.11721796, 0.11770203],', '    [ 0.129968  , 0.11663788, 0.11792377],', '    [ 0.13410011, 0.11625146, 0.11839138],', '    [ 0.13855459, 0.11606618, 0.11910584],', '    [ 0.14333775, 0.11607038, 0.1200606 ],', '    [ 0.148417  , 0.11626929, 0.12125453],', '    [ 0.15377389, 0.11666192, 0.12268364],', '    [ 0.15941427, 0.11723486, 0.12433911],', '    [ 0.16533376, 0.11797856, 0.12621303],', '    [ 0.17152547, 0.11888403, 0.12829735],', '    [ 0.17797765, 0.11994436, 0.13058435],', '    [ 0.18468769, 0.12114722, 0.13306426],', '    [ 0.19165663, 0.12247737, 0.13572616],', '    [ 0.19884415, 0.12394381, 0.1385669 ],', '    [ 0.20627181, 0.12551883, 0.14157124],', '    [ 0.21394877, 0.12718055, 0.14472604],', '    [ 0.22184572, 0.12893119, 0.14802579],', '    [ 0.22994394, 0.13076731, 0.15146314],', '    [ 0.23823937, 0.13267611, 0.15502793],', '    [ 0.24676041, 0.13462172, 0.15870321],', '    [ 0.25546457, 0.13661751, 0.16248722],', '    [ 0.26433628, 0.13865956, 0.16637301],', '    [ 0.27341345, 0.14070412, 0.17034221],', '    [ 0.28264773, 0.14277192, 0.1743957 ],', '    [ 0.29202272, 0.14486161, 0.17852793],', '    [ 0.30159648, 0.14691224, 0.1827169 ],', '    [ 0.31129002, 0.14897583, 0.18695213],', '    [ 0.32111555, 0.15103351, 0.19119629],', '    [ 0.33107961, 0.1530674 , 0.19543758],', '    [ 0.34119892, 0.15504762, 0.1996803 ],', '    [ 0.35142388, 0.15701131, 0.20389086],', '    [ 0.36178937, 0.1589124 , 0.20807639],', '    [ 0.37229381, 0.16073993, 0.21223189],', '    [ 0.38288348, 0.16254006, 0.2163249 ],', '    [ 0.39359592, 0.16426336, 0.22036577],', '    [ 0.40444332, 0.16588767, 0.22434027],', '    [ 0.41537995, 0.16745325, 0.2282297 ],', '    [ 0.42640867, 0.16894939, 0.23202755],', '    [ 0.43754706, 0.17034847, 0.23572899],', '    [ 0.44878564, 0.1716535 , 0.23932344],', '    [ 0.4601126 , 0.17287365, 0.24278607],', '    [ 0.47151732, 0.17401641, 0.24610337],', '    [ 0.48300689, 0.17506676, 0.2492737 ],', '    [ 0.49458302, 0.17601892, 0.25227688],', '    [ 0.50623876, 0.17687777, 0.255096  ],', '    [ 0.5179623 , 0.17765528, 0.2577162 ],', '    [ 0.52975234, 0.17835232, 0.2601134 ],', '    [ 0.54159776, 0.17898292, 0.26226847],', '    [ 0.55348804, 0.17956232, 0.26416003],', '    [ 0.56541729, 0.18010175, 0.26575971],', '    [ 0.57736669, 0.180631  , 0.26704888],', '    [ 0.58932081, 0.18117827, 0.26800409],', '    [ 0.60127582, 0.18175888, 0.26858488],', '    [ 0.61319563, 0.1824336 , 0.2687872 ],', '    [ 0.62506376, 0.18324015, 0.26858301],', '    [ 0.63681202, 0.18430173, 0.26795276],', '    [ 0.64842603, 0.18565472, 0.26689463],', '    [ 0.65988195, 0.18734638, 0.26543435],', '    [ 0.67111966, 0.18948885, 0.26357955],', '    [ 0.68209194, 0.19216636, 0.26137175],', '    [ 0.69281185, 0.19535326, 0.25887063],', '    [ 0.70335022, 0.19891271, 0.25617971],', '    [ 0.71375229, 0.20276438, 0.25331365],', '    [ 0.72401436, 0.20691287, 0.25027366],', '    [ 0.73407638, 0.21145051, 0.24710661],', '    [ 0.74396983, 0.21631913, 0.24380715],', '    [ 0.75361506, 0.22163653, 0.24043996],', '    [ 0.7630579 , 0.22731637, 0.23700095],', '    [ 0.77222228, 0.23346231, 0.23356628],', '    [ 0.78115441, 0.23998404, 0.23013825],', '    [ 0.78979746, 0.24694858, 0.22678822],', '    [ 0.79819286, 0.25427223, 0.22352658],', '    [ 0.80630444, 0.26198807, 0.22040877],', '    [ 0.81417437, 0.27001406, 0.21744645],', '    [ 0.82177364, 0.27837336, 0.21468316],', '    [ 0.82915955, 0.28696963, 0.21210766],', '    [ 0.83628628, 0.2958499 , 0.20977813],', '    [ 0.84322168, 0.30491136, 0.20766435],', '    [ 0.84995458, 0.31415945, 0.2057863 ],', '    [ 0.85648867, 0.32358058, 0.20415327],', '    [ 0.86286243, 0.33312058, 0.20274969],', '    [ 0.86908321, 0.34276705, 0.20157271],', '    [ 0.87512876, 0.3525416 , 0.20064949],', '    [ 0.88100349, 0.36243385, 0.19999078],', '    [ 0.8866469 , 0.37249496, 0.1997976 ],', '    [ 0.89203964, 0.38273475, 0.20013431],', '    [ 0.89713496, 0.39318156, 0.20121514],', '    [ 0.90195099, 0.40380687, 0.20301555],', '    [ 0.90648379, 0.41460191, 0.20558847],', '    [ 0.9106967 , 0.42557857, 0.20918529],', '    [ 0.91463791, 0.43668557, 0.21367954],', '    [ 0.91830723, 0.44790913, 0.21916352],', '    [ 0.92171507, 0.45922856, 0.22568002],', '    [ 0.92491786, 0.4705936 , 0.23308207],', '    [ 0.92790792, 0.48200153, 0.24145932],', '    [ 0.93073701, 0.49341219, 0.25065486],', '    [ 0.93343918, 0.5048017 , 0.26056148],', '    [ 0.93602064, 0.51616486, 0.27118485],', '    [ 0.93850535, 0.52748892, 0.28242464],', '    [ 0.94092933, 0.53875462, 0.29416042],', '    [ 0.94330011, 0.5499628 , 0.30634189],', '    [ 0.94563159, 0.56110987, 0.31891624],', '    [ 0.94792955, 0.57219822, 0.33184256],', '    [ 0.95020929, 0.5832232 , 0.34508419],', '    [ 0.95247324, 0.59419035, 0.35859866],', '    [ 0.95471709, 0.60510869, 0.37236035],', '    [ 0.95698411, 0.61595766, 0.38629631],', '    [ 0.95923863, 0.62676473, 0.40043317],', '    [ 0.9615041 , 0.6375203 , 0.41474106],', '    [ 0.96371553, 0.64826619, 0.42928335],', '    [ 0.96591497, 0.65899621, 0.44380444],', '    [ 0.96809871, 0.66971662, 0.45830232],', '    [ 0.9702495 , 0.6804394 , 0.47280492],', '    [ 0.9723881 , 0.69115622, 0.48729272],', '    [ 0.97450723, 0.70187358, 0.50178034],', '    [ 0.9766108 , 0.712592  , 0.51626837],', '    [ 0.97871716, 0.72330511, 0.53074053],', '    [ 0.98082222, 0.73401769, 0.54520694],', '    [ 0.9829001 , 0.74474445, 0.5597019 ],', '    [ 0.98497466, 0.75547635, 0.57420239],', '    [ 0.98705581, 0.76621129, 0.58870185],', '    [ 0.98913325, 0.77695637, 0.60321626],', '    [ 0.99119918, 0.78771716, 0.61775821],', '    [ 0.9932672 , 0.79848979, 0.63231691],', '    [ 0.99535958, 0.80926704, 0.64687278],', '    [ 0.99740544, 0.82008078, 0.66150571],', '    [ 0.9992197 , 0.83100723, 0.6764127 ]', ']', '', '', '_flare_lut = [', '    [0.92907237, 0.68878959, 0.50411509],', '    [0.92891402, 0.68494686, 0.50173994],', '    [0.92864754, 0.68116207, 0.4993754],', '    [0.92836112, 0.67738527, 0.49701572],', '    [0.9280599, 0.67361354, 0.49466044],', '    [0.92775569, 0.66983999, 0.49230866],', '    [0.9274375, 0.66607098, 0.48996097],', '    [0.927111, 0.66230315, 0.48761688],', '    [0.92677996, 0.6585342, 0.485276],', '    [0.92644317, 0.65476476, 0.48293832],', '    [0.92609759, 0.65099658, 0.48060392],', '    [0.925747, 0.64722729, 0.47827244],', '    [0.92539502, 0.64345456, 0.47594352],', '    [0.92503106, 0.6396848, 0.47361782],', '    [0.92466877, 0.6359095, 0.47129427],', '    [0.92429828, 0.63213463, 0.46897349],', '    [0.92392172, 0.62835879, 0.46665526],', '    [0.92354597, 0.62457749, 0.46433898],', '    [0.9231622, 0.6207962, 0.46202524],', '    [0.92277222, 0.61701365, 0.45971384],', '    [0.92237978, 0.61322733, 0.45740444],', '    [0.92198615, 0.60943622, 0.45509686],', '    [0.92158735, 0.60564276, 0.45279137],', '    [0.92118373, 0.60184659, 0.45048789],', '    [0.92077582, 0.59804722, 0.44818634],', '    [0.92036413, 0.59424414, 0.44588663],', '    [0.91994924, 0.5904368, 0.44358868],', '    [0.91952943, 0.58662619, 0.4412926],', '    [0.91910675, 0.58281075, 0.43899817],', '    [0.91868096, 0.57899046, 0.4367054],', '    [0.91825103, 0.57516584, 0.43441436],', '    [0.91781857, 0.57133556, 0.43212486],', '    [0.9173814, 0.56750099, 0.4298371],', '    [0.91694139, 0.56366058, 0.42755089],', '    [0.91649756, 0.55981483, 0.42526631],', '    [0.91604942, 0.55596387, 0.42298339],', '    [0.9155979, 0.55210684, 0.42070204],', '    [0.9151409, 0.54824485, 0.4184247],', '    [0.91466138, 0.54438817, 0.41617858],', '    [0.91416896, 0.54052962, 0.41396347],', '    [0.91366559, 0.53666778, 0.41177769],', '    [0.91315173, 0.53280208, 0.40962196],', '    [0.91262605, 0.52893336, 0.40749715],', '    [0.91208866, 0.52506133, 0.40540404],', '    [0.91153952, 0.52118582, 0.40334346],', '    [0.91097732, 0.51730767, 0.4013163],', '    [0.910403, 0.51342591, 0.39932342],', '    [0.90981494, 0.50954168, 0.39736571],', '    [0.90921368, 0.5056543, 0.39544411],', '    [0.90859797, 0.50176463, 0.39355952],', '    [0.90796841, 0.49787195, 0.39171297],', '    [0.90732341, 0.4939774, 0.38990532],', '    [0.90666382, 0.49008006, 0.38813773],', '    [0.90598815, 0.486181, 0.38641107],', '    [0.90529624, 0.48228017, 0.38472641],', '    [0.90458808, 0.47837738, 0.38308489],', '    [0.90386248, 0.47447348, 0.38148746],', '    [0.90311921, 0.4705685, 0.37993524],', '    [0.90235809, 0.46666239, 0.37842943],', '    [0.90157824, 0.46275577, 0.37697105],', '    [0.90077904, 0.45884905, 0.37556121],', '    [0.89995995, 0.45494253, 0.37420106],', '    [0.89912041, 0.4510366, 0.37289175],', '    [0.8982602, 0.44713126, 0.37163458],', '    [0.89737819, 0.44322747, 0.37043052],', '    [0.89647387, 0.43932557, 0.36928078],', '    [0.89554477, 0.43542759, 0.36818855],', '    [0.89458871, 0.4315354, 0.36715654],', '    [0.89360794, 0.42764714, 0.36618273],', '    [0.89260152, 0.42376366, 0.36526813],', '    [0.8915687, 0.41988565, 0.36441384],', '    [0.89050882, 0.41601371, 0.36362102],', '    [0.8894159, 0.41215334, 0.36289639],', '    [0.888292, 0.40830288, 0.36223756],', '    [0.88713784, 0.40446193, 0.36164328],', '    [0.88595253, 0.40063149, 0.36111438],', '    [0.88473115, 0.39681635, 0.3606566],', '    [0.88347246, 0.39301805, 0.36027074],', '    [0.88217931, 0.38923439, 0.35995244],', '    [0.880851, 0.38546632, 0.35970244],', '    [0.87947728, 0.38172422, 0.35953127],', '    [0.87806542, 0.37800172, 0.35942941],', '    [0.87661509, 0.37429964, 0.35939659],', '    [0.87511668, 0.37062819, 0.35944178],', '    [0.87357554, 0.36698279, 0.35955811],', '    [0.87199254, 0.3633634, 0.35974223],', '    [0.87035691, 0.35978174, 0.36000516],', '    [0.86867647, 0.35623087, 0.36033559],', '    [0.86694949, 0.35271349, 0.36073358],', '    [0.86516775, 0.34923921, 0.36120624],', '    [0.86333996, 0.34580008, 0.36174113],', '    [0.86145909, 0.3424046, 0.36234402],', '    [0.85952586, 0.33905327, 0.36301129],', '    [0.85754536, 0.33574168, 0.36373567],', '    [0.855514, 0.33247568, 0.36451271],', '    [0.85344392, 0.32924217, 0.36533344],', '    [0.8513284, 0.32604977, 0.36620106],', '    [0.84916723, 0.32289973, 0.36711424],', '    [0.84696243, 0.31979068, 0.36806976],', '    [0.84470627, 0.31673295, 0.36907066],', '    [0.84240761, 0.31371695, 0.37010969],', '    [0.84005337, 0.31075974, 0.37119284],', '    [0.83765537, 0.30784814, 0.3723105],', '    [0.83520234, 0.30499724, 0.37346726],', '    [0.83270291, 0.30219766, 0.37465552],', '    [0.83014895, 0.29946081, 0.37587769],', '    [0.82754694, 0.29677989, 0.37712733],', '    [0.82489111, 0.29416352, 0.37840532],', '    [0.82218644, 0.29160665, 0.37970606],', '    [0.81942908, 0.28911553, 0.38102921],', '    [0.81662276, 0.28668665, 0.38236999],', '    [0.81376555, 0.28432371, 0.383727],', '    [0.81085964, 0.28202508, 0.38509649],', '    [0.8079055, 0.27979128, 0.38647583],', '    [0.80490309, 0.27762348, 0.3878626],', '    [0.80185613, 0.2755178, 0.38925253],', '    [0.79876118, 0.27347974, 0.39064559],', '    [0.79562644, 0.27149928, 0.39203532],', '    [0.79244362, 0.2695883, 0.39342447],', '    [0.78922456, 0.26773176, 0.3948046],', '    [0.78596161, 0.26594053, 0.39617873],', '    [0.7826624, 0.26420493, 0.39754146],', '    [0.77932717, 0.26252522, 0.39889102],', '    [0.77595363, 0.2609049, 0.4002279],', '    [0.77254999, 0.25933319, 0.40154704],', '    [0.76911107, 0.25781758, 0.40284959],', '    [0.76564158, 0.25635173, 0.40413341],', '    [0.76214598, 0.25492998, 0.40539471],', '    [0.75861834, 0.25356035, 0.40663694],', '    [0.75506533, 0.25223402, 0.40785559],', '    [0.75148963, 0.2509473, 0.40904966],', '    [0.74788835, 0.24970413, 0.41022028],', '    [0.74426345, 0.24850191, 0.41136599],', '    [0.74061927, 0.24733457, 0.41248516],', '    [0.73695678, 0.24620072, 0.41357737],', '    [0.73327278, 0.24510469, 0.41464364],', '    [0.72957096, 0.24404127, 0.4156828],', '    [0.72585394, 0.24300672, 0.41669383],', '    [0.7221226, 0.24199971, 0.41767651],', '    [0.71837612, 0.24102046, 0.41863486],', '    [0.71463236, 0.24004289, 0.41956983],', '    [0.7108932, 0.23906316, 0.42048681],', '    [0.70715842, 0.23808142, 0.42138647],', '    [0.70342811, 0.2370976, 0.42226844],', '    [0.69970218, 0.23611179, 0.42313282],', '    [0.69598055, 0.2351247, 0.42397678],', '    [0.69226314, 0.23413578, 0.42480327],', '    [0.68854988, 0.23314511, 0.42561234],', '    [0.68484064, 0.23215279, 0.42640419],', '    [0.68113541, 0.23115942, 0.42717615],', '    [0.67743412, 0.23016472, 0.42792989],', '    [0.67373662, 0.22916861, 0.42866642],', '    [0.67004287, 0.22817117, 0.42938576],', '    [0.66635279, 0.22717328, 0.43008427],', '    [0.66266621, 0.22617435, 0.43076552],', '    [0.65898313, 0.22517434, 0.43142956],', '    [0.65530349, 0.22417381, 0.43207427],', '    [0.65162696, 0.22317307, 0.4327001],', '    [0.64795375, 0.22217149, 0.43330852],', '    [0.64428351, 0.22116972, 0.43389854],', '    [0.64061624, 0.22016818, 0.43446845],', '    [0.63695183, 0.21916625, 0.43502123],', '    [0.63329016, 0.21816454, 0.43555493],', '    [0.62963102, 0.2171635, 0.43606881],', '    [0.62597451, 0.21616235, 0.43656529],', '    [0.62232019, 0.21516239, 0.43704153],', '    [0.61866821, 0.21416307, 0.43749868],', '    [0.61501835, 0.21316435, 0.43793808],', '    [0.61137029, 0.21216761, 0.4383556],', '    [0.60772426, 0.2111715, 0.43875552],', '    [0.60407977, 0.21017746, 0.43913439],', '    [0.60043678, 0.20918503, 0.43949412],', '    [0.59679524, 0.20819447, 0.43983393],', '    [0.59315487, 0.20720639, 0.44015254],', '    [0.58951566, 0.20622027, 0.44045213],', '    [0.58587715, 0.20523751, 0.44072926],', '    [0.5822395, 0.20425693, 0.44098758],', '    [0.57860222, 0.20328034, 0.44122241],', '    [0.57496549, 0.20230637, 0.44143805],', '    [0.57132875, 0.20133689, 0.4416298],', '    [0.56769215, 0.20037071, 0.44180142],', '    [0.5640552, 0.19940936, 0.44194923],', '    [0.56041794, 0.19845221, 0.44207535],', '    [0.55678004, 0.1975, 0.44217824],', '    [0.55314129, 0.19655316, 0.44225723],', '    [0.54950166, 0.19561118, 0.44231412],', '    [0.54585987, 0.19467771, 0.44234111],', '    [0.54221157, 0.19375869, 0.44233698],', '    [0.5385549, 0.19285696, 0.44229959],', '    [0.5348913, 0.19197036, 0.44222958],', '    [0.53122177, 0.1910974, 0.44212735],', '    [0.52754464, 0.19024042, 0.44199159],', '    [0.52386353, 0.18939409, 0.44182449],', '    [0.52017476, 0.18856368, 0.44162345],', '    [0.51648277, 0.18774266, 0.44139128],', '    [0.51278481, 0.18693492, 0.44112605],', '    [0.50908361, 0.18613639, 0.4408295],', '    [0.50537784, 0.18534893, 0.44050064],', '    [0.50166912, 0.18457008, 0.44014054],', '    [0.49795686, 0.18380056, 0.43974881],', '    [0.49424218, 0.18303865, 0.43932623],', '    [0.49052472, 0.18228477, 0.43887255],', '    [0.48680565, 0.1815371, 0.43838867],', '    [0.48308419, 0.18079663, 0.43787408],', '    [0.47936222, 0.18006056, 0.43733022],', '    [0.47563799, 0.17933127, 0.43675585],', '    [0.47191466, 0.17860416, 0.43615337],', '    [0.46818879, 0.17788392, 0.43552047],', '    [0.46446454, 0.17716458, 0.43486036],', '    [0.46073893, 0.17645017, 0.43417097],', '    [0.45701462, 0.17573691, 0.43345429],', '    [0.45329097, 0.17502549, 0.43271025],', '    [0.44956744, 0.17431649, 0.4319386],', '    [0.44584668, 0.17360625, 0.43114133],', '    [0.44212538, 0.17289906, 0.43031642],', '    [0.43840678, 0.17219041, 0.42946642],', '    [0.43469046, 0.17148074, 0.42859124],', '    [0.4309749, 0.17077192, 0.42769008],', '    [0.42726297, 0.17006003, 0.42676519],', '    [0.42355299, 0.16934709, 0.42581586],', '    [0.41984535, 0.16863258, 0.42484219],', '    [0.41614149, 0.16791429, 0.42384614],', '    [0.41244029, 0.16719372, 0.42282661],', '    [0.40874177, 0.16647061, 0.42178429],', '    [0.40504765, 0.16574261, 0.42072062],', '    [0.401357, 0.16501079, 0.41963528],', '    [0.397669, 0.16427607, 0.418528],', '    [0.39398585, 0.16353554, 0.41740053],', '    [0.39030735, 0.16278924, 0.41625344],', '    [0.3866314, 0.16203977, 0.41508517],', '    [0.38295904, 0.16128519, 0.41389849],', '    [0.37928736, 0.16052483, 0.41270599],', '    [0.37562649, 0.15974704, 0.41151182],', '    [0.37197803, 0.15895049, 0.41031532],', '    [0.36833779, 0.15813871, 0.40911916],', '    [0.36470944, 0.15730861, 0.40792149],', '    [0.36109117, 0.15646169, 0.40672362],', '    [0.35748213, 0.15559861, 0.40552633],', '    [0.353885, 0.15471714, 0.40432831],', '    [0.35029682, 0.15381967, 0.4031316],', '    [0.34671861, 0.1529053, 0.40193587],', '    [0.34315191, 0.15197275, 0.40074049],', '    [0.33959331, 0.15102466, 0.3995478],', '    [0.33604378, 0.15006017, 0.39835754],', '    [0.33250529, 0.14907766, 0.39716879],', '    [0.32897621, 0.14807831, 0.39598285],', '    [0.3254559, 0.14706248, 0.39480044],', '    [0.32194567, 0.14602909, 0.39362106],', '    [0.31844477, 0.14497857, 0.39244549],', '    [0.31494974, 0.14391333, 0.39127626],', '    [0.31146605, 0.14282918, 0.39011024],', '    [0.30798857, 0.1417297, 0.38895105],', '    [0.30451661, 0.14061515, 0.38779953],', '    [0.30105136, 0.13948445, 0.38665531],', '    [0.2975886, 0.1383403, 0.38552159],', '    [0.29408557, 0.13721193, 0.38442775]', ']', '', '', '_crest_lut = [', '    [0.6468274, 0.80289262, 0.56592265],', '    [0.64233318, 0.80081141, 0.56639461],', '    [0.63791969, 0.7987162, 0.56674976],', '    [0.6335316, 0.79661833, 0.56706128],', '    [0.62915226, 0.7945212, 0.56735066],', '    [0.62477862, 0.79242543, 0.56762143],', '    [0.62042003, 0.79032918, 0.56786129],', '    [0.61606327, 0.78823508, 0.56808666],', '    [0.61171322, 0.78614216, 0.56829092],', '    [0.60736933, 0.78405055, 0.56847436],', '    [0.60302658, 0.78196121, 0.56864272],', '    [0.59868708, 0.77987374, 0.56879289],', '    [0.59435366, 0.77778758, 0.56892099],', '    [0.59001953, 0.77570403, 0.56903477],', '    [0.58568753, 0.77362254, 0.56913028],', '    [0.58135593, 0.77154342, 0.56920908],', '    [0.57702623, 0.76946638, 0.56926895],', '    [0.57269165, 0.76739266, 0.5693172],', '    [0.56835934, 0.76532092, 0.56934507],', '    [0.56402533, 0.76325185, 0.56935664],', '    [0.55968429, 0.76118643, 0.56935732],', '    [0.55534159, 0.75912361, 0.56934052],', '    [0.55099572, 0.75706366, 0.56930743],', '    [0.54664626, 0.75500662, 0.56925799],', '    [0.54228969, 0.75295306, 0.56919546],', '    [0.53792417, 0.75090328, 0.56912118],', '    [0.53355172, 0.74885687, 0.5690324],', '    [0.52917169, 0.74681387, 0.56892926],', '    [0.52478243, 0.74477453, 0.56881287],', '    [0.52038338, 0.74273888, 0.56868323],', '    [0.5159739, 0.74070697, 0.56854039],', '    [0.51155269, 0.73867895, 0.56838507],', '    [0.50711872, 0.73665492, 0.56821764],', '    [0.50267118, 0.73463494, 0.56803826],', '    [0.49822926, 0.73261388, 0.56785146],', '    [0.49381422, 0.73058524, 0.56767484],', '    [0.48942421, 0.72854938, 0.56751036],', '    [0.48505993, 0.72650623, 0.56735752],', '    [0.48072207, 0.72445575, 0.56721583],', '    [0.4764113, 0.72239788, 0.56708475],', '    [0.47212827, 0.72033258, 0.56696376],', '    [0.46787361, 0.71825983, 0.56685231],', '    [0.46364792, 0.71617961, 0.56674986],', '    [0.45945271, 0.71409167, 0.56665625],', '    [0.45528878, 0.71199595, 0.56657103],', '    [0.45115557, 0.70989276, 0.5664931],', '    [0.44705356, 0.70778212, 0.56642189],', '    [0.44298321, 0.70566406, 0.56635683],', '    [0.43894492, 0.70353863, 0.56629734],', '    [0.43493911, 0.70140588, 0.56624286],', '    [0.43096612, 0.69926587, 0.5661928],', '    [0.42702625, 0.69711868, 0.56614659],', '    [0.42311977, 0.69496438, 0.56610368],', '    [0.41924689, 0.69280308, 0.56606355],', '    [0.41540778, 0.69063486, 0.56602564],', '    [0.41160259, 0.68845984, 0.56598944],', '    [0.40783143, 0.68627814, 0.56595436],', '    [0.40409434, 0.68408988, 0.56591994],', '    [0.40039134, 0.68189518, 0.56588564],', '    [0.39672238, 0.6796942, 0.56585103],', '    [0.39308781, 0.67748696, 0.56581581],', '    [0.38949137, 0.67527276, 0.56578084],', '    [0.38592889, 0.67305266, 0.56574422],', '    [0.38240013, 0.67082685, 0.56570561],', '    [0.37890483, 0.66859548, 0.56566462],', '    [0.37544276, 0.66635871, 0.56562081],', '    [0.37201365, 0.66411673, 0.56557372],', '    [0.36861709, 0.6618697, 0.5655231],', '    [0.36525264, 0.65961782, 0.56546873],', '    [0.36191986, 0.65736125, 0.56541032],', '    [0.35861935, 0.65509998, 0.56534768],', '    [0.35535621, 0.65283302, 0.56528211],', '    [0.35212361, 0.65056188, 0.56521171],', '    [0.34892097, 0.64828676, 0.56513633],', '    [0.34574785, 0.64600783, 0.56505539],', '    [0.34260357, 0.64372528, 0.5649689],', '    [0.33948744, 0.64143931, 0.56487679],', '    [0.33639887, 0.6391501, 0.56477869],', '    [0.33334501, 0.63685626, 0.56467661],', '    [0.33031952, 0.63455911, 0.564569],', '    [0.3273199, 0.63225924, 0.56445488],', '    [0.32434526, 0.62995682, 0.56433457],', '    [0.32139487, 0.62765201, 0.56420795],', '    [0.31846807, 0.62534504, 0.56407446],', '    [0.3155731, 0.62303426, 0.56393695],', '    [0.31270304, 0.62072111, 0.56379321],', '    [0.30985436, 0.61840624, 0.56364307],', '    [0.30702635, 0.61608984, 0.56348606],', '    [0.30421803, 0.61377205, 0.56332267],', '    [0.30143611, 0.61145167, 0.56315419],', '    [0.29867863, 0.60912907, 0.56298054],', '    [0.29593872, 0.60680554, 0.56280022],', '    [0.29321538, 0.60448121, 0.56261376],', '    [0.2905079, 0.60215628, 0.56242036],', '    [0.28782827, 0.5998285, 0.56222366],', '    [0.28516521, 0.59749996, 0.56202093],', '    [0.28251558, 0.59517119, 0.56181204],', '    [0.27987847, 0.59284232, 0.56159709],', '    [0.27726216, 0.59051189, 0.56137785],', '    [0.27466434, 0.58818027, 0.56115433],', '    [0.2720767, 0.58584893, 0.56092486],', '    [0.26949829, 0.58351797, 0.56068983],', '    [0.26693801, 0.58118582, 0.56045121],', '    [0.26439366, 0.57885288, 0.56020858],', '    [0.26185616, 0.57652063, 0.55996077],', '    [0.25932459, 0.57418919, 0.55970795],', '    [0.25681303, 0.57185614, 0.55945297],', '    [0.25431024, 0.56952337, 0.55919385],', '    [0.25180492, 0.56719255, 0.5589305],', '    [0.24929311, 0.56486397, 0.5586654],', '    [0.24678356, 0.56253666, 0.55839491],', '    [0.24426587, 0.56021153, 0.55812473],', '    [0.24174022, 0.55788852, 0.55785448],', '    [0.23921167, 0.55556705, 0.55758211],', '    [0.23668315, 0.55324675, 0.55730676],', '    [0.23414742, 0.55092825, 0.55703167],', '    [0.23160473, 0.54861143, 0.5567573],', '    [0.22905996, 0.54629572, 0.55648168],', '    [0.22651648, 0.54398082, 0.5562029],', '    [0.22396709, 0.54166721, 0.55592542],', '    [0.22141221, 0.53935481, 0.55564885],', '    [0.21885269, 0.53704347, 0.55537294],', '    [0.21629986, 0.53473208, 0.55509319],', '    [0.21374297, 0.53242154, 0.5548144],', '    [0.21118255, 0.53011166, 0.55453708],', '    [0.2086192, 0.52780237, 0.55426067],', '    [0.20605624, 0.52549322, 0.55398479],', '    [0.20350004, 0.5231837, 0.55370601],', '    [0.20094292, 0.52087429, 0.55342884],', '    [0.19838567, 0.51856489, 0.55315283],', '    [0.19582911, 0.51625531, 0.55287818],', '    [0.19327413, 0.51394542, 0.55260469],', '    [0.19072933, 0.51163448, 0.5523289],', '    [0.18819045, 0.50932268, 0.55205372],', '    [0.18565609, 0.50701014, 0.55177937],', '    [0.18312739, 0.50469666, 0.55150597],', '    [0.18060561, 0.50238204, 0.55123374],', '    [0.178092, 0.50006616, 0.55096224],', '    [0.17558808, 0.49774882, 0.55069118],', '    [0.17310341, 0.49542924, 0.5504176],', '    [0.17063111, 0.49310789, 0.55014445],', '    [0.1681728, 0.49078458, 0.54987159],', '    [0.1657302, 0.48845913, 0.54959882],', '    [0.16330517, 0.48613135, 0.54932605],', '    [0.16089963, 0.48380104, 0.54905306],', '    [0.15851561, 0.48146803, 0.54877953],', '    [0.15615526, 0.47913212, 0.54850526],', '    [0.15382083, 0.47679313, 0.54822991],', '    [0.15151471, 0.47445087, 0.54795318],', '    [0.14924112, 0.47210502, 0.54767411],', '    [0.1470032, 0.46975537, 0.54739226],', '    [0.14480101, 0.46740187, 0.54710832],', '    [0.14263736, 0.46504434, 0.54682188],', '    [0.14051521, 0.46268258, 0.54653253],', '    [0.13843761, 0.46031639, 0.54623985],', '    [0.13640774, 0.45794558, 0.5459434],', '    [0.13442887, 0.45556994, 0.54564272],', '    [0.1325044, 0.45318928, 0.54533736],', '    [0.13063777, 0.4508034, 0.54502674],', '    [0.12883252, 0.44841211, 0.5447104],', '    [0.12709242, 0.44601517, 0.54438795],', '    [0.1254209, 0.44361244, 0.54405855],', '    [0.12382162, 0.44120373, 0.54372156],', '    [0.12229818, 0.43878887, 0.54337634],', '    [0.12085453, 0.4363676, 0.54302253],', '    [0.11949938, 0.43393955, 0.54265715],', '    [0.11823166, 0.43150478, 0.54228104],', '    [0.11705496, 0.42906306, 0.54189388],', '    [0.115972, 0.42661431, 0.54149449],', '    [0.11498598, 0.42415835, 0.54108222],', '    [0.11409965, 0.42169502, 0.54065622],', '    [0.11331533, 0.41922424, 0.5402155],', '    [0.11263542, 0.41674582, 0.53975931],', '    [0.1120615, 0.4142597, 0.53928656],', '    [0.11159738, 0.41176567, 0.53879549],', '    [0.11125248, 0.40926325, 0.53828203],', '    [0.11101698, 0.40675289, 0.53774864],', '    [0.11089152, 0.40423445, 0.53719455],', '    [0.11085121, 0.4017095, 0.53662425],', '    [0.11087217, 0.39917938, 0.53604354],', '    [0.11095515, 0.39664394, 0.53545166],', '    [0.11110676, 0.39410282, 0.53484509],', '    [0.11131735, 0.39155635, 0.53422678],', '    [0.11158595, 0.38900446, 0.53359634],', '    [0.11191139, 0.38644711, 0.5329534],', '    [0.11229224, 0.38388426, 0.53229748],', '    [0.11273683, 0.38131546, 0.53162393],', '    [0.11323438, 0.37874109, 0.53093619],', '    [0.11378271, 0.37616112, 0.53023413],', '    [0.11437992, 0.37357557, 0.52951727],', '    [0.11502681, 0.37098429, 0.52878396],', '    [0.11572661, 0.36838709, 0.52803124],', '    [0.11646936, 0.36578429, 0.52726234],', '    [0.11725299, 0.3631759, 0.52647685],', '    [0.1180755, 0.36056193, 0.52567436],', '    [0.1189438, 0.35794203, 0.5248497],', '    [0.11984752, 0.35531657, 0.52400649],', '    [0.1207833, 0.35268564, 0.52314492],', '    [0.12174895, 0.35004927, 0.52226461],', '    [0.12274959, 0.34740723, 0.52136104],', '    [0.12377809, 0.34475975, 0.52043639],', '    [0.12482961, 0.34210702, 0.51949179],', '    [0.125902, 0.33944908, 0.51852688],', '    [0.12699998, 0.33678574, 0.51753708],', '    [0.12811691, 0.33411727, 0.51652464],', '    [0.12924811, 0.33144384, 0.51549084],', '    [0.13039157, 0.32876552, 0.51443538],', '    [0.13155228, 0.32608217, 0.51335321],', '    [0.13272282, 0.32339407, 0.51224759],', '    [0.13389954, 0.32070138, 0.51111946],', '    [0.13508064, 0.31800419, 0.50996862],', '    [0.13627149, 0.31530238, 0.50878942],', '    [0.13746376, 0.31259627, 0.50758645],', '    [0.13865499, 0.30988598, 0.50636017],', '    [0.13984364, 0.30717161, 0.50511042],', '    [0.14103515, 0.30445309, 0.50383119],', '    [0.14222093, 0.30173071, 0.50252813],', '    [0.14339946, 0.2990046, 0.50120127],', '    [0.14456941, 0.29627483, 0.49985054],', '    [0.14573579, 0.29354139, 0.49847009],', '    [0.14689091, 0.29080452, 0.49706566],', '    [0.1480336, 0.28806432, 0.49563732],', '    [0.1491628, 0.28532086, 0.49418508],', '    [0.15028228, 0.28257418, 0.49270402],', '    [0.15138673, 0.27982444, 0.49119848],', '    [0.15247457, 0.27707172, 0.48966925],', '    [0.15354487, 0.2743161, 0.48811641],', '    [0.15459955, 0.27155765, 0.4865371],', '    [0.15563716, 0.26879642, 0.4849321],', '    [0.1566572, 0.26603191, 0.48330429],', '    [0.15765823, 0.26326032, 0.48167456],', '    [0.15862147, 0.26048295, 0.48005785],', '    [0.15954301, 0.25770084, 0.47845341],', '    [0.16043267, 0.25491144, 0.4768626],', '    [0.16129262, 0.25211406, 0.4752857],', '    [0.1621119, 0.24931169, 0.47372076],', '    [0.16290577, 0.24649998, 0.47217025],', '    [0.16366819, 0.24368054, 0.47063302],', '    [0.1644021, 0.24085237, 0.46910949],', '    [0.16510882, 0.2380149, 0.46759982],', '    [0.16579015, 0.23516739, 0.46610429],', '    [0.1664433, 0.2323105, 0.46462219],', '    [0.16707586, 0.22944155, 0.46315508],', '    [0.16768475, 0.22656122, 0.46170223],', '    [0.16826815, 0.22366984, 0.46026308],', '    [0.16883174, 0.22076514, 0.45883891],', '    [0.16937589, 0.21784655, 0.45742976],', '    [0.16990129, 0.21491339, 0.45603578],', '    [0.1704074, 0.21196535, 0.45465677],', '    [0.17089473, 0.20900176, 0.4532928],', '    [0.17136819, 0.20602012, 0.45194524],', '    [0.17182683, 0.20302012, 0.45061386],', '    [0.17227059, 0.20000106, 0.44929865],', '    [0.17270583, 0.19695949, 0.44800165],', '    [0.17313804, 0.19389201, 0.44672488],', '    [0.17363177, 0.19076859, 0.44549087]', ']', '', '', '_lut_dict = dict(', '    rocket=_rocket_lut,', '    mako=_mako_lut,', '    icefire=_icefire_lut,', '    vlag=_vlag_lut,', '    flare=_flare_lut,', '    crest=_crest_lut,', '', ')', '', 'for _name, _lut in _lut_dict.items():', '', '    _cmap = colors.ListedColormap(_lut, _name)', '    locals()[_name] = _cmap', '', '    _cmap_r = colors.ListedColormap(_lut[::-1], _name + \"_r\")', '    locals()[_name + \"_r\"] = _cmap_r', '', '    register_colormap(_name, _cmap)', '    register_colormap(_name + \"_r\", _cmap_r)', '', 'del colors, register_colormap']}, '_compat.py': {'classes': [{'name': 'ScaledNorm', 'start_line': 38, 'end_line': 62, 'text': ['    class ScaledNorm(mpl.colors.Normalize):', '', '        def __call__(self, value, clip=None):', '            # From github.com/matplotlib/matplotlib/blob/v3.4.2/lib/matplotlib/colors.py', '            # See github.com/matplotlib/matplotlib/tree/v3.4.2/LICENSE', '            value, is_scalar = self.process_value(value)', '            self.autoscale_None(value)', '            if self.vmin > self.vmax:', '                raise ValueError(\"vmin must be less or equal to vmax\")', '            if self.vmin == self.vmax:', '                return np.full_like(value, 0)', '            if clip is None:', '                clip = self.clip', '            if clip:', '                value = np.clip(value, self.vmin, self.vmax)', '            # ***** Seaborn changes start ****', '            t_value = self.transform(value).reshape(np.shape(value))', '            t_vmin, t_vmax = self.transform([self.vmin, self.vmax])', '            # ***** Seaborn changes end *****', '            if not np.isfinite([t_vmin, t_vmax]).all():', '                raise ValueError(\"Invalid vmin or vmax\")', '            t_value -= t_vmin', '            t_value /= (t_vmax - t_vmin)', '            t_value = np.ma.masked_invalid(t_value, copy=False)', '            return t_value[0] if is_scalar else t_value'], 'methods': [{'name': '__call__', 'start_line': 40, 'end_line': 62, 'text': ['        def __call__(self, value, clip=None):', '            # From github.com/matplotlib/matplotlib/blob/v3.4.2/lib/matplotlib/colors.py', '            # See github.com/matplotlib/matplotlib/tree/v3.4.2/LICENSE', '            value, is_scalar = self.process_value(value)', '            self.autoscale_None(value)', '            if self.vmin > self.vmax:', '                raise ValueError(\"vmin must be less or equal to vmax\")', '            if self.vmin == self.vmax:', '                return np.full_like(value, 0)', '            if clip is None:', '                clip = self.clip', '            if clip:', '                value = np.clip(value, self.vmin, self.vmax)', '            # ***** Seaborn changes start ****', '            t_value = self.transform(value).reshape(np.shape(value))', '            t_vmin, t_vmax = self.transform([self.vmin, self.vmax])', '            # ***** Seaborn changes end *****', '            if not np.isfinite([t_vmin, t_vmax]).all():', '                raise ValueError(\"Invalid vmin or vmax\")', '            t_value -= t_vmin', '            t_value /= (t_vmax - t_vmin)', '            t_value = np.ma.masked_invalid(t_value, copy=False)', '            return t_value[0] if is_scalar else t_value']}]}, {'name': 'Axis', 'start_line': 91, 'end_line': 92, 'text': ['        class Axis:', '            axis_name = axis'], 'methods': []}], 'functions': [{'name': 'MarkerStyle', 'start_line': 6, 'end_line': 19, 'text': ['def MarkerStyle(marker=None, fillstyle=None):', '    \"\"\"', '    Allow MarkerStyle to accept a MarkerStyle object as parameter.', '', '    Supports matplotlib < 3.3.0', '    https://github.com/matplotlib/matplotlib/pull/16692', '', '    \"\"\"', '    if isinstance(marker, mpl.markers.MarkerStyle):', '        if fillstyle is None:', '            return marker', '        else:', '            marker = marker.get_marker()', '    return mpl.markers.MarkerStyle(marker, fillstyle)']}, {'name': 'norm_from_scale', 'start_line': 22, 'end_line': 67, 'text': ['def norm_from_scale(scale, norm):', '    \"\"\"Produce a Normalize object given a Scale and min/max domain limits.\"\"\"', '    # This is an internal maplotlib function that simplifies things to access', '    # It is likely to become part of the matplotlib API at some point:', '    # https://github.com/matplotlib/matplotlib/issues/20329', '    if isinstance(norm, mpl.colors.Normalize):', '        return norm', '', '    if scale is None:', '        return None', '', '    if norm is None:', '        vmin = vmax = None', '    else:', '        vmin, vmax = norm  # TODO more helpful error if this fails?', '', '    class ScaledNorm(mpl.colors.Normalize):', '', '        def __call__(self, value, clip=None):', '            # From github.com/matplotlib/matplotlib/blob/v3.4.2/lib/matplotlib/colors.py', '            # See github.com/matplotlib/matplotlib/tree/v3.4.2/LICENSE', '            value, is_scalar = self.process_value(value)', '            self.autoscale_None(value)', '            if self.vmin > self.vmax:', '                raise ValueError(\"vmin must be less or equal to vmax\")', '            if self.vmin == self.vmax:', '                return np.full_like(value, 0)', '            if clip is None:', '                clip = self.clip', '            if clip:', '                value = np.clip(value, self.vmin, self.vmax)', '            # ***** Seaborn changes start ****', '            t_value = self.transform(value).reshape(np.shape(value))', '            t_vmin, t_vmax = self.transform([self.vmin, self.vmax])', '            # ***** Seaborn changes end *****', '            if not np.isfinite([t_vmin, t_vmax]).all():', '                raise ValueError(\"Invalid vmin or vmax\")', '            t_value -= t_vmin', '            t_value /= (t_vmax - t_vmin)', '            t_value = np.ma.masked_invalid(t_value, copy=False)', '            return t_value[0] if is_scalar else t_value', '', '    new_norm = ScaledNorm(vmin, vmax)', '    new_norm.transform = scale.get_transform().transform', '', '    return new_norm']}, {'name': 'scale_factory', 'start_line': 70, 'end_line': 105, 'text': ['def scale_factory(scale, axis, **kwargs):', '    \"\"\"', '    Backwards compatability for creation of independent scales.', '', '    Matplotlib scales require an Axis object for instantiation on < 3.4.', '    But the axis is not used, aside from extraction of the axis_name in LogScale.', '', '    \"\"\"', '    modify_transform = False', '    if Version(mpl.__version__) < Version(\"3.4\"):', '        if axis[0] in \"xy\":', '            modify_transform = True', '            axis = axis[0]', '            base = kwargs.pop(\"base\", None)', '            if base is not None:', '                kwargs[f\"base{axis}\"] = base', '            nonpos = kwargs.pop(\"nonpositive\", None)', '            if nonpos is not None:', '                kwargs[f\"nonpos{axis}\"] = nonpos', '', '    if isinstance(scale, str):', '        class Axis:', '            axis_name = axis', '        axis = Axis()', '', '    scale = mpl.scale.scale_factory(scale, axis, **kwargs)', '', '    if modify_transform:', '        transform = scale.get_transform()', '        transform.base = kwargs.get(\"base\", 10)', '        if kwargs.get(\"nonpositive\") == \"mask\":', '            # Setting a private attribute, but we only get here', \"            # on an old matplotlib, so this won't break going forwards\", '            transform._clip = False', '', '    return scale']}, {'name': 'set_scale_obj', 'start_line': 108, 'end_line': 127, 'text': ['def set_scale_obj(ax, axis, scale):', '    \"\"\"Handle backwards compatability with setting matplotlib scale.\"\"\"', '    if Version(mpl.__version__) < Version(\"3.4\"):', '        # The ability to pass a BaseScale instance to Axes.set_{}scale was added', '        # to matplotlib in version 3.4.0: GH: matplotlib/matplotlib/pull/19089', '        # Workaround: use the scale name, which is restrictive only if the user', \"        # wants to define a custom scale; they'll need to update the registry too.\", '        if scale.name is None:', '            # Hack to support our custom Formatter-less CatScale', '            return', '        method = getattr(ax, f\"set_{axis}scale\")', '        kws = {}', '        if scale.name == \"function\":', '            trans = scale.get_transform()', '            kws[\"functions\"] = (trans._forward, trans._inverse)', '        method(scale.name, **kws)', '        axis_obj = getattr(ax, f\"{axis}axis\")', '        scale.set_default_locators_and_formatters(axis_obj)', '    else:', '        ax.set(**{f\"{axis}scale\": scale})']}, {'name': 'get_colormap', 'start_line': 130, 'end_line': 135, 'text': ['def get_colormap(name):', '    \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"', '    try:', '        return mpl.colormaps[name]', '    except AttributeError:', '        return mpl.cm.get_cmap(name)']}, {'name': 'register_colormap', 'start_line': 138, 'end_line': 144, 'text': ['def register_colormap(name, cmap):', '    \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"', '    try:', '        if name not in mpl.colormaps:', '            mpl.colormaps.register(cmap, name=name)', '    except AttributeError:', '        mpl.cm.register_cmap(name, cmap)']}, {'name': 'set_layout_engine', 'start_line': 147, 'end_line': 155, 'text': ['def set_layout_engine(fig, engine):', '    \"\"\"Handle changes to auto layout engine interface in 3.6\"\"\"', '    if hasattr(fig, \"set_layout_engine\"):', '        fig.set_layout_engine(engine)', '    else:', '        if engine == \"tight\":', '            fig.set_tight_layout(True)', '        elif engine == \"constrained\":', '            fig.set_constrained_layout(True)']}, {'name': 'share_axis', 'start_line': 158, 'end_line': 164, 'text': ['def share_axis(ax0, ax1, which):', '    \"\"\"Handle changes to post-hoc axis sharing.\"\"\"', '    if Version(mpl.__version__) < Version(\"3.5.0\"):', '        group = getattr(ax0, f\"get_shared_{which}_axes\")()', '        group.join(ax1, ax0)', '    else:', '        getattr(ax1, f\"share{which}\")(ax0)']}], 'text': ['import numpy as np', 'import matplotlib as mpl', 'from seaborn.external.version import Version', '', '', 'def MarkerStyle(marker=None, fillstyle=None):', '    \"\"\"', '    Allow MarkerStyle to accept a MarkerStyle object as parameter.', '', '    Supports matplotlib < 3.3.0', '    https://github.com/matplotlib/matplotlib/pull/16692', '', '    \"\"\"', '    if isinstance(marker, mpl.markers.MarkerStyle):', '        if fillstyle is None:', '            return marker', '        else:', '            marker = marker.get_marker()', '    return mpl.markers.MarkerStyle(marker, fillstyle)', '', '', 'def norm_from_scale(scale, norm):', '    \"\"\"Produce a Normalize object given a Scale and min/max domain limits.\"\"\"', '    # This is an internal maplotlib function that simplifies things to access', '    # It is likely to become part of the matplotlib API at some point:', '    # https://github.com/matplotlib/matplotlib/issues/20329', '    if isinstance(norm, mpl.colors.Normalize):', '        return norm', '', '    if scale is None:', '        return None', '', '    if norm is None:', '        vmin = vmax = None', '    else:', '        vmin, vmax = norm  # TODO more helpful error if this fails?', '', '    class ScaledNorm(mpl.colors.Normalize):', '', '        def __call__(self, value, clip=None):', '            # From github.com/matplotlib/matplotlib/blob/v3.4.2/lib/matplotlib/colors.py', '            # See github.com/matplotlib/matplotlib/tree/v3.4.2/LICENSE', '            value, is_scalar = self.process_value(value)', '            self.autoscale_None(value)', '            if self.vmin > self.vmax:', '                raise ValueError(\"vmin must be less or equal to vmax\")', '            if self.vmin == self.vmax:', '                return np.full_like(value, 0)', '            if clip is None:', '                clip = self.clip', '            if clip:', '                value = np.clip(value, self.vmin, self.vmax)', '            # ***** Seaborn changes start ****', '            t_value = self.transform(value).reshape(np.shape(value))', '            t_vmin, t_vmax = self.transform([self.vmin, self.vmax])', '            # ***** Seaborn changes end *****', '            if not np.isfinite([t_vmin, t_vmax]).all():', '                raise ValueError(\"Invalid vmin or vmax\")', '            t_value -= t_vmin', '            t_value /= (t_vmax - t_vmin)', '            t_value = np.ma.masked_invalid(t_value, copy=False)', '            return t_value[0] if is_scalar else t_value', '', '    new_norm = ScaledNorm(vmin, vmax)', '    new_norm.transform = scale.get_transform().transform', '', '    return new_norm', '', '', 'def scale_factory(scale, axis, **kwargs):', '    \"\"\"', '    Backwards compatability for creation of independent scales.', '', '    Matplotlib scales require an Axis object for instantiation on < 3.4.', '    But the axis is not used, aside from extraction of the axis_name in LogScale.', '', '    \"\"\"', '    modify_transform = False', '    if Version(mpl.__version__) < Version(\"3.4\"):', '        if axis[0] in \"xy\":', '            modify_transform = True', '            axis = axis[0]', '            base = kwargs.pop(\"base\", None)', '            if base is not None:', '                kwargs[f\"base{axis}\"] = base', '            nonpos = kwargs.pop(\"nonpositive\", None)', '            if nonpos is not None:', '                kwargs[f\"nonpos{axis}\"] = nonpos', '', '    if isinstance(scale, str):', '        class Axis:', '            axis_name = axis', '        axis = Axis()', '', '    scale = mpl.scale.scale_factory(scale, axis, **kwargs)', '', '    if modify_transform:', '        transform = scale.get_transform()', '        transform.base = kwargs.get(\"base\", 10)', '        if kwargs.get(\"nonpositive\") == \"mask\":', '            # Setting a private attribute, but we only get here', \"            # on an old matplotlib, so this won't break going forwards\", '            transform._clip = False', '', '    return scale', '', '', 'def set_scale_obj(ax, axis, scale):', '    \"\"\"Handle backwards compatability with setting matplotlib scale.\"\"\"', '    if Version(mpl.__version__) < Version(\"3.4\"):', '        # The ability to pass a BaseScale instance to Axes.set_{}scale was added', '        # to matplotlib in version 3.4.0: GH: matplotlib/matplotlib/pull/19089', '        # Workaround: use the scale name, which is restrictive only if the user', \"        # wants to define a custom scale; they'll need to update the registry too.\", '        if scale.name is None:', '            # Hack to support our custom Formatter-less CatScale', '            return', '        method = getattr(ax, f\"set_{axis}scale\")', '        kws = {}', '        if scale.name == \"function\":', '            trans = scale.get_transform()', '            kws[\"functions\"] = (trans._forward, trans._inverse)', '        method(scale.name, **kws)', '        axis_obj = getattr(ax, f\"{axis}axis\")', '        scale.set_default_locators_and_formatters(axis_obj)', '    else:', '        ax.set(**{f\"{axis}scale\": scale})', '', '', 'def get_colormap(name):', '    \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"', '    try:', '        return mpl.colormaps[name]', '    except AttributeError:', '        return mpl.cm.get_cmap(name)', '', '', 'def register_colormap(name, cmap):', '    \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"', '    try:', '        if name not in mpl.colormaps:', '            mpl.colormaps.register(cmap, name=name)', '    except AttributeError:', '        mpl.cm.register_cmap(name, cmap)', '', '', 'def set_layout_engine(fig, engine):', '    \"\"\"Handle changes to auto layout engine interface in 3.6\"\"\"', '    if hasattr(fig, \"set_layout_engine\"):', '        fig.set_layout_engine(engine)', '    else:', '        if engine == \"tight\":', '            fig.set_tight_layout(True)', '        elif engine == \"constrained\":', '            fig.set_constrained_layout(True)', '', '', 'def share_axis(ax0, ax1, which):', '    \"\"\"Handle changes to post-hoc axis sharing.\"\"\"', '    if Version(mpl.__version__) < Version(\"3.5.0\"):', '        group = getattr(ax0, f\"get_shared_{which}_axes\")()', '        group.join(ax1, ax0)', '    else:', '        getattr(ax1, f\"share{which}\")(ax0)']}, 'categorical.py': {'classes': [{'name': '_CategoricalPlotterNew', 'start_line': 44, 'end_line': 411, 'text': ['class _CategoricalPlotterNew(_RelationalPlotter):', '', '    semantics = \"x\", \"y\", \"hue\", \"units\"', '', '    wide_structure = {\"x\": \"@columns\", \"y\": \"@values\", \"hue\": \"@columns\"}', '', '    # flat_structure = {\"x\": \"@values\", \"y\": \"@values\"}', '    flat_structure = {\"y\": \"@values\"}', '', '    _legend_func = \"scatter\"', '    _legend_attributes = [\"color\"]', '', '    def __init__(', '        self,', '        data=None,', '        variables={},', '        order=None,', '        orient=None,', '        require_numeric=False,', '        legend=\"auto\",', '    ):', '', '        super().__init__(data=data, variables=variables)', '', '        # This method takes care of some bookkeeping that is necessary because the', '        # original categorical plots (prior to the 2021 refactor) had some rules that', \"        # don't fit exactly into the logic of _core. It may be wise to have a second\", '        # round of refactoring that moves the logic deeper, but this will keep things', '        # relatively sensible for now.', '', '        # For wide data, orient determines assignment to x/y differently from the', '        # wide_structure rules in _core. If we do decide to make orient part of the', \"        # _core variable assignment, we'll want to figure out how to express that.\", '        if self.input_format == \"wide\" and orient == \"h\":', '            self.plot_data = self.plot_data.rename(columns={\"x\": \"y\", \"y\": \"x\"})', '            orig_variables = set(self.variables)', '            orig_x = self.variables.pop(\"x\", None)', '            orig_y = self.variables.pop(\"y\", None)', '            orig_x_type = self.var_types.pop(\"x\", None)', '            orig_y_type = self.var_types.pop(\"y\", None)', '            if \"x\" in orig_variables:', '                self.variables[\"y\"] = orig_x', '                self.var_types[\"y\"] = orig_x_type', '            if \"y\" in orig_variables:', '                self.variables[\"x\"] = orig_y', '                self.var_types[\"x\"] = orig_y_type', '', '        # The concept of an \"orientation\" is important to the original categorical', \"        # plots, but there's no provision for it in _core, so we need to do it here.\", '        # Note that it could be useful for the other functions in at least two ways', '        # (orienting a univariate distribution plot from long-form data and selecting', '        # the aggregation axis in lineplot), so we may want to eventually refactor it.', '        self.orient = infer_orient(', '            x=self.plot_data.get(\"x\", None),', '            y=self.plot_data.get(\"y\", None),', '            orient=orient,', '            require_numeric=require_numeric,', '        )', '', '        self.legend = legend', '', '        # Short-circuit in the case of an empty plot', '        if not self.has_xy_data:', '            return', '', '        # Categorical plots can be \"univariate\" in which case they get an anonymous', '        # category label on the opposite axis. Note: this duplicates code in the core', '        # scale_categorical function. We need to do it here because of the next line.', '        if self.cat_axis not in self.variables:', '            self.variables[self.cat_axis] = None', '            self.var_types[self.cat_axis] = \"categorical\"', '            self.plot_data[self.cat_axis] = \"\"', '', '        # Categorical variables have discrete levels that we need to track', '        cat_levels = categorical_order(self.plot_data[self.cat_axis], order)', '        self.var_levels[self.cat_axis] = cat_levels', '', '    def _hue_backcompat(self, color, palette, hue_order, force_hue=False):', '        \"\"\"Implement backwards compatibility for hue parametrization.', '', '        Note: the force_hue parameter is used so that functions can be shown to', '        pass existing tests during refactoring and then tested for new behavior.', '        It can be removed after completion of the work.', '', '        \"\"\"', '        # The original categorical functions applied a palette to the categorical axis', '        # by default. We want to require an explicit hue mapping, to be more consistent', \"        # with how things work elsewhere now. I don't think there's any good way to\", \"        # do this gently -- because it's triggered by the default value of hue=None,\", '        # users would always get a warning, unless we introduce some sentinel \"default\"', \"        # argument for this change. That's possible, but asking users to set `hue=None`\", '        # on every call is annoying.', '        # We are keeping the logic for implementing the old behavior in with the current', '        # system so that (a) we can punt on that decision and (b) we can ensure that', '        # refactored code passes old tests.', '        default_behavior = color is None or palette is not None', '        if force_hue and \"hue\" not in self.variables and default_behavior:', '            self._redundant_hue = True', '            self.plot_data[\"hue\"] = self.plot_data[self.cat_axis]', '            self.variables[\"hue\"] = self.variables[self.cat_axis]', '            self.var_types[\"hue\"] = \"categorical\"', '            hue_order = self.var_levels[self.cat_axis]', '', '            # Because we convert the categorical axis variable to string,', '            # we need to update a dictionary palette too', '            if isinstance(palette, dict):', '                palette = {str(k): v for k, v in palette.items()}', '', '        else:', '            self._redundant_hue = False', '', '        # Previously, categorical plots had a trick where color= could seed the palette.', \"        # Because that's an explicit parameterization, we are going to give it one\", '        # release cycle with a warning before removing.', '        if \"hue\" in self.variables and palette is None and color is not None:', '            if not isinstance(color, str):', '                color = mpl.colors.to_hex(color)', '            palette = f\"dark:{color}\"', '            msg = (', '                \"Setting a gradient palette using color= is deprecated and will be \"', '                f\"removed in version 0.13. Set `palette=\\'{palette}\\'` for same effect.\"', '            )', '            warnings.warn(msg, FutureWarning)', '', '        return palette, hue_order', '', '    def _palette_without_hue_backcompat(self, palette, hue_order):', '        \"\"\"Provide one cycle where palette= implies hue= when not provided\"\"\"', '        if \"hue\" not in self.variables and palette is not None:', '            msg = \"Passing `palette` without assigning `hue` is deprecated.\"', '            warnings.warn(msg, FutureWarning, stacklevel=3)', '            self.legend = False', '            self.plot_data[\"hue\"] = self.plot_data[self.cat_axis]', '            self.variables[\"hue\"] = self.variables.get(self.cat_axis)', '            self.var_types[\"hue\"] = self.var_types.get(self.cat_axis)', '            hue_order = self.var_levels.get(self.cat_axis)', '        return hue_order', '', '    @property', '    def cat_axis(self):', '        return {\"v\": \"x\", \"h\": \"y\"}[self.orient]', '', '    def _get_gray(self, colors):', '        \"\"\"Get a grayscale value that looks good with color.\"\"\"', '        if not len(colors):', '            return None', '        unique_colors = np.unique(colors, axis=0)', '        light_vals = [rgb_to_hls(*rgb[:3])[1] for rgb in unique_colors]', '        lum = min(light_vals) * .6', '        return (lum, lum, lum)', '', '    def _adjust_cat_axis(self, ax, axis):', '        \"\"\"Set ticks and limits for a categorical variable.\"\"\"', '        # Note: in theory, this could happen in _attach for all categorical axes', '        # But two reasons not to do that:', '        # - If it happens before plotting, autoscaling messes up the plot limits', '        # - It would change existing plots from other seaborn functions', '        if self.var_types[axis] != \"categorical\":', '            return', '', '        # If both x/y data are empty, the correct way to set up the plot is', \"        # somewhat undefined; because we don't add null category data to the plot in\", \"        # this case we don't *have* a categorical axis (yet), so best to just bail.\", '        if self.plot_data[axis].empty:', '            return', '', '        # We can infer the total number of categories (including those from previous', '        # plots that are not part of the plot we are currently making) from the number', '        # of ticks, which matplotlib sets up while doing unit conversion. This feels', '        # slightly risky, as if we are relying on something that may be a matplotlib', '        # implementation detail. But I cannot think of a better way to keep track of', '        # the state from previous categorical calls (see GH2516 for context)', '        n = len(getattr(ax, f\"get_{axis}ticks\")())', '', '        if axis == \"x\":', '            ax.xaxis.grid(False)', '            ax.set_xlim(-.5, n - .5, auto=None)', '        else:', '            ax.yaxis.grid(False)', '            # Note limits that correspond to previously-inverted y axis', '            ax.set_ylim(n - .5, -.5, auto=None)', '', '    @property', '    def _native_width(self):', '        \"\"\"Return unit of width separating categories on native numeric scale.\"\"\"', '        unique_values = np.unique(self.comp_data[self.cat_axis])', '        if len(unique_values) > 1:', '            native_width = np.nanmin(np.diff(unique_values))', '        else:', '            native_width = 1', '        return native_width', '', '    def _nested_offsets(self, width, dodge):', '        \"\"\"Return offsets for each hue level for dodged plots.\"\"\"', '        offsets = None', '        if \"hue\" in self.variables:', '            n_levels = len(self._hue_map.levels)', '            if dodge:', '                each_width = width / n_levels', '                offsets = np.linspace(0, width - each_width, n_levels)', '                offsets -= offsets.mean()', '            else:', '                offsets = np.zeros(n_levels)', '        return offsets', '', '    # Note that the plotting methods here aim (in most cases) to produce the', '    # exact same artists as the original (pre 0.12) version of the code, so', '    # there is some weirdness that might not otherwise be clean or make sense in', '    # this context, such as adding empty artists for combinations of variables', '    # with no observations', '', '    def plot_strips(', '        self,', '        jitter,', '        dodge,', '        color,', '        edgecolor,', '        plot_kws,', '    ):', '', '        width = .8 * self._native_width', '        offsets = self._nested_offsets(width, dodge)', '', '        if jitter is True:', '            jlim = 0.1', '        else:', '            jlim = float(jitter)', '        if \"hue\" in self.variables and dodge:', '            jlim /= len(self._hue_map.levels)', '        jlim *= self._native_width', '        jitterer = partial(np.random.uniform, low=-jlim, high=+jlim)', '', '        iter_vars = [self.cat_axis]', '        if dodge:', '            iter_vars.append(\"hue\")', '', '        ax = self.ax', '        dodge_move = jitter_move = 0', '', '        for sub_vars, sub_data in self.iter_data(iter_vars,', '                                                 from_comp_data=True,', '                                                 allow_empty=True):', '            if offsets is not None and (offsets != 0).any():', '                dodge_move = offsets[sub_data[\"hue\"].map(self._hue_map.levels.index)]', '', '            jitter_move = jitterer(size=len(sub_data)) if len(sub_data) > 1 else 0', '', '            adjusted_data = sub_data[self.cat_axis] + dodge_move + jitter_move', '            sub_data[self.cat_axis] = adjusted_data', '', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    sub_data[var] = np.power(10, sub_data[var])', '', '            ax = self._get_axes(sub_vars)', '            points = ax.scatter(sub_data[\"x\"], sub_data[\"y\"], color=color, **plot_kws)', '', '            if \"hue\" in self.variables:', '                points.set_facecolors(self._hue_map(sub_data[\"hue\"]))', '', '            if edgecolor == \"gray\":  # XXX TODO change to \"auto\"', '                points.set_edgecolors(self._get_gray(points.get_facecolors()))', '            else:', '                points.set_edgecolors(edgecolor)', '', '        # Finalize the axes details', '        if self.legend == \"auto\":', '            show_legend = not self._redundant_hue and self.input_format != \"wide\"', '        else:', '            show_legend = bool(self.legend)', '', '        if show_legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                ax.legend(title=self.legend_title)', '', '    def plot_swarms(', '        self,', '        dodge,', '        color,', '        edgecolor,', '        warn_thresh,', '        plot_kws,', '    ):', '', '        width = .8 * self._native_width', '        offsets = self._nested_offsets(width, dodge)', '', '        iter_vars = [self.cat_axis]', '        if dodge:', '            iter_vars.append(\"hue\")', '', '        ax = self.ax', '        point_collections = {}', '        dodge_move = 0', '', '        for sub_vars, sub_data in self.iter_data(iter_vars,', '                                                 from_comp_data=True,', '                                                 allow_empty=True):', '', '            if offsets is not None:', '                dodge_move = offsets[sub_data[\"hue\"].map(self._hue_map.levels.index)]', '', '            if not sub_data.empty:', '                sub_data[self.cat_axis] = sub_data[self.cat_axis] + dodge_move', '', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    sub_data[var] = np.power(10, sub_data[var])', '', '            ax = self._get_axes(sub_vars)', '            points = ax.scatter(sub_data[\"x\"], sub_data[\"y\"], color=color, **plot_kws)', '', '            if \"hue\" in self.variables:', '                points.set_facecolors(self._hue_map(sub_data[\"hue\"]))', '', '            if edgecolor == \"gray\":  # XXX TODO change to \"auto\"', '                points.set_edgecolors(self._get_gray(points.get_facecolors()))', '            else:', '                points.set_edgecolors(edgecolor)', '', '            if not sub_data.empty:', '                point_collections[(ax, sub_data[self.cat_axis].iloc[0])] = points', '', '        beeswarm = Beeswarm(', '            width=width, orient=self.orient, warn_thresh=warn_thresh,', '        )', '        for (ax, center), points in point_collections.items():', '            if points.get_offsets().shape[0] > 1:', '', '                def draw(points, renderer, *, center=center):', '', '                    beeswarm(points, center)', '', '                    if self.orient == \"h\":', '                        scalex = False', '                        scaley = ax.get_autoscaley_on()', '                    else:', '                        scalex = ax.get_autoscalex_on()', '                        scaley = False', '', '                    # This prevents us from undoing the nice categorical axis limits', '                    # set in _adjust_cat_axis, because that method currently leave', '                    # the autoscale flag in its original setting. It may be better', '                    # to disable autoscaling there to avoid needing to do this.', '                    fixed_scale = self.var_types[self.cat_axis] == \"categorical\"', '                    ax.update_datalim(points.get_datalim(ax.transData))', '                    if not fixed_scale and (scalex or scaley):', '                        ax.autoscale_view(scalex=scalex, scaley=scaley)', '', '                    super(points.__class__, points).draw(renderer)', '', '                points.draw = draw.__get__(points)', '', '        _draw_figure(ax.figure)', '', '        # Finalize the axes details', '        if self.legend == \"auto\":', '            show_legend = not self._redundant_hue and self.input_format != \"wide\"', '        else:', '            show_legend = bool(self.legend)', '', '        if show_legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                ax.legend(title=self.legend_title)'], 'methods': [{'name': '__init__', 'start_line': 56, 'end_line': 119, 'text': ['    def __init__(', '        self,', '        data=None,', '        variables={},', '        order=None,', '        orient=None,', '        require_numeric=False,', '        legend=\"auto\",', '    ):', '', '        super().__init__(data=data, variables=variables)', '', '        # This method takes care of some bookkeeping that is necessary because the', '        # original categorical plots (prior to the 2021 refactor) had some rules that', \"        # don't fit exactly into the logic of _core. It may be wise to have a second\", '        # round of refactoring that moves the logic deeper, but this will keep things', '        # relatively sensible for now.', '', '        # For wide data, orient determines assignment to x/y differently from the', '        # wide_structure rules in _core. If we do decide to make orient part of the', \"        # _core variable assignment, we'll want to figure out how to express that.\", '        if self.input_format == \"wide\" and orient == \"h\":', '            self.plot_data = self.plot_data.rename(columns={\"x\": \"y\", \"y\": \"x\"})', '            orig_variables = set(self.variables)', '            orig_x = self.variables.pop(\"x\", None)', '            orig_y = self.variables.pop(\"y\", None)', '            orig_x_type = self.var_types.pop(\"x\", None)', '            orig_y_type = self.var_types.pop(\"y\", None)', '            if \"x\" in orig_variables:', '                self.variables[\"y\"] = orig_x', '                self.var_types[\"y\"] = orig_x_type', '            if \"y\" in orig_variables:', '                self.variables[\"x\"] = orig_y', '                self.var_types[\"x\"] = orig_y_type', '', '        # The concept of an \"orientation\" is important to the original categorical', \"        # plots, but there's no provision for it in _core, so we need to do it here.\", '        # Note that it could be useful for the other functions in at least two ways', '        # (orienting a univariate distribution plot from long-form data and selecting', '        # the aggregation axis in lineplot), so we may want to eventually refactor it.', '        self.orient = infer_orient(', '            x=self.plot_data.get(\"x\", None),', '            y=self.plot_data.get(\"y\", None),', '            orient=orient,', '            require_numeric=require_numeric,', '        )', '', '        self.legend = legend', '', '        # Short-circuit in the case of an empty plot', '        if not self.has_xy_data:', '            return', '', '        # Categorical plots can be \"univariate\" in which case they get an anonymous', '        # category label on the opposite axis. Note: this duplicates code in the core', '        # scale_categorical function. We need to do it here because of the next line.', '        if self.cat_axis not in self.variables:', '            self.variables[self.cat_axis] = None', '            self.var_types[self.cat_axis] = \"categorical\"', '            self.plot_data[self.cat_axis] = \"\"', '', '        # Categorical variables have discrete levels that we need to track', '        cat_levels = categorical_order(self.plot_data[self.cat_axis], order)', '        self.var_levels[self.cat_axis] = cat_levels']}, {'name': '_hue_backcompat', 'start_line': 121, 'end_line': 168, 'text': ['    def _hue_backcompat(self, color, palette, hue_order, force_hue=False):', '        \"\"\"Implement backwards compatibility for hue parametrization.', '', '        Note: the force_hue parameter is used so that functions can be shown to', '        pass existing tests during refactoring and then tested for new behavior.', '        It can be removed after completion of the work.', '', '        \"\"\"', '        # The original categorical functions applied a palette to the categorical axis', '        # by default. We want to require an explicit hue mapping, to be more consistent', \"        # with how things work elsewhere now. I don't think there's any good way to\", \"        # do this gently -- because it's triggered by the default value of hue=None,\", '        # users would always get a warning, unless we introduce some sentinel \"default\"', \"        # argument for this change. That's possible, but asking users to set `hue=None`\", '        # on every call is annoying.', '        # We are keeping the logic for implementing the old behavior in with the current', '        # system so that (a) we can punt on that decision and (b) we can ensure that', '        # refactored code passes old tests.', '        default_behavior = color is None or palette is not None', '        if force_hue and \"hue\" not in self.variables and default_behavior:', '            self._redundant_hue = True', '            self.plot_data[\"hue\"] = self.plot_data[self.cat_axis]', '            self.variables[\"hue\"] = self.variables[self.cat_axis]', '            self.var_types[\"hue\"] = \"categorical\"', '            hue_order = self.var_levels[self.cat_axis]', '', '            # Because we convert the categorical axis variable to string,', '            # we need to update a dictionary palette too', '            if isinstance(palette, dict):', '                palette = {str(k): v for k, v in palette.items()}', '', '        else:', '            self._redundant_hue = False', '', '        # Previously, categorical plots had a trick where color= could seed the palette.', \"        # Because that's an explicit parameterization, we are going to give it one\", '        # release cycle with a warning before removing.', '        if \"hue\" in self.variables and palette is None and color is not None:', '            if not isinstance(color, str):', '                color = mpl.colors.to_hex(color)', '            palette = f\"dark:{color}\"', '            msg = (', '                \"Setting a gradient palette using color= is deprecated and will be \"', '                f\"removed in version 0.13. Set `palette=\\'{palette}\\'` for same effect.\"', '            )', '            warnings.warn(msg, FutureWarning)', '', '        return palette, hue_order']}, {'name': '_palette_without_hue_backcompat', 'start_line': 170, 'end_line': 180, 'text': ['    def _palette_without_hue_backcompat(self, palette, hue_order):', '        \"\"\"Provide one cycle where palette= implies hue= when not provided\"\"\"', '        if \"hue\" not in self.variables and palette is not None:', '            msg = \"Passing `palette` without assigning `hue` is deprecated.\"', '            warnings.warn(msg, FutureWarning, stacklevel=3)', '            self.legend = False', '            self.plot_data[\"hue\"] = self.plot_data[self.cat_axis]', '            self.variables[\"hue\"] = self.variables.get(self.cat_axis)', '            self.var_types[\"hue\"] = self.var_types.get(self.cat_axis)', '            hue_order = self.var_levels.get(self.cat_axis)', '        return hue_order']}, {'name': 'cat_axis', 'start_line': 183, 'end_line': 184, 'text': ['    def cat_axis(self):', '        return {\"v\": \"x\", \"h\": \"y\"}[self.orient]']}, {'name': '_get_gray', 'start_line': 186, 'end_line': 193, 'text': ['    def _get_gray(self, colors):', '        \"\"\"Get a grayscale value that looks good with color.\"\"\"', '        if not len(colors):', '            return None', '        unique_colors = np.unique(colors, axis=0)', '        light_vals = [rgb_to_hls(*rgb[:3])[1] for rgb in unique_colors]', '        lum = min(light_vals) * .6', '        return (lum, lum, lum)']}, {'name': '_adjust_cat_axis', 'start_line': 195, 'end_line': 224, 'text': ['    def _adjust_cat_axis(self, ax, axis):', '        \"\"\"Set ticks and limits for a categorical variable.\"\"\"', '        # Note: in theory, this could happen in _attach for all categorical axes', '        # But two reasons not to do that:', '        # - If it happens before plotting, autoscaling messes up the plot limits', '        # - It would change existing plots from other seaborn functions', '        if self.var_types[axis] != \"categorical\":', '            return', '', '        # If both x/y data are empty, the correct way to set up the plot is', \"        # somewhat undefined; because we don't add null category data to the plot in\", \"        # this case we don't *have* a categorical axis (yet), so best to just bail.\", '        if self.plot_data[axis].empty:', '            return', '', '        # We can infer the total number of categories (including those from previous', '        # plots that are not part of the plot we are currently making) from the number', '        # of ticks, which matplotlib sets up while doing unit conversion. This feels', '        # slightly risky, as if we are relying on something that may be a matplotlib', '        # implementation detail. But I cannot think of a better way to keep track of', '        # the state from previous categorical calls (see GH2516 for context)', '        n = len(getattr(ax, f\"get_{axis}ticks\")())', '', '        if axis == \"x\":', '            ax.xaxis.grid(False)', '            ax.set_xlim(-.5, n - .5, auto=None)', '        else:', '            ax.yaxis.grid(False)', '            # Note limits that correspond to previously-inverted y axis', '            ax.set_ylim(n - .5, -.5, auto=None)']}, {'name': '_native_width', 'start_line': 227, 'end_line': 234, 'text': ['    def _native_width(self):', '        \"\"\"Return unit of width separating categories on native numeric scale.\"\"\"', '        unique_values = np.unique(self.comp_data[self.cat_axis])', '        if len(unique_values) > 1:', '            native_width = np.nanmin(np.diff(unique_values))', '        else:', '            native_width = 1', '        return native_width']}, {'name': '_nested_offsets', 'start_line': 236, 'end_line': 247, 'text': ['    def _nested_offsets(self, width, dodge):', '        \"\"\"Return offsets for each hue level for dodged plots.\"\"\"', '        offsets = None', '        if \"hue\" in self.variables:', '            n_levels = len(self._hue_map.levels)', '            if dodge:', '                each_width = width / n_levels', '                offsets = np.linspace(0, width - each_width, n_levels)', '                offsets -= offsets.mean()', '            else:', '                offsets = np.zeros(n_levels)', '        return offsets']}, {'name': 'plot_strips', 'start_line': 255, 'end_line': 319, 'text': ['    def plot_strips(', '        self,', '        jitter,', '        dodge,', '        color,', '        edgecolor,', '        plot_kws,', '    ):', '', '        width = .8 * self._native_width', '        offsets = self._nested_offsets(width, dodge)', '', '        if jitter is True:', '            jlim = 0.1', '        else:', '            jlim = float(jitter)', '        if \"hue\" in self.variables and dodge:', '            jlim /= len(self._hue_map.levels)', '        jlim *= self._native_width', '        jitterer = partial(np.random.uniform, low=-jlim, high=+jlim)', '', '        iter_vars = [self.cat_axis]', '        if dodge:', '            iter_vars.append(\"hue\")', '', '        ax = self.ax', '        dodge_move = jitter_move = 0', '', '        for sub_vars, sub_data in self.iter_data(iter_vars,', '                                                 from_comp_data=True,', '                                                 allow_empty=True):', '            if offsets is not None and (offsets != 0).any():', '                dodge_move = offsets[sub_data[\"hue\"].map(self._hue_map.levels.index)]', '', '            jitter_move = jitterer(size=len(sub_data)) if len(sub_data) > 1 else 0', '', '            adjusted_data = sub_data[self.cat_axis] + dodge_move + jitter_move', '            sub_data[self.cat_axis] = adjusted_data', '', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    sub_data[var] = np.power(10, sub_data[var])', '', '            ax = self._get_axes(sub_vars)', '            points = ax.scatter(sub_data[\"x\"], sub_data[\"y\"], color=color, **plot_kws)', '', '            if \"hue\" in self.variables:', '                points.set_facecolors(self._hue_map(sub_data[\"hue\"]))', '', '            if edgecolor == \"gray\":  # XXX TODO change to \"auto\"', '                points.set_edgecolors(self._get_gray(points.get_facecolors()))', '            else:', '                points.set_edgecolors(edgecolor)', '', '        # Finalize the axes details', '        if self.legend == \"auto\":', '            show_legend = not self._redundant_hue and self.input_format != \"wide\"', '        else:', '            show_legend = bool(self.legend)', '', '        if show_legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                ax.legend(title=self.legend_title)']}, {'name': 'plot_swarms', 'start_line': 321, 'end_line': 411, 'text': ['    def plot_swarms(', '        self,', '        dodge,', '        color,', '        edgecolor,', '        warn_thresh,', '        plot_kws,', '    ):', '', '        width = .8 * self._native_width', '        offsets = self._nested_offsets(width, dodge)', '', '        iter_vars = [self.cat_axis]', '        if dodge:', '            iter_vars.append(\"hue\")', '', '        ax = self.ax', '        point_collections = {}', '        dodge_move = 0', '', '        for sub_vars, sub_data in self.iter_data(iter_vars,', '                                                 from_comp_data=True,', '                                                 allow_empty=True):', '', '            if offsets is not None:', '                dodge_move = offsets[sub_data[\"hue\"].map(self._hue_map.levels.index)]', '', '            if not sub_data.empty:', '                sub_data[self.cat_axis] = sub_data[self.cat_axis] + dodge_move', '', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    sub_data[var] = np.power(10, sub_data[var])', '', '            ax = self._get_axes(sub_vars)', '            points = ax.scatter(sub_data[\"x\"], sub_data[\"y\"], color=color, **plot_kws)', '', '            if \"hue\" in self.variables:', '                points.set_facecolors(self._hue_map(sub_data[\"hue\"]))', '', '            if edgecolor == \"gray\":  # XXX TODO change to \"auto\"', '                points.set_edgecolors(self._get_gray(points.get_facecolors()))', '            else:', '                points.set_edgecolors(edgecolor)', '', '            if not sub_data.empty:', '                point_collections[(ax, sub_data[self.cat_axis].iloc[0])] = points', '', '        beeswarm = Beeswarm(', '            width=width, orient=self.orient, warn_thresh=warn_thresh,', '        )', '        for (ax, center), points in point_collections.items():', '            if points.get_offsets().shape[0] > 1:', '', '                def draw(points, renderer, *, center=center):', '', '                    beeswarm(points, center)', '', '                    if self.orient == \"h\":', '                        scalex = False', '                        scaley = ax.get_autoscaley_on()', '                    else:', '                        scalex = ax.get_autoscalex_on()', '                        scaley = False', '', '                    # This prevents us from undoing the nice categorical axis limits', '                    # set in _adjust_cat_axis, because that method currently leave', '                    # the autoscale flag in its original setting. It may be better', '                    # to disable autoscaling there to avoid needing to do this.', '                    fixed_scale = self.var_types[self.cat_axis] == \"categorical\"', '                    ax.update_datalim(points.get_datalim(ax.transData))', '                    if not fixed_scale and (scalex or scaley):', '                        ax.autoscale_view(scalex=scalex, scaley=scaley)', '', '                    super(points.__class__, points).draw(renderer)', '', '                points.draw = draw.__get__(points)', '', '        _draw_figure(ax.figure)', '', '        # Finalize the axes details', '        if self.legend == \"auto\":', '            show_legend = not self._redundant_hue and self.input_format != \"wide\"', '        else:', '            show_legend = bool(self.legend)', '', '        if show_legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                ax.legend(title=self.legend_title)']}]}, {'name': '_CategoricalFacetPlotter', 'start_line': 414, 'end_line': 416, 'text': ['class _CategoricalFacetPlotter(_CategoricalPlotterNew):', '', '    semantics = _CategoricalPlotterNew.semantics + (\"col\", \"row\")'], 'methods': []}, {'name': '_CategoricalPlotter', 'start_line': 419, 'end_line': 776, 'text': ['class _CategoricalPlotter:', '', '    width = .8', '    default_palette = \"light\"', '    require_numeric = True', '', '    def establish_variables(self, x=None, y=None, hue=None, data=None,', '                            orient=None, order=None, hue_order=None,', '                            units=None):', '        \"\"\"Convert input specification into a common representation.\"\"\"', '        # Option 1:', '        # We are plotting a wide-form dataset', '        # -----------------------------------', '        if x is None and y is None:', '', '            # Do a sanity check on the inputs', '            if hue is not None:', '                error = \"Cannot use `hue` without `x` and `y`\"', '                raise ValueError(error)', '', '            # No hue grouping with wide inputs', '            plot_hues = None', '            hue_title = None', '            hue_names = None', '', '            # No statistical units with wide inputs', '            plot_units = None', '', \"            # We also won't get a axes labels here\", '            value_label = None', '            group_label = None', '', '            # Option 1a:', '            # The input data is a Pandas DataFrame', '            # ------------------------------------', '', '            if isinstance(data, pd.DataFrame):', '', '                # Order the data correctly', '                if order is None:', '                    order = []', '                    # Reduce to just numeric columns', '                    for col in data:', '                        if variable_type(data[col]) == \"numeric\":', '                            order.append(col)', '                plot_data = data[order]', '                group_names = order', '                group_label = data.columns.name', '', '                # Convert to a list of arrays, the common representation', '                iter_data = plot_data.items()', '                plot_data = [np.asarray(s, float) for k, s in iter_data]', '', '            # Option 1b:', '            # The input data is an array or list', '            # ----------------------------------', '', '            else:', '', \"                # We can't reorder the data\", '                if order is not None:', '                    error = \"Input data must be a pandas object to reorder\"', '                    raise ValueError(error)', '', '                # The input data is an array', '                if hasattr(data, \"shape\"):', '                    if len(data.shape) == 1:', '                        if np.isscalar(data[0]):', '                            plot_data = [data]', '                        else:', '                            plot_data = list(data)', '                    elif len(data.shape) == 2:', '                        nr, nc = data.shape', '                        if nr == 1 or nc == 1:', '                            plot_data = [data.ravel()]', '                        else:', '                            plot_data = [data[:, i] for i in range(nc)]', '                    else:', '                        error = (\"Input `data` can have no \"', '                                 \"more than 2 dimensions\")', '                        raise ValueError(error)', '', '                # Check if `data` is None to let us bail out here (for testing)', '                elif data is None:', '                    plot_data = [[]]', '', '                # The input data is a flat list', '                elif np.isscalar(data[0]):', '                    plot_data = [data]', '', '                # The input data is a nested list', '                # This will catch some things that might fail later', '                # but exhaustive checks are hard', '                else:', '                    plot_data = data', '', '                # Convert to a list of arrays, the common representation', '                plot_data = [np.asarray(d, float) for d in plot_data]', '', '                # The group names will just be numeric indices', '                group_names = list(range(len(plot_data)))', '', '            # Figure out the plotting orientation', '            orient = \"h\" if str(orient).startswith(\"h\") else \"v\"', '', '        # Option 2:', '        # We are plotting a long-form dataset', '        # -----------------------------------', '', '        else:', '', '            # See if we need to get variables from `data`', '            if data is not None:', '                x = data.get(x, x)', '                y = data.get(y, y)', '                hue = data.get(hue, hue)', '                units = data.get(units, units)', '', '            # Validate the inputs', '            for var in [x, y, hue, units]:', '                if isinstance(var, str):', '                    err = f\"Could not interpret input \\'{var}\\'\"', '                    raise ValueError(err)', '', '            # Figure out the plotting orientation', '            orient = infer_orient(', '                x, y, orient, require_numeric=self.require_numeric', '            )', '', '            # Option 2a:', '            # We are plotting a single set of data', '            # ------------------------------------', '            if x is None or y is None:', '', '                # Determine where the data are', '                vals = y if x is None else x', '', '                # Put them into the common representation', '                plot_data = [np.asarray(vals)]', '', '                # Get a label for the value axis', '                if hasattr(vals, \"name\"):', '                    value_label = vals.name', '                else:', '                    value_label = None', '', '                # This plot will not have group labels or hue nesting', '                groups = None', '                group_label = None', '                group_names = []', '                plot_hues = None', '                hue_names = None', '                hue_title = None', '                plot_units = None', '', '            # Option 2b:', '            # We are grouping the data values by another variable', '            # ---------------------------------------------------', '            else:', '', '                # Determine which role each variable will play', '                if orient == \"v\":', '                    vals, groups = y, x', '                else:', '                    vals, groups = x, y', '', '                # Get the categorical axis label', '                group_label = None', '                if hasattr(groups, \"name\"):', '                    group_label = groups.name', '', '                # Get the order on the categorical axis', '                group_names = categorical_order(groups, order)', '', '                # Group the numeric data', '                plot_data, value_label = self._group_longform(vals, groups,', '                                                              group_names)', '', '                # Now handle the hue levels for nested ordering', '                if hue is None:', '                    plot_hues = None', '                    hue_title = None', '                    hue_names = None', '                else:', '', '                    # Get the order of the hue levels', '                    hue_names = categorical_order(hue, hue_order)', '', '                    # Group the hue data', '                    plot_hues, hue_title = self._group_longform(hue, groups,', '                                                                group_names)', '', '                # Now handle the units for nested observations', '                if units is None:', '                    plot_units = None', '                else:', '                    plot_units, _ = self._group_longform(units, groups,', '                                                         group_names)', '', '        # Assign object attributes', '        # ------------------------', '        self.orient = orient', '        self.plot_data = plot_data', '        self.group_label = group_label', '        self.value_label = value_label', '        self.group_names = group_names', '        self.plot_hues = plot_hues', '        self.hue_title = hue_title', '        self.hue_names = hue_names', '        self.plot_units = plot_units', '', '    def _group_longform(self, vals, grouper, order):', '        \"\"\"Group a long-form variable by another with correct order.\"\"\"', '        # Ensure that the groupby will work', '        if not isinstance(vals, pd.Series):', '            if isinstance(grouper, pd.Series):', '                index = grouper.index', '            else:', '                index = None', '            vals = pd.Series(vals, index=index)', '', '        # Group the val data', '        grouped_vals = vals.groupby(grouper)', '        out_data = []', '        for g in order:', '            try:', '                g_vals = grouped_vals.get_group(g)', '            except KeyError:', '                g_vals = np.array([])', '            out_data.append(g_vals)', '', '        # Get the vals axis label', '        label = vals.name', '', '        return out_data, label', '', '    def establish_colors(self, color, palette, saturation):', '        \"\"\"Get a list of colors for the main component of the plots.\"\"\"', '        if self.hue_names is None:', '            n_colors = len(self.plot_data)', '        else:', '            n_colors = len(self.hue_names)', '', '        # Determine the main colors', '        if color is None and palette is None:', '            # Determine whether the current palette will have enough values', \"            # If not, we'll default to the husl palette so each is distinct\", '            current_palette = utils.get_color_cycle()', '            if n_colors <= len(current_palette):', '                colors = color_palette(n_colors=n_colors)', '            else:', '                colors = husl_palette(n_colors, l=.7)  # noqa', '', '        elif palette is None:', '            # When passing a specific color, the interpretation depends', '            # on whether there is a hue variable or not.', '            # If so, we will make a blend palette so that the different', '            # levels have some amount of variation.', '            if self.hue_names is None:', '                colors = [color] * n_colors', '            else:', '                if self.default_palette == \"light\":', '                    colors = light_palette(color, n_colors)', '                elif self.default_palette == \"dark\":', '                    colors = dark_palette(color, n_colors)', '                else:', '                    raise RuntimeError(\"No default palette specified\")', '        else:', '', '            # Let `palette` be a dict mapping level to color', '            if isinstance(palette, dict):', '                if self.hue_names is None:', '                    levels = self.group_names', '                else:', '                    levels = self.hue_names', '                palette = [palette[l] for l in levels]', '', '            colors = color_palette(palette, n_colors)', '', '        # Desaturate a bit because these are patches', '        if saturation < 1:', '            colors = color_palette(colors, desat=saturation)', '', '        # Convert the colors to a common representations', '        rgb_colors = color_palette(colors)', '', '        # Determine the gray color to use for the lines framing the plot', '        light_vals = [rgb_to_hls(*c)[1] for c in rgb_colors]', '        lum = min(light_vals) * .6', '        gray = mpl.colors.rgb2hex((lum, lum, lum))', '', '        # Assign object attributes', '        self.colors = rgb_colors', '        self.gray = gray', '', '    @property', '    def hue_offsets(self):', '        \"\"\"A list of center positions for plots when hue nesting is used.\"\"\"', '        n_levels = len(self.hue_names)', '        if self.dodge:', '            each_width = self.width / n_levels', '            offsets = np.linspace(0, self.width - each_width, n_levels)', '            offsets -= offsets.mean()', '        else:', '            offsets = np.zeros(n_levels)', '', '        return offsets', '', '    @property', '    def nested_width(self):', '        \"\"\"A float with the width of plot elements when hue nesting is used.\"\"\"', '        if self.dodge:', '            width = self.width / len(self.hue_names) * .98', '        else:', '            width = self.width', '        return width', '', '    def annotate_axes(self, ax):', '        \"\"\"Add descriptive labels to an Axes object.\"\"\"', '        if self.orient == \"v\":', '            xlabel, ylabel = self.group_label, self.value_label', '        else:', '            xlabel, ylabel = self.value_label, self.group_label', '', '        if xlabel is not None:', '            ax.set_xlabel(xlabel)', '        if ylabel is not None:', '            ax.set_ylabel(ylabel)', '', '        group_names = self.group_names', '        if not group_names:', '            group_names = [\"\" for _ in range(len(self.plot_data))]', '', '        if self.orient == \"v\":', '            ax.set_xticks(np.arange(len(self.plot_data)))', '            ax.set_xticklabels(group_names)', '        else:', '            ax.set_yticks(np.arange(len(self.plot_data)))', '            ax.set_yticklabels(group_names)', '', '        if self.orient == \"v\":', '            ax.xaxis.grid(False)', '            ax.set_xlim(-.5, len(self.plot_data) - .5, auto=None)', '        else:', '            ax.yaxis.grid(False)', '            ax.set_ylim(-.5, len(self.plot_data) - .5, auto=None)', '', '        if self.hue_names is not None:', '            ax.legend(loc=\"best\", title=self.hue_title)', '', '    def add_legend_data(self, ax, color, label):', '        \"\"\"Add a dummy patch object so we can get legend data.\"\"\"', '        rect = plt.Rectangle([0, 0], 0, 0,', '                             linewidth=self.linewidth / 2,', '                             edgecolor=self.gray,', '                             facecolor=color,', '                             label=label)', '        ax.add_patch(rect)'], 'methods': [{'name': 'establish_variables', 'start_line': 425, 'end_line': 628, 'text': ['    def establish_variables(self, x=None, y=None, hue=None, data=None,', '                            orient=None, order=None, hue_order=None,', '                            units=None):', '        \"\"\"Convert input specification into a common representation.\"\"\"', '        # Option 1:', '        # We are plotting a wide-form dataset', '        # -----------------------------------', '        if x is None and y is None:', '', '            # Do a sanity check on the inputs', '            if hue is not None:', '                error = \"Cannot use `hue` without `x` and `y`\"', '                raise ValueError(error)', '', '            # No hue grouping with wide inputs', '            plot_hues = None', '            hue_title = None', '            hue_names = None', '', '            # No statistical units with wide inputs', '            plot_units = None', '', \"            # We also won't get a axes labels here\", '            value_label = None', '            group_label = None', '', '            # Option 1a:', '            # The input data is a Pandas DataFrame', '            # ------------------------------------', '', '            if isinstance(data, pd.DataFrame):', '', '                # Order the data correctly', '                if order is None:', '                    order = []', '                    # Reduce to just numeric columns', '                    for col in data:', '                        if variable_type(data[col]) == \"numeric\":', '                            order.append(col)', '                plot_data = data[order]', '                group_names = order', '                group_label = data.columns.name', '', '                # Convert to a list of arrays, the common representation', '                iter_data = plot_data.items()', '                plot_data = [np.asarray(s, float) for k, s in iter_data]', '', '            # Option 1b:', '            # The input data is an array or list', '            # ----------------------------------', '', '            else:', '', \"                # We can't reorder the data\", '                if order is not None:', '                    error = \"Input data must be a pandas object to reorder\"', '                    raise ValueError(error)', '', '                # The input data is an array', '                if hasattr(data, \"shape\"):', '                    if len(data.shape) == 1:', '                        if np.isscalar(data[0]):', '                            plot_data = [data]', '                        else:', '                            plot_data = list(data)', '                    elif len(data.shape) == 2:', '                        nr, nc = data.shape', '                        if nr == 1 or nc == 1:', '                            plot_data = [data.ravel()]', '                        else:', '                            plot_data = [data[:, i] for i in range(nc)]', '                    else:', '                        error = (\"Input `data` can have no \"', '                                 \"more than 2 dimensions\")', '                        raise ValueError(error)', '', '                # Check if `data` is None to let us bail out here (for testing)', '                elif data is None:', '                    plot_data = [[]]', '', '                # The input data is a flat list', '                elif np.isscalar(data[0]):', '                    plot_data = [data]', '', '                # The input data is a nested list', '                # This will catch some things that might fail later', '                # but exhaustive checks are hard', '                else:', '                    plot_data = data', '', '                # Convert to a list of arrays, the common representation', '                plot_data = [np.asarray(d, float) for d in plot_data]', '', '                # The group names will just be numeric indices', '                group_names = list(range(len(plot_data)))', '', '            # Figure out the plotting orientation', '            orient = \"h\" if str(orient).startswith(\"h\") else \"v\"', '', '        # Option 2:', '        # We are plotting a long-form dataset', '        # -----------------------------------', '', '        else:', '', '            # See if we need to get variables from `data`', '            if data is not None:', '                x = data.get(x, x)', '                y = data.get(y, y)', '                hue = data.get(hue, hue)', '                units = data.get(units, units)', '', '            # Validate the inputs', '            for var in [x, y, hue, units]:', '                if isinstance(var, str):', '                    err = f\"Could not interpret input \\'{var}\\'\"', '                    raise ValueError(err)', '', '            # Figure out the plotting orientation', '            orient = infer_orient(', '                x, y, orient, require_numeric=self.require_numeric', '            )', '', '            # Option 2a:', '            # We are plotting a single set of data', '            # ------------------------------------', '            if x is None or y is None:', '', '                # Determine where the data are', '                vals = y if x is None else x', '', '                # Put them into the common representation', '                plot_data = [np.asarray(vals)]', '', '                # Get a label for the value axis', '                if hasattr(vals, \"name\"):', '                    value_label = vals.name', '                else:', '                    value_label = None', '', '                # This plot will not have group labels or hue nesting', '                groups = None', '                group_label = None', '                group_names = []', '                plot_hues = None', '                hue_names = None', '                hue_title = None', '                plot_units = None', '', '            # Option 2b:', '            # We are grouping the data values by another variable', '            # ---------------------------------------------------', '            else:', '', '                # Determine which role each variable will play', '                if orient == \"v\":', '                    vals, groups = y, x', '                else:', '                    vals, groups = x, y', '', '                # Get the categorical axis label', '                group_label = None', '                if hasattr(groups, \"name\"):', '                    group_label = groups.name', '', '                # Get the order on the categorical axis', '                group_names = categorical_order(groups, order)', '', '                # Group the numeric data', '                plot_data, value_label = self._group_longform(vals, groups,', '                                                              group_names)', '', '                # Now handle the hue levels for nested ordering', '                if hue is None:', '                    plot_hues = None', '                    hue_title = None', '                    hue_names = None', '                else:', '', '                    # Get the order of the hue levels', '                    hue_names = categorical_order(hue, hue_order)', '', '                    # Group the hue data', '                    plot_hues, hue_title = self._group_longform(hue, groups,', '                                                                group_names)', '', '                # Now handle the units for nested observations', '                if units is None:', '                    plot_units = None', '                else:', '                    plot_units, _ = self._group_longform(units, groups,', '                                                         group_names)', '', '        # Assign object attributes', '        # ------------------------', '        self.orient = orient', '        self.plot_data = plot_data', '        self.group_label = group_label', '        self.value_label = value_label', '        self.group_names = group_names', '        self.plot_hues = plot_hues', '        self.hue_title = hue_title', '        self.hue_names = hue_names', '        self.plot_units = plot_units']}, {'name': '_group_longform', 'start_line': 630, 'end_line': 653, 'text': ['    def _group_longform(self, vals, grouper, order):', '        \"\"\"Group a long-form variable by another with correct order.\"\"\"', '        # Ensure that the groupby will work', '        if not isinstance(vals, pd.Series):', '            if isinstance(grouper, pd.Series):', '                index = grouper.index', '            else:', '                index = None', '            vals = pd.Series(vals, index=index)', '', '        # Group the val data', '        grouped_vals = vals.groupby(grouper)', '        out_data = []', '        for g in order:', '            try:', '                g_vals = grouped_vals.get_group(g)', '            except KeyError:', '                g_vals = np.array([])', '            out_data.append(g_vals)', '', '        # Get the vals axis label', '        label = vals.name', '', '        return out_data, label']}, {'name': 'establish_colors', 'start_line': 655, 'end_line': 712, 'text': ['    def establish_colors(self, color, palette, saturation):', '        \"\"\"Get a list of colors for the main component of the plots.\"\"\"', '        if self.hue_names is None:', '            n_colors = len(self.plot_data)', '        else:', '            n_colors = len(self.hue_names)', '', '        # Determine the main colors', '        if color is None and palette is None:', '            # Determine whether the current palette will have enough values', \"            # If not, we'll default to the husl palette so each is distinct\", '            current_palette = utils.get_color_cycle()', '            if n_colors <= len(current_palette):', '                colors = color_palette(n_colors=n_colors)', '            else:', '                colors = husl_palette(n_colors, l=.7)  # noqa', '', '        elif palette is None:', '            # When passing a specific color, the interpretation depends', '            # on whether there is a hue variable or not.', '            # If so, we will make a blend palette so that the different', '            # levels have some amount of variation.', '            if self.hue_names is None:', '                colors = [color] * n_colors', '            else:', '                if self.default_palette == \"light\":', '                    colors = light_palette(color, n_colors)', '                elif self.default_palette == \"dark\":', '                    colors = dark_palette(color, n_colors)', '                else:', '                    raise RuntimeError(\"No default palette specified\")', '        else:', '', '            # Let `palette` be a dict mapping level to color', '            if isinstance(palette, dict):', '                if self.hue_names is None:', '                    levels = self.group_names', '                else:', '                    levels = self.hue_names', '                palette = [palette[l] for l in levels]', '', '            colors = color_palette(palette, n_colors)', '', '        # Desaturate a bit because these are patches', '        if saturation < 1:', '            colors = color_palette(colors, desat=saturation)', '', '        # Convert the colors to a common representations', '        rgb_colors = color_palette(colors)', '', '        # Determine the gray color to use for the lines framing the plot', '        light_vals = [rgb_to_hls(*c)[1] for c in rgb_colors]', '        lum = min(light_vals) * .6', '        gray = mpl.colors.rgb2hex((lum, lum, lum))', '', '        # Assign object attributes', '        self.colors = rgb_colors', '        self.gray = gray']}, {'name': 'hue_offsets', 'start_line': 715, 'end_line': 725, 'text': ['    def hue_offsets(self):', '        \"\"\"A list of center positions for plots when hue nesting is used.\"\"\"', '        n_levels = len(self.hue_names)', '        if self.dodge:', '            each_width = self.width / n_levels', '            offsets = np.linspace(0, self.width - each_width, n_levels)', '            offsets -= offsets.mean()', '        else:', '            offsets = np.zeros(n_levels)', '', '        return offsets']}, {'name': 'nested_width', 'start_line': 728, 'end_line': 734, 'text': ['    def nested_width(self):', '        \"\"\"A float with the width of plot elements when hue nesting is used.\"\"\"', '        if self.dodge:', '            width = self.width / len(self.hue_names) * .98', '        else:', '            width = self.width', '        return width']}, {'name': 'annotate_axes', 'start_line': 736, 'end_line': 767, 'text': ['    def annotate_axes(self, ax):', '        \"\"\"Add descriptive labels to an Axes object.\"\"\"', '        if self.orient == \"v\":', '            xlabel, ylabel = self.group_label, self.value_label', '        else:', '            xlabel, ylabel = self.value_label, self.group_label', '', '        if xlabel is not None:', '            ax.set_xlabel(xlabel)', '        if ylabel is not None:', '            ax.set_ylabel(ylabel)', '', '        group_names = self.group_names', '        if not group_names:', '            group_names = [\"\" for _ in range(len(self.plot_data))]', '', '        if self.orient == \"v\":', '            ax.set_xticks(np.arange(len(self.plot_data)))', '            ax.set_xticklabels(group_names)', '        else:', '            ax.set_yticks(np.arange(len(self.plot_data)))', '            ax.set_yticklabels(group_names)', '', '        if self.orient == \"v\":', '            ax.xaxis.grid(False)', '            ax.set_xlim(-.5, len(self.plot_data) - .5, auto=None)', '        else:', '            ax.yaxis.grid(False)', '            ax.set_ylim(-.5, len(self.plot_data) - .5, auto=None)', '', '        if self.hue_names is not None:', '            ax.legend(loc=\"best\", title=self.hue_title)']}, {'name': 'add_legend_data', 'start_line': 769, 'end_line': 776, 'text': ['    def add_legend_data(self, ax, color, label):', '        \"\"\"Add a dummy patch object so we can get legend data.\"\"\"', '        rect = plt.Rectangle([0, 0], 0, 0,', '                             linewidth=self.linewidth / 2,', '                             edgecolor=self.gray,', '                             facecolor=color,', '                             label=label)', '        ax.add_patch(rect)']}]}, {'name': '_BoxPlotter', 'start_line': 779, 'end_line': 891, 'text': ['class _BoxPlotter(_CategoricalPlotter):', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 orient, color, palette, saturation,', '                 width, dodge, fliersize, linewidth):', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)', '', '        self.dodge = dodge', '        self.width = width', '        self.fliersize = fliersize', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth', '', '    def draw_boxplot(self, ax, kws):', '        \"\"\"Use matplotlib to draw a boxplot on an Axes.\"\"\"', '        vert = self.orient == \"v\"', '', '        props = {}', '        for obj in [\"box\", \"whisker\", \"cap\", \"median\", \"flier\"]:', '            props[obj] = kws.pop(obj + \"props\", {})', '', '        for i, group_data in enumerate(self.plot_data):', '', '            if self.plot_hues is None:', '', '                # Handle case where there is data at this level', '                if group_data.size == 0:', '                    continue', '', '                # Draw a single box or a set of boxes', '                # with a single level of grouping', '                box_data = np.asarray(remove_na(group_data))', '', '                # Handle case where there is no non-null data', '                if box_data.size == 0:', '                    continue', '', '                artist_dict = ax.boxplot(box_data,', '                                         vert=vert,', '                                         patch_artist=True,', '                                         positions=[i],', '                                         widths=self.width,', '                                         **kws)', '                color = self.colors[i]', '                self.restyle_boxplot(artist_dict, color, props)', '            else:', '                # Draw nested groups of boxes', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Add a legend for this hue level', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle case where there is data at this level', '                    if group_data.size == 0:', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    box_data = np.asarray(remove_na(group_data[hue_mask]))', '', '                    # Handle case where there is no non-null data', '                    if box_data.size == 0:', '                        continue', '', '                    center = i + offsets[j]', '                    artist_dict = ax.boxplot(box_data,', '                                             vert=vert,', '                                             patch_artist=True,', '                                             positions=[center],', '                                             widths=self.nested_width,', '                                             **kws)', '                    self.restyle_boxplot(artist_dict, self.colors[j], props)', '                    # Add legend data, but just for one set of boxes', '', '    def restyle_boxplot(self, artist_dict, color, props):', '        \"\"\"Take a drawn matplotlib boxplot and make it look nice.\"\"\"', '        for box in artist_dict[\"boxes\"]:', '            box.update(dict(facecolor=color,', '                            zorder=.9,', '                            edgecolor=self.gray,', '                            linewidth=self.linewidth))', '            box.update(props[\"box\"])', '        for whisk in artist_dict[\"whiskers\"]:', '            whisk.update(dict(color=self.gray,', '                              linewidth=self.linewidth,', '                              linestyle=\"-\"))', '            whisk.update(props[\"whisker\"])', '        for cap in artist_dict[\"caps\"]:', '            cap.update(dict(color=self.gray,', '                            linewidth=self.linewidth))', '            cap.update(props[\"cap\"])', '        for med in artist_dict[\"medians\"]:', '            med.update(dict(color=self.gray,', '                            linewidth=self.linewidth))', '            med.update(props[\"median\"])', '        for fly in artist_dict[\"fliers\"]:', '            fly.update(dict(markerfacecolor=self.gray,', '                            marker=\"d\",', '                            markeredgecolor=self.gray,', '                            markersize=self.fliersize))', '            fly.update(props[\"flier\"])', '', '    def plot(self, ax, boxplot_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_boxplot(ax, boxplot_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()'], 'methods': [{'name': '__init__', 'start_line': 781, 'end_line': 794, 'text': ['    def __init__(self, x, y, hue, data, order, hue_order,', '                 orient, color, palette, saturation,', '                 width, dodge, fliersize, linewidth):', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)', '', '        self.dodge = dodge', '        self.width = width', '        self.fliersize = fliersize', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth']}, {'name': 'draw_boxplot', 'start_line': 796, 'end_line': 855, 'text': ['    def draw_boxplot(self, ax, kws):', '        \"\"\"Use matplotlib to draw a boxplot on an Axes.\"\"\"', '        vert = self.orient == \"v\"', '', '        props = {}', '        for obj in [\"box\", \"whisker\", \"cap\", \"median\", \"flier\"]:', '            props[obj] = kws.pop(obj + \"props\", {})', '', '        for i, group_data in enumerate(self.plot_data):', '', '            if self.plot_hues is None:', '', '                # Handle case where there is data at this level', '                if group_data.size == 0:', '                    continue', '', '                # Draw a single box or a set of boxes', '                # with a single level of grouping', '                box_data = np.asarray(remove_na(group_data))', '', '                # Handle case where there is no non-null data', '                if box_data.size == 0:', '                    continue', '', '                artist_dict = ax.boxplot(box_data,', '                                         vert=vert,', '                                         patch_artist=True,', '                                         positions=[i],', '                                         widths=self.width,', '                                         **kws)', '                color = self.colors[i]', '                self.restyle_boxplot(artist_dict, color, props)', '            else:', '                # Draw nested groups of boxes', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Add a legend for this hue level', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle case where there is data at this level', '                    if group_data.size == 0:', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    box_data = np.asarray(remove_na(group_data[hue_mask]))', '', '                    # Handle case where there is no non-null data', '                    if box_data.size == 0:', '                        continue', '', '                    center = i + offsets[j]', '                    artist_dict = ax.boxplot(box_data,', '                                             vert=vert,', '                                             patch_artist=True,', '                                             positions=[center],', '                                             widths=self.nested_width,', '                                             **kws)', '                    self.restyle_boxplot(artist_dict, self.colors[j], props)']}, {'name': 'restyle_boxplot', 'start_line': 858, 'end_line': 884, 'text': ['    def restyle_boxplot(self, artist_dict, color, props):', '        \"\"\"Take a drawn matplotlib boxplot and make it look nice.\"\"\"', '        for box in artist_dict[\"boxes\"]:', '            box.update(dict(facecolor=color,', '                            zorder=.9,', '                            edgecolor=self.gray,', '                            linewidth=self.linewidth))', '            box.update(props[\"box\"])', '        for whisk in artist_dict[\"whiskers\"]:', '            whisk.update(dict(color=self.gray,', '                              linewidth=self.linewidth,', '                              linestyle=\"-\"))', '            whisk.update(props[\"whisker\"])', '        for cap in artist_dict[\"caps\"]:', '            cap.update(dict(color=self.gray,', '                            linewidth=self.linewidth))', '            cap.update(props[\"cap\"])', '        for med in artist_dict[\"medians\"]:', '            med.update(dict(color=self.gray,', '                            linewidth=self.linewidth))', '            med.update(props[\"median\"])', '        for fly in artist_dict[\"fliers\"]:', '            fly.update(dict(markerfacecolor=self.gray,', '                            marker=\"d\",', '                            markeredgecolor=self.gray,', '                            markersize=self.fliersize))', '            fly.update(props[\"flier\"])']}, {'name': 'plot', 'start_line': 886, 'end_line': 891, 'text': ['    def plot(self, ax, boxplot_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_boxplot(ax, boxplot_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()']}]}, {'name': '_ViolinPlotter', 'start_line': 894, 'end_line': 1422, 'text': ['class _ViolinPlotter(_CategoricalPlotter):', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 bw, cut, scale, scale_hue, gridsize,', '                 width, inner, split, dodge, orient, linewidth,', '                 color, palette, saturation):', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)', '        self.estimate_densities(bw, cut, scale, scale_hue, gridsize)', '', '        self.gridsize = gridsize', '        self.width = width', '        self.dodge = dodge', '', '        if inner is not None:', '            if not any([inner.startswith(\"quart\"),', '                        inner.startswith(\"box\"),', '                        inner.startswith(\"stick\"),', '                        inner.startswith(\"point\")]):', '                err = f\"Inner style \\'{inner}\\' not recognized\"', '                raise ValueError(err)', '        self.inner = inner', '', '        if split and self.hue_names is not None and len(self.hue_names) != 2:', '            msg = \"There must be exactly two hue levels to use `split`.\\'\"', '            raise ValueError(msg)', '        self.split = split', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth', '', '    def estimate_densities(self, bw, cut, scale, scale_hue, gridsize):', '        \"\"\"Find the support and density for all of the data.\"\"\"', '        # Initialize data structures to keep track of plotting data', '        if self.hue_names is None:', '            support = []', '            density = []', '            counts = np.zeros(len(self.plot_data))', '            max_density = np.zeros(len(self.plot_data))', '        else:', '            support = [[] for _ in self.plot_data]', '            density = [[] for _ in self.plot_data]', '            size = len(self.group_names), len(self.hue_names)', '            counts = np.zeros(size)', '            max_density = np.zeros(size)', '', '        for i, group_data in enumerate(self.plot_data):', '', '            # Option 1: we have a single level of grouping', '            # --------------------------------------------', '', '            if self.plot_hues is None:', '', '                # Strip missing datapoints', '                kde_data = remove_na(group_data)', '', '                # Handle special case of no data at this level', '                if kde_data.size == 0:', '                    support.append(np.array([]))', '                    density.append(np.array([1.]))', '                    counts[i] = 0', '                    max_density[i] = 0', '                    continue', '', '                # Handle special case of a single unique datapoint', '                elif np.unique(kde_data).size == 1:', '                    support.append(np.unique(kde_data))', '                    density.append(np.array([1.]))', '                    counts[i] = 1', '                    max_density[i] = 0', '                    continue', '', '                # Fit the KDE and get the used bandwidth size', '                kde, bw_used = self.fit_kde(kde_data, bw)', '', '                # Determine the support grid and get the density over it', '                support_i = self.kde_support(kde_data, bw_used, cut, gridsize)', '                density_i = kde.evaluate(support_i)', '', '                # Update the data structures with these results', '                support.append(support_i)', '                density.append(density_i)', '                counts[i] = kde_data.size', '                max_density[i] = density_i.max()', '', '            # Option 2: we have nested grouping by a hue variable', '            # ---------------------------------------------------', '', '            else:', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Handle special case of no data at this category level', '                    if not group_data.size:', '                        support[i].append(np.array([]))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 0', '                        max_density[i, j] = 0', '                        continue', '', '                    # Select out the observations for this hue level', '                    hue_mask = self.plot_hues[i] == hue_level', '', '                    # Strip missing datapoints', '                    kde_data = remove_na(group_data[hue_mask])', '', '                    # Handle special case of no data at this level', '                    if kde_data.size == 0:', '                        support[i].append(np.array([]))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 0', '                        max_density[i, j] = 0', '                        continue', '', '                    # Handle special case of a single unique datapoint', '                    elif np.unique(kde_data).size == 1:', '                        support[i].append(np.unique(kde_data))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 1', '                        max_density[i, j] = 0', '                        continue', '', '                    # Fit the KDE and get the used bandwidth size', '                    kde, bw_used = self.fit_kde(kde_data, bw)', '', '                    # Determine the support grid and get the density over it', '                    support_ij = self.kde_support(kde_data, bw_used,', '                                                  cut, gridsize)', '                    density_ij = kde.evaluate(support_ij)', '', '                    # Update the data structures with these results', '                    support[i].append(support_ij)', '                    density[i].append(density_ij)', '                    counts[i, j] = kde_data.size', '                    max_density[i, j] = density_ij.max()', '', '        # Scale the height of the density curve.', '        # For a violinplot the density is non-quantitative.', '        # The objective here is to scale the curves relative to 1 so that', '        # they can be multiplied by the width parameter during plotting.', '', '        if scale == \"area\":', '            self.scale_area(density, max_density, scale_hue)', '', '        elif scale == \"width\":', '            self.scale_width(density)', '', '        elif scale == \"count\":', '            self.scale_count(density, counts, scale_hue)', '', '        else:', '            raise ValueError(f\"scale method \\'{scale}\\' not recognized\")', '', '        # Set object attributes that will be used while plotting', '        self.support = support', '        self.density = density', '', '    def fit_kde(self, x, bw):', '        \"\"\"Estimate a KDE for a vector of data with flexible bandwidth.\"\"\"', '        kde = gaussian_kde(x, bw)', '', '        # Extract the numeric bandwidth from the KDE object', '        bw_used = kde.factor', '', '        # At this point, bw will be a numeric scale factor.', '        # To get the actual bandwidth of the kernel, we multiple by the', '        # unbiased standard deviation of the data, which we will use', '        # elsewhere to compute the range of the support.', '        bw_used = bw_used * x.std(ddof=1)', '', '        return kde, bw_used', '', '    def kde_support(self, x, bw, cut, gridsize):', '        \"\"\"Define a grid of support for the violin.\"\"\"', '        support_min = x.min() - bw * cut', '        support_max = x.max() + bw * cut', '        return np.linspace(support_min, support_max, gridsize)', '', '    def scale_area(self, density, max_density, scale_hue):', '        \"\"\"Scale the relative area under the KDE curve.', '', '        This essentially preserves the \"standard\" KDE scaling, but the', '        resulting maximum density will be 1 so that the curve can be', '        properly multiplied by the violin width.', '', '        \"\"\"', '        if self.hue_names is None:', '            for d in density:', '                if d.size > 1:', '                    d /= max_density.max()', '        else:', '            for i, group in enumerate(density):', '                for d in group:', '                    if scale_hue:', '                        max = max_density[i].max()', '                    else:', '                        max = max_density.max()', '                    if d.size > 1:', '                        d /= max', '', '    def scale_width(self, density):', '        \"\"\"Scale each density curve to the same height.\"\"\"', '        if self.hue_names is None:', '            for d in density:', '                d /= d.max()', '        else:', '            for group in density:', '                for d in group:', '                    d /= d.max()', '', '    def scale_count(self, density, counts, scale_hue):', '        \"\"\"Scale each density curve by the number of observations.\"\"\"', '        if self.hue_names is None:', '            if counts.max() == 0:', '                d = 0', '            else:', '                for count, d in zip(counts, density):', '                    d /= d.max()', '                    d *= count / counts.max()', '        else:', '            for i, group in enumerate(density):', '                for j, d in enumerate(group):', '                    if counts[i].max() == 0:', '                        d = 0', '                    else:', '                        count = counts[i, j]', '                        if scale_hue:', '                            scaler = count / counts[i].max()', '                        else:', '                            scaler = count / counts.max()', '                        d /= d.max()', '                        d *= scaler', '', '    @property', '    def dwidth(self):', '', '        if self.hue_names is None or not self.dodge:', '            return self.width / 2', '        elif self.split:', '            return self.width / 2', '        else:', '            return self.width / (2 * len(self.hue_names))', '', '    def draw_violins(self, ax):', '        \"\"\"Draw the violins onto `ax`.\"\"\"', '        fill_func = ax.fill_betweenx if self.orient == \"v\" else ax.fill_between', '        for i, group_data in enumerate(self.plot_data):', '', '            kws = dict(edgecolor=self.gray, linewidth=self.linewidth)', '', '            # Option 1: we have a single level of grouping', '            # --------------------------------------------', '', '            if self.plot_hues is None:', '', '                support, density = self.support[i], self.density[i]', '', '                # Handle special case of no observations in this bin', '                if support.size == 0:', '                    continue', '', '                # Handle special case of a single observation', '                elif support.size == 1:', '                    val = support.item()', '                    d = density.item()', '                    self.draw_single_observation(ax, i, val, d)', '                    continue', '', '                # Draw the violin for this group', '                grid = np.ones(self.gridsize) * i', '                fill_func(support,', '                          grid - density * self.dwidth,', '                          grid + density * self.dwidth,', '                          facecolor=self.colors[i],', '                          **kws)', '', '                # Draw the interior representation of the data', '                if self.inner is None:', '                    continue', '', '                # Get a nan-free vector of datapoints', '                violin_data = remove_na(group_data)', '', '                # Draw box and whisker information', '                if self.inner.startswith(\"box\"):', '                    self.draw_box_lines(ax, violin_data, i)', '', '                # Draw quartile lines', '                elif self.inner.startswith(\"quart\"):', '                    self.draw_quartiles(ax, violin_data, support, density, i)', '', '                # Draw stick observations', '                elif self.inner.startswith(\"stick\"):', '                    self.draw_stick_lines(ax, violin_data, support, density, i)', '', '                # Draw point observations', '                elif self.inner.startswith(\"point\"):', '                    self.draw_points(ax, violin_data, i)', '', '            # Option 2: we have nested grouping by a hue variable', '            # ---------------------------------------------------', '', '            else:', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    support, density = self.support[i][j], self.density[i][j]', '                    kws[\"facecolor\"] = self.colors[j]', '', '                    # Add legend data, but just for one set of violins', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle the special case where we have no observations', '                    if support.size == 0:', '                        continue', '', '                    # Handle the special case where we have one observation', '                    elif support.size == 1:', '                        val = support.item()', '                        d = density.item()', '                        if self.split:', '                            d = d / 2', '                        at_group = i + offsets[j]', '                        self.draw_single_observation(ax, at_group, val, d)', '                        continue', '', '                    # Option 2a: we are drawing a single split violin', '                    # -----------------------------------------------', '', '                    if self.split:', '', '                        grid = np.ones(self.gridsize) * i', '                        if j:', '                            fill_func(support,', '                                      grid,', '                                      grid + density * self.dwidth,', '                                      **kws)', '                        else:', '                            fill_func(support,', '                                      grid - density * self.dwidth,', '                                      grid,', '                                      **kws)', '', '                        # Draw the interior representation of the data', '                        if self.inner is None:', '                            continue', '', '                        # Get a nan-free vector of datapoints', '                        hue_mask = self.plot_hues[i] == hue_level', '                        violin_data = remove_na(group_data[hue_mask])', '', '                        # Draw quartile lines', '                        if self.inner.startswith(\"quart\"):', '                            self.draw_quartiles(ax, violin_data,', '                                                support, density, i,', '                                                [\"left\", \"right\"][j])', '', '                        # Draw stick observations', '                        elif self.inner.startswith(\"stick\"):', '                            self.draw_stick_lines(ax, violin_data,', '                                                  support, density, i,', '                                                  [\"left\", \"right\"][j])', '', '                        # The box and point interior plots are drawn for', '                        # all data at the group level, so we just do that once', '                        if j and any(self.plot_hues[0] == hue_level):', '                            continue', '', '                        # Get the whole vector for this group level', '                        violin_data = remove_na(group_data)', '', '                        # Draw box and whisker information', '                        if self.inner.startswith(\"box\"):', '                            self.draw_box_lines(ax, violin_data, i)', '', '                        # Draw point observations', '                        elif self.inner.startswith(\"point\"):', '                            self.draw_points(ax, violin_data, i)', '', '                    # Option 2b: we are drawing full nested violins', '                    # -----------------------------------------------', '', '                    else:', '                        grid = np.ones(self.gridsize) * (i + offsets[j])', '                        fill_func(support,', '                                  grid - density * self.dwidth,', '                                  grid + density * self.dwidth,', '                                  **kws)', '', '                        # Draw the interior representation', '                        if self.inner is None:', '                            continue', '', '                        # Get a nan-free vector of datapoints', '                        hue_mask = self.plot_hues[i] == hue_level', '                        violin_data = remove_na(group_data[hue_mask])', '', '                        # Draw box and whisker information', '                        if self.inner.startswith(\"box\"):', '                            self.draw_box_lines(ax, violin_data, i + offsets[j])', '', '                        # Draw quartile lines', '                        elif self.inner.startswith(\"quart\"):', '                            self.draw_quartiles(ax, violin_data,', '                                                support, density,', '                                                i + offsets[j])', '', '                        # Draw stick observations', '                        elif self.inner.startswith(\"stick\"):', '                            self.draw_stick_lines(ax, violin_data,', '                                                  support, density,', '                                                  i + offsets[j])', '', '                        # Draw point observations', '                        elif self.inner.startswith(\"point\"):', '                            self.draw_points(ax, violin_data, i + offsets[j])', '', '    def draw_single_observation(self, ax, at_group, at_quant, density):', '        \"\"\"Draw a line to mark a single observation.\"\"\"', '        d_width = density * self.dwidth', '        if self.orient == \"v\":', '            ax.plot([at_group - d_width, at_group + d_width],', '                    [at_quant, at_quant],', '                    color=self.gray,', '                    linewidth=self.linewidth)', '        else:', '            ax.plot([at_quant, at_quant],', '                    [at_group - d_width, at_group + d_width],', '                    color=self.gray,', '                    linewidth=self.linewidth)', '', '    def draw_box_lines(self, ax, data, center):', '        \"\"\"Draw boxplot information at center of the density.\"\"\"', '        # Compute the boxplot statistics', '        q25, q50, q75 = np.percentile(data, [25, 50, 75])', '        whisker_lim = 1.5 * (q75 - q25)', '        h1 = np.min(data[data >= (q25 - whisker_lim)])', '        h2 = np.max(data[data <= (q75 + whisker_lim)])', '', '        # Draw a boxplot using lines and a point', '        if self.orient == \"v\":', '            ax.plot([center, center], [h1, h2],', '                    linewidth=self.linewidth,', '                    color=self.gray)', '            ax.plot([center, center], [q25, q75],', '                    linewidth=self.linewidth * 3,', '                    color=self.gray)', '            ax.scatter(center, q50,', '                       zorder=3,', '                       color=\"white\",', '                       edgecolor=self.gray,', '                       s=np.square(self.linewidth * 2))', '        else:', '            ax.plot([h1, h2], [center, center],', '                    linewidth=self.linewidth,', '                    color=self.gray)', '            ax.plot([q25, q75], [center, center],', '                    linewidth=self.linewidth * 3,', '                    color=self.gray)', '            ax.scatter(q50, center,', '                       zorder=3,', '                       color=\"white\",', '                       edgecolor=self.gray,', '                       s=np.square(self.linewidth * 2))', '', '    def draw_quartiles(self, ax, data, support, density, center, split=False):', '        \"\"\"Draw the quartiles as lines at width of density.\"\"\"', '        q25, q50, q75 = np.percentile(data, [25, 50, 75])', '', '        self.draw_to_density(ax, center, q25, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 1.5] * 2)', '        self.draw_to_density(ax, center, q50, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 3] * 2)', '        self.draw_to_density(ax, center, q75, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 1.5] * 2)', '', '    def draw_points(self, ax, data, center):', '        \"\"\"Draw individual observations as points at middle of the violin.\"\"\"', '        kws = dict(s=np.square(self.linewidth * 2),', '                   color=self.gray,', '                   edgecolor=self.gray)', '', '        grid = np.ones(len(data)) * center', '', '        if self.orient == \"v\":', '            ax.scatter(grid, data, **kws)', '        else:', '            ax.scatter(data, grid, **kws)', '', '    def draw_stick_lines(self, ax, data, support, density,', '                         center, split=False):', '        \"\"\"Draw individual observations as sticks at width of density.\"\"\"', '        for val in data:', '            self.draw_to_density(ax, center, val, support, density, split,', '                                 linewidth=self.linewidth * .5)', '', '    def draw_to_density(self, ax, center, val, support, density, split, **kws):', '        \"\"\"Draw a line orthogonal to the value axis at width of density.\"\"\"', '        idx = np.argmin(np.abs(support - val))', '        width = self.dwidth * density[idx] * .99', '', '        kws[\"color\"] = self.gray', '', '        if self.orient == \"v\":', '            if split == \"left\":', '                ax.plot([center - width, center], [val, val], **kws)', '            elif split == \"right\":', '                ax.plot([center, center + width], [val, val], **kws)', '            else:', '                ax.plot([center - width, center + width], [val, val], **kws)', '        else:', '            if split == \"left\":', '                ax.plot([val, val], [center - width, center], **kws)', '            elif split == \"right\":', '                ax.plot([val, val], [center, center + width], **kws)', '            else:', '                ax.plot([val, val], [center - width, center + width], **kws)', '', '    def plot(self, ax):', '        \"\"\"Make the violin plot.\"\"\"', '        self.draw_violins(ax)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()'], 'methods': [{'name': '__init__', 'start_line': 896, 'end_line': 925, 'text': ['    def __init__(self, x, y, hue, data, order, hue_order,', '                 bw, cut, scale, scale_hue, gridsize,', '                 width, inner, split, dodge, orient, linewidth,', '                 color, palette, saturation):', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)', '        self.estimate_densities(bw, cut, scale, scale_hue, gridsize)', '', '        self.gridsize = gridsize', '        self.width = width', '        self.dodge = dodge', '', '        if inner is not None:', '            if not any([inner.startswith(\"quart\"),', '                        inner.startswith(\"box\"),', '                        inner.startswith(\"stick\"),', '                        inner.startswith(\"point\")]):', '                err = f\"Inner style \\'{inner}\\' not recognized\"', '                raise ValueError(err)', '        self.inner = inner', '', '        if split and self.hue_names is not None and len(self.hue_names) != 2:', '            msg = \"There must be exactly two hue levels to use `split`.\\'\"', '            raise ValueError(msg)', '        self.split = split', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth']}, {'name': 'estimate_densities', 'start_line': 927, 'end_line': 1050, 'text': ['    def estimate_densities(self, bw, cut, scale, scale_hue, gridsize):', '        \"\"\"Find the support and density for all of the data.\"\"\"', '        # Initialize data structures to keep track of plotting data', '        if self.hue_names is None:', '            support = []', '            density = []', '            counts = np.zeros(len(self.plot_data))', '            max_density = np.zeros(len(self.plot_data))', '        else:', '            support = [[] for _ in self.plot_data]', '            density = [[] for _ in self.plot_data]', '            size = len(self.group_names), len(self.hue_names)', '            counts = np.zeros(size)', '            max_density = np.zeros(size)', '', '        for i, group_data in enumerate(self.plot_data):', '', '            # Option 1: we have a single level of grouping', '            # --------------------------------------------', '', '            if self.plot_hues is None:', '', '                # Strip missing datapoints', '                kde_data = remove_na(group_data)', '', '                # Handle special case of no data at this level', '                if kde_data.size == 0:', '                    support.append(np.array([]))', '                    density.append(np.array([1.]))', '                    counts[i] = 0', '                    max_density[i] = 0', '                    continue', '', '                # Handle special case of a single unique datapoint', '                elif np.unique(kde_data).size == 1:', '                    support.append(np.unique(kde_data))', '                    density.append(np.array([1.]))', '                    counts[i] = 1', '                    max_density[i] = 0', '                    continue', '', '                # Fit the KDE and get the used bandwidth size', '                kde, bw_used = self.fit_kde(kde_data, bw)', '', '                # Determine the support grid and get the density over it', '                support_i = self.kde_support(kde_data, bw_used, cut, gridsize)', '                density_i = kde.evaluate(support_i)', '', '                # Update the data structures with these results', '                support.append(support_i)', '                density.append(density_i)', '                counts[i] = kde_data.size', '                max_density[i] = density_i.max()', '', '            # Option 2: we have nested grouping by a hue variable', '            # ---------------------------------------------------', '', '            else:', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Handle special case of no data at this category level', '                    if not group_data.size:', '                        support[i].append(np.array([]))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 0', '                        max_density[i, j] = 0', '                        continue', '', '                    # Select out the observations for this hue level', '                    hue_mask = self.plot_hues[i] == hue_level', '', '                    # Strip missing datapoints', '                    kde_data = remove_na(group_data[hue_mask])', '', '                    # Handle special case of no data at this level', '                    if kde_data.size == 0:', '                        support[i].append(np.array([]))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 0', '                        max_density[i, j] = 0', '                        continue', '', '                    # Handle special case of a single unique datapoint', '                    elif np.unique(kde_data).size == 1:', '                        support[i].append(np.unique(kde_data))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 1', '                        max_density[i, j] = 0', '                        continue', '', '                    # Fit the KDE and get the used bandwidth size', '                    kde, bw_used = self.fit_kde(kde_data, bw)', '', '                    # Determine the support grid and get the density over it', '                    support_ij = self.kde_support(kde_data, bw_used,', '                                                  cut, gridsize)', '                    density_ij = kde.evaluate(support_ij)', '', '                    # Update the data structures with these results', '                    support[i].append(support_ij)', '                    density[i].append(density_ij)', '                    counts[i, j] = kde_data.size', '                    max_density[i, j] = density_ij.max()', '', '        # Scale the height of the density curve.', '        # For a violinplot the density is non-quantitative.', '        # The objective here is to scale the curves relative to 1 so that', '        # they can be multiplied by the width parameter during plotting.', '', '        if scale == \"area\":', '            self.scale_area(density, max_density, scale_hue)', '', '        elif scale == \"width\":', '            self.scale_width(density)', '', '        elif scale == \"count\":', '            self.scale_count(density, counts, scale_hue)', '', '        else:', '            raise ValueError(f\"scale method \\'{scale}\\' not recognized\")', '', '        # Set object attributes that will be used while plotting', '        self.support = support', '        self.density = density']}, {'name': 'fit_kde', 'start_line': 1052, 'end_line': 1065, 'text': ['    def fit_kde(self, x, bw):', '        \"\"\"Estimate a KDE for a vector of data with flexible bandwidth.\"\"\"', '        kde = gaussian_kde(x, bw)', '', '        # Extract the numeric bandwidth from the KDE object', '        bw_used = kde.factor', '', '        # At this point, bw will be a numeric scale factor.', '        # To get the actual bandwidth of the kernel, we multiple by the', '        # unbiased standard deviation of the data, which we will use', '        # elsewhere to compute the range of the support.', '        bw_used = bw_used * x.std(ddof=1)', '', '        return kde, bw_used']}, {'name': 'kde_support', 'start_line': 1067, 'end_line': 1071, 'text': ['    def kde_support(self, x, bw, cut, gridsize):', '        \"\"\"Define a grid of support for the violin.\"\"\"', '        support_min = x.min() - bw * cut', '        support_max = x.max() + bw * cut', '        return np.linspace(support_min, support_max, gridsize)']}, {'name': 'scale_area', 'start_line': 1073, 'end_line': 1093, 'text': ['    def scale_area(self, density, max_density, scale_hue):', '        \"\"\"Scale the relative area under the KDE curve.', '', '        This essentially preserves the \"standard\" KDE scaling, but the', '        resulting maximum density will be 1 so that the curve can be', '        properly multiplied by the violin width.', '', '        \"\"\"', '        if self.hue_names is None:', '            for d in density:', '                if d.size > 1:', '                    d /= max_density.max()', '        else:', '            for i, group in enumerate(density):', '                for d in group:', '                    if scale_hue:', '                        max = max_density[i].max()', '                    else:', '                        max = max_density.max()', '                    if d.size > 1:', '                        d /= max']}, {'name': 'scale_width', 'start_line': 1095, 'end_line': 1103, 'text': ['    def scale_width(self, density):', '        \"\"\"Scale each density curve to the same height.\"\"\"', '        if self.hue_names is None:', '            for d in density:', '                d /= d.max()', '        else:', '            for group in density:', '                for d in group:', '                    d /= d.max()']}, {'name': 'scale_count', 'start_line': 1105, 'end_line': 1126, 'text': ['    def scale_count(self, density, counts, scale_hue):', '        \"\"\"Scale each density curve by the number of observations.\"\"\"', '        if self.hue_names is None:', '            if counts.max() == 0:', '                d = 0', '            else:', '                for count, d in zip(counts, density):', '                    d /= d.max()', '                    d *= count / counts.max()', '        else:', '            for i, group in enumerate(density):', '                for j, d in enumerate(group):', '                    if counts[i].max() == 0:', '                        d = 0', '                    else:', '                        count = counts[i, j]', '                        if scale_hue:', '                            scaler = count / counts[i].max()', '                        else:', '                            scaler = count / counts.max()', '                        d /= d.max()', '                        d *= scaler']}, {'name': 'dwidth', 'start_line': 1129, 'end_line': 1136, 'text': ['    def dwidth(self):', '', '        if self.hue_names is None or not self.dodge:', '            return self.width / 2', '        elif self.split:', '            return self.width / 2', '        else:', '            return self.width / (2 * len(self.hue_names))']}, {'name': 'draw_violins', 'start_line': 1138, 'end_line': 1311, 'text': ['    def draw_violins(self, ax):', '        \"\"\"Draw the violins onto `ax`.\"\"\"', '        fill_func = ax.fill_betweenx if self.orient == \"v\" else ax.fill_between', '        for i, group_data in enumerate(self.plot_data):', '', '            kws = dict(edgecolor=self.gray, linewidth=self.linewidth)', '', '            # Option 1: we have a single level of grouping', '            # --------------------------------------------', '', '            if self.plot_hues is None:', '', '                support, density = self.support[i], self.density[i]', '', '                # Handle special case of no observations in this bin', '                if support.size == 0:', '                    continue', '', '                # Handle special case of a single observation', '                elif support.size == 1:', '                    val = support.item()', '                    d = density.item()', '                    self.draw_single_observation(ax, i, val, d)', '                    continue', '', '                # Draw the violin for this group', '                grid = np.ones(self.gridsize) * i', '                fill_func(support,', '                          grid - density * self.dwidth,', '                          grid + density * self.dwidth,', '                          facecolor=self.colors[i],', '                          **kws)', '', '                # Draw the interior representation of the data', '                if self.inner is None:', '                    continue', '', '                # Get a nan-free vector of datapoints', '                violin_data = remove_na(group_data)', '', '                # Draw box and whisker information', '                if self.inner.startswith(\"box\"):', '                    self.draw_box_lines(ax, violin_data, i)', '', '                # Draw quartile lines', '                elif self.inner.startswith(\"quart\"):', '                    self.draw_quartiles(ax, violin_data, support, density, i)', '', '                # Draw stick observations', '                elif self.inner.startswith(\"stick\"):', '                    self.draw_stick_lines(ax, violin_data, support, density, i)', '', '                # Draw point observations', '                elif self.inner.startswith(\"point\"):', '                    self.draw_points(ax, violin_data, i)', '', '            # Option 2: we have nested grouping by a hue variable', '            # ---------------------------------------------------', '', '            else:', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    support, density = self.support[i][j], self.density[i][j]', '                    kws[\"facecolor\"] = self.colors[j]', '', '                    # Add legend data, but just for one set of violins', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle the special case where we have no observations', '                    if support.size == 0:', '                        continue', '', '                    # Handle the special case where we have one observation', '                    elif support.size == 1:', '                        val = support.item()', '                        d = density.item()', '                        if self.split:', '                            d = d / 2', '                        at_group = i + offsets[j]', '                        self.draw_single_observation(ax, at_group, val, d)', '                        continue', '', '                    # Option 2a: we are drawing a single split violin', '                    # -----------------------------------------------', '', '                    if self.split:', '', '                        grid = np.ones(self.gridsize) * i', '                        if j:', '                            fill_func(support,', '                                      grid,', '                                      grid + density * self.dwidth,', '                                      **kws)', '                        else:', '                            fill_func(support,', '                                      grid - density * self.dwidth,', '                                      grid,', '                                      **kws)', '', '                        # Draw the interior representation of the data', '                        if self.inner is None:', '                            continue', '', '                        # Get a nan-free vector of datapoints', '                        hue_mask = self.plot_hues[i] == hue_level', '                        violin_data = remove_na(group_data[hue_mask])', '', '                        # Draw quartile lines', '                        if self.inner.startswith(\"quart\"):', '                            self.draw_quartiles(ax, violin_data,', '                                                support, density, i,', '                                                [\"left\", \"right\"][j])', '', '                        # Draw stick observations', '                        elif self.inner.startswith(\"stick\"):', '                            self.draw_stick_lines(ax, violin_data,', '                                                  support, density, i,', '                                                  [\"left\", \"right\"][j])', '', '                        # The box and point interior plots are drawn for', '                        # all data at the group level, so we just do that once', '                        if j and any(self.plot_hues[0] == hue_level):', '                            continue', '', '                        # Get the whole vector for this group level', '                        violin_data = remove_na(group_data)', '', '                        # Draw box and whisker information', '                        if self.inner.startswith(\"box\"):', '                            self.draw_box_lines(ax, violin_data, i)', '', '                        # Draw point observations', '                        elif self.inner.startswith(\"point\"):', '                            self.draw_points(ax, violin_data, i)', '', '                    # Option 2b: we are drawing full nested violins', '                    # -----------------------------------------------', '', '                    else:', '                        grid = np.ones(self.gridsize) * (i + offsets[j])', '                        fill_func(support,', '                                  grid - density * self.dwidth,', '                                  grid + density * self.dwidth,', '                                  **kws)', '', '                        # Draw the interior representation', '                        if self.inner is None:', '                            continue', '', '                        # Get a nan-free vector of datapoints', '                        hue_mask = self.plot_hues[i] == hue_level', '                        violin_data = remove_na(group_data[hue_mask])', '', '                        # Draw box and whisker information', '                        if self.inner.startswith(\"box\"):', '                            self.draw_box_lines(ax, violin_data, i + offsets[j])', '', '                        # Draw quartile lines', '                        elif self.inner.startswith(\"quart\"):', '                            self.draw_quartiles(ax, violin_data,', '                                                support, density,', '                                                i + offsets[j])', '', '                        # Draw stick observations', '                        elif self.inner.startswith(\"stick\"):', '                            self.draw_stick_lines(ax, violin_data,', '                                                  support, density,', '                                                  i + offsets[j])', '', '                        # Draw point observations', '                        elif self.inner.startswith(\"point\"):', '                            self.draw_points(ax, violin_data, i + offsets[j])']}, {'name': 'draw_single_observation', 'start_line': 1313, 'end_line': 1325, 'text': ['    def draw_single_observation(self, ax, at_group, at_quant, density):', '        \"\"\"Draw a line to mark a single observation.\"\"\"', '        d_width = density * self.dwidth', '        if self.orient == \"v\":', '            ax.plot([at_group - d_width, at_group + d_width],', '                    [at_quant, at_quant],', '                    color=self.gray,', '                    linewidth=self.linewidth)', '        else:', '            ax.plot([at_quant, at_quant],', '                    [at_group - d_width, at_group + d_width],', '                    color=self.gray,', '                    linewidth=self.linewidth)']}, {'name': 'draw_box_lines', 'start_line': 1327, 'end_line': 1359, 'text': ['    def draw_box_lines(self, ax, data, center):', '        \"\"\"Draw boxplot information at center of the density.\"\"\"', '        # Compute the boxplot statistics', '        q25, q50, q75 = np.percentile(data, [25, 50, 75])', '        whisker_lim = 1.5 * (q75 - q25)', '        h1 = np.min(data[data >= (q25 - whisker_lim)])', '        h2 = np.max(data[data <= (q75 + whisker_lim)])', '', '        # Draw a boxplot using lines and a point', '        if self.orient == \"v\":', '            ax.plot([center, center], [h1, h2],', '                    linewidth=self.linewidth,', '                    color=self.gray)', '            ax.plot([center, center], [q25, q75],', '                    linewidth=self.linewidth * 3,', '                    color=self.gray)', '            ax.scatter(center, q50,', '                       zorder=3,', '                       color=\"white\",', '                       edgecolor=self.gray,', '                       s=np.square(self.linewidth * 2))', '        else:', '            ax.plot([h1, h2], [center, center],', '                    linewidth=self.linewidth,', '                    color=self.gray)', '            ax.plot([q25, q75], [center, center],', '                    linewidth=self.linewidth * 3,', '                    color=self.gray)', '            ax.scatter(q50, center,', '                       zorder=3,', '                       color=\"white\",', '                       edgecolor=self.gray,', '                       s=np.square(self.linewidth * 2))']}, {'name': 'draw_quartiles', 'start_line': 1361, 'end_line': 1373, 'text': ['    def draw_quartiles(self, ax, data, support, density, center, split=False):', '        \"\"\"Draw the quartiles as lines at width of density.\"\"\"', '        q25, q50, q75 = np.percentile(data, [25, 50, 75])', '', '        self.draw_to_density(ax, center, q25, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 1.5] * 2)', '        self.draw_to_density(ax, center, q50, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 3] * 2)', '        self.draw_to_density(ax, center, q75, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 1.5] * 2)']}, {'name': 'draw_points', 'start_line': 1375, 'end_line': 1386, 'text': ['    def draw_points(self, ax, data, center):', '        \"\"\"Draw individual observations as points at middle of the violin.\"\"\"', '        kws = dict(s=np.square(self.linewidth * 2),', '                   color=self.gray,', '                   edgecolor=self.gray)', '', '        grid = np.ones(len(data)) * center', '', '        if self.orient == \"v\":', '            ax.scatter(grid, data, **kws)', '        else:', '            ax.scatter(data, grid, **kws)']}, {'name': 'draw_stick_lines', 'start_line': 1388, 'end_line': 1393, 'text': ['    def draw_stick_lines(self, ax, data, support, density,', '                         center, split=False):', '        \"\"\"Draw individual observations as sticks at width of density.\"\"\"', '        for val in data:', '            self.draw_to_density(ax, center, val, support, density, split,', '                                 linewidth=self.linewidth * .5)']}, {'name': 'draw_to_density', 'start_line': 1395, 'end_line': 1415, 'text': ['    def draw_to_density(self, ax, center, val, support, density, split, **kws):', '        \"\"\"Draw a line orthogonal to the value axis at width of density.\"\"\"', '        idx = np.argmin(np.abs(support - val))', '        width = self.dwidth * density[idx] * .99', '', '        kws[\"color\"] = self.gray', '', '        if self.orient == \"v\":', '            if split == \"left\":', '                ax.plot([center - width, center], [val, val], **kws)', '            elif split == \"right\":', '                ax.plot([center, center + width], [val, val], **kws)', '            else:', '                ax.plot([center - width, center + width], [val, val], **kws)', '        else:', '            if split == \"left\":', '                ax.plot([val, val], [center - width, center], **kws)', '            elif split == \"right\":', '                ax.plot([val, val], [center, center + width], **kws)', '            else:', '                ax.plot([val, val], [center - width, center + width], **kws)']}, {'name': 'plot', 'start_line': 1417, 'end_line': 1422, 'text': ['    def plot(self, ax):', '        \"\"\"Make the violin plot.\"\"\"', '        self.draw_violins(ax)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()']}]}, {'name': '_CategoricalStatPlotter', 'start_line': 1425, 'end_line': 1520, 'text': ['class _CategoricalStatPlotter(_CategoricalPlotter):', '', '    require_numeric = True', '', '    @property', '    def nested_width(self):', '        \"\"\"A float with the width of plot elements when hue nesting is used.\"\"\"', '        if self.dodge:', '            width = self.width / len(self.hue_names)', '        else:', '            width = self.width', '        return width', '', '    def estimate_statistic(self, estimator, errorbar, n_boot, seed):', '', '        if self.hue_names is None:', '            statistic = []', '            confint = []', '        else:', '            statistic = [[] for _ in self.plot_data]', '            confint = [[] for _ in self.plot_data]', '', '        var = {\"v\": \"y\", \"h\": \"x\"}[self.orient]', '', '        agg = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)', '', '        for i, group_data in enumerate(self.plot_data):', '', '            # Option 1: we have a single layer of grouping', '            # --------------------------------------------', '            if self.plot_hues is None:', '', '                df = pd.DataFrame({var: group_data})', '                if self.plot_units is not None:', '                    df[\"units\"] = self.plot_units[i]', '', '                res = agg(df, var)', '', '                statistic.append(res[var])', '                if errorbar is not None:', '                    confint.append((res[f\"{var}min\"], res[f\"{var}max\"]))', '', '            # Option 2: we are grouping by a hue layer', '            # ----------------------------------------', '', '            else:', '                for hue_level in self.hue_names:', '', '                    if not self.plot_hues[i].size:', '                        statistic[i].append(np.nan)', '                        if errorbar is not None:', '                            confint[i].append((np.nan, np.nan))', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    df = pd.DataFrame({var: group_data[hue_mask]})', '                    if self.plot_units is not None:', '                        df[\"units\"] = self.plot_units[i][hue_mask]', '', '                    res = agg(df, var)', '', '                    statistic[i].append(res[var])', '                    if errorbar is not None:', '                        confint[i].append((res[f\"{var}min\"], res[f\"{var}max\"]))', '', '        # Save the resulting values for plotting', '        self.statistic = np.array(statistic)', '        self.confint = np.array(confint)', '', '    def draw_confints(self, ax, at_group, confint, colors,', '                      errwidth=None, capsize=None, **kws):', '', '        if errwidth is not None:', '            kws.setdefault(\"lw\", errwidth)', '        else:', '            kws.setdefault(\"lw\", mpl.rcParams[\"lines.linewidth\"] * 1.8)', '', '        for at, (ci_low, ci_high), color in zip(at_group,', '                                                confint,', '                                                colors):', '            if self.orient == \"v\":', '                ax.plot([at, at], [ci_low, ci_high], color=color, **kws)', '                if capsize is not None:', '                    ax.plot([at - capsize / 2, at + capsize / 2],', '                            [ci_low, ci_low], color=color, **kws)', '                    ax.plot([at - capsize / 2, at + capsize / 2],', '                            [ci_high, ci_high], color=color, **kws)', '            else:', '                ax.plot([ci_low, ci_high], [at, at], color=color, **kws)', '                if capsize is not None:', '                    ax.plot([ci_low, ci_low],', '                            [at - capsize / 2, at + capsize / 2],', '                            color=color, **kws)', '                    ax.plot([ci_high, ci_high],', '                            [at - capsize / 2, at + capsize / 2],', '                            color=color, **kws)'], 'methods': [{'name': 'nested_width', 'start_line': 1430, 'end_line': 1436, 'text': ['    def nested_width(self):', '        \"\"\"A float with the width of plot elements when hue nesting is used.\"\"\"', '        if self.dodge:', '            width = self.width / len(self.hue_names)', '        else:', '            width = self.width', '        return width']}, {'name': 'estimate_statistic', 'start_line': 1438, 'end_line': 1492, 'text': ['    def estimate_statistic(self, estimator, errorbar, n_boot, seed):', '', '        if self.hue_names is None:', '            statistic = []', '            confint = []', '        else:', '            statistic = [[] for _ in self.plot_data]', '            confint = [[] for _ in self.plot_data]', '', '        var = {\"v\": \"y\", \"h\": \"x\"}[self.orient]', '', '        agg = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)', '', '        for i, group_data in enumerate(self.plot_data):', '', '            # Option 1: we have a single layer of grouping', '            # --------------------------------------------', '            if self.plot_hues is None:', '', '                df = pd.DataFrame({var: group_data})', '                if self.plot_units is not None:', '                    df[\"units\"] = self.plot_units[i]', '', '                res = agg(df, var)', '', '                statistic.append(res[var])', '                if errorbar is not None:', '                    confint.append((res[f\"{var}min\"], res[f\"{var}max\"]))', '', '            # Option 2: we are grouping by a hue layer', '            # ----------------------------------------', '', '            else:', '                for hue_level in self.hue_names:', '', '                    if not self.plot_hues[i].size:', '                        statistic[i].append(np.nan)', '                        if errorbar is not None:', '                            confint[i].append((np.nan, np.nan))', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    df = pd.DataFrame({var: group_data[hue_mask]})', '                    if self.plot_units is not None:', '                        df[\"units\"] = self.plot_units[i][hue_mask]', '', '                    res = agg(df, var)', '', '                    statistic[i].append(res[var])', '                    if errorbar is not None:', '                        confint[i].append((res[f\"{var}min\"], res[f\"{var}max\"]))', '', '        # Save the resulting values for plotting', '        self.statistic = np.array(statistic)', '        self.confint = np.array(confint)']}, {'name': 'draw_confints', 'start_line': 1494, 'end_line': 1520, 'text': ['    def draw_confints(self, ax, at_group, confint, colors,', '                      errwidth=None, capsize=None, **kws):', '', '        if errwidth is not None:', '            kws.setdefault(\"lw\", errwidth)', '        else:', '            kws.setdefault(\"lw\", mpl.rcParams[\"lines.linewidth\"] * 1.8)', '', '        for at, (ci_low, ci_high), color in zip(at_group,', '                                                confint,', '                                                colors):', '            if self.orient == \"v\":', '                ax.plot([at, at], [ci_low, ci_high], color=color, **kws)', '                if capsize is not None:', '                    ax.plot([at - capsize / 2, at + capsize / 2],', '                            [ci_low, ci_low], color=color, **kws)', '                    ax.plot([at - capsize / 2, at + capsize / 2],', '                            [ci_high, ci_high], color=color, **kws)', '            else:', '                ax.plot([ci_low, ci_high], [at, at], color=color, **kws)', '                if capsize is not None:', '                    ax.plot([ci_low, ci_low],', '                            [at - capsize / 2, at + capsize / 2],', '                            color=color, **kws)', '                    ax.plot([ci_high, ci_high],', '                            [at - capsize / 2, at + capsize / 2],', '                            color=color, **kws)']}]}, {'name': '_BarPlotter', 'start_line': 1523, 'end_line': 1589, 'text': ['class _BarPlotter(_CategoricalStatPlotter):', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 estimator, errorbar, n_boot, units, seed,', '                 orient, color, palette, saturation, width,', '                 errcolor, errwidth, capsize, dodge):', '        \"\"\"Initialize the plotter.\"\"\"', '        self.establish_variables(x, y, hue, data, orient,', '                                 order, hue_order, units)', '        self.establish_colors(color, palette, saturation)', '        self.estimate_statistic(estimator, errorbar, n_boot, seed)', '', '        self.dodge = dodge', '        self.width = width', '', '        self.errcolor = errcolor', '        self.errwidth = errwidth', '        self.capsize = capsize', '', '    def draw_bars(self, ax, kws):', '        \"\"\"Draw the bars onto `ax`.\"\"\"', '        # Get the right matplotlib function depending on the orientation', '        barfunc = ax.bar if self.orient == \"v\" else ax.barh', '        barpos = np.arange(len(self.statistic))', '', '        if self.plot_hues is None:', '', '            # Draw the bars', '            barfunc(barpos, self.statistic, self.width,', '                    color=self.colors, align=\"center\", **kws)', '', '            # Draw the confidence intervals', '            errcolors = [self.errcolor] * len(barpos)', '            self.draw_confints(ax,', '                               barpos,', '                               self.confint,', '                               errcolors,', '                               self.errwidth,', '                               self.capsize)', '', '        else:', '', '            for j, hue_level in enumerate(self.hue_names):', '', '                # Draw the bars', '                offpos = barpos + self.hue_offsets[j]', '                barfunc(offpos, self.statistic[:, j], self.nested_width,', '                        color=self.colors[j], align=\"center\",', '                        label=hue_level, **kws)', '', '                # Draw the confidence intervals', '                if self.confint.size:', '                    confint = self.confint[:, j]', '                    errcolors = [self.errcolor] * len(offpos)', '                    self.draw_confints(ax,', '                                       offpos,', '                                       confint,', '                                       errcolors,', '                                       self.errwidth,', '                                       self.capsize)', '', '    def plot(self, ax, bar_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_bars(ax, bar_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()'], 'methods': [{'name': '__init__', 'start_line': 1525, 'end_line': 1540, 'text': ['    def __init__(self, x, y, hue, data, order, hue_order,', '                 estimator, errorbar, n_boot, units, seed,', '                 orient, color, palette, saturation, width,', '                 errcolor, errwidth, capsize, dodge):', '        \"\"\"Initialize the plotter.\"\"\"', '        self.establish_variables(x, y, hue, data, orient,', '                                 order, hue_order, units)', '        self.establish_colors(color, palette, saturation)', '        self.estimate_statistic(estimator, errorbar, n_boot, seed)', '', '        self.dodge = dodge', '        self.width = width', '', '        self.errcolor = errcolor', '        self.errwidth = errwidth', '        self.capsize = capsize']}, {'name': 'draw_bars', 'start_line': 1542, 'end_line': 1582, 'text': ['    def draw_bars(self, ax, kws):', '        \"\"\"Draw the bars onto `ax`.\"\"\"', '        # Get the right matplotlib function depending on the orientation', '        barfunc = ax.bar if self.orient == \"v\" else ax.barh', '        barpos = np.arange(len(self.statistic))', '', '        if self.plot_hues is None:', '', '            # Draw the bars', '            barfunc(barpos, self.statistic, self.width,', '                    color=self.colors, align=\"center\", **kws)', '', '            # Draw the confidence intervals', '            errcolors = [self.errcolor] * len(barpos)', '            self.draw_confints(ax,', '                               barpos,', '                               self.confint,', '                               errcolors,', '                               self.errwidth,', '                               self.capsize)', '', '        else:', '', '            for j, hue_level in enumerate(self.hue_names):', '', '                # Draw the bars', '                offpos = barpos + self.hue_offsets[j]', '                barfunc(offpos, self.statistic[:, j], self.nested_width,', '                        color=self.colors[j], align=\"center\",', '                        label=hue_level, **kws)', '', '                # Draw the confidence intervals', '                if self.confint.size:', '                    confint = self.confint[:, j]', '                    errcolors = [self.errcolor] * len(offpos)', '                    self.draw_confints(ax,', '                                       offpos,', '                                       confint,', '                                       errcolors,', '                                       self.errwidth,', '                                       self.capsize)']}, {'name': 'plot', 'start_line': 1584, 'end_line': 1589, 'text': ['    def plot(self, ax, bar_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_bars(ax, bar_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()']}]}, {'name': '_PointPlotter', 'start_line': 1592, 'end_line': 1737, 'text': ['class _PointPlotter(_CategoricalStatPlotter):', '', '    default_palette = \"dark\"', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 estimator, errorbar, n_boot, units, seed,', '                 markers, linestyles, dodge, join, scale,', '                 orient, color, palette, errwidth=None, capsize=None):', '        \"\"\"Initialize the plotter.\"\"\"', '        self.establish_variables(x, y, hue, data, orient,', '                                 order, hue_order, units)', '        self.establish_colors(color, palette, 1)', '        self.estimate_statistic(estimator, errorbar, n_boot, seed)', '', '        # Override the default palette for single-color plots', '        if hue is None and color is None and palette is None:', '            self.colors = [color_palette()[0]] * len(self.colors)', '', \"        # Don't join single-layer plots with different colors\", '        if hue is None and palette is not None:', '            join = False', '', '        # Use a good default for `dodge=True`', '        if dodge is True and self.hue_names is not None:', '            dodge = .025 * len(self.hue_names)', '', '        # Make sure we have a marker for each hue level', '        if isinstance(markers, str):', '            markers = [markers] * len(self.colors)', '        self.markers = markers', '', '        # Make sure we have a line style for each hue level', '        if isinstance(linestyles, str):', '            linestyles = [linestyles] * len(self.colors)', '        self.linestyles = linestyles', '', '        # Set the other plot components', '        self.dodge = dodge', '        self.join = join', '        self.scale = scale', '        self.errwidth = errwidth', '        self.capsize = capsize', '', '    @property', '    def hue_offsets(self):', '        \"\"\"Offsets relative to the center position for each hue level.\"\"\"', '        if self.dodge:', '            offset = np.linspace(0, self.dodge, len(self.hue_names))', '            offset -= offset.mean()', '        else:', '            offset = np.zeros(len(self.hue_names))', '        return offset', '', '    def draw_points(self, ax):', '        \"\"\"Draw the main data components of the plot.\"\"\"', '        # Get the center positions on the categorical axis', '        pointpos = np.arange(len(self.statistic))', '', '        # Get the size of the plot elements', '        lw = mpl.rcParams[\"lines.linewidth\"] * 1.8 * self.scale', '        mew = lw * .75', '        markersize = np.pi * np.square(lw) * 2', '', '        if self.plot_hues is None:', '', '            # Draw lines joining each estimate point', '            if self.join:', '                color = self.colors[0]', '                ls = self.linestyles[0]', '                if self.orient == \"h\":', '                    ax.plot(self.statistic, pointpos,', '                            color=color, ls=ls, lw=lw)', '                else:', '                    ax.plot(pointpos, self.statistic,', '                            color=color, ls=ls, lw=lw)', '', '            # Draw the confidence intervals', '            self.draw_confints(ax, pointpos, self.confint, self.colors,', '                               self.errwidth, self.capsize)', '', '            # Draw the estimate points', '            marker = self.markers[0]', '            colors = [mpl.colors.colorConverter.to_rgb(c) for c in self.colors]', '            if self.orient == \"h\":', '                x, y = self.statistic, pointpos', '            else:', '                x, y = pointpos, self.statistic', '            ax.scatter(x, y,', '                       linewidth=mew, marker=marker, s=markersize,', '                       facecolor=colors, edgecolor=colors)', '', '        else:', '', '            offsets = self.hue_offsets', '            for j, hue_level in enumerate(self.hue_names):', '', '                # Determine the values to plot for this level', '                statistic = self.statistic[:, j]', '', '                # Determine the position on the categorical and z axes', '                offpos = pointpos + offsets[j]', '                z = j + 1', '', '                # Draw lines joining each estimate point', '                if self.join:', '                    color = self.colors[j]', '                    ls = self.linestyles[j]', '                    if self.orient == \"h\":', '                        ax.plot(statistic, offpos, color=color,', '                                zorder=z, ls=ls, lw=lw)', '                    else:', '                        ax.plot(offpos, statistic, color=color,', '                                zorder=z, ls=ls, lw=lw)', '', '                # Draw the confidence intervals', '                if self.confint.size:', '                    confint = self.confint[:, j]', '                    errcolors = [self.colors[j]] * len(offpos)', '                    self.draw_confints(ax, offpos, confint, errcolors,', '                                       self.errwidth, self.capsize,', '                                       zorder=z)', '', '                # Draw the estimate points', '                n_points = len(remove_na(offpos))', '                marker = self.markers[j]', '                color = mpl.colors.colorConverter.to_rgb(self.colors[j])', '', '                if self.orient == \"h\":', '                    x, y = statistic, offpos', '                else:', '                    x, y = offpos, statistic', '', '                if not len(remove_na(statistic)):', '                    x = y = [np.nan] * n_points', '', '                ax.scatter(x, y, label=hue_level,', '                           facecolor=color, edgecolor=color,', '                           linewidth=mew, marker=marker, s=markersize,', '                           zorder=z)', '', '    def plot(self, ax):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_points(ax)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()'], 'methods': [{'name': '__init__', 'start_line': 1596, 'end_line': 1633, 'text': ['    def __init__(self, x, y, hue, data, order, hue_order,', '                 estimator, errorbar, n_boot, units, seed,', '                 markers, linestyles, dodge, join, scale,', '                 orient, color, palette, errwidth=None, capsize=None):', '        \"\"\"Initialize the plotter.\"\"\"', '        self.establish_variables(x, y, hue, data, orient,', '                                 order, hue_order, units)', '        self.establish_colors(color, palette, 1)', '        self.estimate_statistic(estimator, errorbar, n_boot, seed)', '', '        # Override the default palette for single-color plots', '        if hue is None and color is None and palette is None:', '            self.colors = [color_palette()[0]] * len(self.colors)', '', \"        # Don't join single-layer plots with different colors\", '        if hue is None and palette is not None:', '            join = False', '', '        # Use a good default for `dodge=True`', '        if dodge is True and self.hue_names is not None:', '            dodge = .025 * len(self.hue_names)', '', '        # Make sure we have a marker for each hue level', '        if isinstance(markers, str):', '            markers = [markers] * len(self.colors)', '        self.markers = markers', '', '        # Make sure we have a line style for each hue level', '        if isinstance(linestyles, str):', '            linestyles = [linestyles] * len(self.colors)', '        self.linestyles = linestyles', '', '        # Set the other plot components', '        self.dodge = dodge', '        self.join = join', '        self.scale = scale', '        self.errwidth = errwidth', '        self.capsize = capsize']}, {'name': 'hue_offsets', 'start_line': 1636, 'end_line': 1643, 'text': ['    def hue_offsets(self):', '        \"\"\"Offsets relative to the center position for each hue level.\"\"\"', '        if self.dodge:', '            offset = np.linspace(0, self.dodge, len(self.hue_names))', '            offset -= offset.mean()', '        else:', '            offset = np.zeros(len(self.hue_names))', '        return offset']}, {'name': 'draw_points', 'start_line': 1645, 'end_line': 1730, 'text': ['    def draw_points(self, ax):', '        \"\"\"Draw the main data components of the plot.\"\"\"', '        # Get the center positions on the categorical axis', '        pointpos = np.arange(len(self.statistic))', '', '        # Get the size of the plot elements', '        lw = mpl.rcParams[\"lines.linewidth\"] * 1.8 * self.scale', '        mew = lw * .75', '        markersize = np.pi * np.square(lw) * 2', '', '        if self.plot_hues is None:', '', '            # Draw lines joining each estimate point', '            if self.join:', '                color = self.colors[0]', '                ls = self.linestyles[0]', '                if self.orient == \"h\":', '                    ax.plot(self.statistic, pointpos,', '                            color=color, ls=ls, lw=lw)', '                else:', '                    ax.plot(pointpos, self.statistic,', '                            color=color, ls=ls, lw=lw)', '', '            # Draw the confidence intervals', '            self.draw_confints(ax, pointpos, self.confint, self.colors,', '                               self.errwidth, self.capsize)', '', '            # Draw the estimate points', '            marker = self.markers[0]', '            colors = [mpl.colors.colorConverter.to_rgb(c) for c in self.colors]', '            if self.orient == \"h\":', '                x, y = self.statistic, pointpos', '            else:', '                x, y = pointpos, self.statistic', '            ax.scatter(x, y,', '                       linewidth=mew, marker=marker, s=markersize,', '                       facecolor=colors, edgecolor=colors)', '', '        else:', '', '            offsets = self.hue_offsets', '            for j, hue_level in enumerate(self.hue_names):', '', '                # Determine the values to plot for this level', '                statistic = self.statistic[:, j]', '', '                # Determine the position on the categorical and z axes', '                offpos = pointpos + offsets[j]', '                z = j + 1', '', '                # Draw lines joining each estimate point', '                if self.join:', '                    color = self.colors[j]', '                    ls = self.linestyles[j]', '                    if self.orient == \"h\":', '                        ax.plot(statistic, offpos, color=color,', '                                zorder=z, ls=ls, lw=lw)', '                    else:', '                        ax.plot(offpos, statistic, color=color,', '                                zorder=z, ls=ls, lw=lw)', '', '                # Draw the confidence intervals', '                if self.confint.size:', '                    confint = self.confint[:, j]', '                    errcolors = [self.colors[j]] * len(offpos)', '                    self.draw_confints(ax, offpos, confint, errcolors,', '                                       self.errwidth, self.capsize,', '                                       zorder=z)', '', '                # Draw the estimate points', '                n_points = len(remove_na(offpos))', '                marker = self.markers[j]', '                color = mpl.colors.colorConverter.to_rgb(self.colors[j])', '', '                if self.orient == \"h\":', '                    x, y = statistic, offpos', '                else:', '                    x, y = offpos, statistic', '', '                if not len(remove_na(statistic)):', '                    x = y = [np.nan] * n_points', '', '                ax.scatter(x, y, label=hue_level,', '                           facecolor=color, edgecolor=color,', '                           linewidth=mew, marker=marker, s=markersize,', '                           zorder=z)']}, {'name': 'plot', 'start_line': 1732, 'end_line': 1737, 'text': ['    def plot(self, ax):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_points(ax)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()']}]}, {'name': '_CountPlotter', 'start_line': 1740, 'end_line': 1741, 'text': ['class _CountPlotter(_BarPlotter):', '    require_numeric = False'], 'methods': []}, {'name': '_LVPlotter', 'start_line': 1744, 'end_line': 2047, 'text': ['class _LVPlotter(_CategoricalPlotter):', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 orient, color, palette, saturation,', '                 width, dodge, k_depth, linewidth, scale, outlier_prop,', '                 trust_alpha, showfliers=True):', '', '        self.width = width', '        self.dodge = dodge', '        self.saturation = saturation', '', \"        k_depth_methods = ['proportion', 'tukey', 'trustworthy', 'full']\", '        if not (k_depth in k_depth_methods or isinstance(k_depth, Number)):', \"            msg = (f'k_depth must be one of {k_depth_methods} or a number, '\", \"                   f'but {k_depth} was passed.')\", '            raise ValueError(msg)', '        self.k_depth = k_depth', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth', '', \"        scales = ['linear', 'exponential', 'area']\", '        if scale not in scales:', \"            msg = f'scale must be one of {scales}, but {scale} was passed.'\", '            raise ValueError(msg)', '        self.scale = scale', '', '        if ((outlier_prop > 1) or (outlier_prop <= 0)):', \"            msg = f'outlier_prop {outlier_prop} not in range (0, 1]'\", '            raise ValueError(msg)', '        self.outlier_prop = outlier_prop', '', '        if not 0 < trust_alpha < 1:', \"            msg = f'trust_alpha {trust_alpha} not in range (0, 1)'\", '            raise ValueError(msg)', '        self.trust_alpha = trust_alpha', '', '        self.showfliers = showfliers', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)', '', '    def _lv_box_ends(self, vals):', '        \"\"\"Get the number of data points and calculate `depth` of', '        letter-value plot.\"\"\"', '        vals = np.asarray(vals)', \"        # Remove infinite values while handling a 'object' dtype\", '        # that can come from pd.Float64Dtype() input', \"        with pd.option_context('mode.use_inf_as_null', True):\", '            vals = vals[~pd.isnull(vals)]', '        n = len(vals)', '        p = self.outlier_prop', '', '        # Select the depth, i.e. number of boxes to draw, based on the method', \"        if self.k_depth == 'full':\", '            # extend boxes to 100% of the data', '            k = int(np.log2(n)) + 1', \"        elif self.k_depth == 'tukey':\", '            # This results with 5-8 points in each tail', '            k = int(np.log2(n)) - 3', \"        elif self.k_depth == 'proportion':\", '            k = int(np.log2(n)) - int(np.log2(n * p)) + 1', \"        elif self.k_depth == 'trustworthy':\", '            point_conf = 2 * _normal_quantile_func(1 - self.trust_alpha / 2) ** 2', '            k = int(np.log2(n / point_conf)) + 1', '        else:', '            k = int(self.k_depth)  # allow having k as input', '        # If the number happens to be less than 1, set k to 1', '        if k < 1:', '            k = 1', '', '        # Calculate the upper end for each of the k boxes', '        upper = [100 * (1 - 0.5 ** (i + 1)) for i in range(k, 0, -1)]', '        # Calculate the lower end for each of the k boxes', '        lower = [100 * (0.5 ** (i + 1)) for i in range(k, 0, -1)]', '        # Stitch the box ends together', '        percentile_ends = [(i, j) for i, j in zip(lower, upper)]', '        box_ends = [np.percentile(vals, q) for q in percentile_ends]', '        return box_ends, k', '', '    def _lv_outliers(self, vals, k):', '        \"\"\"Find the outliers based on the letter value depth.\"\"\"', '        box_edge = 0.5 ** (k + 1)', '        perc_ends = (100 * box_edge, 100 * (1 - box_edge))', '        edges = np.percentile(vals, perc_ends)', '        lower_out = vals[np.where(vals < edges[0])[0]]', '        upper_out = vals[np.where(vals > edges[1])[0]]', '        return np.concatenate((lower_out, upper_out))', '', '    def _width_functions(self, width_func):', '        # Dictionary of functions for computing the width of the boxes', \"        width_functions = {'linear': lambda h, i, k: (i + 1.) / k,\", \"                           'exponential': lambda h, i, k: 2**(-k + i - 1),\", \"                           'area': lambda h, i, k: (1 - 2**(-k + i - 2)) / h}\", '        return width_functions[width_func]', '', '    def _lvplot(self, box_data, positions,', '                color=[255. / 256., 185. / 256., 0.],', '                widths=1, ax=None, box_kws=None,', '                flier_kws=None,', '                line_kws=None):', '', '        # -- Default keyword dicts - based on', '        # distributions.plot_univariate_histogram', '        box_kws = {} if box_kws is None else box_kws.copy()', '        flier_kws = {} if flier_kws is None else flier_kws.copy()', '        line_kws = {} if line_kws is None else line_kws.copy()', '', '        # Set the default kwargs for the boxes', '        box_default_kws = dict(edgecolor=self.gray,', '                               linewidth=self.linewidth)', '        for k, v in box_default_kws.items():', '            box_kws.setdefault(k, v)', '', '        # Set the default kwargs for the lines denoting medians', '        line_default_kws = dict(', '            color=\".15\", alpha=0.45, solid_capstyle=\"butt\", linewidth=self.linewidth', '        )', '        for k, v in line_default_kws.items():', '            line_kws.setdefault(k, v)', '', '        # Set the default kwargs for the outliers scatterplot', \"        flier_default_kws = dict(marker='d', color=self.gray)\", '        for k, v in flier_default_kws.items():', '            flier_kws.setdefault(k, v)', '', '        vert = self.orient == \"v\"', '        x = positions[0]', '        box_data = np.asarray(box_data)', '', '        # If we only have one data point, plot a line', '        if len(box_data) == 1:', '            line_kws.update({', \"                'color': box_kws['edgecolor'],\", \"                'linestyle': box_kws.get('linestyle', '-'),\", '                \\'linewidth\\': max(box_kws[\"linewidth\"], line_kws[\"linewidth\"])', '            })', '            ys = [box_data[0], box_data[0]]', '            xs = [x - widths / 2, x + widths / 2]', '            if vert:', '                xx, yy = xs, ys', '            else:', '                xx, yy = ys, xs', '            ax.plot(xx, yy, **line_kws)', '        else:', '            # Get the number of data points and calculate \"depth\" of', '            # letter-value plot', '            box_ends, k = self._lv_box_ends(box_data)', '', '            # Anonymous functions for calculating the width and height', '            # of the letter value boxes', '            width = self._width_functions(self.scale)', '', '            # Function to find height of boxes', '            def height(b):', '                return b[1] - b[0]', '', '            # Functions to construct the letter value boxes', '            def vert_perc_box(x, b, i, k, w):', '                rect = Patches.Rectangle((x - widths * w / 2, b[0]),', '                                         widths * w,', '                                         height(b), fill=True)', '                return rect', '', '            def horz_perc_box(x, b, i, k, w):', '                rect = Patches.Rectangle((b[0], x - widths * w / 2),', '                                         height(b), widths * w,', '                                         fill=True)', '                return rect', '', '            # Scale the width of the boxes so the biggest starts at 1', '            w_area = np.array([width(height(b), i, k)', '                               for i, b in enumerate(box_ends)])', '            w_area = w_area / np.max(w_area)', '', '            # Calculate the medians', '            y = np.median(box_data)', '', '            # Calculate the outliers and plot (only if showfliers == True)', '            outliers = []', '            if self.showfliers:', '                outliers = self._lv_outliers(box_data, k)', '            hex_color = mpl.colors.rgb2hex(color)', '', '            if vert:', '                box_func = vert_perc_box', '                xs_median = [x - widths / 2, x + widths / 2]', '                ys_median = [y, y]', '                xs_outliers = np.full(len(outliers), x)', '                ys_outliers = outliers', '', '            else:', '                box_func = horz_perc_box', '                xs_median = [y, y]', '                ys_median = [x - widths / 2, x + widths / 2]', '                xs_outliers = outliers', '                ys_outliers = np.full(len(outliers), x)', '', '            # Plot the medians', '            ax.plot(', '                xs_median,', '                ys_median,', '                **line_kws', '            )', '', '            # Plot outliers (if any)', '            if len(outliers) > 0:', '                ax.scatter(xs_outliers, ys_outliers,', '                           **flier_kws', '                           )', '', '            # Construct a color map from the input color', '            rgb = [hex_color, (1, 1, 1)]', \"            cmap = mpl.colors.LinearSegmentedColormap.from_list('new_map', rgb)\", '            # Make sure that the last boxes contain hue and are not pure white', '            rgb = [hex_color, cmap(.85)]', \"            cmap = mpl.colors.LinearSegmentedColormap.from_list('new_map', rgb)\", '', '            # Update box_kws with `cmap` if not defined in dict until now', \"            box_kws.setdefault('cmap', cmap)\", '', '            boxes = [box_func(x, b[0], i, k, b[1])', '                     for i, b in enumerate(zip(box_ends, w_area))]', '', '            collection = PatchCollection(boxes, **box_kws)', '', '            # Set the color gradation, first box will have color=hex_color', '            collection.set_array(np.array(np.linspace(1, 0, len(boxes))))', '', '            # Plot the boxes', '            ax.add_collection(collection)', '', '    def draw_letter_value_plot(self, ax, box_kws=None, flier_kws=None,', '                               line_kws=None):', '        \"\"\"Use matplotlib to draw a letter value plot on an Axes.\"\"\"', '', '        for i, group_data in enumerate(self.plot_data):', '', '            if self.plot_hues is None:', '', '                # Handle case where there is data at this level', '                if group_data.size == 0:', '                    continue', '', '                # Draw a single box or a set of boxes', '                # with a single level of grouping', '                box_data = remove_na(group_data)', '', '                # Handle case where there is no non-null data', '                if box_data.size == 0:', '                    continue', '', '                color = self.colors[i]', '', '                self._lvplot(box_data,', '                             positions=[i],', '                             color=color,', '                             widths=self.width,', '                             ax=ax,', '                             box_kws=box_kws,', '                             flier_kws=flier_kws,', '                             line_kws=line_kws)', '', '            else:', '                # Draw nested groups of boxes', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Add a legend for this hue level', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle case where there is data at this level', '                    if group_data.size == 0:', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    box_data = remove_na(group_data[hue_mask])', '', '                    # Handle case where there is no non-null data', '                    if box_data.size == 0:', '                        continue', '', '                    color = self.colors[j]', '                    center = i + offsets[j]', '                    self._lvplot(box_data,', '                                 positions=[center],', '                                 color=color,', '                                 widths=self.nested_width,', '                                 ax=ax,', '                                 box_kws=box_kws,', '                                 flier_kws=flier_kws,', '                                 line_kws=line_kws)', '', '        # Autoscale the values axis to make sure all patches are visible', '        ax.autoscale_view(scalex=self.orient == \"h\", scaley=self.orient == \"v\")', '', '    def plot(self, ax, box_kws, flier_kws, line_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_letter_value_plot(ax, box_kws, flier_kws, line_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()'], 'methods': [{'name': '__init__', 'start_line': 1746, 'end_line': 1785, 'text': ['    def __init__(self, x, y, hue, data, order, hue_order,', '                 orient, color, palette, saturation,', '                 width, dodge, k_depth, linewidth, scale, outlier_prop,', '                 trust_alpha, showfliers=True):', '', '        self.width = width', '        self.dodge = dodge', '        self.saturation = saturation', '', \"        k_depth_methods = ['proportion', 'tukey', 'trustworthy', 'full']\", '        if not (k_depth in k_depth_methods or isinstance(k_depth, Number)):', \"            msg = (f'k_depth must be one of {k_depth_methods} or a number, '\", \"                   f'but {k_depth} was passed.')\", '            raise ValueError(msg)', '        self.k_depth = k_depth', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth', '', \"        scales = ['linear', 'exponential', 'area']\", '        if scale not in scales:', \"            msg = f'scale must be one of {scales}, but {scale} was passed.'\", '            raise ValueError(msg)', '        self.scale = scale', '', '        if ((outlier_prop > 1) or (outlier_prop <= 0)):', \"            msg = f'outlier_prop {outlier_prop} not in range (0, 1]'\", '            raise ValueError(msg)', '        self.outlier_prop = outlier_prop', '', '        if not 0 < trust_alpha < 1:', \"            msg = f'trust_alpha {trust_alpha} not in range (0, 1)'\", '            raise ValueError(msg)', '        self.trust_alpha = trust_alpha', '', '        self.showfliers = showfliers', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)']}, {'name': '_lv_box_ends', 'start_line': 1787, 'end_line': 1823, 'text': ['    def _lv_box_ends(self, vals):', '        \"\"\"Get the number of data points and calculate `depth` of', '        letter-value plot.\"\"\"', '        vals = np.asarray(vals)', \"        # Remove infinite values while handling a 'object' dtype\", '        # that can come from pd.Float64Dtype() input', \"        with pd.option_context('mode.use_inf_as_null', True):\", '            vals = vals[~pd.isnull(vals)]', '        n = len(vals)', '        p = self.outlier_prop', '', '        # Select the depth, i.e. number of boxes to draw, based on the method', \"        if self.k_depth == 'full':\", '            # extend boxes to 100% of the data', '            k = int(np.log2(n)) + 1', \"        elif self.k_depth == 'tukey':\", '            # This results with 5-8 points in each tail', '            k = int(np.log2(n)) - 3', \"        elif self.k_depth == 'proportion':\", '            k = int(np.log2(n)) - int(np.log2(n * p)) + 1', \"        elif self.k_depth == 'trustworthy':\", '            point_conf = 2 * _normal_quantile_func(1 - self.trust_alpha / 2) ** 2', '            k = int(np.log2(n / point_conf)) + 1', '        else:', '            k = int(self.k_depth)  # allow having k as input', '        # If the number happens to be less than 1, set k to 1', '        if k < 1:', '            k = 1', '', '        # Calculate the upper end for each of the k boxes', '        upper = [100 * (1 - 0.5 ** (i + 1)) for i in range(k, 0, -1)]', '        # Calculate the lower end for each of the k boxes', '        lower = [100 * (0.5 ** (i + 1)) for i in range(k, 0, -1)]', '        # Stitch the box ends together', '        percentile_ends = [(i, j) for i, j in zip(lower, upper)]', '        box_ends = [np.percentile(vals, q) for q in percentile_ends]', '        return box_ends, k']}, {'name': '_lv_outliers', 'start_line': 1825, 'end_line': 1832, 'text': ['    def _lv_outliers(self, vals, k):', '        \"\"\"Find the outliers based on the letter value depth.\"\"\"', '        box_edge = 0.5 ** (k + 1)', '        perc_ends = (100 * box_edge, 100 * (1 - box_edge))', '        edges = np.percentile(vals, perc_ends)', '        lower_out = vals[np.where(vals < edges[0])[0]]', '        upper_out = vals[np.where(vals > edges[1])[0]]', '        return np.concatenate((lower_out, upper_out))']}, {'name': '_width_functions', 'start_line': 1834, 'end_line': 1839, 'text': ['    def _width_functions(self, width_func):', '        # Dictionary of functions for computing the width of the boxes', \"        width_functions = {'linear': lambda h, i, k: (i + 1.) / k,\", \"                           'exponential': lambda h, i, k: 2**(-k + i - 1),\", \"                           'area': lambda h, i, k: (1 - 2**(-k + i - 2)) / h}\", '        return width_functions[width_func]']}, {'name': '_lvplot', 'start_line': 1841, 'end_line': 1975, 'text': ['    def _lvplot(self, box_data, positions,', '                color=[255. / 256., 185. / 256., 0.],', '                widths=1, ax=None, box_kws=None,', '                flier_kws=None,', '                line_kws=None):', '', '        # -- Default keyword dicts - based on', '        # distributions.plot_univariate_histogram', '        box_kws = {} if box_kws is None else box_kws.copy()', '        flier_kws = {} if flier_kws is None else flier_kws.copy()', '        line_kws = {} if line_kws is None else line_kws.copy()', '', '        # Set the default kwargs for the boxes', '        box_default_kws = dict(edgecolor=self.gray,', '                               linewidth=self.linewidth)', '        for k, v in box_default_kws.items():', '            box_kws.setdefault(k, v)', '', '        # Set the default kwargs for the lines denoting medians', '        line_default_kws = dict(', '            color=\".15\", alpha=0.45, solid_capstyle=\"butt\", linewidth=self.linewidth', '        )', '        for k, v in line_default_kws.items():', '            line_kws.setdefault(k, v)', '', '        # Set the default kwargs for the outliers scatterplot', \"        flier_default_kws = dict(marker='d', color=self.gray)\", '        for k, v in flier_default_kws.items():', '            flier_kws.setdefault(k, v)', '', '        vert = self.orient == \"v\"', '        x = positions[0]', '        box_data = np.asarray(box_data)', '', '        # If we only have one data point, plot a line', '        if len(box_data) == 1:', '            line_kws.update({', \"                'color': box_kws['edgecolor'],\", \"                'linestyle': box_kws.get('linestyle', '-'),\", '                \\'linewidth\\': max(box_kws[\"linewidth\"], line_kws[\"linewidth\"])', '            })', '            ys = [box_data[0], box_data[0]]', '            xs = [x - widths / 2, x + widths / 2]', '            if vert:', '                xx, yy = xs, ys', '            else:', '                xx, yy = ys, xs', '            ax.plot(xx, yy, **line_kws)', '        else:', '            # Get the number of data points and calculate \"depth\" of', '            # letter-value plot', '            box_ends, k = self._lv_box_ends(box_data)', '', '            # Anonymous functions for calculating the width and height', '            # of the letter value boxes', '            width = self._width_functions(self.scale)', '', '            # Function to find height of boxes', '            def height(b):', '                return b[1] - b[0]', '', '            # Functions to construct the letter value boxes', '            def vert_perc_box(x, b, i, k, w):', '                rect = Patches.Rectangle((x - widths * w / 2, b[0]),', '                                         widths * w,', '                                         height(b), fill=True)', '                return rect', '', '            def horz_perc_box(x, b, i, k, w):', '                rect = Patches.Rectangle((b[0], x - widths * w / 2),', '                                         height(b), widths * w,', '                                         fill=True)', '                return rect', '', '            # Scale the width of the boxes so the biggest starts at 1', '            w_area = np.array([width(height(b), i, k)', '                               for i, b in enumerate(box_ends)])', '            w_area = w_area / np.max(w_area)', '', '            # Calculate the medians', '            y = np.median(box_data)', '', '            # Calculate the outliers and plot (only if showfliers == True)', '            outliers = []', '            if self.showfliers:', '                outliers = self._lv_outliers(box_data, k)', '            hex_color = mpl.colors.rgb2hex(color)', '', '            if vert:', '                box_func = vert_perc_box', '                xs_median = [x - widths / 2, x + widths / 2]', '                ys_median = [y, y]', '                xs_outliers = np.full(len(outliers), x)', '                ys_outliers = outliers', '', '            else:', '                box_func = horz_perc_box', '                xs_median = [y, y]', '                ys_median = [x - widths / 2, x + widths / 2]', '                xs_outliers = outliers', '                ys_outliers = np.full(len(outliers), x)', '', '            # Plot the medians', '            ax.plot(', '                xs_median,', '                ys_median,', '                **line_kws', '            )', '', '            # Plot outliers (if any)', '            if len(outliers) > 0:', '                ax.scatter(xs_outliers, ys_outliers,', '                           **flier_kws', '                           )', '', '            # Construct a color map from the input color', '            rgb = [hex_color, (1, 1, 1)]', \"            cmap = mpl.colors.LinearSegmentedColormap.from_list('new_map', rgb)\", '            # Make sure that the last boxes contain hue and are not pure white', '            rgb = [hex_color, cmap(.85)]', \"            cmap = mpl.colors.LinearSegmentedColormap.from_list('new_map', rgb)\", '', '            # Update box_kws with `cmap` if not defined in dict until now', \"            box_kws.setdefault('cmap', cmap)\", '', '            boxes = [box_func(x, b[0], i, k, b[1])', '                     for i, b in enumerate(zip(box_ends, w_area))]', '', '            collection = PatchCollection(boxes, **box_kws)', '', '            # Set the color gradation, first box will have color=hex_color', '            collection.set_array(np.array(np.linspace(1, 0, len(boxes))))', '', '            # Plot the boxes', '            ax.add_collection(collection)']}, {'name': 'draw_letter_value_plot', 'start_line': 1977, 'end_line': 2040, 'text': ['    def draw_letter_value_plot(self, ax, box_kws=None, flier_kws=None,', '                               line_kws=None):', '        \"\"\"Use matplotlib to draw a letter value plot on an Axes.\"\"\"', '', '        for i, group_data in enumerate(self.plot_data):', '', '            if self.plot_hues is None:', '', '                # Handle case where there is data at this level', '                if group_data.size == 0:', '                    continue', '', '                # Draw a single box or a set of boxes', '                # with a single level of grouping', '                box_data = remove_na(group_data)', '', '                # Handle case where there is no non-null data', '                if box_data.size == 0:', '                    continue', '', '                color = self.colors[i]', '', '                self._lvplot(box_data,', '                             positions=[i],', '                             color=color,', '                             widths=self.width,', '                             ax=ax,', '                             box_kws=box_kws,', '                             flier_kws=flier_kws,', '                             line_kws=line_kws)', '', '            else:', '                # Draw nested groups of boxes', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Add a legend for this hue level', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle case where there is data at this level', '                    if group_data.size == 0:', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    box_data = remove_na(group_data[hue_mask])', '', '                    # Handle case where there is no non-null data', '                    if box_data.size == 0:', '                        continue', '', '                    color = self.colors[j]', '                    center = i + offsets[j]', '                    self._lvplot(box_data,', '                                 positions=[center],', '                                 color=color,', '                                 widths=self.nested_width,', '                                 ax=ax,', '                                 box_kws=box_kws,', '                                 flier_kws=flier_kws,', '                                 line_kws=line_kws)', '', '        # Autoscale the values axis to make sure all patches are visible', '        ax.autoscale_view(scalex=self.orient == \"h\", scaley=self.orient == \"v\")']}, {'name': 'plot', 'start_line': 2042, 'end_line': 2047, 'text': ['    def plot(self, ax, box_kws, flier_kws, line_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_letter_value_plot(ax, box_kws, flier_kws, line_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()']}]}, {'name': 'Beeswarm', 'start_line': 3348, 'end_line': 3542, 'text': ['class Beeswarm:', '    \"\"\"Modifies a scatterplot artist to show a beeswarm plot.\"\"\"', '    def __init__(self, orient=\"v\", width=0.8, warn_thresh=.05):', '', '        # XXX should we keep the orient parameterization or specify the swarm axis?', '', '        self.orient = orient', '        self.width = width', '        self.warn_thresh = warn_thresh', '', '    def __call__(self, points, center):', '        \"\"\"Swarm `points`, a PathCollection, around the `center` position.\"\"\"', '        # Convert from point size (area) to diameter', '', '        ax = points.axes', '        dpi = ax.figure.dpi', '', '        # Get the original positions of the points', '        orig_xy_data = points.get_offsets()', '', '        # Reset the categorical positions to the center line', '        cat_idx = 1 if self.orient == \"h\" else 0', '        orig_xy_data[:, cat_idx] = center', '', '        # Transform the data coordinates to point coordinates.', \"        # We'll figure out the swarm positions in the latter\", '        # and then convert back to data coordinates and replot', '        orig_x_data, orig_y_data = orig_xy_data.T', '        orig_xy = ax.transData.transform(orig_xy_data)', '', '        # Order the variables so that x is the categorical axis', '        if self.orient == \"h\":', '            orig_xy = orig_xy[:, [1, 0]]', '', \"        # Add a column with each point's radius\", '        sizes = points.get_sizes()', '        if sizes.size == 1:', '            sizes = np.repeat(sizes, orig_xy.shape[0])', '        edge = points.get_linewidth().item()', '        radii = (np.sqrt(sizes) + edge) / 2 * (dpi / 72)', '        orig_xy = np.c_[orig_xy, radii]', '', '        # Sort along the value axis to facilitate the beeswarm', '        sorter = np.argsort(orig_xy[:, 1])', '        orig_xyr = orig_xy[sorter]', '', '        # Adjust points along the categorical axis to prevent overlaps', '        new_xyr = np.empty_like(orig_xyr)', '        new_xyr[sorter] = self.beeswarm(orig_xyr)', '', '        # Transform the point coordinates back to data coordinates', '        if self.orient == \"h\":', '            new_xy = new_xyr[:, [1, 0]]', '        else:', '            new_xy = new_xyr[:, :2]', '        new_x_data, new_y_data = ax.transData.inverted().transform(new_xy).T', '', '        swarm_axis = {\"h\": \"y\", \"v\": \"x\"}[self.orient]', '        log_scale = getattr(ax, f\"get_{swarm_axis}scale\")() == \"log\"', '', '        # Add gutters', '        if self.orient == \"h\":', '            self.add_gutters(new_y_data, center, log_scale=log_scale)', '        else:', '            self.add_gutters(new_x_data, center, log_scale=log_scale)', '', '        # Reposition the points so they do not overlap', '        if self.orient == \"h\":', '            points.set_offsets(np.c_[orig_x_data, new_y_data])', '        else:', '            points.set_offsets(np.c_[new_x_data, orig_y_data])', '', '    def beeswarm(self, orig_xyr):', '        \"\"\"Adjust x position of points to avoid overlaps.\"\"\"', '        # In this method, `x` is always the categorical axis', '        # Center of the swarm, in point coordinates', '        midline = orig_xyr[0, 0]', '', '        # Start the swarm with the first point', '        swarm = np.atleast_2d(orig_xyr[0])', '', '        # Loop over the remaining points', '        for xyr_i in orig_xyr[1:]:', '', '            # Find the points in the swarm that could possibly', '            # overlap with the point we are currently placing', '            neighbors = self.could_overlap(xyr_i, swarm)', '', '            # Find positions that would be valid individually', '            # with respect to each of the swarm neighbors', '            candidates = self.position_candidates(xyr_i, neighbors)', '', '            # Sort candidates by their centrality', '            offsets = np.abs(candidates[:, 0] - midline)', '            candidates = candidates[np.argsort(offsets)]', '', '            # Find the first candidate that does not overlap any neighbors', '            new_xyr_i = self.first_non_overlapping_candidate(candidates, neighbors)', '', '            # Place it into the swarm', '            swarm = np.vstack([swarm, new_xyr_i])', '', '        return swarm', '', '    def could_overlap(self, xyr_i, swarm):', '        \"\"\"Return a list of all swarm points that could overlap with target.\"\"\"', '        # Because we work backwards through the swarm and can short-circuit,', '        # the for-loop is faster than vectorization', '        _, y_i, r_i = xyr_i', '        neighbors = []', '        for xyr_j in reversed(swarm):', '            _, y_j, r_j = xyr_j', '            if (y_i - y_j) < (r_i + r_j):', '                neighbors.append(xyr_j)', '            else:', '                break', '        return np.array(neighbors)[::-1]', '', '    def position_candidates(self, xyr_i, neighbors):', '        \"\"\"Return a list of coordinates that might be valid by adjusting x.\"\"\"', '        candidates = [xyr_i]', '        x_i, y_i, r_i = xyr_i', '        left_first = True', '        for x_j, y_j, r_j in neighbors:', '            dy = y_i - y_j', '            dx = np.sqrt(max((r_i + r_j) ** 2 - dy ** 2, 0)) * 1.05', '            cl, cr = (x_j - dx, y_i, r_i), (x_j + dx, y_i, r_i)', '            if left_first:', '                new_candidates = [cl, cr]', '            else:', '                new_candidates = [cr, cl]', '            candidates.extend(new_candidates)', '            left_first = not left_first', '        return np.array(candidates)', '', '    def first_non_overlapping_candidate(self, candidates, neighbors):', '        \"\"\"Find the first candidate that does not overlap with the swarm.\"\"\"', '', '        # If we have no neighbors, all candidates are good.', '        if len(neighbors) == 0:', '            return candidates[0]', '', '        neighbors_x = neighbors[:, 0]', '        neighbors_y = neighbors[:, 1]', '        neighbors_r = neighbors[:, 2]', '', '        for xyr_i in candidates:', '', '            x_i, y_i, r_i = xyr_i', '', '            dx = neighbors_x - x_i', '            dy = neighbors_y - y_i', '            sq_distances = np.square(dx) + np.square(dy)', '', '            sep_needed = np.square(neighbors_r + r_i)', '', '            # Good candidate does not overlap any of neighbors which means that', '            # squared distance between candidate and any of the neighbors has', '            # to be at least square of the summed radii', '            good_candidate = np.all(sq_distances >= sep_needed)', '', '            if good_candidate:', '                return xyr_i', '', '        raise RuntimeError(', '            \"No non-overlapping candidates found. This should not happen.\"', '        )', '', '    def add_gutters(self, points, center, log_scale=False):', '        \"\"\"Stop points from extending beyond their territory.\"\"\"', '        half_width = self.width / 2', '        if log_scale:', '            low_gutter = 10 ** (np.log10(center) - half_width)', '        else:', '            low_gutter = center - half_width', '        off_low = points < low_gutter', '        if off_low.any():', '            points[off_low] = low_gutter', '        if log_scale:', '            high_gutter = 10 ** (np.log10(center) + half_width)', '        else:', '            high_gutter = center + half_width', '        off_high = points > high_gutter', '        if off_high.any():', '            points[off_high] = high_gutter', '', '        gutter_prop = (off_high + off_low).sum() / len(points)', '        if gutter_prop > self.warn_thresh:', '            msg = (', '                \"{:.1%} of the points cannot be placed; you may want \"', '                \"to decrease the size of the markers or use stripplot.\"', '            ).format(gutter_prop)', '            warnings.warn(msg, UserWarning)', '', '        return points'], 'methods': [{'name': '__init__', 'start_line': 3350, 'end_line': 3356, 'text': ['    def __init__(self, orient=\"v\", width=0.8, warn_thresh=.05):', '', '        # XXX should we keep the orient parameterization or specify the swarm axis?', '', '        self.orient = orient', '        self.width = width', '        self.warn_thresh = warn_thresh']}, {'name': '__call__', 'start_line': 3358, 'end_line': 3418, 'text': ['    def __call__(self, points, center):', '        \"\"\"Swarm `points`, a PathCollection, around the `center` position.\"\"\"', '        # Convert from point size (area) to diameter', '', '        ax = points.axes', '        dpi = ax.figure.dpi', '', '        # Get the original positions of the points', '        orig_xy_data = points.get_offsets()', '', '        # Reset the categorical positions to the center line', '        cat_idx = 1 if self.orient == \"h\" else 0', '        orig_xy_data[:, cat_idx] = center', '', '        # Transform the data coordinates to point coordinates.', \"        # We'll figure out the swarm positions in the latter\", '        # and then convert back to data coordinates and replot', '        orig_x_data, orig_y_data = orig_xy_data.T', '        orig_xy = ax.transData.transform(orig_xy_data)', '', '        # Order the variables so that x is the categorical axis', '        if self.orient == \"h\":', '            orig_xy = orig_xy[:, [1, 0]]', '', \"        # Add a column with each point's radius\", '        sizes = points.get_sizes()', '        if sizes.size == 1:', '            sizes = np.repeat(sizes, orig_xy.shape[0])', '        edge = points.get_linewidth().item()', '        radii = (np.sqrt(sizes) + edge) / 2 * (dpi / 72)', '        orig_xy = np.c_[orig_xy, radii]', '', '        # Sort along the value axis to facilitate the beeswarm', '        sorter = np.argsort(orig_xy[:, 1])', '        orig_xyr = orig_xy[sorter]', '', '        # Adjust points along the categorical axis to prevent overlaps', '        new_xyr = np.empty_like(orig_xyr)', '        new_xyr[sorter] = self.beeswarm(orig_xyr)', '', '        # Transform the point coordinates back to data coordinates', '        if self.orient == \"h\":', '            new_xy = new_xyr[:, [1, 0]]', '        else:', '            new_xy = new_xyr[:, :2]', '        new_x_data, new_y_data = ax.transData.inverted().transform(new_xy).T', '', '        swarm_axis = {\"h\": \"y\", \"v\": \"x\"}[self.orient]', '        log_scale = getattr(ax, f\"get_{swarm_axis}scale\")() == \"log\"', '', '        # Add gutters', '        if self.orient == \"h\":', '            self.add_gutters(new_y_data, center, log_scale=log_scale)', '        else:', '            self.add_gutters(new_x_data, center, log_scale=log_scale)', '', '        # Reposition the points so they do not overlap', '        if self.orient == \"h\":', '            points.set_offsets(np.c_[orig_x_data, new_y_data])', '        else:', '            points.set_offsets(np.c_[new_x_data, orig_y_data])']}, {'name': 'beeswarm', 'start_line': 3420, 'end_line': 3450, 'text': ['    def beeswarm(self, orig_xyr):', '        \"\"\"Adjust x position of points to avoid overlaps.\"\"\"', '        # In this method, `x` is always the categorical axis', '        # Center of the swarm, in point coordinates', '        midline = orig_xyr[0, 0]', '', '        # Start the swarm with the first point', '        swarm = np.atleast_2d(orig_xyr[0])', '', '        # Loop over the remaining points', '        for xyr_i in orig_xyr[1:]:', '', '            # Find the points in the swarm that could possibly', '            # overlap with the point we are currently placing', '            neighbors = self.could_overlap(xyr_i, swarm)', '', '            # Find positions that would be valid individually', '            # with respect to each of the swarm neighbors', '            candidates = self.position_candidates(xyr_i, neighbors)', '', '            # Sort candidates by their centrality', '            offsets = np.abs(candidates[:, 0] - midline)', '            candidates = candidates[np.argsort(offsets)]', '', '            # Find the first candidate that does not overlap any neighbors', '            new_xyr_i = self.first_non_overlapping_candidate(candidates, neighbors)', '', '            # Place it into the swarm', '            swarm = np.vstack([swarm, new_xyr_i])', '', '        return swarm']}, {'name': 'could_overlap', 'start_line': 3452, 'end_line': 3464, 'text': ['    def could_overlap(self, xyr_i, swarm):', '        \"\"\"Return a list of all swarm points that could overlap with target.\"\"\"', '        # Because we work backwards through the swarm and can short-circuit,', '        # the for-loop is faster than vectorization', '        _, y_i, r_i = xyr_i', '        neighbors = []', '        for xyr_j in reversed(swarm):', '            _, y_j, r_j = xyr_j', '            if (y_i - y_j) < (r_i + r_j):', '                neighbors.append(xyr_j)', '            else:', '                break', '        return np.array(neighbors)[::-1]']}, {'name': 'position_candidates', 'start_line': 3466, 'end_line': 3481, 'text': ['    def position_candidates(self, xyr_i, neighbors):', '        \"\"\"Return a list of coordinates that might be valid by adjusting x.\"\"\"', '        candidates = [xyr_i]', '        x_i, y_i, r_i = xyr_i', '        left_first = True', '        for x_j, y_j, r_j in neighbors:', '            dy = y_i - y_j', '            dx = np.sqrt(max((r_i + r_j) ** 2 - dy ** 2, 0)) * 1.05', '            cl, cr = (x_j - dx, y_i, r_i), (x_j + dx, y_i, r_i)', '            if left_first:', '                new_candidates = [cl, cr]', '            else:', '                new_candidates = [cr, cl]', '            candidates.extend(new_candidates)', '            left_first = not left_first', '        return np.array(candidates)']}, {'name': 'first_non_overlapping_candidate', 'start_line': 3483, 'end_line': 3514, 'text': ['    def first_non_overlapping_candidate(self, candidates, neighbors):', '        \"\"\"Find the first candidate that does not overlap with the swarm.\"\"\"', '', '        # If we have no neighbors, all candidates are good.', '        if len(neighbors) == 0:', '            return candidates[0]', '', '        neighbors_x = neighbors[:, 0]', '        neighbors_y = neighbors[:, 1]', '        neighbors_r = neighbors[:, 2]', '', '        for xyr_i in candidates:', '', '            x_i, y_i, r_i = xyr_i', '', '            dx = neighbors_x - x_i', '            dy = neighbors_y - y_i', '            sq_distances = np.square(dx) + np.square(dy)', '', '            sep_needed = np.square(neighbors_r + r_i)', '', '            # Good candidate does not overlap any of neighbors which means that', '            # squared distance between candidate and any of the neighbors has', '            # to be at least square of the summed radii', '            good_candidate = np.all(sq_distances >= sep_needed)', '', '            if good_candidate:', '                return xyr_i', '', '        raise RuntimeError(', '            \"No non-overlapping candidates found. This should not happen.\"', '        )']}, {'name': 'add_gutters', 'start_line': 3516, 'end_line': 3542, 'text': ['    def add_gutters(self, points, center, log_scale=False):', '        \"\"\"Stop points from extending beyond their territory.\"\"\"', '        half_width = self.width / 2', '        if log_scale:', '            low_gutter = 10 ** (np.log10(center) - half_width)', '        else:', '            low_gutter = center - half_width', '        off_low = points < low_gutter', '        if off_low.any():', '            points[off_low] = low_gutter', '        if log_scale:', '            high_gutter = 10 ** (np.log10(center) + half_width)', '        else:', '            high_gutter = center + half_width', '        off_high = points > high_gutter', '        if off_high.any():', '            points[off_high] = high_gutter', '', '        gutter_prop = (off_high + off_low).sum() / len(points)', '        if gutter_prop > self.warn_thresh:', '            msg = (', '                \"{:.1%} of the points cannot be placed; you may want \"', '                \"to decrease the size of the markers or use stripplot.\"', '            ).format(gutter_prop)', '            warnings.warn(msg, UserWarning)', '', '        return points']}]}], 'functions': [{'name': 'boxplot', 'start_line': 2223, 'end_line': 2239, 'text': ['def boxplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    orient=None, color=None, palette=None, saturation=.75, width=.8,', '    dodge=True, fliersize=5, linewidth=None, whis=1.5, ax=None,', '    **kwargs', '):', '', '    plotter = _BoxPlotter(x, y, hue, data, order, hue_order,', '                          orient, color, palette, saturation,', '                          width, dodge, fliersize, linewidth)', '', '    if ax is None:', '        ax = plt.gca()', '    kwargs.update(dict(whis=whis))', '', '    plotter.plot(ax, kwargs)', '    return ax']}, {'name': 'violinplot', 'start_line': 2296, 'end_line': 2313, 'text': ['def violinplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    bw=\"scott\", cut=2, scale=\"area\", scale_hue=True, gridsize=100,', '    width=.8, inner=\"box\", split=False, dodge=True, orient=None,', '    linewidth=None, color=None, palette=None, saturation=.75,', '    ax=None, **kwargs,', '):', '', '    plotter = _ViolinPlotter(x, y, hue, data, order, hue_order,', '                             bw, cut, scale, scale_hue, gridsize,', '                             width, inner, split, dodge, orient, linewidth,', '                             color, palette, saturation)', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax)', '    return ax']}, {'name': 'boxenplot', 'start_line': 2398, 'end_line': 2415, 'text': ['def boxenplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    orient=None, color=None, palette=None, saturation=.75,', \"    width=.8, dodge=True, k_depth='tukey', linewidth=None,\", \"    scale='exponential', outlier_prop=0.007, trust_alpha=0.05,\", '    showfliers=True,', '    ax=None, box_kws=None, flier_kws=None, line_kws=None,', '):', '    plotter = _LVPlotter(x, y, hue, data, order, hue_order,', '                         orient, color, palette, saturation,', '                         width, dodge, k_depth, linewidth, scale,', '                         outlier_prop, trust_alpha, showfliers)', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax, box_kws, flier_kws, line_kws)', '    return ax']}, {'name': 'stripplot', 'start_line': 2494, 'end_line': 2550, 'text': ['def stripplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    jitter=True, dodge=False, orient=None, color=None, palette=None,', '    size=5, edgecolor=\"gray\", linewidth=0,', '    hue_norm=None, native_scale=False, formatter=None, legend=\"auto\",', '    ax=None, **kwargs', '):', '', '    p = _CategoricalPlotterNew(', '        data=data,', '        variables=_CategoricalPlotterNew.get_semantics(locals()),', '        order=order,', '        orient=orient,', '        require_numeric=False,', '        legend=legend,', '    )', '', '    if ax is None:', '        ax = plt.gca()', '', '    if p.var_types.get(p.cat_axis) == \"categorical\" or not native_scale:', '        p.scale_categorical(p.cat_axis, order=order, formatter=formatter)', '', '    p._attach(ax)', '', '    hue_order = p._palette_without_hue_backcompat(palette, hue_order)', '    palette, hue_order = p._hue_backcompat(color, palette, hue_order)', '', '    color = _default_color(ax.scatter, hue, color, kwargs)', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    # XXX Copying possibly bad default decisions from original code for now', '    kwargs.setdefault(\"zorder\", 3)', '    size = kwargs.get(\"s\", size)', '', '    kwargs.update(dict(', '        s=size ** 2,', '        edgecolor=edgecolor,', '        linewidth=linewidth)', '    )', '', '    p.plot_strips(', '        jitter=jitter,', '        dodge=dodge,', '        color=color,', '        edgecolor=edgecolor,', '        plot_kws=kwargs,', '    )', '', '    # XXX this happens inside a plotting method in the distribution plots', \"    # but maybe it's better out here? Alternatively, we have an open issue\", '    # suggesting that _attach could add default axes labels, which seems smart.', '    p._add_axis_labels(ax)', '    p._adjust_cat_axis(ax, axis=p.cat_axis)', '', '    return ax']}, {'name': 'swarmplot', 'start_line': 2615, 'end_line': 2673, 'text': ['def swarmplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    dodge=False, orient=None, color=None, palette=None,', '    size=5, edgecolor=\"gray\", linewidth=0, hue_norm=None,', '    native_scale=False, formatter=None, legend=\"auto\", warn_thresh=.05,', '    ax=None, **kwargs', '):', '', '    p = _CategoricalPlotterNew(', '        data=data,', '        variables=_CategoricalPlotterNew.get_semantics(locals()),', '        order=order,', '        orient=orient,', '        require_numeric=False,', '        legend=legend,', '    )', '', '    if ax is None:', '        ax = plt.gca()', '', '    if p.var_types.get(p.cat_axis) == \"categorical\" or not native_scale:', '        p.scale_categorical(p.cat_axis, order=order, formatter=formatter)', '', '    p._attach(ax)', '', '    if not p.has_xy_data:', '        return ax', '', '    hue_order = p._palette_without_hue_backcompat(palette, hue_order)', '    palette, hue_order = p._hue_backcompat(color, palette, hue_order)', '', '    color = _default_color(ax.scatter, hue, color, kwargs)', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    # XXX Copying possibly bad default decisions from original code for now', '    kwargs.setdefault(\"zorder\", 3)', '    size = kwargs.get(\"s\", size)', '', '    if linewidth is None:', '        linewidth = size / 10', '', '    kwargs.update(dict(', '        s=size ** 2,', '        linewidth=linewidth,', '    ))', '', '    p.plot_swarms(', '        dodge=dodge,', '        color=color,', '        edgecolor=edgecolor,', '        warn_thresh=warn_thresh,', '        plot_kws=kwargs,', '    )', '', '    p._add_axis_labels(ax)', '    p._adjust_cat_axis(ax, axis=p.cat_axis)', '', '    return ax']}, {'name': 'barplot', 'start_line': 2737, 'end_line': 2762, 'text': ['def barplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,', '    orient=None, color=None, palette=None, saturation=.75, width=.8,', '    errcolor=\".26\", errwidth=None, capsize=None, dodge=True, ci=\"deprecated\",', '    ax=None,', '    **kwargs,', '):', '', '    errorbar = utils._deprecate_ci(errorbar, ci)', '', '    # Be backwards compatible with len passed directly, which', '    # does not work in Series.agg (maybe a pandas bug?)', '    if estimator is len:', '        estimator = \"size\"', '', '    plotter = _BarPlotter(x, y, hue, data, order, hue_order,', '                          estimator, errorbar, n_boot, units, seed,', '                          orient, color, palette, saturation,', '                          width, errcolor, errwidth, capsize, dodge)', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax, kwargs)', '    return ax']}, {'name': 'pointplot', 'start_line': 2827, 'end_line': 2846, 'text': ['def pointplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,', '    markers=\"o\", linestyles=\"-\", dodge=False, join=True, scale=1,', '    orient=None, color=None, palette=None, errwidth=None, ci=\"deprecated\",', '    capsize=None, ax=None,', '):', '', '    errorbar = utils._deprecate_ci(errorbar, ci)', '', '    plotter = _PointPlotter(x, y, hue, data, order, hue_order,', '                            estimator, errorbar, n_boot, units, seed,', '                            markers, linestyles, dodge, join, scale,', '                            orient, color, palette, errwidth, capsize)', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax)', '    return ax']}, {'name': 'countplot', 'start_line': 2915, 'end_line': 2952, 'text': ['def countplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    orient=None, color=None, palette=None, saturation=.75, width=.8,', '    dodge=True, ax=None, **kwargs', '):', '', '    estimator = \"size\"', '    errorbar = None', '    n_boot = 0', '    units = None', '    seed = None', '    errcolor = None', '    errwidth = None', '    capsize = None', '', '    if x is None and y is not None:', '        orient = \"h\"', '        x = y', '    elif y is None and x is not None:', '        orient = \"v\"', '        y = x', '    elif x is not None and y is not None:', '        raise ValueError(\"Cannot pass values for both `x` and `y`\")', '', '    plotter = _CountPlotter(', '        x, y, hue, data, order, hue_order,', '        estimator, errorbar, n_boot, units, seed,', '        orient, color, palette, saturation,', '        width, errcolor, errwidth, capsize, dodge', '    )', '', '    plotter.value_label = \"count\"', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax, kwargs)', '    return ax']}, {'name': 'catplot', 'start_line': 2999, 'end_line': 3258, 'text': ['def catplot(', '    data=None, *, x=None, y=None, hue=None, row=None, col=None,', '    col_wrap=None, estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000,', '    units=None, seed=None, order=None, hue_order=None, row_order=None,', '    col_order=None, height=5, aspect=1, kind=\"strip\", native_scale=False,', '    formatter=None, orient=None, color=None, palette=None, hue_norm=None,', '    legend=\"auto\", legend_out=True, sharex=True, sharey=True,', '    margin_titles=False, facet_kws=None, ci=\"deprecated\",', '    **kwargs', '):', '', '    # Determine the plotting function', '    try:', '        plot_func = globals()[kind + \"plot\"]', '    except KeyError:', '        err = f\"Plot kind \\'{kind}\\' is not recognized\"', '        raise ValueError(err)', '', '    # Check for attempt to plot onto specific axes and warn', '    if \"ax\" in kwargs:', '        msg = (\"catplot is a figure-level function and does not accept \"', '               f\"target axes. You may wish to try {kind}plot\")', '        warnings.warn(msg, UserWarning)', '        kwargs.pop(\"ax\")', '', '    refactored_kinds = [\"strip\", \"swarm\"]', '    if kind in refactored_kinds:', '', '        p = _CategoricalFacetPlotter(', '            data=data,', '            variables=_CategoricalFacetPlotter.get_semantics(locals()),', '            order=order,', '            orient=orient,', '            require_numeric=False,', '            legend=legend,', '        )', '', '        # XXX Copying a fair amount from displot, which is not ideal', '', '        for var in [\"row\", \"col\"]:', '            # Handle faceting variables that lack name information', '            if var in p.variables and p.variables[var] is None:', '                p.variables[var] = f\"_{var}_\"', '', '        # Adapt the plot_data dataframe for use with FacetGrid', '        data = p.plot_data.rename(columns=p.variables)', '        data = data.loc[:, ~data.columns.duplicated()]', '', '        col_name = p.variables.get(\"col\", None)', '        row_name = p.variables.get(\"row\", None)', '', '        if facet_kws is None:', '            facet_kws = {}', '', '        g = FacetGrid(', '            data=data, row=row_name, col=col_name,', '            col_wrap=col_wrap, row_order=row_order,', '            col_order=col_order, height=height,', '            sharex=sharex, sharey=sharey,', '            aspect=aspect,', '            **facet_kws,', '        )', '', '        # Capture this here because scale_categorical is going to insert a (null)', \"        # x variable even if it is empty. It's not clear whether that needs to\", '        # happen or if disabling that is the cleaner solution.', '        has_xy_data = p.has_xy_data', '', '        if not native_scale or p.var_types[p.cat_axis] == \"categorical\":', '            p.scale_categorical(p.cat_axis, order=order, formatter=formatter)', '', '        p._attach(g)', '', '        if not has_xy_data:', '            return g', '', '        hue_order = p._palette_without_hue_backcompat(palette, hue_order)', '        palette, hue_order = p._hue_backcompat(color, palette, hue_order)', '        p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '        # Set a default color', '        # Otherwise each artist will be plotted separately and trip the color cycle', '        if hue is None and color is None:', '            color = \"C0\"', '', '        if kind == \"strip\":', '', '            # TODO get these defaults programmatically?', '            jitter = kwargs.pop(\"jitter\", True)', '            dodge = kwargs.pop(\"dodge\", False)', '            edgecolor = kwargs.pop(\"edgecolor\", \"gray\")  # XXX TODO default', '', '            plot_kws = kwargs.copy()', '', '            # XXX Copying possibly bad default decisions from original code for now', '            plot_kws.setdefault(\"zorder\", 3)', '            plot_kws.setdefault(\"s\", plot_kws.pop(\"size\", 5) ** 2)', '            plot_kws.setdefault(\"linewidth\", 0)', '', '            p.plot_strips(', '                jitter=jitter,', '                dodge=dodge,', '                color=color,', '                edgecolor=edgecolor,', '                plot_kws=plot_kws,', '            )', '', '        elif kind == \"swarm\":', '', '            # TODO get these defaults programmatically?', '            dodge = kwargs.pop(\"dodge\", False)', '            edgecolor = kwargs.pop(\"edgecolor\", \"gray\")  # XXX TODO default', '            warn_thresh = kwargs.pop(\"warn_thresh\", .05)', '', '            plot_kws = kwargs.copy()', '', '            # XXX Copying possibly bad default decisions from original code for now', '            plot_kws.setdefault(\"zorder\", 3)', '            plot_kws.setdefault(\"s\", plot_kws.pop(\"size\", 5) ** 2)', '', '            if plot_kws.setdefault(\"linewidth\", 0) is None:', '                plot_kws[\"linewidth\"] = np.sqrt(plot_kws[\"s\"]) / 10', '', '            p.plot_swarms(', '                dodge=dodge,', '                color=color,', '                edgecolor=edgecolor,', '                warn_thresh=warn_thresh,', '                plot_kws=plot_kws,', '            )', '', '        # XXX best way to do this housekeeping?', '        for ax in g.axes.flat:', '            p._adjust_cat_axis(ax, axis=p.cat_axis)', '', '        g.set_axis_labels(', '            p.variables.get(\"x\", None),', '            p.variables.get(\"y\", None),', '        )', '        g.set_titles()', '        g.tight_layout()', '', '        # XXX Hack to get the legend data in the right place', '        for ax in g.axes.flat:', '            g._update_legend_data(ax)', '            ax.legend_ = None', '', '        if legend and (hue is not None) and (hue not in [x, row, col]):', '            g.add_legend(title=hue, label_order=hue_order)', '', '        return g', '', \"    # Don't allow usage of forthcoming functionality\", '    if native_scale is True:', '        err = f\"native_scale not yet implemented for `kind={kind}`\"', '        raise ValueError(err)', '    if formatter is not None:', '        err = f\"formatter not yet implemented for `kind={kind}`\"', '        raise ValueError(err)', '', '    # Alias the input variables to determine categorical order and palette', '    # correctly in the case of a count plot', '    if kind == \"count\":', '        if x is None and y is not None:', '            x_, y_, orient = y, y, \"h\"', '        elif y is None and x is not None:', '            x_, y_, orient = x, x, \"v\"', '        else:', '            raise ValueError(\"Either `x` or `y` must be None for kind=\\'count\\'\")', '    else:', '        x_, y_ = x, y', '', '    # Determine the order for the whole dataset, which will be used in all', '    # facets to ensure representation of all data in the final plot', '    plotter_class = {', '        \"box\": _BoxPlotter,', '        \"violin\": _ViolinPlotter,', '        \"boxen\": _LVPlotter,', '        \"bar\": _BarPlotter,', '        \"point\": _PointPlotter,', '        \"count\": _CountPlotter,', '    }[kind]', '    p = _CategoricalPlotter()', '    p.require_numeric = plotter_class.require_numeric', '    p.establish_variables(x_, y_, hue, data, orient, order, hue_order)', '    if (', '        order is not None', '        or (sharex and p.orient == \"v\")', '        or (sharey and p.orient == \"h\")', '    ):', '        # Sync categorical axis between facets to have the same categories', '        order = p.group_names', '    elif color is None and hue is None:', '        msg = (', '            \"Setting `{}=False` with `color=None` may cause different levels of the \"', '            \"`{}` variable to share colors. This will change in a future version.\"', '        )', '        if not sharex and p.orient == \"v\":', '            warnings.warn(msg.format(\"sharex\", \"x\"), UserWarning)', '        if not sharey and p.orient == \"h\":', '            warnings.warn(msg.format(\"sharey\", \"y\"), UserWarning)', '', '    hue_order = p.hue_names', '', '    # Determine the palette to use', '    # (FacetGrid will pass a value for ``color`` to the plotting function', '    # so we need to define ``palette`` to get default behavior for the', '    # categorical functions', '    p.establish_colors(color, palette, 1)', '    if kind != \"point\" or hue is not None:', '        palette = p.colors', '', '    # Determine keyword arguments for the facets', '    facet_kws = {} if facet_kws is None else facet_kws', '    facet_kws.update(', '        data=data, row=row, col=col,', '        row_order=row_order, col_order=col_order,', '        col_wrap=col_wrap, height=height, aspect=aspect,', '        sharex=sharex, sharey=sharey,', '        legend_out=legend_out, margin_titles=margin_titles,', '        dropna=False,', '    )', '', '    # Determine keyword arguments for the plotting function', '    plot_kws = dict(', '        order=order, hue_order=hue_order,', '        orient=orient, color=color, palette=palette,', '    )', '    plot_kws.update(kwargs)', '', '    if kind in [\"bar\", \"point\"]:', '        errorbar = utils._deprecate_ci(errorbar, ci)', '        plot_kws.update(', '            estimator=estimator, errorbar=errorbar,', '            n_boot=n_boot, units=units, seed=seed,', '        )', '', '    # Initialize the facets', '    g = FacetGrid(**facet_kws)', '', '    # Draw the plot onto the facets', '    g.map_dataframe(plot_func, x=x, y=y, hue=hue, **plot_kws)', '', '    if p.orient == \"h\":', '        g.set_axis_labels(p.value_label, p.group_label)', '    else:', '        g.set_axis_labels(p.group_label, p.value_label)', '', '    # Special case axis labels for a count type plot', '    if kind == \"count\":', '        if x is None:', '            g.set_axis_labels(x_var=\"count\")', '        if y is None:', '            g.set_axis_labels(y_var=\"count\")', '', '    if legend and (hue is not None) and (hue not in [x, row, col]):', '        hue_order = list(map(utils.to_utf8, hue_order))', '        g.add_legend(title=hue, label_order=hue_order)', '', '    return g']}, {'name': 'height', 'start_line': 1899, 'end_line': 1900, 'text': ['            def height(b):', '                return b[1] - b[0]']}, {'name': 'vert_perc_box', 'start_line': 1903, 'end_line': 1907, 'text': ['            def vert_perc_box(x, b, i, k, w):', '                rect = Patches.Rectangle((x - widths * w / 2, b[0]),', '                                         widths * w,', '                                         height(b), fill=True)', '                return rect']}, {'name': 'horz_perc_box', 'start_line': 1909, 'end_line': 1913, 'text': ['            def horz_perc_box(x, b, i, k, w):', '                rect = Patches.Rectangle((b[0], x - widths * w / 2),', '                                         height(b), widths * w,', '                                         fill=True)', '                return rect']}, {'name': 'draw', 'start_line': 375, 'end_line': 395, 'text': ['                def draw(points, renderer, *, center=center):', '', '                    beeswarm(points, center)', '', '                    if self.orient == \"h\":', '                        scalex = False', '                        scaley = ax.get_autoscaley_on()', '                    else:', '                        scalex = ax.get_autoscalex_on()', '                        scaley = False', '', '                    # This prevents us from undoing the nice categorical axis limits', '                    # set in _adjust_cat_axis, because that method currently leave', '                    # the autoscale flag in its original setting. It may be better', '                    # to disable autoscaling there to avoid needing to do this.', '                    fixed_scale = self.var_types[self.cat_axis] == \"categorical\"', '                    ax.update_datalim(points.get_datalim(ax.transData))', '                    if not fixed_scale and (scalex or scaley):', '                        ax.autoscale_view(scalex=scalex, scaley=scaley)', '', '                    super(points.__class__, points).draw(renderer)']}], 'text': ['from textwrap import dedent', 'from numbers import Number', 'import warnings', 'from colorsys import rgb_to_hls', 'from functools import partial', '', 'import numpy as np', 'import pandas as pd', 'try:', '    from scipy.stats import gaussian_kde', '    _no_scipy = False', 'except ImportError:', '    from .external.kde import gaussian_kde', '    _no_scipy = True', '', 'import matplotlib as mpl', 'from matplotlib.collections import PatchCollection', 'import matplotlib.patches as Patches', 'import matplotlib.pyplot as plt', '', 'from seaborn._oldcore import (', '    variable_type,', '    infer_orient,', '    categorical_order,', ')', 'from seaborn.relational import _RelationalPlotter', 'from seaborn import utils', 'from seaborn.utils import remove_na, _normal_quantile_func, _draw_figure, _default_color', 'from seaborn._statistics import EstimateAggregator', 'from seaborn.palettes import color_palette, husl_palette, light_palette, dark_palette', 'from seaborn.axisgrid import FacetGrid, _facet_docs', '', '', '__all__ = [', '    \"catplot\",', '    \"stripplot\", \"swarmplot\",', '    \"boxplot\", \"violinplot\", \"boxenplot\",', '    \"pointplot\", \"barplot\", \"countplot\",', ']', '', '', '# Subclassing _RelationalPlotter for the legend machinery,', '# but probably should move that more centrally', 'class _CategoricalPlotterNew(_RelationalPlotter):', '', '    semantics = \"x\", \"y\", \"hue\", \"units\"', '', '    wide_structure = {\"x\": \"@columns\", \"y\": \"@values\", \"hue\": \"@columns\"}', '', '    # flat_structure = {\"x\": \"@values\", \"y\": \"@values\"}', '    flat_structure = {\"y\": \"@values\"}', '', '    _legend_func = \"scatter\"', '    _legend_attributes = [\"color\"]', '', '    def __init__(', '        self,', '        data=None,', '        variables={},', '        order=None,', '        orient=None,', '        require_numeric=False,', '        legend=\"auto\",', '    ):', '', '        super().__init__(data=data, variables=variables)', '', '        # This method takes care of some bookkeeping that is necessary because the', '        # original categorical plots (prior to the 2021 refactor) had some rules that', \"        # don't fit exactly into the logic of _core. It may be wise to have a second\", '        # round of refactoring that moves the logic deeper, but this will keep things', '        # relatively sensible for now.', '', '        # For wide data, orient determines assignment to x/y differently from the', '        # wide_structure rules in _core. If we do decide to make orient part of the', \"        # _core variable assignment, we'll want to figure out how to express that.\", '        if self.input_format == \"wide\" and orient == \"h\":', '            self.plot_data = self.plot_data.rename(columns={\"x\": \"y\", \"y\": \"x\"})', '            orig_variables = set(self.variables)', '            orig_x = self.variables.pop(\"x\", None)', '            orig_y = self.variables.pop(\"y\", None)', '            orig_x_type = self.var_types.pop(\"x\", None)', '            orig_y_type = self.var_types.pop(\"y\", None)', '            if \"x\" in orig_variables:', '                self.variables[\"y\"] = orig_x', '                self.var_types[\"y\"] = orig_x_type', '            if \"y\" in orig_variables:', '                self.variables[\"x\"] = orig_y', '                self.var_types[\"x\"] = orig_y_type', '', '        # The concept of an \"orientation\" is important to the original categorical', \"        # plots, but there's no provision for it in _core, so we need to do it here.\", '        # Note that it could be useful for the other functions in at least two ways', '        # (orienting a univariate distribution plot from long-form data and selecting', '        # the aggregation axis in lineplot), so we may want to eventually refactor it.', '        self.orient = infer_orient(', '            x=self.plot_data.get(\"x\", None),', '            y=self.plot_data.get(\"y\", None),', '            orient=orient,', '            require_numeric=require_numeric,', '        )', '', '        self.legend = legend', '', '        # Short-circuit in the case of an empty plot', '        if not self.has_xy_data:', '            return', '', '        # Categorical plots can be \"univariate\" in which case they get an anonymous', '        # category label on the opposite axis. Note: this duplicates code in the core', '        # scale_categorical function. We need to do it here because of the next line.', '        if self.cat_axis not in self.variables:', '            self.variables[self.cat_axis] = None', '            self.var_types[self.cat_axis] = \"categorical\"', '            self.plot_data[self.cat_axis] = \"\"', '', '        # Categorical variables have discrete levels that we need to track', '        cat_levels = categorical_order(self.plot_data[self.cat_axis], order)', '        self.var_levels[self.cat_axis] = cat_levels', '', '    def _hue_backcompat(self, color, palette, hue_order, force_hue=False):', '        \"\"\"Implement backwards compatibility for hue parametrization.', '', '        Note: the force_hue parameter is used so that functions can be shown to', '        pass existing tests during refactoring and then tested for new behavior.', '        It can be removed after completion of the work.', '', '        \"\"\"', '        # The original categorical functions applied a palette to the categorical axis', '        # by default. We want to require an explicit hue mapping, to be more consistent', \"        # with how things work elsewhere now. I don't think there's any good way to\", \"        # do this gently -- because it's triggered by the default value of hue=None,\", '        # users would always get a warning, unless we introduce some sentinel \"default\"', \"        # argument for this change. That's possible, but asking users to set `hue=None`\", '        # on every call is annoying.', '        # We are keeping the logic for implementing the old behavior in with the current', '        # system so that (a) we can punt on that decision and (b) we can ensure that', '        # refactored code passes old tests.', '        default_behavior = color is None or palette is not None', '        if force_hue and \"hue\" not in self.variables and default_behavior:', '            self._redundant_hue = True', '            self.plot_data[\"hue\"] = self.plot_data[self.cat_axis]', '            self.variables[\"hue\"] = self.variables[self.cat_axis]', '            self.var_types[\"hue\"] = \"categorical\"', '            hue_order = self.var_levels[self.cat_axis]', '', '            # Because we convert the categorical axis variable to string,', '            # we need to update a dictionary palette too', '            if isinstance(palette, dict):', '                palette = {str(k): v for k, v in palette.items()}', '', '        else:', '            self._redundant_hue = False', '', '        # Previously, categorical plots had a trick where color= could seed the palette.', \"        # Because that's an explicit parameterization, we are going to give it one\", '        # release cycle with a warning before removing.', '        if \"hue\" in self.variables and palette is None and color is not None:', '            if not isinstance(color, str):', '                color = mpl.colors.to_hex(color)', '            palette = f\"dark:{color}\"', '            msg = (', '                \"Setting a gradient palette using color= is deprecated and will be \"', '                f\"removed in version 0.13. Set `palette=\\'{palette}\\'` for same effect.\"', '            )', '            warnings.warn(msg, FutureWarning)', '', '        return palette, hue_order', '', '    def _palette_without_hue_backcompat(self, palette, hue_order):', '        \"\"\"Provide one cycle where palette= implies hue= when not provided\"\"\"', '        if \"hue\" not in self.variables and palette is not None:', '            msg = \"Passing `palette` without assigning `hue` is deprecated.\"', '            warnings.warn(msg, FutureWarning, stacklevel=3)', '            self.legend = False', '            self.plot_data[\"hue\"] = self.plot_data[self.cat_axis]', '            self.variables[\"hue\"] = self.variables.get(self.cat_axis)', '            self.var_types[\"hue\"] = self.var_types.get(self.cat_axis)', '            hue_order = self.var_levels.get(self.cat_axis)', '        return hue_order', '', '    @property', '    def cat_axis(self):', '        return {\"v\": \"x\", \"h\": \"y\"}[self.orient]', '', '    def _get_gray(self, colors):', '        \"\"\"Get a grayscale value that looks good with color.\"\"\"', '        if not len(colors):', '            return None', '        unique_colors = np.unique(colors, axis=0)', '        light_vals = [rgb_to_hls(*rgb[:3])[1] for rgb in unique_colors]', '        lum = min(light_vals) * .6', '        return (lum, lum, lum)', '', '    def _adjust_cat_axis(self, ax, axis):', '        \"\"\"Set ticks and limits for a categorical variable.\"\"\"', '        # Note: in theory, this could happen in _attach for all categorical axes', '        # But two reasons not to do that:', '        # - If it happens before plotting, autoscaling messes up the plot limits', '        # - It would change existing plots from other seaborn functions', '        if self.var_types[axis] != \"categorical\":', '            return', '', '        # If both x/y data are empty, the correct way to set up the plot is', \"        # somewhat undefined; because we don't add null category data to the plot in\", \"        # this case we don't *have* a categorical axis (yet), so best to just bail.\", '        if self.plot_data[axis].empty:', '            return', '', '        # We can infer the total number of categories (including those from previous', '        # plots that are not part of the plot we are currently making) from the number', '        # of ticks, which matplotlib sets up while doing unit conversion. This feels', '        # slightly risky, as if we are relying on something that may be a matplotlib', '        # implementation detail. But I cannot think of a better way to keep track of', '        # the state from previous categorical calls (see GH2516 for context)', '        n = len(getattr(ax, f\"get_{axis}ticks\")())', '', '        if axis == \"x\":', '            ax.xaxis.grid(False)', '            ax.set_xlim(-.5, n - .5, auto=None)', '        else:', '            ax.yaxis.grid(False)', '            # Note limits that correspond to previously-inverted y axis', '            ax.set_ylim(n - .5, -.5, auto=None)', '', '    @property', '    def _native_width(self):', '        \"\"\"Return unit of width separating categories on native numeric scale.\"\"\"', '        unique_values = np.unique(self.comp_data[self.cat_axis])', '        if len(unique_values) > 1:', '            native_width = np.nanmin(np.diff(unique_values))', '        else:', '            native_width = 1', '        return native_width', '', '    def _nested_offsets(self, width, dodge):', '        \"\"\"Return offsets for each hue level for dodged plots.\"\"\"', '        offsets = None', '        if \"hue\" in self.variables:', '            n_levels = len(self._hue_map.levels)', '            if dodge:', '                each_width = width / n_levels', '                offsets = np.linspace(0, width - each_width, n_levels)', '                offsets -= offsets.mean()', '            else:', '                offsets = np.zeros(n_levels)', '        return offsets', '', '    # Note that the plotting methods here aim (in most cases) to produce the', '    # exact same artists as the original (pre 0.12) version of the code, so', '    # there is some weirdness that might not otherwise be clean or make sense in', '    # this context, such as adding empty artists for combinations of variables', '    # with no observations', '', '    def plot_strips(', '        self,', '        jitter,', '        dodge,', '        color,', '        edgecolor,', '        plot_kws,', '    ):', '', '        width = .8 * self._native_width', '        offsets = self._nested_offsets(width, dodge)', '', '        if jitter is True:', '            jlim = 0.1', '        else:', '            jlim = float(jitter)', '        if \"hue\" in self.variables and dodge:', '            jlim /= len(self._hue_map.levels)', '        jlim *= self._native_width', '        jitterer = partial(np.random.uniform, low=-jlim, high=+jlim)', '', '        iter_vars = [self.cat_axis]', '        if dodge:', '            iter_vars.append(\"hue\")', '', '        ax = self.ax', '        dodge_move = jitter_move = 0', '', '        for sub_vars, sub_data in self.iter_data(iter_vars,', '                                                 from_comp_data=True,', '                                                 allow_empty=True):', '            if offsets is not None and (offsets != 0).any():', '                dodge_move = offsets[sub_data[\"hue\"].map(self._hue_map.levels.index)]', '', '            jitter_move = jitterer(size=len(sub_data)) if len(sub_data) > 1 else 0', '', '            adjusted_data = sub_data[self.cat_axis] + dodge_move + jitter_move', '            sub_data[self.cat_axis] = adjusted_data', '', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    sub_data[var] = np.power(10, sub_data[var])', '', '            ax = self._get_axes(sub_vars)', '            points = ax.scatter(sub_data[\"x\"], sub_data[\"y\"], color=color, **plot_kws)', '', '            if \"hue\" in self.variables:', '                points.set_facecolors(self._hue_map(sub_data[\"hue\"]))', '', '            if edgecolor == \"gray\":  # XXX TODO change to \"auto\"', '                points.set_edgecolors(self._get_gray(points.get_facecolors()))', '            else:', '                points.set_edgecolors(edgecolor)', '', '        # Finalize the axes details', '        if self.legend == \"auto\":', '            show_legend = not self._redundant_hue and self.input_format != \"wide\"', '        else:', '            show_legend = bool(self.legend)', '', '        if show_legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                ax.legend(title=self.legend_title)', '', '    def plot_swarms(', '        self,', '        dodge,', '        color,', '        edgecolor,', '        warn_thresh,', '        plot_kws,', '    ):', '', '        width = .8 * self._native_width', '        offsets = self._nested_offsets(width, dodge)', '', '        iter_vars = [self.cat_axis]', '        if dodge:', '            iter_vars.append(\"hue\")', '', '        ax = self.ax', '        point_collections = {}', '        dodge_move = 0', '', '        for sub_vars, sub_data in self.iter_data(iter_vars,', '                                                 from_comp_data=True,', '                                                 allow_empty=True):', '', '            if offsets is not None:', '                dodge_move = offsets[sub_data[\"hue\"].map(self._hue_map.levels.index)]', '', '            if not sub_data.empty:', '                sub_data[self.cat_axis] = sub_data[self.cat_axis] + dodge_move', '', '            for var in \"xy\":', '                if self._log_scaled(var):', '                    sub_data[var] = np.power(10, sub_data[var])', '', '            ax = self._get_axes(sub_vars)', '            points = ax.scatter(sub_data[\"x\"], sub_data[\"y\"], color=color, **plot_kws)', '', '            if \"hue\" in self.variables:', '                points.set_facecolors(self._hue_map(sub_data[\"hue\"]))', '', '            if edgecolor == \"gray\":  # XXX TODO change to \"auto\"', '                points.set_edgecolors(self._get_gray(points.get_facecolors()))', '            else:', '                points.set_edgecolors(edgecolor)', '', '            if not sub_data.empty:', '                point_collections[(ax, sub_data[self.cat_axis].iloc[0])] = points', '', '        beeswarm = Beeswarm(', '            width=width, orient=self.orient, warn_thresh=warn_thresh,', '        )', '        for (ax, center), points in point_collections.items():', '            if points.get_offsets().shape[0] > 1:', '', '                def draw(points, renderer, *, center=center):', '', '                    beeswarm(points, center)', '', '                    if self.orient == \"h\":', '                        scalex = False', '                        scaley = ax.get_autoscaley_on()', '                    else:', '                        scalex = ax.get_autoscalex_on()', '                        scaley = False', '', '                    # This prevents us from undoing the nice categorical axis limits', '                    # set in _adjust_cat_axis, because that method currently leave', '                    # the autoscale flag in its original setting. It may be better', '                    # to disable autoscaling there to avoid needing to do this.', '                    fixed_scale = self.var_types[self.cat_axis] == \"categorical\"', '                    ax.update_datalim(points.get_datalim(ax.transData))', '                    if not fixed_scale and (scalex or scaley):', '                        ax.autoscale_view(scalex=scalex, scaley=scaley)', '', '                    super(points.__class__, points).draw(renderer)', '', '                points.draw = draw.__get__(points)', '', '        _draw_figure(ax.figure)', '', '        # Finalize the axes details', '        if self.legend == \"auto\":', '            show_legend = not self._redundant_hue and self.input_format != \"wide\"', '        else:', '            show_legend = bool(self.legend)', '', '        if show_legend:', '            self.add_legend_data(ax)', '            handles, _ = ax.get_legend_handles_labels()', '            if handles:', '                ax.legend(title=self.legend_title)', '', '', 'class _CategoricalFacetPlotter(_CategoricalPlotterNew):', '', '    semantics = _CategoricalPlotterNew.semantics + (\"col\", \"row\")', '', '', 'class _CategoricalPlotter:', '', '    width = .8', '    default_palette = \"light\"', '    require_numeric = True', '', '    def establish_variables(self, x=None, y=None, hue=None, data=None,', '                            orient=None, order=None, hue_order=None,', '                            units=None):', '        \"\"\"Convert input specification into a common representation.\"\"\"', '        # Option 1:', '        # We are plotting a wide-form dataset', '        # -----------------------------------', '        if x is None and y is None:', '', '            # Do a sanity check on the inputs', '            if hue is not None:', '                error = \"Cannot use `hue` without `x` and `y`\"', '                raise ValueError(error)', '', '            # No hue grouping with wide inputs', '            plot_hues = None', '            hue_title = None', '            hue_names = None', '', '            # No statistical units with wide inputs', '            plot_units = None', '', \"            # We also won't get a axes labels here\", '            value_label = None', '            group_label = None', '', '            # Option 1a:', '            # The input data is a Pandas DataFrame', '            # ------------------------------------', '', '            if isinstance(data, pd.DataFrame):', '', '                # Order the data correctly', '                if order is None:', '                    order = []', '                    # Reduce to just numeric columns', '                    for col in data:', '                        if variable_type(data[col]) == \"numeric\":', '                            order.append(col)', '                plot_data = data[order]', '                group_names = order', '                group_label = data.columns.name', '', '                # Convert to a list of arrays, the common representation', '                iter_data = plot_data.items()', '                plot_data = [np.asarray(s, float) for k, s in iter_data]', '', '            # Option 1b:', '            # The input data is an array or list', '            # ----------------------------------', '', '            else:', '', \"                # We can't reorder the data\", '                if order is not None:', '                    error = \"Input data must be a pandas object to reorder\"', '                    raise ValueError(error)', '', '                # The input data is an array', '                if hasattr(data, \"shape\"):', '                    if len(data.shape) == 1:', '                        if np.isscalar(data[0]):', '                            plot_data = [data]', '                        else:', '                            plot_data = list(data)', '                    elif len(data.shape) == 2:', '                        nr, nc = data.shape', '                        if nr == 1 or nc == 1:', '                            plot_data = [data.ravel()]', '                        else:', '                            plot_data = [data[:, i] for i in range(nc)]', '                    else:', '                        error = (\"Input `data` can have no \"', '                                 \"more than 2 dimensions\")', '                        raise ValueError(error)', '', '                # Check if `data` is None to let us bail out here (for testing)', '                elif data is None:', '                    plot_data = [[]]', '', '                # The input data is a flat list', '                elif np.isscalar(data[0]):', '                    plot_data = [data]', '', '                # The input data is a nested list', '                # This will catch some things that might fail later', '                # but exhaustive checks are hard', '                else:', '                    plot_data = data', '', '                # Convert to a list of arrays, the common representation', '                plot_data = [np.asarray(d, float) for d in plot_data]', '', '                # The group names will just be numeric indices', '                group_names = list(range(len(plot_data)))', '', '            # Figure out the plotting orientation', '            orient = \"h\" if str(orient).startswith(\"h\") else \"v\"', '', '        # Option 2:', '        # We are plotting a long-form dataset', '        # -----------------------------------', '', '        else:', '', '            # See if we need to get variables from `data`', '            if data is not None:', '                x = data.get(x, x)', '                y = data.get(y, y)', '                hue = data.get(hue, hue)', '                units = data.get(units, units)', '', '            # Validate the inputs', '            for var in [x, y, hue, units]:', '                if isinstance(var, str):', '                    err = f\"Could not interpret input \\'{var}\\'\"', '                    raise ValueError(err)', '', '            # Figure out the plotting orientation', '            orient = infer_orient(', '                x, y, orient, require_numeric=self.require_numeric', '            )', '', '            # Option 2a:', '            # We are plotting a single set of data', '            # ------------------------------------', '            if x is None or y is None:', '', '                # Determine where the data are', '                vals = y if x is None else x', '', '                # Put them into the common representation', '                plot_data = [np.asarray(vals)]', '', '                # Get a label for the value axis', '                if hasattr(vals, \"name\"):', '                    value_label = vals.name', '                else:', '                    value_label = None', '', '                # This plot will not have group labels or hue nesting', '                groups = None', '                group_label = None', '                group_names = []', '                plot_hues = None', '                hue_names = None', '                hue_title = None', '                plot_units = None', '', '            # Option 2b:', '            # We are grouping the data values by another variable', '            # ---------------------------------------------------', '            else:', '', '                # Determine which role each variable will play', '                if orient == \"v\":', '                    vals, groups = y, x', '                else:', '                    vals, groups = x, y', '', '                # Get the categorical axis label', '                group_label = None', '                if hasattr(groups, \"name\"):', '                    group_label = groups.name', '', '                # Get the order on the categorical axis', '                group_names = categorical_order(groups, order)', '', '                # Group the numeric data', '                plot_data, value_label = self._group_longform(vals, groups,', '                                                              group_names)', '', '                # Now handle the hue levels for nested ordering', '                if hue is None:', '                    plot_hues = None', '                    hue_title = None', '                    hue_names = None', '                else:', '', '                    # Get the order of the hue levels', '                    hue_names = categorical_order(hue, hue_order)', '', '                    # Group the hue data', '                    plot_hues, hue_title = self._group_longform(hue, groups,', '                                                                group_names)', '', '                # Now handle the units for nested observations', '                if units is None:', '                    plot_units = None', '                else:', '                    plot_units, _ = self._group_longform(units, groups,', '                                                         group_names)', '', '        # Assign object attributes', '        # ------------------------', '        self.orient = orient', '        self.plot_data = plot_data', '        self.group_label = group_label', '        self.value_label = value_label', '        self.group_names = group_names', '        self.plot_hues = plot_hues', '        self.hue_title = hue_title', '        self.hue_names = hue_names', '        self.plot_units = plot_units', '', '    def _group_longform(self, vals, grouper, order):', '        \"\"\"Group a long-form variable by another with correct order.\"\"\"', '        # Ensure that the groupby will work', '        if not isinstance(vals, pd.Series):', '            if isinstance(grouper, pd.Series):', '                index = grouper.index', '            else:', '                index = None', '            vals = pd.Series(vals, index=index)', '', '        # Group the val data', '        grouped_vals = vals.groupby(grouper)', '        out_data = []', '        for g in order:', '            try:', '                g_vals = grouped_vals.get_group(g)', '            except KeyError:', '                g_vals = np.array([])', '            out_data.append(g_vals)', '', '        # Get the vals axis label', '        label = vals.name', '', '        return out_data, label', '', '    def establish_colors(self, color, palette, saturation):', '        \"\"\"Get a list of colors for the main component of the plots.\"\"\"', '        if self.hue_names is None:', '            n_colors = len(self.plot_data)', '        else:', '            n_colors = len(self.hue_names)', '', '        # Determine the main colors', '        if color is None and palette is None:', '            # Determine whether the current palette will have enough values', \"            # If not, we'll default to the husl palette so each is distinct\", '            current_palette = utils.get_color_cycle()', '            if n_colors <= len(current_palette):', '                colors = color_palette(n_colors=n_colors)', '            else:', '                colors = husl_palette(n_colors, l=.7)  # noqa', '', '        elif palette is None:', '            # When passing a specific color, the interpretation depends', '            # on whether there is a hue variable or not.', '            # If so, we will make a blend palette so that the different', '            # levels have some amount of variation.', '            if self.hue_names is None:', '                colors = [color] * n_colors', '            else:', '                if self.default_palette == \"light\":', '                    colors = light_palette(color, n_colors)', '                elif self.default_palette == \"dark\":', '                    colors = dark_palette(color, n_colors)', '                else:', '                    raise RuntimeError(\"No default palette specified\")', '        else:', '', '            # Let `palette` be a dict mapping level to color', '            if isinstance(palette, dict):', '                if self.hue_names is None:', '                    levels = self.group_names', '                else:', '                    levels = self.hue_names', '                palette = [palette[l] for l in levels]', '', '            colors = color_palette(palette, n_colors)', '', '        # Desaturate a bit because these are patches', '        if saturation < 1:', '            colors = color_palette(colors, desat=saturation)', '', '        # Convert the colors to a common representations', '        rgb_colors = color_palette(colors)', '', '        # Determine the gray color to use for the lines framing the plot', '        light_vals = [rgb_to_hls(*c)[1] for c in rgb_colors]', '        lum = min(light_vals) * .6', '        gray = mpl.colors.rgb2hex((lum, lum, lum))', '', '        # Assign object attributes', '        self.colors = rgb_colors', '        self.gray = gray', '', '    @property', '    def hue_offsets(self):', '        \"\"\"A list of center positions for plots when hue nesting is used.\"\"\"', '        n_levels = len(self.hue_names)', '        if self.dodge:', '            each_width = self.width / n_levels', '            offsets = np.linspace(0, self.width - each_width, n_levels)', '            offsets -= offsets.mean()', '        else:', '            offsets = np.zeros(n_levels)', '', '        return offsets', '', '    @property', '    def nested_width(self):', '        \"\"\"A float with the width of plot elements when hue nesting is used.\"\"\"', '        if self.dodge:', '            width = self.width / len(self.hue_names) * .98', '        else:', '            width = self.width', '        return width', '', '    def annotate_axes(self, ax):', '        \"\"\"Add descriptive labels to an Axes object.\"\"\"', '        if self.orient == \"v\":', '            xlabel, ylabel = self.group_label, self.value_label', '        else:', '            xlabel, ylabel = self.value_label, self.group_label', '', '        if xlabel is not None:', '            ax.set_xlabel(xlabel)', '        if ylabel is not None:', '            ax.set_ylabel(ylabel)', '', '        group_names = self.group_names', '        if not group_names:', '            group_names = [\"\" for _ in range(len(self.plot_data))]', '', '        if self.orient == \"v\":', '            ax.set_xticks(np.arange(len(self.plot_data)))', '            ax.set_xticklabels(group_names)', '        else:', '            ax.set_yticks(np.arange(len(self.plot_data)))', '            ax.set_yticklabels(group_names)', '', '        if self.orient == \"v\":', '            ax.xaxis.grid(False)', '            ax.set_xlim(-.5, len(self.plot_data) - .5, auto=None)', '        else:', '            ax.yaxis.grid(False)', '            ax.set_ylim(-.5, len(self.plot_data) - .5, auto=None)', '', '        if self.hue_names is not None:', '            ax.legend(loc=\"best\", title=self.hue_title)', '', '    def add_legend_data(self, ax, color, label):', '        \"\"\"Add a dummy patch object so we can get legend data.\"\"\"', '        rect = plt.Rectangle([0, 0], 0, 0,', '                             linewidth=self.linewidth / 2,', '                             edgecolor=self.gray,', '                             facecolor=color,', '                             label=label)', '        ax.add_patch(rect)', '', '', 'class _BoxPlotter(_CategoricalPlotter):', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 orient, color, palette, saturation,', '                 width, dodge, fliersize, linewidth):', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)', '', '        self.dodge = dodge', '        self.width = width', '        self.fliersize = fliersize', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth', '', '    def draw_boxplot(self, ax, kws):', '        \"\"\"Use matplotlib to draw a boxplot on an Axes.\"\"\"', '        vert = self.orient == \"v\"', '', '        props = {}', '        for obj in [\"box\", \"whisker\", \"cap\", \"median\", \"flier\"]:', '            props[obj] = kws.pop(obj + \"props\", {})', '', '        for i, group_data in enumerate(self.plot_data):', '', '            if self.plot_hues is None:', '', '                # Handle case where there is data at this level', '                if group_data.size == 0:', '                    continue', '', '                # Draw a single box or a set of boxes', '                # with a single level of grouping', '                box_data = np.asarray(remove_na(group_data))', '', '                # Handle case where there is no non-null data', '                if box_data.size == 0:', '                    continue', '', '                artist_dict = ax.boxplot(box_data,', '                                         vert=vert,', '                                         patch_artist=True,', '                                         positions=[i],', '                                         widths=self.width,', '                                         **kws)', '                color = self.colors[i]', '                self.restyle_boxplot(artist_dict, color, props)', '            else:', '                # Draw nested groups of boxes', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Add a legend for this hue level', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle case where there is data at this level', '                    if group_data.size == 0:', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    box_data = np.asarray(remove_na(group_data[hue_mask]))', '', '                    # Handle case where there is no non-null data', '                    if box_data.size == 0:', '                        continue', '', '                    center = i + offsets[j]', '                    artist_dict = ax.boxplot(box_data,', '                                             vert=vert,', '                                             patch_artist=True,', '                                             positions=[center],', '                                             widths=self.nested_width,', '                                             **kws)', '                    self.restyle_boxplot(artist_dict, self.colors[j], props)', '                    # Add legend data, but just for one set of boxes', '', '    def restyle_boxplot(self, artist_dict, color, props):', '        \"\"\"Take a drawn matplotlib boxplot and make it look nice.\"\"\"', '        for box in artist_dict[\"boxes\"]:', '            box.update(dict(facecolor=color,', '                            zorder=.9,', '                            edgecolor=self.gray,', '                            linewidth=self.linewidth))', '            box.update(props[\"box\"])', '        for whisk in artist_dict[\"whiskers\"]:', '            whisk.update(dict(color=self.gray,', '                              linewidth=self.linewidth,', '                              linestyle=\"-\"))', '            whisk.update(props[\"whisker\"])', '        for cap in artist_dict[\"caps\"]:', '            cap.update(dict(color=self.gray,', '                            linewidth=self.linewidth))', '            cap.update(props[\"cap\"])', '        for med in artist_dict[\"medians\"]:', '            med.update(dict(color=self.gray,', '                            linewidth=self.linewidth))', '            med.update(props[\"median\"])', '        for fly in artist_dict[\"fliers\"]:', '            fly.update(dict(markerfacecolor=self.gray,', '                            marker=\"d\",', '                            markeredgecolor=self.gray,', '                            markersize=self.fliersize))', '            fly.update(props[\"flier\"])', '', '    def plot(self, ax, boxplot_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_boxplot(ax, boxplot_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()', '', '', 'class _ViolinPlotter(_CategoricalPlotter):', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 bw, cut, scale, scale_hue, gridsize,', '                 width, inner, split, dodge, orient, linewidth,', '                 color, palette, saturation):', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)', '        self.estimate_densities(bw, cut, scale, scale_hue, gridsize)', '', '        self.gridsize = gridsize', '        self.width = width', '        self.dodge = dodge', '', '        if inner is not None:', '            if not any([inner.startswith(\"quart\"),', '                        inner.startswith(\"box\"),', '                        inner.startswith(\"stick\"),', '                        inner.startswith(\"point\")]):', '                err = f\"Inner style \\'{inner}\\' not recognized\"', '                raise ValueError(err)', '        self.inner = inner', '', '        if split and self.hue_names is not None and len(self.hue_names) != 2:', '            msg = \"There must be exactly two hue levels to use `split`.\\'\"', '            raise ValueError(msg)', '        self.split = split', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth', '', '    def estimate_densities(self, bw, cut, scale, scale_hue, gridsize):', '        \"\"\"Find the support and density for all of the data.\"\"\"', '        # Initialize data structures to keep track of plotting data', '        if self.hue_names is None:', '            support = []', '            density = []', '            counts = np.zeros(len(self.plot_data))', '            max_density = np.zeros(len(self.plot_data))', '        else:', '            support = [[] for _ in self.plot_data]', '            density = [[] for _ in self.plot_data]', '            size = len(self.group_names), len(self.hue_names)', '            counts = np.zeros(size)', '            max_density = np.zeros(size)', '', '        for i, group_data in enumerate(self.plot_data):', '', '            # Option 1: we have a single level of grouping', '            # --------------------------------------------', '', '            if self.plot_hues is None:', '', '                # Strip missing datapoints', '                kde_data = remove_na(group_data)', '', '                # Handle special case of no data at this level', '                if kde_data.size == 0:', '                    support.append(np.array([]))', '                    density.append(np.array([1.]))', '                    counts[i] = 0', '                    max_density[i] = 0', '                    continue', '', '                # Handle special case of a single unique datapoint', '                elif np.unique(kde_data).size == 1:', '                    support.append(np.unique(kde_data))', '                    density.append(np.array([1.]))', '                    counts[i] = 1', '                    max_density[i] = 0', '                    continue', '', '                # Fit the KDE and get the used bandwidth size', '                kde, bw_used = self.fit_kde(kde_data, bw)', '', '                # Determine the support grid and get the density over it', '                support_i = self.kde_support(kde_data, bw_used, cut, gridsize)', '                density_i = kde.evaluate(support_i)', '', '                # Update the data structures with these results', '                support.append(support_i)', '                density.append(density_i)', '                counts[i] = kde_data.size', '                max_density[i] = density_i.max()', '', '            # Option 2: we have nested grouping by a hue variable', '            # ---------------------------------------------------', '', '            else:', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Handle special case of no data at this category level', '                    if not group_data.size:', '                        support[i].append(np.array([]))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 0', '                        max_density[i, j] = 0', '                        continue', '', '                    # Select out the observations for this hue level', '                    hue_mask = self.plot_hues[i] == hue_level', '', '                    # Strip missing datapoints', '                    kde_data = remove_na(group_data[hue_mask])', '', '                    # Handle special case of no data at this level', '                    if kde_data.size == 0:', '                        support[i].append(np.array([]))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 0', '                        max_density[i, j] = 0', '                        continue', '', '                    # Handle special case of a single unique datapoint', '                    elif np.unique(kde_data).size == 1:', '                        support[i].append(np.unique(kde_data))', '                        density[i].append(np.array([1.]))', '                        counts[i, j] = 1', '                        max_density[i, j] = 0', '                        continue', '', '                    # Fit the KDE and get the used bandwidth size', '                    kde, bw_used = self.fit_kde(kde_data, bw)', '', '                    # Determine the support grid and get the density over it', '                    support_ij = self.kde_support(kde_data, bw_used,', '                                                  cut, gridsize)', '                    density_ij = kde.evaluate(support_ij)', '', '                    # Update the data structures with these results', '                    support[i].append(support_ij)', '                    density[i].append(density_ij)', '                    counts[i, j] = kde_data.size', '                    max_density[i, j] = density_ij.max()', '', '        # Scale the height of the density curve.', '        # For a violinplot the density is non-quantitative.', '        # The objective here is to scale the curves relative to 1 so that', '        # they can be multiplied by the width parameter during plotting.', '', '        if scale == \"area\":', '            self.scale_area(density, max_density, scale_hue)', '', '        elif scale == \"width\":', '            self.scale_width(density)', '', '        elif scale == \"count\":', '            self.scale_count(density, counts, scale_hue)', '', '        else:', '            raise ValueError(f\"scale method \\'{scale}\\' not recognized\")', '', '        # Set object attributes that will be used while plotting', '        self.support = support', '        self.density = density', '', '    def fit_kde(self, x, bw):', '        \"\"\"Estimate a KDE for a vector of data with flexible bandwidth.\"\"\"', '        kde = gaussian_kde(x, bw)', '', '        # Extract the numeric bandwidth from the KDE object', '        bw_used = kde.factor', '', '        # At this point, bw will be a numeric scale factor.', '        # To get the actual bandwidth of the kernel, we multiple by the', '        # unbiased standard deviation of the data, which we will use', '        # elsewhere to compute the range of the support.', '        bw_used = bw_used * x.std(ddof=1)', '', '        return kde, bw_used', '', '    def kde_support(self, x, bw, cut, gridsize):', '        \"\"\"Define a grid of support for the violin.\"\"\"', '        support_min = x.min() - bw * cut', '        support_max = x.max() + bw * cut', '        return np.linspace(support_min, support_max, gridsize)', '', '    def scale_area(self, density, max_density, scale_hue):', '        \"\"\"Scale the relative area under the KDE curve.', '', '        This essentially preserves the \"standard\" KDE scaling, but the', '        resulting maximum density will be 1 so that the curve can be', '        properly multiplied by the violin width.', '', '        \"\"\"', '        if self.hue_names is None:', '            for d in density:', '                if d.size > 1:', '                    d /= max_density.max()', '        else:', '            for i, group in enumerate(density):', '                for d in group:', '                    if scale_hue:', '                        max = max_density[i].max()', '                    else:', '                        max = max_density.max()', '                    if d.size > 1:', '                        d /= max', '', '    def scale_width(self, density):', '        \"\"\"Scale each density curve to the same height.\"\"\"', '        if self.hue_names is None:', '            for d in density:', '                d /= d.max()', '        else:', '            for group in density:', '                for d in group:', '                    d /= d.max()', '', '    def scale_count(self, density, counts, scale_hue):', '        \"\"\"Scale each density curve by the number of observations.\"\"\"', '        if self.hue_names is None:', '            if counts.max() == 0:', '                d = 0', '            else:', '                for count, d in zip(counts, density):', '                    d /= d.max()', '                    d *= count / counts.max()', '        else:', '            for i, group in enumerate(density):', '                for j, d in enumerate(group):', '                    if counts[i].max() == 0:', '                        d = 0', '                    else:', '                        count = counts[i, j]', '                        if scale_hue:', '                            scaler = count / counts[i].max()', '                        else:', '                            scaler = count / counts.max()', '                        d /= d.max()', '                        d *= scaler', '', '    @property', '    def dwidth(self):', '', '        if self.hue_names is None or not self.dodge:', '            return self.width / 2', '        elif self.split:', '            return self.width / 2', '        else:', '            return self.width / (2 * len(self.hue_names))', '', '    def draw_violins(self, ax):', '        \"\"\"Draw the violins onto `ax`.\"\"\"', '        fill_func = ax.fill_betweenx if self.orient == \"v\" else ax.fill_between', '        for i, group_data in enumerate(self.plot_data):', '', '            kws = dict(edgecolor=self.gray, linewidth=self.linewidth)', '', '            # Option 1: we have a single level of grouping', '            # --------------------------------------------', '', '            if self.plot_hues is None:', '', '                support, density = self.support[i], self.density[i]', '', '                # Handle special case of no observations in this bin', '                if support.size == 0:', '                    continue', '', '                # Handle special case of a single observation', '                elif support.size == 1:', '                    val = support.item()', '                    d = density.item()', '                    self.draw_single_observation(ax, i, val, d)', '                    continue', '', '                # Draw the violin for this group', '                grid = np.ones(self.gridsize) * i', '                fill_func(support,', '                          grid - density * self.dwidth,', '                          grid + density * self.dwidth,', '                          facecolor=self.colors[i],', '                          **kws)', '', '                # Draw the interior representation of the data', '                if self.inner is None:', '                    continue', '', '                # Get a nan-free vector of datapoints', '                violin_data = remove_na(group_data)', '', '                # Draw box and whisker information', '                if self.inner.startswith(\"box\"):', '                    self.draw_box_lines(ax, violin_data, i)', '', '                # Draw quartile lines', '                elif self.inner.startswith(\"quart\"):', '                    self.draw_quartiles(ax, violin_data, support, density, i)', '', '                # Draw stick observations', '                elif self.inner.startswith(\"stick\"):', '                    self.draw_stick_lines(ax, violin_data, support, density, i)', '', '                # Draw point observations', '                elif self.inner.startswith(\"point\"):', '                    self.draw_points(ax, violin_data, i)', '', '            # Option 2: we have nested grouping by a hue variable', '            # ---------------------------------------------------', '', '            else:', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    support, density = self.support[i][j], self.density[i][j]', '                    kws[\"facecolor\"] = self.colors[j]', '', '                    # Add legend data, but just for one set of violins', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle the special case where we have no observations', '                    if support.size == 0:', '                        continue', '', '                    # Handle the special case where we have one observation', '                    elif support.size == 1:', '                        val = support.item()', '                        d = density.item()', '                        if self.split:', '                            d = d / 2', '                        at_group = i + offsets[j]', '                        self.draw_single_observation(ax, at_group, val, d)', '                        continue', '', '                    # Option 2a: we are drawing a single split violin', '                    # -----------------------------------------------', '', '                    if self.split:', '', '                        grid = np.ones(self.gridsize) * i', '                        if j:', '                            fill_func(support,', '                                      grid,', '                                      grid + density * self.dwidth,', '                                      **kws)', '                        else:', '                            fill_func(support,', '                                      grid - density * self.dwidth,', '                                      grid,', '                                      **kws)', '', '                        # Draw the interior representation of the data', '                        if self.inner is None:', '                            continue', '', '                        # Get a nan-free vector of datapoints', '                        hue_mask = self.plot_hues[i] == hue_level', '                        violin_data = remove_na(group_data[hue_mask])', '', '                        # Draw quartile lines', '                        if self.inner.startswith(\"quart\"):', '                            self.draw_quartiles(ax, violin_data,', '                                                support, density, i,', '                                                [\"left\", \"right\"][j])', '', '                        # Draw stick observations', '                        elif self.inner.startswith(\"stick\"):', '                            self.draw_stick_lines(ax, violin_data,', '                                                  support, density, i,', '                                                  [\"left\", \"right\"][j])', '', '                        # The box and point interior plots are drawn for', '                        # all data at the group level, so we just do that once', '                        if j and any(self.plot_hues[0] == hue_level):', '                            continue', '', '                        # Get the whole vector for this group level', '                        violin_data = remove_na(group_data)', '', '                        # Draw box and whisker information', '                        if self.inner.startswith(\"box\"):', '                            self.draw_box_lines(ax, violin_data, i)', '', '                        # Draw point observations', '                        elif self.inner.startswith(\"point\"):', '                            self.draw_points(ax, violin_data, i)', '', '                    # Option 2b: we are drawing full nested violins', '                    # -----------------------------------------------', '', '                    else:', '                        grid = np.ones(self.gridsize) * (i + offsets[j])', '                        fill_func(support,', '                                  grid - density * self.dwidth,', '                                  grid + density * self.dwidth,', '                                  **kws)', '', '                        # Draw the interior representation', '                        if self.inner is None:', '                            continue', '', '                        # Get a nan-free vector of datapoints', '                        hue_mask = self.plot_hues[i] == hue_level', '                        violin_data = remove_na(group_data[hue_mask])', '', '                        # Draw box and whisker information', '                        if self.inner.startswith(\"box\"):', '                            self.draw_box_lines(ax, violin_data, i + offsets[j])', '', '                        # Draw quartile lines', '                        elif self.inner.startswith(\"quart\"):', '                            self.draw_quartiles(ax, violin_data,', '                                                support, density,', '                                                i + offsets[j])', '', '                        # Draw stick observations', '                        elif self.inner.startswith(\"stick\"):', '                            self.draw_stick_lines(ax, violin_data,', '                                                  support, density,', '                                                  i + offsets[j])', '', '                        # Draw point observations', '                        elif self.inner.startswith(\"point\"):', '                            self.draw_points(ax, violin_data, i + offsets[j])', '', '    def draw_single_observation(self, ax, at_group, at_quant, density):', '        \"\"\"Draw a line to mark a single observation.\"\"\"', '        d_width = density * self.dwidth', '        if self.orient == \"v\":', '            ax.plot([at_group - d_width, at_group + d_width],', '                    [at_quant, at_quant],', '                    color=self.gray,', '                    linewidth=self.linewidth)', '        else:', '            ax.plot([at_quant, at_quant],', '                    [at_group - d_width, at_group + d_width],', '                    color=self.gray,', '                    linewidth=self.linewidth)', '', '    def draw_box_lines(self, ax, data, center):', '        \"\"\"Draw boxplot information at center of the density.\"\"\"', '        # Compute the boxplot statistics', '        q25, q50, q75 = np.percentile(data, [25, 50, 75])', '        whisker_lim = 1.5 * (q75 - q25)', '        h1 = np.min(data[data >= (q25 - whisker_lim)])', '        h2 = np.max(data[data <= (q75 + whisker_lim)])', '', '        # Draw a boxplot using lines and a point', '        if self.orient == \"v\":', '            ax.plot([center, center], [h1, h2],', '                    linewidth=self.linewidth,', '                    color=self.gray)', '            ax.plot([center, center], [q25, q75],', '                    linewidth=self.linewidth * 3,', '                    color=self.gray)', '            ax.scatter(center, q50,', '                       zorder=3,', '                       color=\"white\",', '                       edgecolor=self.gray,', '                       s=np.square(self.linewidth * 2))', '        else:', '            ax.plot([h1, h2], [center, center],', '                    linewidth=self.linewidth,', '                    color=self.gray)', '            ax.plot([q25, q75], [center, center],', '                    linewidth=self.linewidth * 3,', '                    color=self.gray)', '            ax.scatter(q50, center,', '                       zorder=3,', '                       color=\"white\",', '                       edgecolor=self.gray,', '                       s=np.square(self.linewidth * 2))', '', '    def draw_quartiles(self, ax, data, support, density, center, split=False):', '        \"\"\"Draw the quartiles as lines at width of density.\"\"\"', '        q25, q50, q75 = np.percentile(data, [25, 50, 75])', '', '        self.draw_to_density(ax, center, q25, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 1.5] * 2)', '        self.draw_to_density(ax, center, q50, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 3] * 2)', '        self.draw_to_density(ax, center, q75, support, density, split,', '                             linewidth=self.linewidth,', '                             dashes=[self.linewidth * 1.5] * 2)', '', '    def draw_points(self, ax, data, center):', '        \"\"\"Draw individual observations as points at middle of the violin.\"\"\"', '        kws = dict(s=np.square(self.linewidth * 2),', '                   color=self.gray,', '                   edgecolor=self.gray)', '', '        grid = np.ones(len(data)) * center', '', '        if self.orient == \"v\":', '            ax.scatter(grid, data, **kws)', '        else:', '            ax.scatter(data, grid, **kws)', '', '    def draw_stick_lines(self, ax, data, support, density,', '                         center, split=False):', '        \"\"\"Draw individual observations as sticks at width of density.\"\"\"', '        for val in data:', '            self.draw_to_density(ax, center, val, support, density, split,', '                                 linewidth=self.linewidth * .5)', '', '    def draw_to_density(self, ax, center, val, support, density, split, **kws):', '        \"\"\"Draw a line orthogonal to the value axis at width of density.\"\"\"', '        idx = np.argmin(np.abs(support - val))', '        width = self.dwidth * density[idx] * .99', '', '        kws[\"color\"] = self.gray', '', '        if self.orient == \"v\":', '            if split == \"left\":', '                ax.plot([center - width, center], [val, val], **kws)', '            elif split == \"right\":', '                ax.plot([center, center + width], [val, val], **kws)', '            else:', '                ax.plot([center - width, center + width], [val, val], **kws)', '        else:', '            if split == \"left\":', '                ax.plot([val, val], [center - width, center], **kws)', '            elif split == \"right\":', '                ax.plot([val, val], [center, center + width], **kws)', '            else:', '                ax.plot([val, val], [center - width, center + width], **kws)', '', '    def plot(self, ax):', '        \"\"\"Make the violin plot.\"\"\"', '        self.draw_violins(ax)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()', '', '', 'class _CategoricalStatPlotter(_CategoricalPlotter):', '', '    require_numeric = True', '', '    @property', '    def nested_width(self):', '        \"\"\"A float with the width of plot elements when hue nesting is used.\"\"\"', '        if self.dodge:', '            width = self.width / len(self.hue_names)', '        else:', '            width = self.width', '        return width', '', '    def estimate_statistic(self, estimator, errorbar, n_boot, seed):', '', '        if self.hue_names is None:', '            statistic = []', '            confint = []', '        else:', '            statistic = [[] for _ in self.plot_data]', '            confint = [[] for _ in self.plot_data]', '', '        var = {\"v\": \"y\", \"h\": \"x\"}[self.orient]', '', '        agg = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)', '', '        for i, group_data in enumerate(self.plot_data):', '', '            # Option 1: we have a single layer of grouping', '            # --------------------------------------------', '            if self.plot_hues is None:', '', '                df = pd.DataFrame({var: group_data})', '                if self.plot_units is not None:', '                    df[\"units\"] = self.plot_units[i]', '', '                res = agg(df, var)', '', '                statistic.append(res[var])', '                if errorbar is not None:', '                    confint.append((res[f\"{var}min\"], res[f\"{var}max\"]))', '', '            # Option 2: we are grouping by a hue layer', '            # ----------------------------------------', '', '            else:', '                for hue_level in self.hue_names:', '', '                    if not self.plot_hues[i].size:', '                        statistic[i].append(np.nan)', '                        if errorbar is not None:', '                            confint[i].append((np.nan, np.nan))', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    df = pd.DataFrame({var: group_data[hue_mask]})', '                    if self.plot_units is not None:', '                        df[\"units\"] = self.plot_units[i][hue_mask]', '', '                    res = agg(df, var)', '', '                    statistic[i].append(res[var])', '                    if errorbar is not None:', '                        confint[i].append((res[f\"{var}min\"], res[f\"{var}max\"]))', '', '        # Save the resulting values for plotting', '        self.statistic = np.array(statistic)', '        self.confint = np.array(confint)', '', '    def draw_confints(self, ax, at_group, confint, colors,', '                      errwidth=None, capsize=None, **kws):', '', '        if errwidth is not None:', '            kws.setdefault(\"lw\", errwidth)', '        else:', '            kws.setdefault(\"lw\", mpl.rcParams[\"lines.linewidth\"] * 1.8)', '', '        for at, (ci_low, ci_high), color in zip(at_group,', '                                                confint,', '                                                colors):', '            if self.orient == \"v\":', '                ax.plot([at, at], [ci_low, ci_high], color=color, **kws)', '                if capsize is not None:', '                    ax.plot([at - capsize / 2, at + capsize / 2],', '                            [ci_low, ci_low], color=color, **kws)', '                    ax.plot([at - capsize / 2, at + capsize / 2],', '                            [ci_high, ci_high], color=color, **kws)', '            else:', '                ax.plot([ci_low, ci_high], [at, at], color=color, **kws)', '                if capsize is not None:', '                    ax.plot([ci_low, ci_low],', '                            [at - capsize / 2, at + capsize / 2],', '                            color=color, **kws)', '                    ax.plot([ci_high, ci_high],', '                            [at - capsize / 2, at + capsize / 2],', '                            color=color, **kws)', '', '', 'class _BarPlotter(_CategoricalStatPlotter):', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 estimator, errorbar, n_boot, units, seed,', '                 orient, color, palette, saturation, width,', '                 errcolor, errwidth, capsize, dodge):', '        \"\"\"Initialize the plotter.\"\"\"', '        self.establish_variables(x, y, hue, data, orient,', '                                 order, hue_order, units)', '        self.establish_colors(color, palette, saturation)', '        self.estimate_statistic(estimator, errorbar, n_boot, seed)', '', '        self.dodge = dodge', '        self.width = width', '', '        self.errcolor = errcolor', '        self.errwidth = errwidth', '        self.capsize = capsize', '', '    def draw_bars(self, ax, kws):', '        \"\"\"Draw the bars onto `ax`.\"\"\"', '        # Get the right matplotlib function depending on the orientation', '        barfunc = ax.bar if self.orient == \"v\" else ax.barh', '        barpos = np.arange(len(self.statistic))', '', '        if self.plot_hues is None:', '', '            # Draw the bars', '            barfunc(barpos, self.statistic, self.width,', '                    color=self.colors, align=\"center\", **kws)', '', '            # Draw the confidence intervals', '            errcolors = [self.errcolor] * len(barpos)', '            self.draw_confints(ax,', '                               barpos,', '                               self.confint,', '                               errcolors,', '                               self.errwidth,', '                               self.capsize)', '', '        else:', '', '            for j, hue_level in enumerate(self.hue_names):', '', '                # Draw the bars', '                offpos = barpos + self.hue_offsets[j]', '                barfunc(offpos, self.statistic[:, j], self.nested_width,', '                        color=self.colors[j], align=\"center\",', '                        label=hue_level, **kws)', '', '                # Draw the confidence intervals', '                if self.confint.size:', '                    confint = self.confint[:, j]', '                    errcolors = [self.errcolor] * len(offpos)', '                    self.draw_confints(ax,', '                                       offpos,', '                                       confint,', '                                       errcolors,', '                                       self.errwidth,', '                                       self.capsize)', '', '    def plot(self, ax, bar_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_bars(ax, bar_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()', '', '', 'class _PointPlotter(_CategoricalStatPlotter):', '', '    default_palette = \"dark\"', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 estimator, errorbar, n_boot, units, seed,', '                 markers, linestyles, dodge, join, scale,', '                 orient, color, palette, errwidth=None, capsize=None):', '        \"\"\"Initialize the plotter.\"\"\"', '        self.establish_variables(x, y, hue, data, orient,', '                                 order, hue_order, units)', '        self.establish_colors(color, palette, 1)', '        self.estimate_statistic(estimator, errorbar, n_boot, seed)', '', '        # Override the default palette for single-color plots', '        if hue is None and color is None and palette is None:', '            self.colors = [color_palette()[0]] * len(self.colors)', '', \"        # Don't join single-layer plots with different colors\", '        if hue is None and palette is not None:', '            join = False', '', '        # Use a good default for `dodge=True`', '        if dodge is True and self.hue_names is not None:', '            dodge = .025 * len(self.hue_names)', '', '        # Make sure we have a marker for each hue level', '        if isinstance(markers, str):', '            markers = [markers] * len(self.colors)', '        self.markers = markers', '', '        # Make sure we have a line style for each hue level', '        if isinstance(linestyles, str):', '            linestyles = [linestyles] * len(self.colors)', '        self.linestyles = linestyles', '', '        # Set the other plot components', '        self.dodge = dodge', '        self.join = join', '        self.scale = scale', '        self.errwidth = errwidth', '        self.capsize = capsize', '', '    @property', '    def hue_offsets(self):', '        \"\"\"Offsets relative to the center position for each hue level.\"\"\"', '        if self.dodge:', '            offset = np.linspace(0, self.dodge, len(self.hue_names))', '            offset -= offset.mean()', '        else:', '            offset = np.zeros(len(self.hue_names))', '        return offset', '', '    def draw_points(self, ax):', '        \"\"\"Draw the main data components of the plot.\"\"\"', '        # Get the center positions on the categorical axis', '        pointpos = np.arange(len(self.statistic))', '', '        # Get the size of the plot elements', '        lw = mpl.rcParams[\"lines.linewidth\"] * 1.8 * self.scale', '        mew = lw * .75', '        markersize = np.pi * np.square(lw) * 2', '', '        if self.plot_hues is None:', '', '            # Draw lines joining each estimate point', '            if self.join:', '                color = self.colors[0]', '                ls = self.linestyles[0]', '                if self.orient == \"h\":', '                    ax.plot(self.statistic, pointpos,', '                            color=color, ls=ls, lw=lw)', '                else:', '                    ax.plot(pointpos, self.statistic,', '                            color=color, ls=ls, lw=lw)', '', '            # Draw the confidence intervals', '            self.draw_confints(ax, pointpos, self.confint, self.colors,', '                               self.errwidth, self.capsize)', '', '            # Draw the estimate points', '            marker = self.markers[0]', '            colors = [mpl.colors.colorConverter.to_rgb(c) for c in self.colors]', '            if self.orient == \"h\":', '                x, y = self.statistic, pointpos', '            else:', '                x, y = pointpos, self.statistic', '            ax.scatter(x, y,', '                       linewidth=mew, marker=marker, s=markersize,', '                       facecolor=colors, edgecolor=colors)', '', '        else:', '', '            offsets = self.hue_offsets', '            for j, hue_level in enumerate(self.hue_names):', '', '                # Determine the values to plot for this level', '                statistic = self.statistic[:, j]', '', '                # Determine the position on the categorical and z axes', '                offpos = pointpos + offsets[j]', '                z = j + 1', '', '                # Draw lines joining each estimate point', '                if self.join:', '                    color = self.colors[j]', '                    ls = self.linestyles[j]', '                    if self.orient == \"h\":', '                        ax.plot(statistic, offpos, color=color,', '                                zorder=z, ls=ls, lw=lw)', '                    else:', '                        ax.plot(offpos, statistic, color=color,', '                                zorder=z, ls=ls, lw=lw)', '', '                # Draw the confidence intervals', '                if self.confint.size:', '                    confint = self.confint[:, j]', '                    errcolors = [self.colors[j]] * len(offpos)', '                    self.draw_confints(ax, offpos, confint, errcolors,', '                                       self.errwidth, self.capsize,', '                                       zorder=z)', '', '                # Draw the estimate points', '                n_points = len(remove_na(offpos))', '                marker = self.markers[j]', '                color = mpl.colors.colorConverter.to_rgb(self.colors[j])', '', '                if self.orient == \"h\":', '                    x, y = statistic, offpos', '                else:', '                    x, y = offpos, statistic', '', '                if not len(remove_na(statistic)):', '                    x = y = [np.nan] * n_points', '', '                ax.scatter(x, y, label=hue_level,', '                           facecolor=color, edgecolor=color,', '                           linewidth=mew, marker=marker, s=markersize,', '                           zorder=z)', '', '    def plot(self, ax):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_points(ax)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()', '', '', 'class _CountPlotter(_BarPlotter):', '    require_numeric = False', '', '', 'class _LVPlotter(_CategoricalPlotter):', '', '    def __init__(self, x, y, hue, data, order, hue_order,', '                 orient, color, palette, saturation,', '                 width, dodge, k_depth, linewidth, scale, outlier_prop,', '                 trust_alpha, showfliers=True):', '', '        self.width = width', '        self.dodge = dodge', '        self.saturation = saturation', '', \"        k_depth_methods = ['proportion', 'tukey', 'trustworthy', 'full']\", '        if not (k_depth in k_depth_methods or isinstance(k_depth, Number)):', \"            msg = (f'k_depth must be one of {k_depth_methods} or a number, '\", \"                   f'but {k_depth} was passed.')\", '            raise ValueError(msg)', '        self.k_depth = k_depth', '', '        if linewidth is None:', '            linewidth = mpl.rcParams[\"lines.linewidth\"]', '        self.linewidth = linewidth', '', \"        scales = ['linear', 'exponential', 'area']\", '        if scale not in scales:', \"            msg = f'scale must be one of {scales}, but {scale} was passed.'\", '            raise ValueError(msg)', '        self.scale = scale', '', '        if ((outlier_prop > 1) or (outlier_prop <= 0)):', \"            msg = f'outlier_prop {outlier_prop} not in range (0, 1]'\", '            raise ValueError(msg)', '        self.outlier_prop = outlier_prop', '', '        if not 0 < trust_alpha < 1:', \"            msg = f'trust_alpha {trust_alpha} not in range (0, 1)'\", '            raise ValueError(msg)', '        self.trust_alpha = trust_alpha', '', '        self.showfliers = showfliers', '', '        self.establish_variables(x, y, hue, data, orient, order, hue_order)', '        self.establish_colors(color, palette, saturation)', '', '    def _lv_box_ends(self, vals):', '        \"\"\"Get the number of data points and calculate `depth` of', '        letter-value plot.\"\"\"', '        vals = np.asarray(vals)', \"        # Remove infinite values while handling a 'object' dtype\", '        # that can come from pd.Float64Dtype() input', \"        with pd.option_context('mode.use_inf_as_null', True):\", '            vals = vals[~pd.isnull(vals)]', '        n = len(vals)', '        p = self.outlier_prop', '', '        # Select the depth, i.e. number of boxes to draw, based on the method', \"        if self.k_depth == 'full':\", '            # extend boxes to 100% of the data', '            k = int(np.log2(n)) + 1', \"        elif self.k_depth == 'tukey':\", '            # This results with 5-8 points in each tail', '            k = int(np.log2(n)) - 3', \"        elif self.k_depth == 'proportion':\", '            k = int(np.log2(n)) - int(np.log2(n * p)) + 1', \"        elif self.k_depth == 'trustworthy':\", '            point_conf = 2 * _normal_quantile_func(1 - self.trust_alpha / 2) ** 2', '            k = int(np.log2(n / point_conf)) + 1', '        else:', '            k = int(self.k_depth)  # allow having k as input', '        # If the number happens to be less than 1, set k to 1', '        if k < 1:', '            k = 1', '', '        # Calculate the upper end for each of the k boxes', '        upper = [100 * (1 - 0.5 ** (i + 1)) for i in range(k, 0, -1)]', '        # Calculate the lower end for each of the k boxes', '        lower = [100 * (0.5 ** (i + 1)) for i in range(k, 0, -1)]', '        # Stitch the box ends together', '        percentile_ends = [(i, j) for i, j in zip(lower, upper)]', '        box_ends = [np.percentile(vals, q) for q in percentile_ends]', '        return box_ends, k', '', '    def _lv_outliers(self, vals, k):', '        \"\"\"Find the outliers based on the letter value depth.\"\"\"', '        box_edge = 0.5 ** (k + 1)', '        perc_ends = (100 * box_edge, 100 * (1 - box_edge))', '        edges = np.percentile(vals, perc_ends)', '        lower_out = vals[np.where(vals < edges[0])[0]]', '        upper_out = vals[np.where(vals > edges[1])[0]]', '        return np.concatenate((lower_out, upper_out))', '', '    def _width_functions(self, width_func):', '        # Dictionary of functions for computing the width of the boxes', \"        width_functions = {'linear': lambda h, i, k: (i + 1.) / k,\", \"                           'exponential': lambda h, i, k: 2**(-k + i - 1),\", \"                           'area': lambda h, i, k: (1 - 2**(-k + i - 2)) / h}\", '        return width_functions[width_func]', '', '    def _lvplot(self, box_data, positions,', '                color=[255. / 256., 185. / 256., 0.],', '                widths=1, ax=None, box_kws=None,', '                flier_kws=None,', '                line_kws=None):', '', '        # -- Default keyword dicts - based on', '        # distributions.plot_univariate_histogram', '        box_kws = {} if box_kws is None else box_kws.copy()', '        flier_kws = {} if flier_kws is None else flier_kws.copy()', '        line_kws = {} if line_kws is None else line_kws.copy()', '', '        # Set the default kwargs for the boxes', '        box_default_kws = dict(edgecolor=self.gray,', '                               linewidth=self.linewidth)', '        for k, v in box_default_kws.items():', '            box_kws.setdefault(k, v)', '', '        # Set the default kwargs for the lines denoting medians', '        line_default_kws = dict(', '            color=\".15\", alpha=0.45, solid_capstyle=\"butt\", linewidth=self.linewidth', '        )', '        for k, v in line_default_kws.items():', '            line_kws.setdefault(k, v)', '', '        # Set the default kwargs for the outliers scatterplot', \"        flier_default_kws = dict(marker='d', color=self.gray)\", '        for k, v in flier_default_kws.items():', '            flier_kws.setdefault(k, v)', '', '        vert = self.orient == \"v\"', '        x = positions[0]', '        box_data = np.asarray(box_data)', '', '        # If we only have one data point, plot a line', '        if len(box_data) == 1:', '            line_kws.update({', \"                'color': box_kws['edgecolor'],\", \"                'linestyle': box_kws.get('linestyle', '-'),\", '                \\'linewidth\\': max(box_kws[\"linewidth\"], line_kws[\"linewidth\"])', '            })', '            ys = [box_data[0], box_data[0]]', '            xs = [x - widths / 2, x + widths / 2]', '            if vert:', '                xx, yy = xs, ys', '            else:', '                xx, yy = ys, xs', '            ax.plot(xx, yy, **line_kws)', '        else:', '            # Get the number of data points and calculate \"depth\" of', '            # letter-value plot', '            box_ends, k = self._lv_box_ends(box_data)', '', '            # Anonymous functions for calculating the width and height', '            # of the letter value boxes', '            width = self._width_functions(self.scale)', '', '            # Function to find height of boxes', '            def height(b):', '                return b[1] - b[0]', '', '            # Functions to construct the letter value boxes', '            def vert_perc_box(x, b, i, k, w):', '                rect = Patches.Rectangle((x - widths * w / 2, b[0]),', '                                         widths * w,', '                                         height(b), fill=True)', '                return rect', '', '            def horz_perc_box(x, b, i, k, w):', '                rect = Patches.Rectangle((b[0], x - widths * w / 2),', '                                         height(b), widths * w,', '                                         fill=True)', '                return rect', '', '            # Scale the width of the boxes so the biggest starts at 1', '            w_area = np.array([width(height(b), i, k)', '                               for i, b in enumerate(box_ends)])', '            w_area = w_area / np.max(w_area)', '', '            # Calculate the medians', '            y = np.median(box_data)', '', '            # Calculate the outliers and plot (only if showfliers == True)', '            outliers = []', '            if self.showfliers:', '                outliers = self._lv_outliers(box_data, k)', '            hex_color = mpl.colors.rgb2hex(color)', '', '            if vert:', '                box_func = vert_perc_box', '                xs_median = [x - widths / 2, x + widths / 2]', '                ys_median = [y, y]', '                xs_outliers = np.full(len(outliers), x)', '                ys_outliers = outliers', '', '            else:', '                box_func = horz_perc_box', '                xs_median = [y, y]', '                ys_median = [x - widths / 2, x + widths / 2]', '                xs_outliers = outliers', '                ys_outliers = np.full(len(outliers), x)', '', '            # Plot the medians', '            ax.plot(', '                xs_median,', '                ys_median,', '                **line_kws', '            )', '', '            # Plot outliers (if any)', '            if len(outliers) > 0:', '                ax.scatter(xs_outliers, ys_outliers,', '                           **flier_kws', '                           )', '', '            # Construct a color map from the input color', '            rgb = [hex_color, (1, 1, 1)]', \"            cmap = mpl.colors.LinearSegmentedColormap.from_list('new_map', rgb)\", '            # Make sure that the last boxes contain hue and are not pure white', '            rgb = [hex_color, cmap(.85)]', \"            cmap = mpl.colors.LinearSegmentedColormap.from_list('new_map', rgb)\", '', '            # Update box_kws with `cmap` if not defined in dict until now', \"            box_kws.setdefault('cmap', cmap)\", '', '            boxes = [box_func(x, b[0], i, k, b[1])', '                     for i, b in enumerate(zip(box_ends, w_area))]', '', '            collection = PatchCollection(boxes, **box_kws)', '', '            # Set the color gradation, first box will have color=hex_color', '            collection.set_array(np.array(np.linspace(1, 0, len(boxes))))', '', '            # Plot the boxes', '            ax.add_collection(collection)', '', '    def draw_letter_value_plot(self, ax, box_kws=None, flier_kws=None,', '                               line_kws=None):', '        \"\"\"Use matplotlib to draw a letter value plot on an Axes.\"\"\"', '', '        for i, group_data in enumerate(self.plot_data):', '', '            if self.plot_hues is None:', '', '                # Handle case where there is data at this level', '                if group_data.size == 0:', '                    continue', '', '                # Draw a single box or a set of boxes', '                # with a single level of grouping', '                box_data = remove_na(group_data)', '', '                # Handle case where there is no non-null data', '                if box_data.size == 0:', '                    continue', '', '                color = self.colors[i]', '', '                self._lvplot(box_data,', '                             positions=[i],', '                             color=color,', '                             widths=self.width,', '                             ax=ax,', '                             box_kws=box_kws,', '                             flier_kws=flier_kws,', '                             line_kws=line_kws)', '', '            else:', '                # Draw nested groups of boxes', '                offsets = self.hue_offsets', '                for j, hue_level in enumerate(self.hue_names):', '', '                    # Add a legend for this hue level', '                    if not i:', '                        self.add_legend_data(ax, self.colors[j], hue_level)', '', '                    # Handle case where there is data at this level', '                    if group_data.size == 0:', '                        continue', '', '                    hue_mask = self.plot_hues[i] == hue_level', '                    box_data = remove_na(group_data[hue_mask])', '', '                    # Handle case where there is no non-null data', '                    if box_data.size == 0:', '                        continue', '', '                    color = self.colors[j]', '                    center = i + offsets[j]', '                    self._lvplot(box_data,', '                                 positions=[center],', '                                 color=color,', '                                 widths=self.nested_width,', '                                 ax=ax,', '                                 box_kws=box_kws,', '                                 flier_kws=flier_kws,', '                                 line_kws=line_kws)', '', '        # Autoscale the values axis to make sure all patches are visible', '        ax.autoscale_view(scalex=self.orient == \"h\", scaley=self.orient == \"v\")', '', '    def plot(self, ax, box_kws, flier_kws, line_kws):', '        \"\"\"Make the plot.\"\"\"', '        self.draw_letter_value_plot(ax, box_kws, flier_kws, line_kws)', '        self.annotate_axes(ax)', '        if self.orient == \"h\":', '            ax.invert_yaxis()', '', '', '_categorical_docs = dict(', '', '    # Shared narrative docs', '    categorical_narrative=dedent(\"\"\"\\\\', '    .. note::', '        This function always treats one of the variables as categorical and', '        draws data at ordinal positions (0, 1, ... n) on the relevant axis,', '        even when the data has a numeric or date type.', '', '    See the :ref:`tutorial <categorical_tutorial>` for more information.\\\\', '    \"\"\"),', '', '    new_categorical_narrative=dedent(\"\"\"\\\\', '    .. note::', '        By default, this function treats one of the variables as categorical', '        and draws data at ordinal positions (0, 1, ... n) on the relevant axis.', '        This can be disabled with the `native_scale` parameter.', '', '        See the :ref:`tutorial <categorical_tutorial>` for more information.\\\\', '    \"\"\"),', '', '    # Shared function parameters', '    input_params=dedent(\"\"\"\\\\', '    x, y, hue : names of variables in ``data`` or vector data, optional', '        Inputs for plotting long-form data. See examples for interpretation.\\\\', '    \"\"\"),', '    string_input_params=dedent(\"\"\"\\\\', '    x, y, hue : names of variables in ``data``', '        Inputs for plotting long-form data. See examples for interpretation.\\\\', '    \"\"\"),', '    categorical_data=dedent(\"\"\"\\\\', '    data : DataFrame, array, or list of arrays, optional', '        Dataset for plotting. If ``x`` and ``y`` are absent, this is', '        interpreted as wide-form. Otherwise it is expected to be long-form.\\\\', '    \"\"\"),', '    long_form_data=dedent(\"\"\"\\\\', '    data : DataFrame', '        Long-form (tidy) dataset for plotting. Each column should correspond', '        to a variable, and each row should correspond to an observation.\\\\', '    \"\"\"),', '    order_vars=dedent(\"\"\"\\\\', '    order, hue_order : lists of strings, optional', '        Order to plot the categorical levels in; otherwise the levels are', '        inferred from the data objects.\\\\', '    \"\"\"),', '    stat_api_params=dedent(\"\"\"\\\\', '    estimator : string or callable that maps vector -> scalar, optional', '        Statistical function to estimate within each categorical bin.', '    errorbar : string, (string, number) tuple, callable or None', '        Name of errorbar method (either \"ci\", \"pi\", \"se\", or \"sd\"), or a tuple', '        with a method name and a level parameter, or a function that maps from a', '        vector to a (min, max) interval, or None to hide errorbar.', '    n_boot : int, optional', '        Number of bootstrap samples used to compute confidence intervals.', '    units : name of variable in ``data`` or vector data, optional', '        Identifier of sampling units, which will be used to perform a', '        multilevel bootstrap and account for repeated measures design.', '    seed : int, numpy.random.Generator, or numpy.random.RandomState, optional', '        Seed or random number generator for reproducible bootstrapping.\\\\', '    \"\"\"),', '    orient=dedent(\"\"\"\\\\', '    orient : \"v\" | \"h\", optional', '        Orientation of the plot (vertical or horizontal). This is usually', '        inferred based on the type of the input variables, but it can be used', '        to resolve ambiguity when both `x` and `y` are numeric or when', '        plotting wide-form data.\\\\', '    \"\"\"),', '    color=dedent(\"\"\"\\\\', '    color : matplotlib color, optional', '        Single color for the elements in the plot.\\\\', '    \"\"\"),', '    palette=dedent(\"\"\"\\\\', '    palette : palette name, list, or dict, optional', '        Color palette that maps the hue variable. If the palette is a dictionary,', '        keys should be names of levels and values should be matplotlib colors.\\\\', '    \"\"\"),', '    hue_norm=dedent(\"\"\"\\\\', '    hue_norm : tuple or :class:`matplotlib.colors.Normalize` object', '        Normalization in data units for colormap applied to the `hue`', '        variable when it is numeric. Not relevant if `hue` is categorical.\\\\', '    \"\"\"),', '    saturation=dedent(\"\"\"\\\\', '    saturation : float, optional', '        Proportion of the original saturation to draw colors at. Large patches', '        often look better with slightly desaturated colors, but set this to', '        `1` if you want the plot colors to perfectly match the input color.\\\\', '    \"\"\"),', '    capsize=dedent(\"\"\"\\\\', '    capsize : float, optional', '        Width of the \"caps\" on error bars./', '    \"\"\"),', '    errwidth=dedent(\"\"\"\\\\', '    errwidth : float, optional', '        Thickness of error bar lines (and caps).\\\\', '    \"\"\"),', '    width=dedent(\"\"\"\\\\', '    width : float, optional', '        Width of a full element when not using hue nesting, or width of all the', '        elements for one level of the major grouping variable.\\\\', '    \"\"\"),', '    dodge=dedent(\"\"\"\\\\', '    dodge : bool, optional', '        When hue nesting is used, whether elements should be shifted along the', '        categorical axis.\\\\', '    \"\"\"),', '    linewidth=dedent(\"\"\"\\\\', '    linewidth : float, optional', '        Width of the gray lines that frame the plot elements.\\\\', '    \"\"\"),', '    native_scale=dedent(\"\"\"\\\\', '    native_scale : bool, optional', '        When True, numeric or datetime values on the categorical axis will maintain', '        their original scaling rather than being converted to fixed indices.\\\\', '    \"\"\"),', '    formatter=dedent(\"\"\"\\\\', '    formatter : callable, optional', '        Function for converting categorical data into strings. Affects both grouping', '        and tick labels.\\\\', '    \"\"\"),', '    legend=dedent(\"\"\"\\\\', 'legend : \"auto\", \"brief\", \"full\", or False', '    How to draw the legend. If \"brief\", numeric `hue` and `size`', '    variables will be represented with a sample of evenly spaced values.', '    If \"full\", every group will get an entry in the legend. If \"auto\",', '    choose between brief or full representation based on number of levels.', '    If `False`, no legend data is added and no legend is drawn.', '    \"\"\"),', '    ax_in=dedent(\"\"\"\\\\', '    ax : matplotlib Axes, optional', '        Axes object to draw the plot onto, otherwise uses the current Axes.\\\\', '    \"\"\"),', '    ax_out=dedent(\"\"\"\\\\', '    ax : matplotlib Axes', '        Returns the Axes object with the plot drawn onto it.\\\\', '    \"\"\"),', '', '    # Shared see also', '    boxplot=dedent(\"\"\"\\\\', '    boxplot : A traditional box-and-whisker plot with a similar API.\\\\', '    \"\"\"),', '    violinplot=dedent(\"\"\"\\\\', '    violinplot : A combination of boxplot and kernel density estimation.\\\\', '    \"\"\"),', '    stripplot=dedent(\"\"\"\\\\', '    stripplot : A scatterplot where one variable is categorical. Can be used', '                in conjunction with other plots to show each observation.\\\\', '    \"\"\"),', '    swarmplot=dedent(\"\"\"\\\\', '    swarmplot : A categorical scatterplot where the points do not overlap. Can', '                be used with other plots to show each observation.\\\\', '    \"\"\"),', '    barplot=dedent(\"\"\"\\\\', '    barplot : Show point estimates and confidence intervals using bars.\\\\', '    \"\"\"),', '    countplot=dedent(\"\"\"\\\\', '    countplot : Show the counts of observations in each categorical bin.\\\\', '    \"\"\"),', '    pointplot=dedent(\"\"\"\\\\', '    pointplot : Show point estimates and confidence intervals using scatterplot', '                glyphs.\\\\', '    \"\"\"),', '    catplot=dedent(\"\"\"\\\\', '    catplot : Combine a categorical plot with a :class:`FacetGrid`.\\\\', '    \"\"\"),', '    boxenplot=dedent(\"\"\"\\\\', '    boxenplot : An enhanced boxplot for larger datasets.\\\\', '    \"\"\"),', '', ')', '', '_categorical_docs.update(_facet_docs)', '', '', 'def boxplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    orient=None, color=None, palette=None, saturation=.75, width=.8,', '    dodge=True, fliersize=5, linewidth=None, whis=1.5, ax=None,', '    **kwargs', '):', '', '    plotter = _BoxPlotter(x, y, hue, data, order, hue_order,', '                          orient, color, palette, saturation,', '                          width, dodge, fliersize, linewidth)', '', '    if ax is None:', '        ax = plt.gca()', '    kwargs.update(dict(whis=whis))', '', '    plotter.plot(ax, kwargs)', '    return ax', '', '', 'boxplot.__doc__ = dedent(\"\"\"\\\\', '    Draw a box plot to show distributions with respect to categories.', '', '    A box plot (or box-and-whisker plot) shows the distribution of quantitative', '    data in a way that facilitates comparisons between variables or across', '    levels of a categorical variable. The box shows the quartiles of the', '    dataset while the whiskers extend to show the rest of the distribution,', '    except for points that are determined to be \"outliers\" using a method', '    that is a function of the inter-quartile range.', '', '    {categorical_narrative}', '', '    Parameters', '    ----------', '    {categorical_data}', '    {input_params}', '    {order_vars}', '    {orient}', '    {color}', '    {palette}', '    {saturation}', '    {width}', '    {dodge}', '    fliersize : float, optional', '        Size of the markers used to indicate outlier observations.', '    {linewidth}', '    whis : float, optional', '        Maximum length of the plot whiskers as proportion of the', '        interquartile range. Whiskers extend to the furthest datapoint', '        within that range. More extreme points are marked as outliers.', '    {ax_in}', '    kwargs : key, value mappings', '        Other keyword arguments are passed through to', '        :meth:`matplotlib.axes.Axes.boxplot`.', '', '    Returns', '    -------', '    {ax_out}', '', '    See Also', '    --------', '    {violinplot}', '    {stripplot}', '    {swarmplot}', '    {catplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/boxplot.rst', '', '    \"\"\").format(**_categorical_docs)', '', '', 'def violinplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    bw=\"scott\", cut=2, scale=\"area\", scale_hue=True, gridsize=100,', '    width=.8, inner=\"box\", split=False, dodge=True, orient=None,', '    linewidth=None, color=None, palette=None, saturation=.75,', '    ax=None, **kwargs,', '):', '', '    plotter = _ViolinPlotter(x, y, hue, data, order, hue_order,', '                             bw, cut, scale, scale_hue, gridsize,', '                             width, inner, split, dodge, orient, linewidth,', '                             color, palette, saturation)', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax)', '    return ax', '', '', 'violinplot.__doc__ = dedent(\"\"\"\\\\', '    Draw a combination of boxplot and kernel density estimate.', '', '    A violin plot plays a similar role as a box and whisker plot. It shows the', '    distribution of quantitative data across several levels of one (or more)', '    categorical variables such that those distributions can be compared. Unlike', '    a box plot, in which all of the plot components correspond to actual', '    datapoints, the violin plot features a kernel density estimation of the', '    underlying distribution.', '', '    This can be an effective and attractive way to show multiple distributions', '    of data at once, but keep in mind that the estimation procedure is', '    influenced by the sample size, and violins for relatively small samples', '    might look misleadingly smooth.', '', '    {categorical_narrative}', '', '    Parameters', '    ----------', '    {categorical_data}', '    {input_params}', '    {order_vars}', \"    bw : {{'scott', 'silverman', float}}, optional\", '        Either the name of a reference rule or the scale factor to use when', '        computing the kernel bandwidth. The actual kernel size will be', '        determined by multiplying the scale factor by the standard deviation of', '        the data within each bin.', '    cut : float, optional', '        Distance, in units of bandwidth size, to extend the density past the', '        extreme datapoints. Set to 0 to limit the violin range within the range', '        of the observed data (i.e., to have the same effect as ``trim=True`` in', '        ``ggplot``.', '    scale : {{\"area\", \"count\", \"width\"}}, optional', '        The method used to scale the width of each violin. If ``area``, each', '        violin will have the same area. If ``count``, the width of the violins', '        will be scaled by the number of observations in that bin. If ``width``,', '        each violin will have the same width.', '    scale_hue : bool, optional', '        When nesting violins using a ``hue`` variable, this parameter', '        determines whether the scaling is computed within each level of the', '        major grouping variable (``scale_hue=True``) or across all the violins', '        on the plot (``scale_hue=False``).', '    gridsize : int, optional', '        Number of points in the discrete grid used to compute the kernel', '        density estimate.', '    {width}', '    inner : {{\"box\", \"quartile\", \"point\", \"stick\", None}}, optional', '        Representation of the datapoints in the violin interior. If ``box``,', '        draw a miniature boxplot. If ``quartiles``, draw the quartiles of the', '        distribution.  If ``point`` or ``stick``, show each underlying', '        datapoint. Using ``None`` will draw unadorned violins.', '    split : bool, optional', '        When using hue nesting with a variable that takes two levels, setting', '        ``split`` to True will draw half of a violin for each level. This can', '        make it easier to directly compare the distributions.', '    {dodge}', '    {orient}', '    {linewidth}', '    {color}', '    {palette}', '    {saturation}', '    {ax_in}', '', '    Returns', '    -------', '    {ax_out}', '', '    See Also', '    --------', '    {boxplot}', '    {stripplot}', '    {swarmplot}', '    {catplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/violinplot.rst', '', '    \"\"\").format(**_categorical_docs)', '', '', 'def boxenplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    orient=None, color=None, palette=None, saturation=.75,', \"    width=.8, dodge=True, k_depth='tukey', linewidth=None,\", \"    scale='exponential', outlier_prop=0.007, trust_alpha=0.05,\", '    showfliers=True,', '    ax=None, box_kws=None, flier_kws=None, line_kws=None,', '):', '    plotter = _LVPlotter(x, y, hue, data, order, hue_order,', '                         orient, color, palette, saturation,', '                         width, dodge, k_depth, linewidth, scale,', '                         outlier_prop, trust_alpha, showfliers)', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax, box_kws, flier_kws, line_kws)', '    return ax', '', '', 'boxenplot.__doc__ = dedent(\"\"\"\\\\', '    Draw an enhanced box plot for larger datasets.', '', '    This style of plot was originally named a \"letter value\" plot because it', '    shows a large number of quantiles that are defined as \"letter values\".  It', '    is similar to a box plot in plotting a nonparametric representation of a', '    distribution in which all features correspond to actual observations. By', '    plotting more quantiles, it provides more information about the shape of', '    the distribution, particularly in the tails. For a more extensive', '    explanation, you can read the paper that introduced the plot:', '    https://vita.had.co.nz/papers/letter-value-plot.html', '', '    {categorical_narrative}', '', '    Parameters', '    ----------', '    {categorical_data}', '    {input_params}', '    {order_vars}', '    {orient}', '    {color}', '    {palette}', '    {saturation}', '    {width}', '    {dodge}', '    k_depth : {{\"tukey\", \"proportion\", \"trustworthy\", \"full\"}} or scalar', '        The number of boxes, and by extension number of percentiles, to draw.', \"        All methods are detailed in Wickham's paper. Each makes different\", '        assumptions about the number of outliers and leverages different', '        statistical properties. If \"proportion\", draw no more than', '        `outlier_prop` extreme observations. If \"full\", draw `log(n)+1` boxes.', '    {linewidth}', '    scale : {{\"exponential\", \"linear\", \"area\"}}, optional', '        Method to use for the width of the letter value boxes. All give similar', '        results visually. \"linear\" reduces the width by a constant linear', '        factor, \"exponential\" uses the proportion of data not covered, \"area\"', '        is proportional to the percentage of data covered.', '    outlier_prop : float, optional', '        Proportion of data believed to be outliers. Must be in the range', '        (0, 1]. Used to determine the number of boxes to plot when', '        `k_depth=\"proportion\"`.', '    trust_alpha : float, optional', '        Confidence level for a box to be plotted. Used to determine the', '        number of boxes to plot when `k_depth=\"trustworthy\"`. Must be in the', '        range (0, 1).', '    showfliers : bool, optional', '        If False, suppress the plotting of outliers.', '    {ax_in}', '    box_kws: dict, optional', '        Keyword arguments for the box artists; passed to', '        :class:`matplotlib.patches.Rectangle`.', '    line_kws: dict, optional', '        Keyword arguments for the line denoting the median; passed to', '        :meth:`matplotlib.axes.Axes.plot`.', '    flier_kws: dict, optional', '        Keyword arguments for the scatter denoting the outlier observations;', '        passed to :meth:`matplotlib.axes.Axes.scatter`.', '', '    Returns', '    -------', '    {ax_out}', '', '    See Also', '    --------', '    {violinplot}', '    {boxplot}', '    {catplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/boxenplot.rst', '', '    \"\"\").format(**_categorical_docs)', '', '', 'def stripplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    jitter=True, dodge=False, orient=None, color=None, palette=None,', '    size=5, edgecolor=\"gray\", linewidth=0,', '    hue_norm=None, native_scale=False, formatter=None, legend=\"auto\",', '    ax=None, **kwargs', '):', '', '    p = _CategoricalPlotterNew(', '        data=data,', '        variables=_CategoricalPlotterNew.get_semantics(locals()),', '        order=order,', '        orient=orient,', '        require_numeric=False,', '        legend=legend,', '    )', '', '    if ax is None:', '        ax = plt.gca()', '', '    if p.var_types.get(p.cat_axis) == \"categorical\" or not native_scale:', '        p.scale_categorical(p.cat_axis, order=order, formatter=formatter)', '', '    p._attach(ax)', '', '    hue_order = p._palette_without_hue_backcompat(palette, hue_order)', '    palette, hue_order = p._hue_backcompat(color, palette, hue_order)', '', '    color = _default_color(ax.scatter, hue, color, kwargs)', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    # XXX Copying possibly bad default decisions from original code for now', '    kwargs.setdefault(\"zorder\", 3)', '    size = kwargs.get(\"s\", size)', '', '    kwargs.update(dict(', '        s=size ** 2,', '        edgecolor=edgecolor,', '        linewidth=linewidth)', '    )', '', '    p.plot_strips(', '        jitter=jitter,', '        dodge=dodge,', '        color=color,', '        edgecolor=edgecolor,', '        plot_kws=kwargs,', '    )', '', '    # XXX this happens inside a plotting method in the distribution plots', \"    # but maybe it's better out here? Alternatively, we have an open issue\", '    # suggesting that _attach could add default axes labels, which seems smart.', '    p._add_axis_labels(ax)', '    p._adjust_cat_axis(ax, axis=p.cat_axis)', '', '    return ax', '', '', 'stripplot.__doc__ = dedent(\"\"\"\\\\', '    Draw a categorical scatterplot using jitter to reduce overplotting.', '', '    A strip plot can be drawn on its own, but it is also a good complement', '    to a box or violin plot in cases where you want to show all observations', '    along with some representation of the underlying distribution.', '', '    {new_categorical_narrative}', '', '    Parameters', '    ----------', '    {input_params}', '    {categorical_data}', '    {order_vars}', '    jitter : float, ``True``/``1`` is special-cased, optional', '        Amount of jitter (only along the categorical axis) to apply. This', '        can be useful when you have many points and they overlap, so that', '        it is easier to see the distribution. You can specify the amount', '        of jitter (half the width of the uniform random variable support),', '        or just use ``True`` for a good default.', '    dodge : bool, optional', '        When using ``hue`` nesting, setting this to ``True`` will separate', '        the strips for different hue levels along the categorical axis.', '        Otherwise, the points for each level will be plotted on top of', '        each other.', '    {orient}', '    {color}', '    {palette}', '    size : float, optional', '        Radius of the markers, in points.', '    edgecolor : matplotlib color, \"gray\" is special-cased, optional', '        Color of the lines around each point. If you pass ``\"gray\"``, the', '        brightness is determined by the color palette used for the body', '        of the points.', '    {linewidth}', '    {native_scale}', '    {formatter}', '    {legend}', '    {ax_in}', '    kwargs : key, value mappings', '        Other keyword arguments are passed through to', '        :meth:`matplotlib.axes.Axes.scatter`.', '', '    Returns', '    -------', '    {ax_out}', '', '    See Also', '    --------', '    {swarmplot}', '    {boxplot}', '    {violinplot}', '    {catplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/stripplot.rst', '', '    \"\"\").format(**_categorical_docs)', '', '', 'def swarmplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    dodge=False, orient=None, color=None, palette=None,', '    size=5, edgecolor=\"gray\", linewidth=0, hue_norm=None,', '    native_scale=False, formatter=None, legend=\"auto\", warn_thresh=.05,', '    ax=None, **kwargs', '):', '', '    p = _CategoricalPlotterNew(', '        data=data,', '        variables=_CategoricalPlotterNew.get_semantics(locals()),', '        order=order,', '        orient=orient,', '        require_numeric=False,', '        legend=legend,', '    )', '', '    if ax is None:', '        ax = plt.gca()', '', '    if p.var_types.get(p.cat_axis) == \"categorical\" or not native_scale:', '        p.scale_categorical(p.cat_axis, order=order, formatter=formatter)', '', '    p._attach(ax)', '', '    if not p.has_xy_data:', '        return ax', '', '    hue_order = p._palette_without_hue_backcompat(palette, hue_order)', '    palette, hue_order = p._hue_backcompat(color, palette, hue_order)', '', '    color = _default_color(ax.scatter, hue, color, kwargs)', '', '    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '    # XXX Copying possibly bad default decisions from original code for now', '    kwargs.setdefault(\"zorder\", 3)', '    size = kwargs.get(\"s\", size)', '', '    if linewidth is None:', '        linewidth = size / 10', '', '    kwargs.update(dict(', '        s=size ** 2,', '        linewidth=linewidth,', '    ))', '', '    p.plot_swarms(', '        dodge=dodge,', '        color=color,', '        edgecolor=edgecolor,', '        warn_thresh=warn_thresh,', '        plot_kws=kwargs,', '    )', '', '    p._add_axis_labels(ax)', '    p._adjust_cat_axis(ax, axis=p.cat_axis)', '', '    return ax', '', '', 'swarmplot.__doc__ = dedent(\"\"\"\\\\', '    Draw a categorical scatterplot with points adjusted to be non-overlapping.', '', '    This function is similar to :func:`stripplot`, but the points are adjusted', \"    (only along the categorical axis) so that they don't overlap. This gives a\", '    better representation of the distribution of values, but it does not scale', '    well to large numbers of observations. This style of plot is sometimes', '    called a \"beeswarm\".', '', '    A swarm plot can be drawn on its own, but it is also a good complement', '    to a box or violin plot in cases where you want to show all observations', '    along with some representation of the underlying distribution.', '', '    {new_categorical_narrative}', '', '    Parameters', '    ----------', '    {categorical_data}', '    {input_params}', '    {order_vars}', '    dodge : bool, optional', '        When using ``hue`` nesting, setting this to ``True`` will separate', '        the strips for different hue levels along the categorical axis.', '        Otherwise, the points for each level will be plotted in one swarm.', '    {orient}', '    {color}', '    {palette}', '    size : float, optional', '        Radius of the markers, in points.', '    edgecolor : matplotlib color, \"gray\" is special-cased, optional', '        Color of the lines around each point. If you pass ``\"gray\"``, the', '        brightness is determined by the color palette used for the body', '        of the points.', '    {linewidth}', '    {native_scale}', '    {formatter}', '    {legend}', '    {ax_in}', '    kwargs : key, value mappings', '        Other keyword arguments are passed through to', '        :meth:`matplotlib.axes.Axes.scatter`.', '', '    Returns', '    -------', '    {ax_out}', '', '    See Also', '    --------', '    {boxplot}', '    {violinplot}', '    {stripplot}', '    {catplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/swarmplot.rst', '', '    \"\"\").format(**_categorical_docs)', '', '', 'def barplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,', '    orient=None, color=None, palette=None, saturation=.75, width=.8,', '    errcolor=\".26\", errwidth=None, capsize=None, dodge=True, ci=\"deprecated\",', '    ax=None,', '    **kwargs,', '):', '', '    errorbar = utils._deprecate_ci(errorbar, ci)', '', '    # Be backwards compatible with len passed directly, which', '    # does not work in Series.agg (maybe a pandas bug?)', '    if estimator is len:', '        estimator = \"size\"', '', '    plotter = _BarPlotter(x, y, hue, data, order, hue_order,', '                          estimator, errorbar, n_boot, units, seed,', '                          orient, color, palette, saturation,', '                          width, errcolor, errwidth, capsize, dodge)', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax, kwargs)', '    return ax', '', '', 'barplot.__doc__ = dedent(\"\"\"\\\\', '    Show point estimates and errors as rectangular bars.', '', '    A bar plot represents an estimate of central tendency for a numeric', '    variable with the height of each rectangle and provides some indication of', '    the uncertainty around that estimate using error bars. Bar plots include 0', '    in the quantitative axis range, and they are a good choice when 0 is a', '    meaningful value for the quantitative variable, and you want to make', '    comparisons against it.', '', '    For datasets where 0 is not a meaningful value, a point plot will allow you', '    to focus on differences between levels of one or more categorical', '    variables.', '', '    It is also important to keep in mind that a bar plot shows only the mean', '    (or other estimator) value, but in many cases it may be more informative to', '    show the distribution of values at each level of the categorical variables.', '    In that case, other approaches such as a box or violin plot may be more', '    appropriate.', '', '    {categorical_narrative}', '', '    Parameters', '    ----------', '    {categorical_data}', '    {input_params}', '    {order_vars}', '    {stat_api_params}', '    {orient}', '    {color}', '    {palette}', '    {saturation}', '    {width}', '    errcolor : matplotlib color', '        Color used for the error bar lines.', '    {errwidth}', '    {capsize}', '    {dodge}', '    {ax_in}', '    kwargs : key, value mappings', '        Other keyword arguments are passed through to', '        :meth:`matplotlib.axes.Axes.bar`.', '', '    Returns', '    -------', '    {ax_out}', '', '    See Also', '    --------', '    {countplot}', '    {pointplot}', '    {catplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/barplot.rst', '', '', '    \"\"\").format(**_categorical_docs)', '', '', 'def pointplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,', '    markers=\"o\", linestyles=\"-\", dodge=False, join=True, scale=1,', '    orient=None, color=None, palette=None, errwidth=None, ci=\"deprecated\",', '    capsize=None, ax=None,', '):', '', '    errorbar = utils._deprecate_ci(errorbar, ci)', '', '    plotter = _PointPlotter(x, y, hue, data, order, hue_order,', '                            estimator, errorbar, n_boot, units, seed,', '                            markers, linestyles, dodge, join, scale,', '                            orient, color, palette, errwidth, capsize)', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax)', '    return ax', '', '', 'pointplot.__doc__ = dedent(\"\"\"\\\\', '    Show point estimates and errors using dot marks.', '', '    A point plot represents an estimate of central tendency for a numeric', '    variable by the position of the dot and provides some indication of the', '    uncertainty around that estimate using error bars.', '', '    Point plots can be more useful than bar plots for focusing comparisons', '    between different levels of one or more categorical variables. They are', '    particularly adept at showing interactions: how the relationship between', '    levels of one categorical variable changes across levels of a second', '    categorical variable. The lines that join each point from the same `hue`', '    level allow interactions to be judged by differences in slope, which is', '    easier for the eyes than comparing the heights of several groups of points', '    or bars.', '', '    It is important to keep in mind that a point plot shows only the mean (or', '    other estimator) value, but in many cases it may be more informative to', '    show the distribution of values at each level of the categorical variables.', '    In that case, other approaches such as a box or violin plot may be more', '    appropriate.', '', '    {categorical_narrative}', '', '    Parameters', '    ----------', '    {categorical_data}', '    {input_params}', '    {order_vars}', '    {stat_api_params}', '    markers : string or list of strings, optional', '        Markers to use for each of the ``hue`` levels.', '    linestyles : string or list of strings, optional', '        Line styles to use for each of the ``hue`` levels.', '    dodge : bool or float, optional', '        Amount to separate the points for each level of the ``hue`` variable', '        along the categorical axis.', '    join : bool, optional', '        If ``True``, lines will be drawn between point estimates at the same', '        ``hue`` level.', '    scale : float, optional', '        Scale factor for the plot elements.', '    {orient}', '    {color}', '    {palette}', '    {errwidth}', '    {capsize}', '    {ax_in}', '', '    Returns', '    -------', '    {ax_out}', '', '    See Also', '    --------', '    {barplot}', '    {catplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/pointplot.rst', '', '    \"\"\").format(**_categorical_docs)', '', '', 'def countplot(', '    data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,', '    orient=None, color=None, palette=None, saturation=.75, width=.8,', '    dodge=True, ax=None, **kwargs', '):', '', '    estimator = \"size\"', '    errorbar = None', '    n_boot = 0', '    units = None', '    seed = None', '    errcolor = None', '    errwidth = None', '    capsize = None', '', '    if x is None and y is not None:', '        orient = \"h\"', '        x = y', '    elif y is None and x is not None:', '        orient = \"v\"', '        y = x', '    elif x is not None and y is not None:', '        raise ValueError(\"Cannot pass values for both `x` and `y`\")', '', '    plotter = _CountPlotter(', '        x, y, hue, data, order, hue_order,', '        estimator, errorbar, n_boot, units, seed,', '        orient, color, palette, saturation,', '        width, errcolor, errwidth, capsize, dodge', '    )', '', '    plotter.value_label = \"count\"', '', '    if ax is None:', '        ax = plt.gca()', '', '    plotter.plot(ax, kwargs)', '    return ax', '', '', 'countplot.__doc__ = dedent(\"\"\"\\\\', '    Show the counts of observations in each categorical bin using bars.', '', '    A count plot can be thought of as a histogram across a categorical, instead', '    of quantitative, variable. The basic API and options are identical to those', '    for :func:`barplot`, so you can compare counts across nested variables.', '', '    Note that the newer :func:`histplot` function offers more functionality, although', '    its default behavior is somewhat different.', '', '    {categorical_narrative}', '', '    Parameters', '    ----------', '    {categorical_data}', '    {input_params}', '    {order_vars}', '    {orient}', '    {color}', '    {palette}', '    {saturation}', '    {dodge}', '    {ax_in}', '    kwargs : key, value mappings', '        Other keyword arguments are passed through to', '        :meth:`matplotlib.axes.Axes.bar`.', '', '    Returns', '    -------', '    {ax_out}', '', '    See Also', '    --------', '    {barplot}', '    {catplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/countplot.rst', '', '    \"\"\").format(**_categorical_docs)', '', '', 'def catplot(', '    data=None, *, x=None, y=None, hue=None, row=None, col=None,', '    col_wrap=None, estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000,', '    units=None, seed=None, order=None, hue_order=None, row_order=None,', '    col_order=None, height=5, aspect=1, kind=\"strip\", native_scale=False,', '    formatter=None, orient=None, color=None, palette=None, hue_norm=None,', '    legend=\"auto\", legend_out=True, sharex=True, sharey=True,', '    margin_titles=False, facet_kws=None, ci=\"deprecated\",', '    **kwargs', '):', '', '    # Determine the plotting function', '    try:', '        plot_func = globals()[kind + \"plot\"]', '    except KeyError:', '        err = f\"Plot kind \\'{kind}\\' is not recognized\"', '        raise ValueError(err)', '', '    # Check for attempt to plot onto specific axes and warn', '    if \"ax\" in kwargs:', '        msg = (\"catplot is a figure-level function and does not accept \"', '               f\"target axes. You may wish to try {kind}plot\")', '        warnings.warn(msg, UserWarning)', '        kwargs.pop(\"ax\")', '', '    refactored_kinds = [\"strip\", \"swarm\"]', '    if kind in refactored_kinds:', '', '        p = _CategoricalFacetPlotter(', '            data=data,', '            variables=_CategoricalFacetPlotter.get_semantics(locals()),', '            order=order,', '            orient=orient,', '            require_numeric=False,', '            legend=legend,', '        )', '', '        # XXX Copying a fair amount from displot, which is not ideal', '', '        for var in [\"row\", \"col\"]:', '            # Handle faceting variables that lack name information', '            if var in p.variables and p.variables[var] is None:', '                p.variables[var] = f\"_{var}_\"', '', '        # Adapt the plot_data dataframe for use with FacetGrid', '        data = p.plot_data.rename(columns=p.variables)', '        data = data.loc[:, ~data.columns.duplicated()]', '', '        col_name = p.variables.get(\"col\", None)', '        row_name = p.variables.get(\"row\", None)', '', '        if facet_kws is None:', '            facet_kws = {}', '', '        g = FacetGrid(', '            data=data, row=row_name, col=col_name,', '            col_wrap=col_wrap, row_order=row_order,', '            col_order=col_order, height=height,', '            sharex=sharex, sharey=sharey,', '            aspect=aspect,', '            **facet_kws,', '        )', '', '        # Capture this here because scale_categorical is going to insert a (null)', \"        # x variable even if it is empty. It's not clear whether that needs to\", '        # happen or if disabling that is the cleaner solution.', '        has_xy_data = p.has_xy_data', '', '        if not native_scale or p.var_types[p.cat_axis] == \"categorical\":', '            p.scale_categorical(p.cat_axis, order=order, formatter=formatter)', '', '        p._attach(g)', '', '        if not has_xy_data:', '            return g', '', '        hue_order = p._palette_without_hue_backcompat(palette, hue_order)', '        palette, hue_order = p._hue_backcompat(color, palette, hue_order)', '        p.map_hue(palette=palette, order=hue_order, norm=hue_norm)', '', '        # Set a default color', '        # Otherwise each artist will be plotted separately and trip the color cycle', '        if hue is None and color is None:', '            color = \"C0\"', '', '        if kind == \"strip\":', '', '            # TODO get these defaults programmatically?', '            jitter = kwargs.pop(\"jitter\", True)', '            dodge = kwargs.pop(\"dodge\", False)', '            edgecolor = kwargs.pop(\"edgecolor\", \"gray\")  # XXX TODO default', '', '            plot_kws = kwargs.copy()', '', '            # XXX Copying possibly bad default decisions from original code for now', '            plot_kws.setdefault(\"zorder\", 3)', '            plot_kws.setdefault(\"s\", plot_kws.pop(\"size\", 5) ** 2)', '            plot_kws.setdefault(\"linewidth\", 0)', '', '            p.plot_strips(', '                jitter=jitter,', '                dodge=dodge,', '                color=color,', '                edgecolor=edgecolor,', '                plot_kws=plot_kws,', '            )', '', '        elif kind == \"swarm\":', '', '            # TODO get these defaults programmatically?', '            dodge = kwargs.pop(\"dodge\", False)', '            edgecolor = kwargs.pop(\"edgecolor\", \"gray\")  # XXX TODO default', '            warn_thresh = kwargs.pop(\"warn_thresh\", .05)', '', '            plot_kws = kwargs.copy()', '', '            # XXX Copying possibly bad default decisions from original code for now', '            plot_kws.setdefault(\"zorder\", 3)', '            plot_kws.setdefault(\"s\", plot_kws.pop(\"size\", 5) ** 2)', '', '            if plot_kws.setdefault(\"linewidth\", 0) is None:', '                plot_kws[\"linewidth\"] = np.sqrt(plot_kws[\"s\"]) / 10', '', '            p.plot_swarms(', '                dodge=dodge,', '                color=color,', '                edgecolor=edgecolor,', '                warn_thresh=warn_thresh,', '                plot_kws=plot_kws,', '            )', '', '        # XXX best way to do this housekeeping?', '        for ax in g.axes.flat:', '            p._adjust_cat_axis(ax, axis=p.cat_axis)', '', '        g.set_axis_labels(', '            p.variables.get(\"x\", None),', '            p.variables.get(\"y\", None),', '        )', '        g.set_titles()', '        g.tight_layout()', '', '        # XXX Hack to get the legend data in the right place', '        for ax in g.axes.flat:', '            g._update_legend_data(ax)', '            ax.legend_ = None', '', '        if legend and (hue is not None) and (hue not in [x, row, col]):', '            g.add_legend(title=hue, label_order=hue_order)', '', '        return g', '', \"    # Don't allow usage of forthcoming functionality\", '    if native_scale is True:', '        err = f\"native_scale not yet implemented for `kind={kind}`\"', '        raise ValueError(err)', '    if formatter is not None:', '        err = f\"formatter not yet implemented for `kind={kind}`\"', '        raise ValueError(err)', '', '    # Alias the input variables to determine categorical order and palette', '    # correctly in the case of a count plot', '    if kind == \"count\":', '        if x is None and y is not None:', '            x_, y_, orient = y, y, \"h\"', '        elif y is None and x is not None:', '            x_, y_, orient = x, x, \"v\"', '        else:', '            raise ValueError(\"Either `x` or `y` must be None for kind=\\'count\\'\")', '    else:', '        x_, y_ = x, y', '', '    # Determine the order for the whole dataset, which will be used in all', '    # facets to ensure representation of all data in the final plot', '    plotter_class = {', '        \"box\": _BoxPlotter,', '        \"violin\": _ViolinPlotter,', '        \"boxen\": _LVPlotter,', '        \"bar\": _BarPlotter,', '        \"point\": _PointPlotter,', '        \"count\": _CountPlotter,', '    }[kind]', '    p = _CategoricalPlotter()', '    p.require_numeric = plotter_class.require_numeric', '    p.establish_variables(x_, y_, hue, data, orient, order, hue_order)', '    if (', '        order is not None', '        or (sharex and p.orient == \"v\")', '        or (sharey and p.orient == \"h\")', '    ):', '        # Sync categorical axis between facets to have the same categories', '        order = p.group_names', '    elif color is None and hue is None:', '        msg = (', '            \"Setting `{}=False` with `color=None` may cause different levels of the \"', '            \"`{}` variable to share colors. This will change in a future version.\"', '        )', '        if not sharex and p.orient == \"v\":', '            warnings.warn(msg.format(\"sharex\", \"x\"), UserWarning)', '        if not sharey and p.orient == \"h\":', '            warnings.warn(msg.format(\"sharey\", \"y\"), UserWarning)', '', '    hue_order = p.hue_names', '', '    # Determine the palette to use', '    # (FacetGrid will pass a value for ``color`` to the plotting function', '    # so we need to define ``palette`` to get default behavior for the', '    # categorical functions', '    p.establish_colors(color, palette, 1)', '    if kind != \"point\" or hue is not None:', '        palette = p.colors', '', '    # Determine keyword arguments for the facets', '    facet_kws = {} if facet_kws is None else facet_kws', '    facet_kws.update(', '        data=data, row=row, col=col,', '        row_order=row_order, col_order=col_order,', '        col_wrap=col_wrap, height=height, aspect=aspect,', '        sharex=sharex, sharey=sharey,', '        legend_out=legend_out, margin_titles=margin_titles,', '        dropna=False,', '    )', '', '    # Determine keyword arguments for the plotting function', '    plot_kws = dict(', '        order=order, hue_order=hue_order,', '        orient=orient, color=color, palette=palette,', '    )', '    plot_kws.update(kwargs)', '', '    if kind in [\"bar\", \"point\"]:', '        errorbar = utils._deprecate_ci(errorbar, ci)', '        plot_kws.update(', '            estimator=estimator, errorbar=errorbar,', '            n_boot=n_boot, units=units, seed=seed,', '        )', '', '    # Initialize the facets', '    g = FacetGrid(**facet_kws)', '', '    # Draw the plot onto the facets', '    g.map_dataframe(plot_func, x=x, y=y, hue=hue, **plot_kws)', '', '    if p.orient == \"h\":', '        g.set_axis_labels(p.value_label, p.group_label)', '    else:', '        g.set_axis_labels(p.group_label, p.value_label)', '', '    # Special case axis labels for a count type plot', '    if kind == \"count\":', '        if x is None:', '            g.set_axis_labels(x_var=\"count\")', '        if y is None:', '            g.set_axis_labels(y_var=\"count\")', '', '    if legend and (hue is not None) and (hue not in [x, row, col]):', '        hue_order = list(map(utils.to_utf8, hue_order))', '        g.add_legend(title=hue, label_order=hue_order)', '', '    return g', '', '', 'catplot.__doc__ = dedent(\"\"\"\\\\', '    Figure-level interface for drawing categorical plots onto a FacetGrid.', '', '    This function provides access to several axes-level functions that', '    show the relationship between a numerical and one or more categorical', '    variables using one of several visual representations. The `kind`', '    parameter selects the underlying axes-level function to use:', '', '    Categorical scatterplots:', '', '    - :func:`stripplot` (with `kind=\"strip\"`; the default)', '    - :func:`swarmplot` (with `kind=\"swarm\"`)', '', '    Categorical distribution plots:', '', '    - :func:`boxplot` (with `kind=\"box\"`)', '    - :func:`violinplot` (with `kind=\"violin\"`)', '    - :func:`boxenplot` (with `kind=\"boxen\"`)', '', '    Categorical estimate plots:', '', '    - :func:`pointplot` (with `kind=\"point\"`)', '    - :func:`barplot` (with `kind=\"bar\"`)', '    - :func:`countplot` (with `kind=\"count\"`)', '', '    Extra keyword arguments are passed to the underlying function, so you', '    should refer to the documentation for each to see kind-specific options.', '', '    Note that unlike when using the axes-level functions directly, data must be', '    passed in a long-form DataFrame with variables specified by passing strings', '    to `x`, `y`, `hue`, etc.', '', '    {categorical_narrative}', '', '    After plotting, the :class:`FacetGrid` with the plot is returned and can', '    be used directly to tweak supporting plot details or add other layers.', '', '    Parameters', '    ----------', '    {long_form_data}', '    {string_input_params}', '    row, col : names of variables in `data`, optional', '        Categorical variables that will determine the faceting of the grid.', '    {col_wrap}', '    {stat_api_params}', '    {order_vars}', '    row_order, col_order : lists of strings, optional', '        Order to organize the rows and/or columns of the grid in, otherwise the', '        orders are inferred from the data objects.', '    {height}', '    {aspect}', '    kind : str, optional', '        The kind of plot to draw, corresponds to the name of a categorical', '        axes-level plotting function. Options are: \"strip\", \"swarm\", \"box\", \"violin\",', '        \"boxen\", \"point\", \"bar\", or \"count\".', '    {native_scale}', '    {formatter}', '    {orient}', '    {color}', '    {palette}', '    {hue_norm}', '    legend : str or bool, optional', '        Set to `False` to disable the legend. With `strip` or `swarm` plots,', '        this also accepts a string, as described in the axes-level docstrings.', '    {legend_out}', '    {share_xy}', '    {margin_titles}', '    facet_kws : dict, optional', '        Dictionary of other keyword arguments to pass to :class:`FacetGrid`.', '    kwargs : key, value pairings', '        Other keyword arguments are passed through to the underlying plotting', '        function.', '', '    Returns', '    -------', '    g : :class:`FacetGrid`', '        Returns the :class:`FacetGrid` object with the plot on it for further', '        tweaking.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/catplot.rst', '', '    \"\"\").format(**_categorical_docs)', '', '', 'class Beeswarm:', '    \"\"\"Modifies a scatterplot artist to show a beeswarm plot.\"\"\"', '    def __init__(self, orient=\"v\", width=0.8, warn_thresh=.05):', '', '        # XXX should we keep the orient parameterization or specify the swarm axis?', '', '        self.orient = orient', '        self.width = width', '        self.warn_thresh = warn_thresh', '', '    def __call__(self, points, center):', '        \"\"\"Swarm `points`, a PathCollection, around the `center` position.\"\"\"', '        # Convert from point size (area) to diameter', '', '        ax = points.axes', '        dpi = ax.figure.dpi', '', '        # Get the original positions of the points', '        orig_xy_data = points.get_offsets()', '', '        # Reset the categorical positions to the center line', '        cat_idx = 1 if self.orient == \"h\" else 0', '        orig_xy_data[:, cat_idx] = center', '', '        # Transform the data coordinates to point coordinates.', \"        # We'll figure out the swarm positions in the latter\", '        # and then convert back to data coordinates and replot', '        orig_x_data, orig_y_data = orig_xy_data.T', '        orig_xy = ax.transData.transform(orig_xy_data)', '', '        # Order the variables so that x is the categorical axis', '        if self.orient == \"h\":', '            orig_xy = orig_xy[:, [1, 0]]', '', \"        # Add a column with each point's radius\", '        sizes = points.get_sizes()', '        if sizes.size == 1:', '            sizes = np.repeat(sizes, orig_xy.shape[0])', '        edge = points.get_linewidth().item()', '        radii = (np.sqrt(sizes) + edge) / 2 * (dpi / 72)', '        orig_xy = np.c_[orig_xy, radii]', '', '        # Sort along the value axis to facilitate the beeswarm', '        sorter = np.argsort(orig_xy[:, 1])', '        orig_xyr = orig_xy[sorter]', '', '        # Adjust points along the categorical axis to prevent overlaps', '        new_xyr = np.empty_like(orig_xyr)', '        new_xyr[sorter] = self.beeswarm(orig_xyr)', '', '        # Transform the point coordinates back to data coordinates', '        if self.orient == \"h\":', '            new_xy = new_xyr[:, [1, 0]]', '        else:', '            new_xy = new_xyr[:, :2]', '        new_x_data, new_y_data = ax.transData.inverted().transform(new_xy).T', '', '        swarm_axis = {\"h\": \"y\", \"v\": \"x\"}[self.orient]', '        log_scale = getattr(ax, f\"get_{swarm_axis}scale\")() == \"log\"', '', '        # Add gutters', '        if self.orient == \"h\":', '            self.add_gutters(new_y_data, center, log_scale=log_scale)', '        else:', '            self.add_gutters(new_x_data, center, log_scale=log_scale)', '', '        # Reposition the points so they do not overlap', '        if self.orient == \"h\":', '            points.set_offsets(np.c_[orig_x_data, new_y_data])', '        else:', '            points.set_offsets(np.c_[new_x_data, orig_y_data])', '', '    def beeswarm(self, orig_xyr):', '        \"\"\"Adjust x position of points to avoid overlaps.\"\"\"', '        # In this method, `x` is always the categorical axis', '        # Center of the swarm, in point coordinates', '        midline = orig_xyr[0, 0]', '', '        # Start the swarm with the first point', '        swarm = np.atleast_2d(orig_xyr[0])', '', '        # Loop over the remaining points', '        for xyr_i in orig_xyr[1:]:', '', '            # Find the points in the swarm that could possibly', '            # overlap with the point we are currently placing', '            neighbors = self.could_overlap(xyr_i, swarm)', '', '            # Find positions that would be valid individually', '            # with respect to each of the swarm neighbors', '            candidates = self.position_candidates(xyr_i, neighbors)', '', '            # Sort candidates by their centrality', '            offsets = np.abs(candidates[:, 0] - midline)', '            candidates = candidates[np.argsort(offsets)]', '', '            # Find the first candidate that does not overlap any neighbors', '            new_xyr_i = self.first_non_overlapping_candidate(candidates, neighbors)', '', '            # Place it into the swarm', '            swarm = np.vstack([swarm, new_xyr_i])', '', '        return swarm', '', '    def could_overlap(self, xyr_i, swarm):', '        \"\"\"Return a list of all swarm points that could overlap with target.\"\"\"', '        # Because we work backwards through the swarm and can short-circuit,', '        # the for-loop is faster than vectorization', '        _, y_i, r_i = xyr_i', '        neighbors = []', '        for xyr_j in reversed(swarm):', '            _, y_j, r_j = xyr_j', '            if (y_i - y_j) < (r_i + r_j):', '                neighbors.append(xyr_j)', '            else:', '                break', '        return np.array(neighbors)[::-1]', '', '    def position_candidates(self, xyr_i, neighbors):', '        \"\"\"Return a list of coordinates that might be valid by adjusting x.\"\"\"', '        candidates = [xyr_i]', '        x_i, y_i, r_i = xyr_i', '        left_first = True', '        for x_j, y_j, r_j in neighbors:', '            dy = y_i - y_j', '            dx = np.sqrt(max((r_i + r_j) ** 2 - dy ** 2, 0)) * 1.05', '            cl, cr = (x_j - dx, y_i, r_i), (x_j + dx, y_i, r_i)', '            if left_first:', '                new_candidates = [cl, cr]', '            else:', '                new_candidates = [cr, cl]', '            candidates.extend(new_candidates)', '            left_first = not left_first', '        return np.array(candidates)', '', '    def first_non_overlapping_candidate(self, candidates, neighbors):', '        \"\"\"Find the first candidate that does not overlap with the swarm.\"\"\"', '', '        # If we have no neighbors, all candidates are good.', '        if len(neighbors) == 0:', '            return candidates[0]', '', '        neighbors_x = neighbors[:, 0]', '        neighbors_y = neighbors[:, 1]', '        neighbors_r = neighbors[:, 2]', '', '        for xyr_i in candidates:', '', '            x_i, y_i, r_i = xyr_i', '', '            dx = neighbors_x - x_i', '            dy = neighbors_y - y_i', '            sq_distances = np.square(dx) + np.square(dy)', '', '            sep_needed = np.square(neighbors_r + r_i)', '', '            # Good candidate does not overlap any of neighbors which means that', '            # squared distance between candidate and any of the neighbors has', '            # to be at least square of the summed radii', '            good_candidate = np.all(sq_distances >= sep_needed)', '', '            if good_candidate:', '                return xyr_i', '', '        raise RuntimeError(', '            \"No non-overlapping candidates found. This should not happen.\"', '        )', '', '    def add_gutters(self, points, center, log_scale=False):', '        \"\"\"Stop points from extending beyond their territory.\"\"\"', '        half_width = self.width / 2', '        if log_scale:', '            low_gutter = 10 ** (np.log10(center) - half_width)', '        else:', '            low_gutter = center - half_width', '        off_low = points < low_gutter', '        if off_low.any():', '            points[off_low] = low_gutter', '        if log_scale:', '            high_gutter = 10 ** (np.log10(center) + half_width)', '        else:', '            high_gutter = center + half_width', '        off_high = points > high_gutter', '        if off_high.any():', '            points[off_high] = high_gutter', '', '        gutter_prop = (off_high + off_low).sum() / len(points)', '        if gutter_prop > self.warn_thresh:', '            msg = (', '                \"{:.1%} of the points cannot be placed; you may want \"', '                \"to decrease the size of the markers or use stripplot.\"', '            ).format(gutter_prop)', '            warnings.warn(msg, UserWarning)', '', '        return points']}, 'regression.py': {'classes': [{'name': '_LinearPlotter', 'start_line': 25, 'end_line': 67, 'text': ['class _LinearPlotter:', '    \"\"\"Base class for plotting relational data in tidy format.', '', \"    To get anything useful done you'll have to inherit from this, but setup\", '    code that can be abstracted out should be put here.', '', '    \"\"\"', '    def establish_variables(self, data, **kws):', '        \"\"\"Extract variables from data or use directly.\"\"\"', '        self.data = data', '', '        # Validate the inputs', '        any_strings = any([isinstance(v, str) for v in kws.values()])', '        if any_strings and data is None:', '            raise ValueError(\"Must pass `data` if using named variables.\")', '', '        # Set the variables', '        for var, val in kws.items():', '            if isinstance(val, str):', '                vector = data[val]', '            elif isinstance(val, list):', '                vector = np.asarray(val)', '            else:', '                vector = val', '            if vector is not None and vector.shape != (1,):', '                vector = np.squeeze(vector)', '            if np.ndim(vector) > 1:', '                err = \"regplot inputs must be 1d\"', '                raise ValueError(err)', '            setattr(self, var, vector)', '', '    def dropna(self, *vars):', '        \"\"\"Remove observations with missing data.\"\"\"', '        vals = [getattr(self, var) for var in vars]', '        vals = [v for v in vals if v is not None]', '        not_na = np.all(np.column_stack([pd.notnull(v) for v in vals]), axis=1)', '        for var in vars:', '            val = getattr(self, var)', '            if val is not None:', '                setattr(self, var, val[not_na])', '', '    def plot(self, ax):', '        raise NotImplementedError'], 'methods': [{'name': 'establish_variables', 'start_line': 32, 'end_line': 54, 'text': ['    def establish_variables(self, data, **kws):', '        \"\"\"Extract variables from data or use directly.\"\"\"', '        self.data = data', '', '        # Validate the inputs', '        any_strings = any([isinstance(v, str) for v in kws.values()])', '        if any_strings and data is None:', '            raise ValueError(\"Must pass `data` if using named variables.\")', '', '        # Set the variables', '        for var, val in kws.items():', '            if isinstance(val, str):', '                vector = data[val]', '            elif isinstance(val, list):', '                vector = np.asarray(val)', '            else:', '                vector = val', '            if vector is not None and vector.shape != (1,):', '                vector = np.squeeze(vector)', '            if np.ndim(vector) > 1:', '                err = \"regplot inputs must be 1d\"', '                raise ValueError(err)', '            setattr(self, var, vector)']}, {'name': 'dropna', 'start_line': 56, 'end_line': 64, 'text': ['    def dropna(self, *vars):', '        \"\"\"Remove observations with missing data.\"\"\"', '        vals = [getattr(self, var) for var in vars]', '        vals = [v for v in vals if v is not None]', '        not_na = np.all(np.column_stack([pd.notnull(v) for v in vals]), axis=1)', '        for var in vars:', '            val = getattr(self, var)', '            if val is not None:', '                setattr(self, var, val[not_na])']}, {'name': 'plot', 'start_line': 66, 'end_line': 67, 'text': ['    def plot(self, ax):', '        raise NotImplementedError']}]}, {'name': '_RegressionPlotter', 'start_line': 70, 'end_line': 426, 'text': ['class _RegressionPlotter(_LinearPlotter):', '    \"\"\"Plotter for numeric independent variables with regression model.', '', '    This does the computations and drawing for the `regplot` function, and', '    is thus also used indirectly by `lmplot`.', '    \"\"\"', '    def __init__(self, x, y, data=None, x_estimator=None, x_bins=None,', '                 x_ci=\"ci\", scatter=True, fit_reg=True, ci=95, n_boot=1000,', '                 units=None, seed=None, order=1, logistic=False, lowess=False,', '                 robust=False, logx=False, x_partial=None, y_partial=None,', '                 truncate=False, dropna=True, x_jitter=None, y_jitter=None,', '                 color=None, label=None):', '', '        # Set member attributes', '        self.x_estimator = x_estimator', '        self.ci = ci', '        self.x_ci = ci if x_ci == \"ci\" else x_ci', '        self.n_boot = n_boot', '        self.seed = seed', '        self.scatter = scatter', '        self.fit_reg = fit_reg', '        self.order = order', '        self.logistic = logistic', '        self.lowess = lowess', '        self.robust = robust', '        self.logx = logx', '        self.truncate = truncate', '        self.x_jitter = x_jitter', '        self.y_jitter = y_jitter', '        self.color = color', '        self.label = label', '', '        # Validate the regression options:', '        if sum((order > 1, logistic, robust, lowess, logx)) > 1:', '            raise ValueError(\"Mutually exclusive regression options.\")', '', '        # Extract the data vals from the arguments or passed dataframe', '        self.establish_variables(data, x=x, y=y, units=units,', '                                 x_partial=x_partial, y_partial=y_partial)', '', '        # Drop null observations', '        if dropna:', '            self.dropna(\"x\", \"y\", \"units\", \"x_partial\", \"y_partial\")', '', '        # Regress nuisance variables out of the data', '        if self.x_partial is not None:', '            self.x = self.regress_out(self.x, self.x_partial)', '        if self.y_partial is not None:', '            self.y = self.regress_out(self.y, self.y_partial)', '', '        # Possibly bin the predictor variable, which implies a point estimate', '        if x_bins is not None:', '            self.x_estimator = np.mean if x_estimator is None else x_estimator', '            x_discrete, x_bins = self.bin_predictor(x_bins)', '            self.x_discrete = x_discrete', '        else:', '            self.x_discrete = self.x', '', '        # Disable regression in case of singleton inputs', '        if len(self.x) <= 1:', '            self.fit_reg = False', '', '        # Save the range of the x variable for the grid later', '        if self.fit_reg:', '            self.x_range = self.x.min(), self.x.max()', '', '    @property', '    def scatter_data(self):', '        \"\"\"Data where each observation is a point.\"\"\"', '        x_j = self.x_jitter', '        if x_j is None:', '            x = self.x', '        else:', '            x = self.x + np.random.uniform(-x_j, x_j, len(self.x))', '', '        y_j = self.y_jitter', '        if y_j is None:', '            y = self.y', '        else:', '            y = self.y + np.random.uniform(-y_j, y_j, len(self.y))', '', '        return x, y', '', '    @property', '    def estimate_data(self):', '        \"\"\"Data with a point estimate and CI for each discrete x value.\"\"\"', '        x, y = self.x_discrete, self.y', '        vals = sorted(np.unique(x))', '        points, cis = [], []', '', '        for val in vals:', '', '            # Get the point estimate of the y variable', '            _y = y[x == val]', '            est = self.x_estimator(_y)', '            points.append(est)', '', '            # Compute the confidence interval for this estimate', '            if self.x_ci is None:', '                cis.append(None)', '            else:', '                units = None', '                if self.x_ci == \"sd\":', '                    sd = np.std(_y)', '                    _ci = est - sd, est + sd', '                else:', '                    if self.units is not None:', '                        units = self.units[x == val]', '                    boots = algo.bootstrap(_y,', '                                           func=self.x_estimator,', '                                           n_boot=self.n_boot,', '                                           units=units,', '                                           seed=self.seed)', '                    _ci = utils.ci(boots, self.x_ci)', '                cis.append(_ci)', '', '        return vals, points, cis', '', '    def fit_regression(self, ax=None, x_range=None, grid=None):', '        \"\"\"Fit the regression model.\"\"\"', '        # Create the grid for the regression', '        if grid is None:', '            if self.truncate:', '                x_min, x_max = self.x_range', '            else:', '                if ax is None:', '                    x_min, x_max = x_range', '                else:', '                    x_min, x_max = ax.get_xlim()', '            grid = np.linspace(x_min, x_max, 100)', '        ci = self.ci', '', '        # Fit the regression', '        if self.order > 1:', '            yhat, yhat_boots = self.fit_poly(grid, self.order)', '        elif self.logistic:', '            from statsmodels.genmod.generalized_linear_model import GLM', '            from statsmodels.genmod.families import Binomial', '            yhat, yhat_boots = self.fit_statsmodels(grid, GLM,', '                                                    family=Binomial())', '        elif self.lowess:', '            ci = None', '            grid, yhat = self.fit_lowess()', '        elif self.robust:', '            from statsmodels.robust.robust_linear_model import RLM', '            yhat, yhat_boots = self.fit_statsmodels(grid, RLM)', '        elif self.logx:', '            yhat, yhat_boots = self.fit_logx(grid)', '        else:', '            yhat, yhat_boots = self.fit_fast(grid)', '', '        # Compute the confidence interval at each grid point', '        if ci is None:', '            err_bands = None', '        else:', '            err_bands = utils.ci(yhat_boots, ci, axis=0)', '', '        return grid, yhat, err_bands', '', '    def fit_fast(self, grid):', '        \"\"\"Low-level regression and prediction using linear algebra.\"\"\"', '        def reg_func(_x, _y):', '            return np.linalg.pinv(_x).dot(_y)', '', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), grid]', '        yhat = grid.dot(reg_func(X, y))', '        if self.ci is None:', '            return yhat, None', '', '        beta_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed).T', '        yhat_boots = grid.dot(beta_boots).T', '        return yhat, yhat_boots', '', '    def fit_poly(self, grid, order):', '        \"\"\"Regression using numpy polyfit for higher-order trends.\"\"\"', '        def reg_func(_x, _y):', '            return np.polyval(np.polyfit(_x, _y, order), grid)', '', '        x, y = self.x, self.y', '        yhat = reg_func(x, y)', '        if self.ci is None:', '            return yhat, None', '', '        yhat_boots = algo.bootstrap(x, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed)', '        return yhat, yhat_boots', '', '    def fit_statsmodels(self, grid, model, **kwargs):', '        \"\"\"More general regression function using statsmodels objects.\"\"\"', '        import statsmodels.genmod.generalized_linear_model as glm', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), grid]', '', '        def reg_func(_x, _y):', '            try:', '                yhat = model(_y, _x, **kwargs).fit().predict(grid)', '            except glm.PerfectSeparationError:', '                yhat = np.empty(len(grid))', '                yhat.fill(np.nan)', '            return yhat', '', '        yhat = reg_func(X, y)', '        if self.ci is None:', '            return yhat, None', '', '        yhat_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed)', '        return yhat, yhat_boots', '', '    def fit_lowess(self):', '        \"\"\"Fit a locally-weighted regression, which returns its own grid.\"\"\"', '        from statsmodels.nonparametric.smoothers_lowess import lowess', '        grid, yhat = lowess(self.y, self.x).T', '        return grid, yhat', '', '    def fit_logx(self, grid):', '        \"\"\"Fit the model in log-space.\"\"\"', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), np.log(grid)]', '', '        def reg_func(_x, _y):', '            _x = np.c_[_x[:, 0], np.log(_x[:, 1])]', '            return np.linalg.pinv(_x).dot(_y)', '', '        yhat = grid.dot(reg_func(X, y))', '        if self.ci is None:', '            return yhat, None', '', '        beta_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed).T', '        yhat_boots = grid.dot(beta_boots).T', '        return yhat, yhat_boots', '', '    def bin_predictor(self, bins):', '        \"\"\"Discretize a predictor by assigning value to closest bin.\"\"\"', '        x = np.asarray(self.x)', '        if np.isscalar(bins):', '            percentiles = np.linspace(0, 100, bins + 2)[1:-1]', '            bins = np.percentile(x, percentiles)', '        else:', '            bins = np.ravel(bins)', '', '        dist = np.abs(np.subtract.outer(x, bins))', '        x_binned = bins[np.argmin(dist, axis=1)].ravel()', '', '        return x_binned, bins', '', '    def regress_out(self, a, b):', '        \"\"\"Regress b from a keeping a\\'s original mean.\"\"\"', '        a_mean = a.mean()', '        a = a - a_mean', '        b = b - b.mean()', '        b = np.c_[b]', '        a_prime = a - b.dot(np.linalg.pinv(b).dot(a))', '        return np.asarray(a_prime + a_mean).reshape(a.shape)', '', '    def plot(self, ax, scatter_kws, line_kws):', '        \"\"\"Draw the full plot.\"\"\"', '        # Insert the plot label into the correct set of keyword arguments', '        if self.scatter:', '            scatter_kws[\"label\"] = self.label', '        else:', '            line_kws[\"label\"] = self.label', '', '        # Use the current color cycle state as a default', '        if self.color is None:', '            lines, = ax.plot([], [])', '            color = lines.get_color()', '            lines.remove()', '        else:', '            color = self.color', '', '        # Ensure that color is hex to avoid matplotlib weirdness', '        color = mpl.colors.rgb2hex(mpl.colors.colorConverter.to_rgb(color))', '', '        # Let color in keyword arguments override overall plot color', '        scatter_kws.setdefault(\"color\", color)', '        line_kws.setdefault(\"color\", color)', '', '        # Draw the constituent plots', '        if self.scatter:', '            self.scatterplot(ax, scatter_kws)', '', '        if self.fit_reg:', '            self.lineplot(ax, line_kws)', '', '        # Label the axes', '        if hasattr(self.x, \"name\"):', '            ax.set_xlabel(self.x.name)', '        if hasattr(self.y, \"name\"):', '            ax.set_ylabel(self.y.name)', '', '    def scatterplot(self, ax, kws):', '        \"\"\"Draw the data.\"\"\"', '        # Treat the line-based markers specially, explicitly setting larger', '        # linewidth than is provided by the seaborn style defaults.', '        # This would ideally be handled better in matplotlib (i.e., distinguish', '        # between edgewidth for solid glyphs and linewidth for line glyphs', '        # but this should do for now.', '        line_markers = [\"1\", \"2\", \"3\", \"4\", \"+\", \"x\", \"|\", \"_\"]', '        if self.x_estimator is None:', '            if \"marker\" in kws and kws[\"marker\"] in line_markers:', '                lw = mpl.rcParams[\"lines.linewidth\"]', '            else:', '                lw = mpl.rcParams[\"lines.markeredgewidth\"]', '            kws.setdefault(\"linewidths\", lw)', '', \"            if not hasattr(kws['color'], 'shape') or kws['color'].shape[1] < 4:\", '                kws.setdefault(\"alpha\", .8)', '', '            x, y = self.scatter_data', '            ax.scatter(x, y, **kws)', '        else:', '            # TODO abstraction', '            ci_kws = {\"color\": kws[\"color\"]}', '            if \"alpha\" in kws:', '                ci_kws[\"alpha\"] = kws[\"alpha\"]', '            ci_kws[\"linewidth\"] = mpl.rcParams[\"lines.linewidth\"] * 1.75', '            kws.setdefault(\"s\", 50)', '', '            xs, ys, cis = self.estimate_data', '            if [ci for ci in cis if ci is not None]:', '                for x, ci in zip(xs, cis):', '                    ax.plot([x, x], ci, **ci_kws)', '            ax.scatter(xs, ys, **kws)', '', '    def lineplot(self, ax, kws):', '        \"\"\"Draw the model.\"\"\"', '        # Fit the regression model', '        grid, yhat, err_bands = self.fit_regression(ax)', '        edges = grid[0], grid[-1]', '', '        # Get set default aesthetics', '        fill_color = kws[\"color\"]', '        lw = kws.pop(\"lw\", mpl.rcParams[\"lines.linewidth\"] * 1.5)', '        kws.setdefault(\"linewidth\", lw)', '', '        # Draw the regression line and confidence interval', '        line, = ax.plot(grid, yhat, **kws)', '        if not self.truncate:', '            line.sticky_edges.x[:] = edges  # Prevent mpl from adding margin', '        if err_bands is not None:', '            ax.fill_between(grid, *err_bands, facecolor=fill_color, alpha=.15)'], 'methods': [{'name': '__init__', 'start_line': 76, 'end_line': 134, 'text': ['    def __init__(self, x, y, data=None, x_estimator=None, x_bins=None,', '                 x_ci=\"ci\", scatter=True, fit_reg=True, ci=95, n_boot=1000,', '                 units=None, seed=None, order=1, logistic=False, lowess=False,', '                 robust=False, logx=False, x_partial=None, y_partial=None,', '                 truncate=False, dropna=True, x_jitter=None, y_jitter=None,', '                 color=None, label=None):', '', '        # Set member attributes', '        self.x_estimator = x_estimator', '        self.ci = ci', '        self.x_ci = ci if x_ci == \"ci\" else x_ci', '        self.n_boot = n_boot', '        self.seed = seed', '        self.scatter = scatter', '        self.fit_reg = fit_reg', '        self.order = order', '        self.logistic = logistic', '        self.lowess = lowess', '        self.robust = robust', '        self.logx = logx', '        self.truncate = truncate', '        self.x_jitter = x_jitter', '        self.y_jitter = y_jitter', '        self.color = color', '        self.label = label', '', '        # Validate the regression options:', '        if sum((order > 1, logistic, robust, lowess, logx)) > 1:', '            raise ValueError(\"Mutually exclusive regression options.\")', '', '        # Extract the data vals from the arguments or passed dataframe', '        self.establish_variables(data, x=x, y=y, units=units,', '                                 x_partial=x_partial, y_partial=y_partial)', '', '        # Drop null observations', '        if dropna:', '            self.dropna(\"x\", \"y\", \"units\", \"x_partial\", \"y_partial\")', '', '        # Regress nuisance variables out of the data', '        if self.x_partial is not None:', '            self.x = self.regress_out(self.x, self.x_partial)', '        if self.y_partial is not None:', '            self.y = self.regress_out(self.y, self.y_partial)', '', '        # Possibly bin the predictor variable, which implies a point estimate', '        if x_bins is not None:', '            self.x_estimator = np.mean if x_estimator is None else x_estimator', '            x_discrete, x_bins = self.bin_predictor(x_bins)', '            self.x_discrete = x_discrete', '        else:', '            self.x_discrete = self.x', '', '        # Disable regression in case of singleton inputs', '        if len(self.x) <= 1:', '            self.fit_reg = False', '', '        # Save the range of the x variable for the grid later', '        if self.fit_reg:', '            self.x_range = self.x.min(), self.x.max()']}, {'name': 'scatter_data', 'start_line': 137, 'end_line': 151, 'text': ['    def scatter_data(self):', '        \"\"\"Data where each observation is a point.\"\"\"', '        x_j = self.x_jitter', '        if x_j is None:', '            x = self.x', '        else:', '            x = self.x + np.random.uniform(-x_j, x_j, len(self.x))', '', '        y_j = self.y_jitter', '        if y_j is None:', '            y = self.y', '        else:', '            y = self.y + np.random.uniform(-y_j, y_j, len(self.y))', '', '        return x, y']}, {'name': 'estimate_data', 'start_line': 154, 'end_line': 186, 'text': ['    def estimate_data(self):', '        \"\"\"Data with a point estimate and CI for each discrete x value.\"\"\"', '        x, y = self.x_discrete, self.y', '        vals = sorted(np.unique(x))', '        points, cis = [], []', '', '        for val in vals:', '', '            # Get the point estimate of the y variable', '            _y = y[x == val]', '            est = self.x_estimator(_y)', '            points.append(est)', '', '            # Compute the confidence interval for this estimate', '            if self.x_ci is None:', '                cis.append(None)', '            else:', '                units = None', '                if self.x_ci == \"sd\":', '                    sd = np.std(_y)', '                    _ci = est - sd, est + sd', '                else:', '                    if self.units is not None:', '                        units = self.units[x == val]', '                    boots = algo.bootstrap(_y,', '                                           func=self.x_estimator,', '                                           n_boot=self.n_boot,', '                                           units=units,', '                                           seed=self.seed)', '                    _ci = utils.ci(boots, self.x_ci)', '                cis.append(_ci)', '', '        return vals, points, cis']}, {'name': 'fit_regression', 'start_line': 188, 'end_line': 227, 'text': ['    def fit_regression(self, ax=None, x_range=None, grid=None):', '        \"\"\"Fit the regression model.\"\"\"', '        # Create the grid for the regression', '        if grid is None:', '            if self.truncate:', '                x_min, x_max = self.x_range', '            else:', '                if ax is None:', '                    x_min, x_max = x_range', '                else:', '                    x_min, x_max = ax.get_xlim()', '            grid = np.linspace(x_min, x_max, 100)', '        ci = self.ci', '', '        # Fit the regression', '        if self.order > 1:', '            yhat, yhat_boots = self.fit_poly(grid, self.order)', '        elif self.logistic:', '            from statsmodels.genmod.generalized_linear_model import GLM', '            from statsmodels.genmod.families import Binomial', '            yhat, yhat_boots = self.fit_statsmodels(grid, GLM,', '                                                    family=Binomial())', '        elif self.lowess:', '            ci = None', '            grid, yhat = self.fit_lowess()', '        elif self.robust:', '            from statsmodels.robust.robust_linear_model import RLM', '            yhat, yhat_boots = self.fit_statsmodels(grid, RLM)', '        elif self.logx:', '            yhat, yhat_boots = self.fit_logx(grid)', '        else:', '            yhat, yhat_boots = self.fit_fast(grid)', '', '        # Compute the confidence interval at each grid point', '        if ci is None:', '            err_bands = None', '        else:', '            err_bands = utils.ci(yhat_boots, ci, axis=0)', '', '        return grid, yhat, err_bands']}, {'name': 'fit_fast', 'start_line': 229, 'end_line': 246, 'text': ['    def fit_fast(self, grid):', '        \"\"\"Low-level regression and prediction using linear algebra.\"\"\"', '        def reg_func(_x, _y):', '            return np.linalg.pinv(_x).dot(_y)', '', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), grid]', '        yhat = grid.dot(reg_func(X, y))', '        if self.ci is None:', '            return yhat, None', '', '        beta_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed).T', '        yhat_boots = grid.dot(beta_boots).T', '        return yhat, yhat_boots']}, {'name': 'fit_poly', 'start_line': 248, 'end_line': 263, 'text': ['    def fit_poly(self, grid, order):', '        \"\"\"Regression using numpy polyfit for higher-order trends.\"\"\"', '        def reg_func(_x, _y):', '            return np.polyval(np.polyfit(_x, _y, order), grid)', '', '        x, y = self.x, self.y', '        yhat = reg_func(x, y)', '        if self.ci is None:', '            return yhat, None', '', '        yhat_boots = algo.bootstrap(x, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed)', '        return yhat, yhat_boots']}, {'name': 'fit_statsmodels', 'start_line': 265, 'end_line': 288, 'text': ['    def fit_statsmodels(self, grid, model, **kwargs):', '        \"\"\"More general regression function using statsmodels objects.\"\"\"', '        import statsmodels.genmod.generalized_linear_model as glm', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), grid]', '', '        def reg_func(_x, _y):', '            try:', '                yhat = model(_y, _x, **kwargs).fit().predict(grid)', '            except glm.PerfectSeparationError:', '                yhat = np.empty(len(grid))', '                yhat.fill(np.nan)', '            return yhat', '', '        yhat = reg_func(X, y)', '        if self.ci is None:', '            return yhat, None', '', '        yhat_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed)', '        return yhat, yhat_boots']}, {'name': 'fit_lowess', 'start_line': 290, 'end_line': 294, 'text': ['    def fit_lowess(self):', '        \"\"\"Fit a locally-weighted regression, which returns its own grid.\"\"\"', '        from statsmodels.nonparametric.smoothers_lowess import lowess', '        grid, yhat = lowess(self.y, self.x).T', '        return grid, yhat']}, {'name': 'fit_logx', 'start_line': 296, 'end_line': 315, 'text': ['    def fit_logx(self, grid):', '        \"\"\"Fit the model in log-space.\"\"\"', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), np.log(grid)]', '', '        def reg_func(_x, _y):', '            _x = np.c_[_x[:, 0], np.log(_x[:, 1])]', '            return np.linalg.pinv(_x).dot(_y)', '', '        yhat = grid.dot(reg_func(X, y))', '        if self.ci is None:', '            return yhat, None', '', '        beta_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed).T', '        yhat_boots = grid.dot(beta_boots).T', '        return yhat, yhat_boots']}, {'name': 'bin_predictor', 'start_line': 317, 'end_line': 329, 'text': ['    def bin_predictor(self, bins):', '        \"\"\"Discretize a predictor by assigning value to closest bin.\"\"\"', '        x = np.asarray(self.x)', '        if np.isscalar(bins):', '            percentiles = np.linspace(0, 100, bins + 2)[1:-1]', '            bins = np.percentile(x, percentiles)', '        else:', '            bins = np.ravel(bins)', '', '        dist = np.abs(np.subtract.outer(x, bins))', '        x_binned = bins[np.argmin(dist, axis=1)].ravel()', '', '        return x_binned, bins']}, {'name': 'regress_out', 'start_line': 331, 'end_line': 338, 'text': ['    def regress_out(self, a, b):', '        \"\"\"Regress b from a keeping a\\'s original mean.\"\"\"', '        a_mean = a.mean()', '        a = a - a_mean', '        b = b - b.mean()', '        b = np.c_[b]', '        a_prime = a - b.dot(np.linalg.pinv(b).dot(a))', '        return np.asarray(a_prime + a_mean).reshape(a.shape)']}, {'name': 'plot', 'start_line': 340, 'end_line': 374, 'text': ['    def plot(self, ax, scatter_kws, line_kws):', '        \"\"\"Draw the full plot.\"\"\"', '        # Insert the plot label into the correct set of keyword arguments', '        if self.scatter:', '            scatter_kws[\"label\"] = self.label', '        else:', '            line_kws[\"label\"] = self.label', '', '        # Use the current color cycle state as a default', '        if self.color is None:', '            lines, = ax.plot([], [])', '            color = lines.get_color()', '            lines.remove()', '        else:', '            color = self.color', '', '        # Ensure that color is hex to avoid matplotlib weirdness', '        color = mpl.colors.rgb2hex(mpl.colors.colorConverter.to_rgb(color))', '', '        # Let color in keyword arguments override overall plot color', '        scatter_kws.setdefault(\"color\", color)', '        line_kws.setdefault(\"color\", color)', '', '        # Draw the constituent plots', '        if self.scatter:', '            self.scatterplot(ax, scatter_kws)', '', '        if self.fit_reg:', '            self.lineplot(ax, line_kws)', '', '        # Label the axes', '        if hasattr(self.x, \"name\"):', '            ax.set_xlabel(self.x.name)', '        if hasattr(self.y, \"name\"):', '            ax.set_ylabel(self.y.name)']}, {'name': 'scatterplot', 'start_line': 376, 'end_line': 408, 'text': ['    def scatterplot(self, ax, kws):', '        \"\"\"Draw the data.\"\"\"', '        # Treat the line-based markers specially, explicitly setting larger', '        # linewidth than is provided by the seaborn style defaults.', '        # This would ideally be handled better in matplotlib (i.e., distinguish', '        # between edgewidth for solid glyphs and linewidth for line glyphs', '        # but this should do for now.', '        line_markers = [\"1\", \"2\", \"3\", \"4\", \"+\", \"x\", \"|\", \"_\"]', '        if self.x_estimator is None:', '            if \"marker\" in kws and kws[\"marker\"] in line_markers:', '                lw = mpl.rcParams[\"lines.linewidth\"]', '            else:', '                lw = mpl.rcParams[\"lines.markeredgewidth\"]', '            kws.setdefault(\"linewidths\", lw)', '', \"            if not hasattr(kws['color'], 'shape') or kws['color'].shape[1] < 4:\", '                kws.setdefault(\"alpha\", .8)', '', '            x, y = self.scatter_data', '            ax.scatter(x, y, **kws)', '        else:', '            # TODO abstraction', '            ci_kws = {\"color\": kws[\"color\"]}', '            if \"alpha\" in kws:', '                ci_kws[\"alpha\"] = kws[\"alpha\"]', '            ci_kws[\"linewidth\"] = mpl.rcParams[\"lines.linewidth\"] * 1.75', '            kws.setdefault(\"s\", 50)', '', '            xs, ys, cis = self.estimate_data', '            if [ci for ci in cis if ci is not None]:', '                for x, ci in zip(xs, cis):', '                    ax.plot([x, x], ci, **ci_kws)', '            ax.scatter(xs, ys, **kws)']}, {'name': 'lineplot', 'start_line': 410, 'end_line': 426, 'text': ['    def lineplot(self, ax, kws):', '        \"\"\"Draw the model.\"\"\"', '        # Fit the regression model', '        grid, yhat, err_bands = self.fit_regression(ax)', '        edges = grid[0], grid[-1]', '', '        # Get set default aesthetics', '        fill_color = kws[\"color\"]', '        lw = kws.pop(\"lw\", mpl.rcParams[\"lines.linewidth\"] * 1.5)', '        kws.setdefault(\"linewidth\", lw)', '', '        # Draw the regression line and confidence interval', '        line, = ax.plot(grid, yhat, **kws)', '        if not self.truncate:', '            line.sticky_edges.x[:] = edges  # Prevent mpl from adding margin', '        if err_bands is not None:', '            ax.fill_between(grid, *err_bands, facecolor=fill_color, alpha=.15)']}]}], 'functions': [{'name': 'lmplot', 'start_line': 560, 'end_line': 641, 'text': ['def lmplot(', '    data=None, *,', '    x=None, y=None, hue=None, col=None, row=None,', '    palette=None, col_wrap=None, height=5, aspect=1, markers=\"o\",', '    sharex=None, sharey=None, hue_order=None, col_order=None, row_order=None,', '    legend=True, legend_out=None, x_estimator=None, x_bins=None,', '    x_ci=\"ci\", scatter=True, fit_reg=True, ci=95, n_boot=1000,', '    units=None, seed=None, order=1, logistic=False, lowess=False,', '    robust=False, logx=False, x_partial=None, y_partial=None,', '    truncate=True, x_jitter=None, y_jitter=None, scatter_kws=None,', '    line_kws=None, facet_kws=None,', '):', '', '    if facet_kws is None:', '        facet_kws = {}', '', '    def facet_kw_deprecation(key, val):', '        msg = (', '            f\"{key} is deprecated from the `lmplot` function signature. \"', '            \"Please update your code to pass it using `facet_kws`.\"', '        )', '        if val is not None:', '            warnings.warn(msg, UserWarning)', '            facet_kws[key] = val', '', '    facet_kw_deprecation(\"sharex\", sharex)', '    facet_kw_deprecation(\"sharey\", sharey)', '    facet_kw_deprecation(\"legend_out\", legend_out)', '', '    if data is None:', '        raise TypeError(\"Missing required keyword argument `data`.\")', '', '    # Reduce the dataframe to only needed columns', '    need_cols = [x, y, hue, col, row, units, x_partial, y_partial]', '    cols = np.unique([a for a in need_cols if a is not None]).tolist()', '    data = data[cols]', '', '    # Initialize the grid', '    facets = FacetGrid(', '        data, row=row, col=col, hue=hue,', '        palette=palette,', '        row_order=row_order, col_order=col_order, hue_order=hue_order,', '        height=height, aspect=aspect, col_wrap=col_wrap,', '        **facet_kws,', '    )', '', '    # Add the markers here as FacetGrid has figured out how many levels of the', \"    # hue variable are needed and we don't want to duplicate that process\", '    if facets.hue_names is None:', '        n_markers = 1', '    else:', '        n_markers = len(facets.hue_names)', '    if not isinstance(markers, list):', '        markers = [markers] * n_markers', '    if len(markers) != n_markers:', '        raise ValueError(\"markers must be a singleton or a list of markers \"', '                         \"for each level of the hue variable\")', '    facets.hue_kws = {\"marker\": markers}', '', '    def update_datalim(data, x, y, ax, **kws):', '        xys = data[[x, y]].to_numpy().astype(float)', '        ax.update_datalim(xys, updatey=False)', '        ax.autoscale_view(scaley=False)', '', '    facets.map_dataframe(update_datalim, x=x, y=y)', '', '    # Draw the regression plot on each facet', '    regplot_kws = dict(', '        x_estimator=x_estimator, x_bins=x_bins, x_ci=x_ci,', '        scatter=scatter, fit_reg=fit_reg, ci=ci, n_boot=n_boot, units=units,', '        seed=seed, order=order, logistic=logistic, lowess=lowess,', '        robust=robust, logx=logx, x_partial=x_partial, y_partial=y_partial,', '        truncate=truncate, x_jitter=x_jitter, y_jitter=y_jitter,', '        scatter_kws=scatter_kws, line_kws=line_kws,', '    )', '    facets.map_dataframe(regplot, x=x, y=y, **regplot_kws)', '    facets.set_axis_labels(x, y)', '', '    # Add a legend', '    if legend and (hue is not None) and (hue not in [col, row]):', '        facets.add_legend()', '    return facets']}, {'name': 'regplot', 'start_line': 736, 'end_line': 760, 'text': ['def regplot(', '    data=None, *, x=None, y=None,', '    x_estimator=None, x_bins=None, x_ci=\"ci\",', '    scatter=True, fit_reg=True, ci=95, n_boot=1000, units=None,', '    seed=None, order=1, logistic=False, lowess=False, robust=False,', '    logx=False, x_partial=None, y_partial=None,', '    truncate=True, dropna=True, x_jitter=None, y_jitter=None,', '    label=None, color=None, marker=\"o\",', '    scatter_kws=None, line_kws=None, ax=None', '):', '', '    plotter = _RegressionPlotter(x, y, data, x_estimator, x_bins, x_ci,', '                                 scatter, fit_reg, ci, n_boot, units, seed,', '                                 order, logistic, lowess, robust, logx,', '                                 x_partial, y_partial, truncate, dropna,', '                                 x_jitter, y_jitter, color, label)', '', '    if ax is None:', '        ax = plt.gca()', '', '    scatter_kws = {} if scatter_kws is None else copy.copy(scatter_kws)', '    scatter_kws[\"marker\"] = marker', '    line_kws = {} if line_kws is None else copy.copy(line_kws)', '    plotter.plot(ax, scatter_kws, line_kws)', '    return ax']}, {'name': 'residplot', 'start_line': 838, 'end_line': 924, 'text': ['def residplot(', '    data=None, *, x=None, y=None,', '    x_partial=None, y_partial=None, lowess=False,', '    order=1, robust=False, dropna=True, label=None, color=None,', '    scatter_kws=None, line_kws=None, ax=None', '):', '    \"\"\"Plot the residuals of a linear regression.', '', '    This function will regress y on x (possibly as a robust or polynomial', '    regression) and then draw a scatterplot of the residuals. You can', '    optionally fit a lowess smoother to the residual plot, which can', '    help in determining if there is structure to the residuals.', '', '    Parameters', '    ----------', '    data : DataFrame, optional', '        DataFrame to use if `x` and `y` are column names.', '    x : vector or string', '        Data or column name in `data` for the predictor variable.', '    y : vector or string', '        Data or column name in `data` for the response variable.', '    {x, y}_partial : vectors or string(s) , optional', '        These variables are treated as confounding and are removed from', '        the `x` or `y` variables before plotting.', '    lowess : boolean, optional', '        Fit a lowess smoother to the residual scatterplot.', '    order : int, optional', '        Order of the polynomial to fit when calculating the residuals.', '    robust : boolean, optional', '        Fit a robust linear regression when calculating the residuals.', '    dropna : boolean, optional', '        If True, ignore observations with missing data when fitting and', '        plotting.', '    label : string, optional', '        Label that will be used in any plot legends.', '    color : matplotlib color, optional', '        Color to use for all elements of the plot.', '    {scatter, line}_kws : dictionaries, optional', '        Additional keyword arguments passed to scatter() and plot() for drawing', '        the components of the plot.', '    ax : matplotlib axis, optional', '        Plot into this axis, otherwise grab the current axis or make a new', '        one if not existing.', '', '    Returns', '    -------', '    ax: matplotlib axes', '        Axes with the regression plot.', '', '    See Also', '    --------', '    regplot : Plot a simple linear regression model.', '    jointplot : Draw a :func:`residplot` with univariate marginal distributions', '                (when used with ``kind=\"resid\"``).', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/residplot.rst', '', '    \"\"\"', '    plotter = _RegressionPlotter(x, y, data, ci=None,', '                                 order=order, robust=robust,', '                                 x_partial=x_partial, y_partial=y_partial,', '                                 dropna=dropna, color=color, label=label)', '', '    if ax is None:', '        ax = plt.gca()', '', '    # Calculate the residual from a linear regression', '    _, yhat, _ = plotter.fit_regression(grid=plotter.x)', '    plotter.y = plotter.y - yhat', '', '    # Set the regression option on the plotter', '    if lowess:', '        plotter.lowess = True', '    else:', '        plotter.fit_reg = False', '', '    # Plot a horizontal line at 0', '    ax.axhline(0, ls=\":\", c=\".2\")', '', '    # Draw the scatterplot', '    scatter_kws = {} if scatter_kws is None else scatter_kws.copy()', '    line_kws = {} if line_kws is None else line_kws.copy()', '    plotter.plot(ax, scatter_kws, line_kws)', '    return ax']}, {'name': 'facet_kw_deprecation', 'start_line': 576, 'end_line': 583, 'text': ['    def facet_kw_deprecation(key, val):', '        msg = (', '            f\"{key} is deprecated from the `lmplot` function signature. \"', '            \"Please update your code to pass it using `facet_kws`.\"', '        )', '        if val is not None:', '            warnings.warn(msg, UserWarning)', '            facet_kws[key] = val']}, {'name': 'update_datalim', 'start_line': 619, 'end_line': 622, 'text': ['    def update_datalim(data, x, y, ax, **kws):', '        xys = data[[x, y]].to_numpy().astype(float)', '        ax.update_datalim(xys, updatey=False)', '        ax.autoscale_view(scaley=False)']}, {'name': 'reg_func', 'start_line': 231, 'end_line': 232, 'text': ['        def reg_func(_x, _y):', '            return np.linalg.pinv(_x).dot(_y)']}, {'name': 'reg_func', 'start_line': 250, 'end_line': 251, 'text': ['        def reg_func(_x, _y):', '            return np.polyval(np.polyfit(_x, _y, order), grid)']}, {'name': 'reg_func', 'start_line': 271, 'end_line': 277, 'text': ['        def reg_func(_x, _y):', '            try:', '                yhat = model(_y, _x, **kwargs).fit().predict(grid)', '            except glm.PerfectSeparationError:', '                yhat = np.empty(len(grid))', '                yhat.fill(np.nan)', '            return yhat']}, {'name': 'reg_func', 'start_line': 301, 'end_line': 303, 'text': ['        def reg_func(_x, _y):', '            _x = np.c_[_x[:, 0], np.log(_x[:, 1])]', '            return np.linalg.pinv(_x).dot(_y)']}], 'text': ['\"\"\"Plotting functions for linear models (broadly construed).\"\"\"', 'import copy', 'from textwrap import dedent', 'import warnings', 'import numpy as np', 'import pandas as pd', 'import matplotlib as mpl', 'import matplotlib.pyplot as plt', '', 'try:', '    import statsmodels', '    assert statsmodels', '    _has_statsmodels = True', 'except ImportError:', '    _has_statsmodels = False', '', 'from . import utils', 'from . import algorithms as algo', 'from .axisgrid import FacetGrid, _facet_docs', '', '', '__all__ = [\"lmplot\", \"regplot\", \"residplot\"]', '', '', 'class _LinearPlotter:', '    \"\"\"Base class for plotting relational data in tidy format.', '', \"    To get anything useful done you'll have to inherit from this, but setup\", '    code that can be abstracted out should be put here.', '', '    \"\"\"', '    def establish_variables(self, data, **kws):', '        \"\"\"Extract variables from data or use directly.\"\"\"', '        self.data = data', '', '        # Validate the inputs', '        any_strings = any([isinstance(v, str) for v in kws.values()])', '        if any_strings and data is None:', '            raise ValueError(\"Must pass `data` if using named variables.\")', '', '        # Set the variables', '        for var, val in kws.items():', '            if isinstance(val, str):', '                vector = data[val]', '            elif isinstance(val, list):', '                vector = np.asarray(val)', '            else:', '                vector = val', '            if vector is not None and vector.shape != (1,):', '                vector = np.squeeze(vector)', '            if np.ndim(vector) > 1:', '                err = \"regplot inputs must be 1d\"', '                raise ValueError(err)', '            setattr(self, var, vector)', '', '    def dropna(self, *vars):', '        \"\"\"Remove observations with missing data.\"\"\"', '        vals = [getattr(self, var) for var in vars]', '        vals = [v for v in vals if v is not None]', '        not_na = np.all(np.column_stack([pd.notnull(v) for v in vals]), axis=1)', '        for var in vars:', '            val = getattr(self, var)', '            if val is not None:', '                setattr(self, var, val[not_na])', '', '    def plot(self, ax):', '        raise NotImplementedError', '', '', 'class _RegressionPlotter(_LinearPlotter):', '    \"\"\"Plotter for numeric independent variables with regression model.', '', '    This does the computations and drawing for the `regplot` function, and', '    is thus also used indirectly by `lmplot`.', '    \"\"\"', '    def __init__(self, x, y, data=None, x_estimator=None, x_bins=None,', '                 x_ci=\"ci\", scatter=True, fit_reg=True, ci=95, n_boot=1000,', '                 units=None, seed=None, order=1, logistic=False, lowess=False,', '                 robust=False, logx=False, x_partial=None, y_partial=None,', '                 truncate=False, dropna=True, x_jitter=None, y_jitter=None,', '                 color=None, label=None):', '', '        # Set member attributes', '        self.x_estimator = x_estimator', '        self.ci = ci', '        self.x_ci = ci if x_ci == \"ci\" else x_ci', '        self.n_boot = n_boot', '        self.seed = seed', '        self.scatter = scatter', '        self.fit_reg = fit_reg', '        self.order = order', '        self.logistic = logistic', '        self.lowess = lowess', '        self.robust = robust', '        self.logx = logx', '        self.truncate = truncate', '        self.x_jitter = x_jitter', '        self.y_jitter = y_jitter', '        self.color = color', '        self.label = label', '', '        # Validate the regression options:', '        if sum((order > 1, logistic, robust, lowess, logx)) > 1:', '            raise ValueError(\"Mutually exclusive regression options.\")', '', '        # Extract the data vals from the arguments or passed dataframe', '        self.establish_variables(data, x=x, y=y, units=units,', '                                 x_partial=x_partial, y_partial=y_partial)', '', '        # Drop null observations', '        if dropna:', '            self.dropna(\"x\", \"y\", \"units\", \"x_partial\", \"y_partial\")', '', '        # Regress nuisance variables out of the data', '        if self.x_partial is not None:', '            self.x = self.regress_out(self.x, self.x_partial)', '        if self.y_partial is not None:', '            self.y = self.regress_out(self.y, self.y_partial)', '', '        # Possibly bin the predictor variable, which implies a point estimate', '        if x_bins is not None:', '            self.x_estimator = np.mean if x_estimator is None else x_estimator', '            x_discrete, x_bins = self.bin_predictor(x_bins)', '            self.x_discrete = x_discrete', '        else:', '            self.x_discrete = self.x', '', '        # Disable regression in case of singleton inputs', '        if len(self.x) <= 1:', '            self.fit_reg = False', '', '        # Save the range of the x variable for the grid later', '        if self.fit_reg:', '            self.x_range = self.x.min(), self.x.max()', '', '    @property', '    def scatter_data(self):', '        \"\"\"Data where each observation is a point.\"\"\"', '        x_j = self.x_jitter', '        if x_j is None:', '            x = self.x', '        else:', '            x = self.x + np.random.uniform(-x_j, x_j, len(self.x))', '', '        y_j = self.y_jitter', '        if y_j is None:', '            y = self.y', '        else:', '            y = self.y + np.random.uniform(-y_j, y_j, len(self.y))', '', '        return x, y', '', '    @property', '    def estimate_data(self):', '        \"\"\"Data with a point estimate and CI for each discrete x value.\"\"\"', '        x, y = self.x_discrete, self.y', '        vals = sorted(np.unique(x))', '        points, cis = [], []', '', '        for val in vals:', '', '            # Get the point estimate of the y variable', '            _y = y[x == val]', '            est = self.x_estimator(_y)', '            points.append(est)', '', '            # Compute the confidence interval for this estimate', '            if self.x_ci is None:', '                cis.append(None)', '            else:', '                units = None', '                if self.x_ci == \"sd\":', '                    sd = np.std(_y)', '                    _ci = est - sd, est + sd', '                else:', '                    if self.units is not None:', '                        units = self.units[x == val]', '                    boots = algo.bootstrap(_y,', '                                           func=self.x_estimator,', '                                           n_boot=self.n_boot,', '                                           units=units,', '                                           seed=self.seed)', '                    _ci = utils.ci(boots, self.x_ci)', '                cis.append(_ci)', '', '        return vals, points, cis', '', '    def fit_regression(self, ax=None, x_range=None, grid=None):', '        \"\"\"Fit the regression model.\"\"\"', '        # Create the grid for the regression', '        if grid is None:', '            if self.truncate:', '                x_min, x_max = self.x_range', '            else:', '                if ax is None:', '                    x_min, x_max = x_range', '                else:', '                    x_min, x_max = ax.get_xlim()', '            grid = np.linspace(x_min, x_max, 100)', '        ci = self.ci', '', '        # Fit the regression', '        if self.order > 1:', '            yhat, yhat_boots = self.fit_poly(grid, self.order)', '        elif self.logistic:', '            from statsmodels.genmod.generalized_linear_model import GLM', '            from statsmodels.genmod.families import Binomial', '            yhat, yhat_boots = self.fit_statsmodels(grid, GLM,', '                                                    family=Binomial())', '        elif self.lowess:', '            ci = None', '            grid, yhat = self.fit_lowess()', '        elif self.robust:', '            from statsmodels.robust.robust_linear_model import RLM', '            yhat, yhat_boots = self.fit_statsmodels(grid, RLM)', '        elif self.logx:', '            yhat, yhat_boots = self.fit_logx(grid)', '        else:', '            yhat, yhat_boots = self.fit_fast(grid)', '', '        # Compute the confidence interval at each grid point', '        if ci is None:', '            err_bands = None', '        else:', '            err_bands = utils.ci(yhat_boots, ci, axis=0)', '', '        return grid, yhat, err_bands', '', '    def fit_fast(self, grid):', '        \"\"\"Low-level regression and prediction using linear algebra.\"\"\"', '        def reg_func(_x, _y):', '            return np.linalg.pinv(_x).dot(_y)', '', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), grid]', '        yhat = grid.dot(reg_func(X, y))', '        if self.ci is None:', '            return yhat, None', '', '        beta_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed).T', '        yhat_boots = grid.dot(beta_boots).T', '        return yhat, yhat_boots', '', '    def fit_poly(self, grid, order):', '        \"\"\"Regression using numpy polyfit for higher-order trends.\"\"\"', '        def reg_func(_x, _y):', '            return np.polyval(np.polyfit(_x, _y, order), grid)', '', '        x, y = self.x, self.y', '        yhat = reg_func(x, y)', '        if self.ci is None:', '            return yhat, None', '', '        yhat_boots = algo.bootstrap(x, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed)', '        return yhat, yhat_boots', '', '    def fit_statsmodels(self, grid, model, **kwargs):', '        \"\"\"More general regression function using statsmodels objects.\"\"\"', '        import statsmodels.genmod.generalized_linear_model as glm', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), grid]', '', '        def reg_func(_x, _y):', '            try:', '                yhat = model(_y, _x, **kwargs).fit().predict(grid)', '            except glm.PerfectSeparationError:', '                yhat = np.empty(len(grid))', '                yhat.fill(np.nan)', '            return yhat', '', '        yhat = reg_func(X, y)', '        if self.ci is None:', '            return yhat, None', '', '        yhat_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed)', '        return yhat, yhat_boots', '', '    def fit_lowess(self):', '        \"\"\"Fit a locally-weighted regression, which returns its own grid.\"\"\"', '        from statsmodels.nonparametric.smoothers_lowess import lowess', '        grid, yhat = lowess(self.y, self.x).T', '        return grid, yhat', '', '    def fit_logx(self, grid):', '        \"\"\"Fit the model in log-space.\"\"\"', '        X, y = np.c_[np.ones(len(self.x)), self.x], self.y', '        grid = np.c_[np.ones(len(grid)), np.log(grid)]', '', '        def reg_func(_x, _y):', '            _x = np.c_[_x[:, 0], np.log(_x[:, 1])]', '            return np.linalg.pinv(_x).dot(_y)', '', '        yhat = grid.dot(reg_func(X, y))', '        if self.ci is None:', '            return yhat, None', '', '        beta_boots = algo.bootstrap(X, y,', '                                    func=reg_func,', '                                    n_boot=self.n_boot,', '                                    units=self.units,', '                                    seed=self.seed).T', '        yhat_boots = grid.dot(beta_boots).T', '        return yhat, yhat_boots', '', '    def bin_predictor(self, bins):', '        \"\"\"Discretize a predictor by assigning value to closest bin.\"\"\"', '        x = np.asarray(self.x)', '        if np.isscalar(bins):', '            percentiles = np.linspace(0, 100, bins + 2)[1:-1]', '            bins = np.percentile(x, percentiles)', '        else:', '            bins = np.ravel(bins)', '', '        dist = np.abs(np.subtract.outer(x, bins))', '        x_binned = bins[np.argmin(dist, axis=1)].ravel()', '', '        return x_binned, bins', '', '    def regress_out(self, a, b):', '        \"\"\"Regress b from a keeping a\\'s original mean.\"\"\"', '        a_mean = a.mean()', '        a = a - a_mean', '        b = b - b.mean()', '        b = np.c_[b]', '        a_prime = a - b.dot(np.linalg.pinv(b).dot(a))', '        return np.asarray(a_prime + a_mean).reshape(a.shape)', '', '    def plot(self, ax, scatter_kws, line_kws):', '        \"\"\"Draw the full plot.\"\"\"', '        # Insert the plot label into the correct set of keyword arguments', '        if self.scatter:', '            scatter_kws[\"label\"] = self.label', '        else:', '            line_kws[\"label\"] = self.label', '', '        # Use the current color cycle state as a default', '        if self.color is None:', '            lines, = ax.plot([], [])', '            color = lines.get_color()', '            lines.remove()', '        else:', '            color = self.color', '', '        # Ensure that color is hex to avoid matplotlib weirdness', '        color = mpl.colors.rgb2hex(mpl.colors.colorConverter.to_rgb(color))', '', '        # Let color in keyword arguments override overall plot color', '        scatter_kws.setdefault(\"color\", color)', '        line_kws.setdefault(\"color\", color)', '', '        # Draw the constituent plots', '        if self.scatter:', '            self.scatterplot(ax, scatter_kws)', '', '        if self.fit_reg:', '            self.lineplot(ax, line_kws)', '', '        # Label the axes', '        if hasattr(self.x, \"name\"):', '            ax.set_xlabel(self.x.name)', '        if hasattr(self.y, \"name\"):', '            ax.set_ylabel(self.y.name)', '', '    def scatterplot(self, ax, kws):', '        \"\"\"Draw the data.\"\"\"', '        # Treat the line-based markers specially, explicitly setting larger', '        # linewidth than is provided by the seaborn style defaults.', '        # This would ideally be handled better in matplotlib (i.e., distinguish', '        # between edgewidth for solid glyphs and linewidth for line glyphs', '        # but this should do for now.', '        line_markers = [\"1\", \"2\", \"3\", \"4\", \"+\", \"x\", \"|\", \"_\"]', '        if self.x_estimator is None:', '            if \"marker\" in kws and kws[\"marker\"] in line_markers:', '                lw = mpl.rcParams[\"lines.linewidth\"]', '            else:', '                lw = mpl.rcParams[\"lines.markeredgewidth\"]', '            kws.setdefault(\"linewidths\", lw)', '', \"            if not hasattr(kws['color'], 'shape') or kws['color'].shape[1] < 4:\", '                kws.setdefault(\"alpha\", .8)', '', '            x, y = self.scatter_data', '            ax.scatter(x, y, **kws)', '        else:', '            # TODO abstraction', '            ci_kws = {\"color\": kws[\"color\"]}', '            if \"alpha\" in kws:', '                ci_kws[\"alpha\"] = kws[\"alpha\"]', '            ci_kws[\"linewidth\"] = mpl.rcParams[\"lines.linewidth\"] * 1.75', '            kws.setdefault(\"s\", 50)', '', '            xs, ys, cis = self.estimate_data', '            if [ci for ci in cis if ci is not None]:', '                for x, ci in zip(xs, cis):', '                    ax.plot([x, x], ci, **ci_kws)', '            ax.scatter(xs, ys, **kws)', '', '    def lineplot(self, ax, kws):', '        \"\"\"Draw the model.\"\"\"', '        # Fit the regression model', '        grid, yhat, err_bands = self.fit_regression(ax)', '        edges = grid[0], grid[-1]', '', '        # Get set default aesthetics', '        fill_color = kws[\"color\"]', '        lw = kws.pop(\"lw\", mpl.rcParams[\"lines.linewidth\"] * 1.5)', '        kws.setdefault(\"linewidth\", lw)', '', '        # Draw the regression line and confidence interval', '        line, = ax.plot(grid, yhat, **kws)', '        if not self.truncate:', '            line.sticky_edges.x[:] = edges  # Prevent mpl from adding margin', '        if err_bands is not None:', '            ax.fill_between(grid, *err_bands, facecolor=fill_color, alpha=.15)', '', '', '_regression_docs = dict(', '', '    model_api=dedent(\"\"\"\\\\', '    There are a number of mutually exclusive options for estimating the', '    regression model. See the :ref:`tutorial <regression_tutorial>` for more', '    information.\\\\', '    \"\"\"),', '    regplot_vs_lmplot=dedent(\"\"\"\\\\', '    The :func:`regplot` and :func:`lmplot` functions are closely related, but', '    the former is an axes-level function while the latter is a figure-level', '    function that combines :func:`regplot` and :class:`FacetGrid`.\\\\', '    \"\"\"),', '    x_estimator=dedent(\"\"\"\\\\', '    x_estimator : callable that maps vector -> scalar, optional', '        Apply this function to each unique value of ``x`` and plot the', '        resulting estimate. This is useful when ``x`` is a discrete variable.', '        If ``x_ci`` is given, this estimate will be bootstrapped and a', '        confidence interval will be drawn.\\\\', '    \"\"\"),', '    x_bins=dedent(\"\"\"\\\\', '    x_bins : int or vector, optional', '        Bin the ``x`` variable into discrete bins and then estimate the central', '        tendency and a confidence interval. This binning only influences how', '        the scatterplot is drawn; the regression is still fit to the original', '        data.  This parameter is interpreted either as the number of', '        evenly-sized (not necessary spaced) bins or the positions of the bin', '        centers. When this parameter is used, it implies that the default of', '        ``x_estimator`` is ``numpy.mean``.\\\\', '    \"\"\"),', '    x_ci=dedent(\"\"\"\\\\', '    x_ci : \"ci\", \"sd\", int in [0, 100] or None, optional', '        Size of the confidence interval used when plotting a central tendency', '        for discrete values of ``x``. If ``\"ci\"``, defer to the value of the', '        ``ci`` parameter. If ``\"sd\"``, skip bootstrapping and show the', '        standard deviation of the observations in each bin.\\\\', '    \"\"\"),', '    scatter=dedent(\"\"\"\\\\', '    scatter : bool, optional', '        If ``True``, draw a scatterplot with the underlying observations (or', '        the ``x_estimator`` values).\\\\', '    \"\"\"),', '    fit_reg=dedent(\"\"\"\\\\', '    fit_reg : bool, optional', '        If ``True``, estimate and plot a regression model relating the ``x``', '        and ``y`` variables.\\\\', '    \"\"\"),', '    ci=dedent(\"\"\"\\\\', '    ci : int in [0, 100] or None, optional', '        Size of the confidence interval for the regression estimate. This will', '        be drawn using translucent bands around the regression line. The', '        confidence interval is estimated using a bootstrap; for large', '        datasets, it may be advisable to avoid that computation by setting', '        this parameter to None.\\\\', '    \"\"\"),', '    n_boot=dedent(\"\"\"\\\\', '    n_boot : int, optional', '        Number of bootstrap resamples used to estimate the ``ci``. The default', '        value attempts to balance time and stability; you may want to increase', '        this value for \"final\" versions of plots.\\\\', '    \"\"\"),', '    units=dedent(\"\"\"\\\\', '    units : variable name in ``data``, optional', '        If the ``x`` and ``y`` observations are nested within sampling units,', '        those can be specified here. This will be taken into account when', '        computing the confidence intervals by performing a multilevel bootstrap', '        that resamples both units and observations (within unit). This does not', '        otherwise influence how the regression is estimated or drawn.\\\\', '    \"\"\"),', '    seed=dedent(\"\"\"\\\\', '    seed : int, numpy.random.Generator, or numpy.random.RandomState, optional', '        Seed or random number generator for reproducible bootstrapping.\\\\', '    \"\"\"),', '    order=dedent(\"\"\"\\\\', '    order : int, optional', '        If ``order`` is greater than 1, use ``numpy.polyfit`` to estimate a', '        polynomial regression.\\\\', '    \"\"\"),', '    logistic=dedent(\"\"\"\\\\', '    logistic : bool, optional', '        If ``True``, assume that ``y`` is a binary variable and use', '        ``statsmodels`` to estimate a logistic regression model. Note that this', '        is substantially more computationally intensive than linear regression,', '        so you may wish to decrease the number of bootstrap resamples', '        (``n_boot``) or set ``ci`` to None.\\\\', '    \"\"\"),', '    lowess=dedent(\"\"\"\\\\', '    lowess : bool, optional', '        If ``True``, use ``statsmodels`` to estimate a nonparametric lowess', '        model (locally weighted linear regression). Note that confidence', '        intervals cannot currently be drawn for this kind of model.\\\\', '    \"\"\"),', '    robust=dedent(\"\"\"\\\\', '    robust : bool, optional', '        If ``True``, use ``statsmodels`` to estimate a robust regression. This', '        will de-weight outliers. Note that this is substantially more', '        computationally intensive than standard linear regression, so you may', '        wish to decrease the number of bootstrap resamples (``n_boot``) or set', '        ``ci`` to None.\\\\', '    \"\"\"),', '    logx=dedent(\"\"\"\\\\', '    logx : bool, optional', '        If ``True``, estimate a linear regression of the form y ~ log(x), but', '        plot the scatterplot and regression model in the input space. Note that', '        ``x`` must be positive for this to work.\\\\', '    \"\"\"),', '    xy_partial=dedent(\"\"\"\\\\', '    {x,y}_partial : strings in ``data`` or matrices', '        Confounding variables to regress out of the ``x`` or ``y`` variables', '        before plotting.\\\\', '    \"\"\"),', '    truncate=dedent(\"\"\"\\\\', '    truncate : bool, optional', '        If ``True``, the regression line is bounded by the data limits. If', '        ``False``, it extends to the ``x`` axis limits.', '    \"\"\"),', '    xy_jitter=dedent(\"\"\"\\\\', '    {x,y}_jitter : floats, optional', '        Add uniform random noise of this size to either the ``x`` or ``y``', '        variables. The noise is added to a copy of the data after fitting the', '        regression, and only influences the look of the scatterplot. This can', '        be helpful when plotting variables that take discrete values.\\\\', '    \"\"\"),', '    scatter_line_kws=dedent(\"\"\"\\\\', '    {scatter,line}_kws : dictionaries', '        Additional keyword arguments to pass to ``plt.scatter`` and', '        ``plt.plot``.\\\\', '    \"\"\"),', ')', '_regression_docs.update(_facet_docs)', '', '', 'def lmplot(', '    data=None, *,', '    x=None, y=None, hue=None, col=None, row=None,', '    palette=None, col_wrap=None, height=5, aspect=1, markers=\"o\",', '    sharex=None, sharey=None, hue_order=None, col_order=None, row_order=None,', '    legend=True, legend_out=None, x_estimator=None, x_bins=None,', '    x_ci=\"ci\", scatter=True, fit_reg=True, ci=95, n_boot=1000,', '    units=None, seed=None, order=1, logistic=False, lowess=False,', '    robust=False, logx=False, x_partial=None, y_partial=None,', '    truncate=True, x_jitter=None, y_jitter=None, scatter_kws=None,', '    line_kws=None, facet_kws=None,', '):', '', '    if facet_kws is None:', '        facet_kws = {}', '', '    def facet_kw_deprecation(key, val):', '        msg = (', '            f\"{key} is deprecated from the `lmplot` function signature. \"', '            \"Please update your code to pass it using `facet_kws`.\"', '        )', '        if val is not None:', '            warnings.warn(msg, UserWarning)', '            facet_kws[key] = val', '', '    facet_kw_deprecation(\"sharex\", sharex)', '    facet_kw_deprecation(\"sharey\", sharey)', '    facet_kw_deprecation(\"legend_out\", legend_out)', '', '    if data is None:', '        raise TypeError(\"Missing required keyword argument `data`.\")', '', '    # Reduce the dataframe to only needed columns', '    need_cols = [x, y, hue, col, row, units, x_partial, y_partial]', '    cols = np.unique([a for a in need_cols if a is not None]).tolist()', '    data = data[cols]', '', '    # Initialize the grid', '    facets = FacetGrid(', '        data, row=row, col=col, hue=hue,', '        palette=palette,', '        row_order=row_order, col_order=col_order, hue_order=hue_order,', '        height=height, aspect=aspect, col_wrap=col_wrap,', '        **facet_kws,', '    )', '', '    # Add the markers here as FacetGrid has figured out how many levels of the', \"    # hue variable are needed and we don't want to duplicate that process\", '    if facets.hue_names is None:', '        n_markers = 1', '    else:', '        n_markers = len(facets.hue_names)', '    if not isinstance(markers, list):', '        markers = [markers] * n_markers', '    if len(markers) != n_markers:', '        raise ValueError(\"markers must be a singleton or a list of markers \"', '                         \"for each level of the hue variable\")', '    facets.hue_kws = {\"marker\": markers}', '', '    def update_datalim(data, x, y, ax, **kws):', '        xys = data[[x, y]].to_numpy().astype(float)', '        ax.update_datalim(xys, updatey=False)', '        ax.autoscale_view(scaley=False)', '', '    facets.map_dataframe(update_datalim, x=x, y=y)', '', '    # Draw the regression plot on each facet', '    regplot_kws = dict(', '        x_estimator=x_estimator, x_bins=x_bins, x_ci=x_ci,', '        scatter=scatter, fit_reg=fit_reg, ci=ci, n_boot=n_boot, units=units,', '        seed=seed, order=order, logistic=logistic, lowess=lowess,', '        robust=robust, logx=logx, x_partial=x_partial, y_partial=y_partial,', '        truncate=truncate, x_jitter=x_jitter, y_jitter=y_jitter,', '        scatter_kws=scatter_kws, line_kws=line_kws,', '    )', '    facets.map_dataframe(regplot, x=x, y=y, **regplot_kws)', '    facets.set_axis_labels(x, y)', '', '    # Add a legend', '    if legend and (hue is not None) and (hue not in [col, row]):', '        facets.add_legend()', '    return facets', '', '', 'lmplot.__doc__ = dedent(\"\"\"\\\\', '    Plot data and regression model fits across a FacetGrid.', '', '    This function combines :func:`regplot` and :class:`FacetGrid`. It is', '    intended as a convenient interface to fit regression models across', '    conditional subsets of a dataset.', '', '    When thinking about how to assign variables to different facets, a general', '    rule is that it makes sense to use ``hue`` for the most important', '    comparison, followed by ``col`` and ``row``. However, always think about', '    your particular dataset and the goals of the visualization you are', '    creating.', '', '    {model_api}', '', '    The parameters to this function span most of the options in', '    :class:`FacetGrid`, although there may be occasional cases where you will', '    want to use that class and :func:`regplot` directly.', '', '    Parameters', '    ----------', '    {data}', '    x, y : strings, optional', '        Input variables; these should be column names in ``data``.', '    hue, col, row : strings', '        Variables that define subsets of the data, which will be drawn on', '        separate facets in the grid. See the ``*_order`` parameters to control', '        the order of levels of this variable.', '    {palette}', '    {col_wrap}', '    {height}', '    {aspect}', '    markers : matplotlib marker code or list of marker codes, optional', '        Markers for the scatterplot. If a list, each marker in the list will be', '        used for each level of the ``hue`` variable.', '    {share_xy}', '', '        .. deprecated:: 0.12.0', '            Pass using the `facet_kws` dictionary.', '', '    {{hue,col,row}}_order : lists, optional', '        Order for the levels of the faceting variables. By default, this will', '        be the order that the levels appear in ``data`` or, if the variables', '        are pandas categoricals, the category order.', '    legend : bool, optional', '        If ``True`` and there is a ``hue`` variable, add a legend.', '    {legend_out}', '', '        .. deprecated:: 0.12.0', '            Pass using the `facet_kws` dictionary.', '', '    {x_estimator}', '    {x_bins}', '    {x_ci}', '    {scatter}', '    {fit_reg}', '    {ci}', '    {n_boot}', '    {units}', '    {seed}', '    {order}', '    {logistic}', '    {lowess}', '    {robust}', '    {logx}', '    {xy_partial}', '    {truncate}', '    {xy_jitter}', '    {scatter_line_kws}', '    facet_kws : dict', '        Dictionary of keyword arguments for :class:`FacetGrid`.', '', '    See Also', '    --------', '    regplot : Plot data and a conditional model fit.', '    FacetGrid : Subplot grid for plotting conditional relationships.', '    pairplot : Combine :func:`regplot` and :class:`PairGrid` (when used with', '               ``kind=\"reg\"``).', '', '    Notes', '    -----', '', '    {regplot_vs_lmplot}', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/lmplot.rst', '', '    \"\"\").format(**_regression_docs)', '', '', 'def regplot(', '    data=None, *, x=None, y=None,', '    x_estimator=None, x_bins=None, x_ci=\"ci\",', '    scatter=True, fit_reg=True, ci=95, n_boot=1000, units=None,', '    seed=None, order=1, logistic=False, lowess=False, robust=False,', '    logx=False, x_partial=None, y_partial=None,', '    truncate=True, dropna=True, x_jitter=None, y_jitter=None,', '    label=None, color=None, marker=\"o\",', '    scatter_kws=None, line_kws=None, ax=None', '):', '', '    plotter = _RegressionPlotter(x, y, data, x_estimator, x_bins, x_ci,', '                                 scatter, fit_reg, ci, n_boot, units, seed,', '                                 order, logistic, lowess, robust, logx,', '                                 x_partial, y_partial, truncate, dropna,', '                                 x_jitter, y_jitter, color, label)', '', '    if ax is None:', '        ax = plt.gca()', '', '    scatter_kws = {} if scatter_kws is None else copy.copy(scatter_kws)', '    scatter_kws[\"marker\"] = marker', '    line_kws = {} if line_kws is None else copy.copy(line_kws)', '    plotter.plot(ax, scatter_kws, line_kws)', '    return ax', '', '', 'regplot.__doc__ = dedent(\"\"\"\\\\', '    Plot data and a linear regression model fit.', '', '    {model_api}', '', '    Parameters', '    ----------', '    x, y: string, series, or vector array', '        Input variables. If strings, these should correspond with column names', '        in ``data``. When pandas objects are used, axes will be labeled with', '        the series name.', '    {data}', '    {x_estimator}', '    {x_bins}', '    {x_ci}', '    {scatter}', '    {fit_reg}', '    {ci}', '    {n_boot}', '    {units}', '    {seed}', '    {order}', '    {logistic}', '    {lowess}', '    {robust}', '    {logx}', '    {xy_partial}', '    {truncate}', '    {xy_jitter}', '    label : string', '        Label to apply to either the scatterplot or regression line (if', '        ``scatter`` is ``False``) for use in a legend.', '    color : matplotlib color', '        Color to apply to all plot elements; will be superseded by colors', '        passed in ``scatter_kws`` or ``line_kws``.', '    marker : matplotlib marker code', '        Marker to use for the scatterplot glyphs.', '    {scatter_line_kws}', '    ax : matplotlib Axes, optional', '        Axes object to draw the plot onto, otherwise uses the current Axes.', '', '    Returns', '    -------', '    ax : matplotlib Axes', '        The Axes object containing the plot.', '', '    See Also', '    --------', '    lmplot : Combine :func:`regplot` and :class:`FacetGrid` to plot multiple', '             linear relationships in a dataset.', '    jointplot : Combine :func:`regplot` and :class:`JointGrid` (when used with', '                ``kind=\"reg\"``).', '    pairplot : Combine :func:`regplot` and :class:`PairGrid` (when used with', '               ``kind=\"reg\"``).', '    residplot : Plot the residuals of a linear regression model.', '', '    Notes', '    -----', '', '    {regplot_vs_lmplot}', '', '', \"    It's also easy to combine :func:`regplot` and :class:`JointGrid` or\", '    :class:`PairGrid` through the :func:`jointplot` and :func:`pairplot`', \"    functions, although these do not directly accept all of :func:`regplot`'s\", '    parameters.', '', '    Examples', '    --------', '', '    .. include: ../docstrings/regplot.rst', '', '    \"\"\").format(**_regression_docs)', '', '', 'def residplot(', '    data=None, *, x=None, y=None,', '    x_partial=None, y_partial=None, lowess=False,', '    order=1, robust=False, dropna=True, label=None, color=None,', '    scatter_kws=None, line_kws=None, ax=None', '):', '    \"\"\"Plot the residuals of a linear regression.', '', '    This function will regress y on x (possibly as a robust or polynomial', '    regression) and then draw a scatterplot of the residuals. You can', '    optionally fit a lowess smoother to the residual plot, which can', '    help in determining if there is structure to the residuals.', '', '    Parameters', '    ----------', '    data : DataFrame, optional', '        DataFrame to use if `x` and `y` are column names.', '    x : vector or string', '        Data or column name in `data` for the predictor variable.', '    y : vector or string', '        Data or column name in `data` for the response variable.', '    {x, y}_partial : vectors or string(s) , optional', '        These variables are treated as confounding and are removed from', '        the `x` or `y` variables before plotting.', '    lowess : boolean, optional', '        Fit a lowess smoother to the residual scatterplot.', '    order : int, optional', '        Order of the polynomial to fit when calculating the residuals.', '    robust : boolean, optional', '        Fit a robust linear regression when calculating the residuals.', '    dropna : boolean, optional', '        If True, ignore observations with missing data when fitting and', '        plotting.', '    label : string, optional', '        Label that will be used in any plot legends.', '    color : matplotlib color, optional', '        Color to use for all elements of the plot.', '    {scatter, line}_kws : dictionaries, optional', '        Additional keyword arguments passed to scatter() and plot() for drawing', '        the components of the plot.', '    ax : matplotlib axis, optional', '        Plot into this axis, otherwise grab the current axis or make a new', '        one if not existing.', '', '    Returns', '    -------', '    ax: matplotlib axes', '        Axes with the regression plot.', '', '    See Also', '    --------', '    regplot : Plot a simple linear regression model.', '    jointplot : Draw a :func:`residplot` with univariate marginal distributions', '                (when used with ``kind=\"resid\"``).', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/residplot.rst', '', '    \"\"\"', '    plotter = _RegressionPlotter(x, y, data, ci=None,', '                                 order=order, robust=robust,', '                                 x_partial=x_partial, y_partial=y_partial,', '                                 dropna=dropna, color=color, label=label)', '', '    if ax is None:', '        ax = plt.gca()', '', '    # Calculate the residual from a linear regression', '    _, yhat, _ = plotter.fit_regression(grid=plotter.x)', '    plotter.y = plotter.y - yhat', '', '    # Set the regression option on the plotter', '    if lowess:', '        plotter.lowess = True', '    else:', '        plotter.fit_reg = False', '', '    # Plot a horizontal line at 0', '    ax.axhline(0, ls=\":\", c=\".2\")', '', '    # Draw the scatterplot', '    scatter_kws = {} if scatter_kws is None else scatter_kws.copy()', '    line_kws = {} if line_kws is None else line_kws.copy()', '    plotter.plot(ax, scatter_kws, line_kws)', '    return ax']}, 'axisgrid.py': {'classes': [{'name': '_BaseGrid', 'start_line': 32, 'end_line': 95, 'text': ['class _BaseGrid:', '    \"\"\"Base class for grids of subplots.\"\"\"', '', '    def set(self, **kwargs):', '        \"\"\"Set attributes on each subplot Axes.\"\"\"', '        for ax in self.axes.flat:', '            if ax is not None:  # Handle removed axes', '                ax.set(**kwargs)', '        return self', '', '    @property', '    def fig(self):', '        \"\"\"DEPRECATED: prefer the `figure` property.\"\"\"', '        # Grid.figure is preferred because it matches the Axes attribute name.', '        # But as the maintanace burden on having this property is minimal,', \"        # let's be slow about formally deprecating it. For now just note its deprecation\", '        # in the docstring; add a warning in version 0.13, and eventually remove it.', '        return self._figure', '', '    @property', '    def figure(self):', '        \"\"\"Access the :class:`matplotlib.figure.Figure` object underlying the grid.\"\"\"', '        return self._figure', '', '    def apply(self, func, *args, **kwargs):', '        \"\"\"', '        Pass the grid to a user-supplied function and return self.', '', '        The `func` must accept an object of this type for its first', '        positional argument. Additional arguments are passed through.', '        The return value of `func` is ignored; this method returns self.', '        See the `pipe` method if you want the return value.', '', '        Added in v0.12.0.', '', '        \"\"\"', '        func(self, *args, **kwargs)', '        return self', '', '    def pipe(self, func, *args, **kwargs):', '        \"\"\"', '        Pass the grid to a user-supplied function and return its value.', '', '        The `func` must accept an object of this type for its first', '        positional argument. Additional arguments are passed through.', '        The return value of `func` becomes the return value of this method.', '        See the `apply` method if you want to return self instead.', '', '        Added in v0.12.0.', '', '        \"\"\"', '        return func(self, *args, **kwargs)', '', '    def savefig(self, *args, **kwargs):', '        \"\"\"', '        Save an image of the plot.', '', '        This wraps :meth:`matplotlib.figure.Figure.savefig`, using bbox_inches=\"tight\"', '        by default. Parameters are passed through to the matplotlib function.', '', '        \"\"\"', '        kwargs = kwargs.copy()', '        kwargs.setdefault(\"bbox_inches\", \"tight\")', '        self.figure.savefig(*args, **kwargs)'], 'methods': [{'name': 'set', 'start_line': 35, 'end_line': 40, 'text': ['    def set(self, **kwargs):', '        \"\"\"Set attributes on each subplot Axes.\"\"\"', '        for ax in self.axes.flat:', '            if ax is not None:  # Handle removed axes', '                ax.set(**kwargs)', '        return self']}, {'name': 'fig', 'start_line': 43, 'end_line': 49, 'text': ['    def fig(self):', '        \"\"\"DEPRECATED: prefer the `figure` property.\"\"\"', '        # Grid.figure is preferred because it matches the Axes attribute name.', '        # But as the maintanace burden on having this property is minimal,', \"        # let's be slow about formally deprecating it. For now just note its deprecation\", '        # in the docstring; add a warning in version 0.13, and eventually remove it.', '        return self._figure']}, {'name': 'figure', 'start_line': 52, 'end_line': 54, 'text': ['    def figure(self):', '        \"\"\"Access the :class:`matplotlib.figure.Figure` object underlying the grid.\"\"\"', '        return self._figure']}, {'name': 'apply', 'start_line': 56, 'end_line': 69, 'text': ['    def apply(self, func, *args, **kwargs):', '        \"\"\"', '        Pass the grid to a user-supplied function and return self.', '', '        The `func` must accept an object of this type for its first', '        positional argument. Additional arguments are passed through.', '        The return value of `func` is ignored; this method returns self.', '        See the `pipe` method if you want the return value.', '', '        Added in v0.12.0.', '', '        \"\"\"', '        func(self, *args, **kwargs)', '        return self']}, {'name': 'pipe', 'start_line': 71, 'end_line': 83, 'text': ['    def pipe(self, func, *args, **kwargs):', '        \"\"\"', '        Pass the grid to a user-supplied function and return its value.', '', '        The `func` must accept an object of this type for its first', '        positional argument. Additional arguments are passed through.', '        The return value of `func` becomes the return value of this method.', '        See the `apply` method if you want to return self instead.', '', '        Added in v0.12.0.', '', '        \"\"\"', '        return func(self, *args, **kwargs)']}, {'name': 'savefig', 'start_line': 85, 'end_line': 95, 'text': ['    def savefig(self, *args, **kwargs):', '        \"\"\"', '        Save an image of the plot.', '', '        This wraps :meth:`matplotlib.figure.Figure.savefig`, using bbox_inches=\"tight\"', '        by default. Parameters are passed through to the matplotlib function.', '', '        \"\"\"', '        kwargs = kwargs.copy()', '        kwargs.setdefault(\"bbox_inches\", \"tight\")', '        self.figure.savefig(*args, **kwargs)']}]}, {'name': 'Grid', 'start_line': 98, 'end_line': 301, 'text': ['class Grid(_BaseGrid):', '    \"\"\"A grid that can have multiple subplots and an external legend.\"\"\"', '    _margin_titles = False', '    _legend_out = True', '', '    def __init__(self):', '', '        self._tight_layout_rect = [0, 0, 1, 1]', '        self._tight_layout_pad = None', '', '        # This attribute is set externally and is a hack to handle newer functions that', \"        # don't add proxy artists onto the Axes. We need an overall cleaner approach.\", '        self._extract_legend_handles = False', '', '    def tight_layout(self, *args, **kwargs):', '        \"\"\"Call fig.tight_layout within rect that exclude the legend.\"\"\"', '        kwargs = kwargs.copy()', '        kwargs.setdefault(\"rect\", self._tight_layout_rect)', '        if self._tight_layout_pad is not None:', '            kwargs.setdefault(\"pad\", self._tight_layout_pad)', '        self._figure.tight_layout(*args, **kwargs)', '        return self', '', '    def add_legend(self, legend_data=None, title=None, label_order=None,', '                   adjust_subtitles=False, **kwargs):', '        \"\"\"Draw a legend, maybe placing it outside axes and resizing the figure.', '', '        Parameters', '        ----------', '        legend_data : dict', '            Dictionary mapping label names (or two-element tuples where the', '            second element is a label name) to matplotlib artist handles. The', '            default reads from ``self._legend_data``.', '        title : string', '            Title for the legend. The default reads from ``self._hue_var``.', '        label_order : list of labels', '            The order that the legend entries should appear in. The default', '            reads from ``self.hue_names``.', '        adjust_subtitles : bool', '            If True, modify entries with invisible artists to left-align', '            the labels and set the font size to that of a title.', '        kwargs : key, value pairings', '            Other keyword arguments are passed to the underlying legend methods', '            on the Figure or Axes object.', '', '        Returns', '        -------', '        self : Grid instance', '            Returns self for easy chaining.', '', '        \"\"\"', '        # Find the data for the legend', '        if legend_data is None:', '            legend_data = self._legend_data', '        if label_order is None:', '            if self.hue_names is None:', '                label_order = list(legend_data.keys())', '            else:', '                label_order = list(map(utils.to_utf8, self.hue_names))', '', '        blank_handle = mpl.patches.Patch(alpha=0, linewidth=0)', '        handles = [legend_data.get(l, blank_handle) for l in label_order]', '        title = self._hue_var if title is None else title', '        title_size = mpl.rcParams[\"legend.title_fontsize\"]', '', '        # Unpack nested labels from a hierarchical legend', '        labels = []', '        for entry in label_order:', '            if isinstance(entry, tuple):', '                _, label = entry', '            else:', '                label = entry', '            labels.append(label)', '', '        # Set default legend kwargs', '        kwargs.setdefault(\"scatterpoints\", 1)', '', '        if self._legend_out:', '', '            kwargs.setdefault(\"frameon\", False)', '            kwargs.setdefault(\"loc\", \"center right\")', '', '            # Draw a full-figure legend outside the grid', '            figlegend = self._figure.legend(handles, labels, **kwargs)', '', '            self._legend = figlegend', '            figlegend.set_title(title, prop={\"size\": title_size})', '', '            if adjust_subtitles:', '                adjust_legend_subtitles(figlegend)', '', '            # Draw the plot to set the bounding boxes correctly', '            _draw_figure(self._figure)', '', '            # Calculate and set the new width of the figure so the legend fits', '            legend_width = figlegend.get_window_extent().width / self._figure.dpi', '            fig_width, fig_height = self._figure.get_size_inches()', '            self._figure.set_size_inches(fig_width + legend_width, fig_height)', '', '            # Draw the plot again to get the new transformations', '            _draw_figure(self._figure)', '', '            # Now calculate how much space we need on the right side', '            legend_width = figlegend.get_window_extent().width / self._figure.dpi', '            space_needed = legend_width / (fig_width + legend_width)', '            margin = .04 if self._margin_titles else .01', '            self._space_needed = margin + space_needed', '            right = 1 - self._space_needed', '', '            # Place the subplot axes to give space for the legend', '            self._figure.subplots_adjust(right=right)', '            self._tight_layout_rect[2] = right', '', '        else:', '            # Draw a legend in the first axis', '            ax = self.axes.flat[0]', '            kwargs.setdefault(\"loc\", \"best\")', '', '            leg = ax.legend(handles, labels, **kwargs)', '            leg.set_title(title, prop={\"size\": title_size})', '            self._legend = leg', '', '            if adjust_subtitles:', '                adjust_legend_subtitles(leg)', '', '        return self', '', '    def _update_legend_data(self, ax):', '        \"\"\"Extract the legend data from an axes object and save it.\"\"\"', '        data = {}', '', '        # Get data directly from the legend, which is necessary', \"        # for newer functions that don't add labeled proxy artists\", '        if ax.legend_ is not None and self._extract_legend_handles:', '            handles = ax.legend_.legendHandles', '            labels = [t.get_text() for t in ax.legend_.texts]', '            data.update({l: h for h, l in zip(handles, labels)})', '', '        handles, labels = ax.get_legend_handles_labels()', '        data.update({l: h for h, l in zip(handles, labels)})', '', '        self._legend_data.update(data)', '', '        # Now clear the legend', '        ax.legend_ = None', '', '    def _get_palette(self, data, hue, hue_order, palette):', '        \"\"\"Get a list of colors for the hue variable.\"\"\"', '        if hue is None:', '            palette = color_palette(n_colors=1)', '', '        else:', '            hue_names = categorical_order(data[hue], hue_order)', '            n_colors = len(hue_names)', '', '            # By default use either the current color palette or HUSL', '            if palette is None:', '                current_palette = utils.get_color_cycle()', '                if n_colors > len(current_palette):', '                    colors = color_palette(\"husl\", n_colors)', '                else:', '                    colors = color_palette(n_colors=n_colors)', '', '            # Allow for palette to map from hue variable names', '            elif isinstance(palette, dict):', '                color_names = [palette[h] for h in hue_names]', '                colors = color_palette(color_names, n_colors)', '', '            # Otherwise act as if we just got a list of colors', '            else:', '                colors = color_palette(palette, n_colors)', '', '            palette = color_palette(colors, n_colors)', '', '        return palette', '', '    @property', '    def legend(self):', '        \"\"\"The :class:`matplotlib.legend.Legend` object, if present.\"\"\"', '        try:', '            return self._legend', '        except AttributeError:', '            return None', '', \"    def tick_params(self, axis='both', **kwargs):\", '        \"\"\"Modify the ticks, tick labels, and gridlines.', '', '        Parameters', '        ----------', \"        axis : {'x', 'y', 'both'}\", '            The axis on which to apply the formatting.', '        kwargs : keyword arguments', '            Additional keyword arguments to pass to', '            :meth:`matplotlib.axes.Axes.tick_params`.', '', '        Returns', '        -------', '        self : Grid instance', '            Returns self for easy chaining.', '', '        \"\"\"', '        for ax in self.figure.axes:', '            ax.tick_params(axis=axis, **kwargs)', '        return self'], 'methods': [{'name': '__init__', 'start_line': 103, 'end_line': 110, 'text': ['    def __init__(self):', '', '        self._tight_layout_rect = [0, 0, 1, 1]', '        self._tight_layout_pad = None', '', '        # This attribute is set externally and is a hack to handle newer functions that', \"        # don't add proxy artists onto the Axes. We need an overall cleaner approach.\", '        self._extract_legend_handles = False']}, {'name': 'tight_layout', 'start_line': 112, 'end_line': 119, 'text': ['    def tight_layout(self, *args, **kwargs):', '        \"\"\"Call fig.tight_layout within rect that exclude the legend.\"\"\"', '        kwargs = kwargs.copy()', '        kwargs.setdefault(\"rect\", self._tight_layout_rect)', '        if self._tight_layout_pad is not None:', '            kwargs.setdefault(\"pad\", self._tight_layout_pad)', '        self._figure.tight_layout(*args, **kwargs)', '        return self']}, {'name': 'add_legend', 'start_line': 121, 'end_line': 223, 'text': ['    def add_legend(self, legend_data=None, title=None, label_order=None,', '                   adjust_subtitles=False, **kwargs):', '        \"\"\"Draw a legend, maybe placing it outside axes and resizing the figure.', '', '        Parameters', '        ----------', '        legend_data : dict', '            Dictionary mapping label names (or two-element tuples where the', '            second element is a label name) to matplotlib artist handles. The', '            default reads from ``self._legend_data``.', '        title : string', '            Title for the legend. The default reads from ``self._hue_var``.', '        label_order : list of labels', '            The order that the legend entries should appear in. The default', '            reads from ``self.hue_names``.', '        adjust_subtitles : bool', '            If True, modify entries with invisible artists to left-align', '            the labels and set the font size to that of a title.', '        kwargs : key, value pairings', '            Other keyword arguments are passed to the underlying legend methods', '            on the Figure or Axes object.', '', '        Returns', '        -------', '        self : Grid instance', '            Returns self for easy chaining.', '', '        \"\"\"', '        # Find the data for the legend', '        if legend_data is None:', '            legend_data = self._legend_data', '        if label_order is None:', '            if self.hue_names is None:', '                label_order = list(legend_data.keys())', '            else:', '                label_order = list(map(utils.to_utf8, self.hue_names))', '', '        blank_handle = mpl.patches.Patch(alpha=0, linewidth=0)', '        handles = [legend_data.get(l, blank_handle) for l in label_order]', '        title = self._hue_var if title is None else title', '        title_size = mpl.rcParams[\"legend.title_fontsize\"]', '', '        # Unpack nested labels from a hierarchical legend', '        labels = []', '        for entry in label_order:', '            if isinstance(entry, tuple):', '                _, label = entry', '            else:', '                label = entry', '            labels.append(label)', '', '        # Set default legend kwargs', '        kwargs.setdefault(\"scatterpoints\", 1)', '', '        if self._legend_out:', '', '            kwargs.setdefault(\"frameon\", False)', '            kwargs.setdefault(\"loc\", \"center right\")', '', '            # Draw a full-figure legend outside the grid', '            figlegend = self._figure.legend(handles, labels, **kwargs)', '', '            self._legend = figlegend', '            figlegend.set_title(title, prop={\"size\": title_size})', '', '            if adjust_subtitles:', '                adjust_legend_subtitles(figlegend)', '', '            # Draw the plot to set the bounding boxes correctly', '            _draw_figure(self._figure)', '', '            # Calculate and set the new width of the figure so the legend fits', '            legend_width = figlegend.get_window_extent().width / self._figure.dpi', '            fig_width, fig_height = self._figure.get_size_inches()', '            self._figure.set_size_inches(fig_width + legend_width, fig_height)', '', '            # Draw the plot again to get the new transformations', '            _draw_figure(self._figure)', '', '            # Now calculate how much space we need on the right side', '            legend_width = figlegend.get_window_extent().width / self._figure.dpi', '            space_needed = legend_width / (fig_width + legend_width)', '            margin = .04 if self._margin_titles else .01', '            self._space_needed = margin + space_needed', '            right = 1 - self._space_needed', '', '            # Place the subplot axes to give space for the legend', '            self._figure.subplots_adjust(right=right)', '            self._tight_layout_rect[2] = right', '', '        else:', '            # Draw a legend in the first axis', '            ax = self.axes.flat[0]', '            kwargs.setdefault(\"loc\", \"best\")', '', '            leg = ax.legend(handles, labels, **kwargs)', '            leg.set_title(title, prop={\"size\": title_size})', '            self._legend = leg', '', '            if adjust_subtitles:', '                adjust_legend_subtitles(leg)', '', '        return self']}, {'name': '_update_legend_data', 'start_line': 225, 'end_line': 242, 'text': ['    def _update_legend_data(self, ax):', '        \"\"\"Extract the legend data from an axes object and save it.\"\"\"', '        data = {}', '', '        # Get data directly from the legend, which is necessary', \"        # for newer functions that don't add labeled proxy artists\", '        if ax.legend_ is not None and self._extract_legend_handles:', '            handles = ax.legend_.legendHandles', '            labels = [t.get_text() for t in ax.legend_.texts]', '            data.update({l: h for h, l in zip(handles, labels)})', '', '        handles, labels = ax.get_legend_handles_labels()', '        data.update({l: h for h, l in zip(handles, labels)})', '', '        self._legend_data.update(data)', '', '        # Now clear the legend', '        ax.legend_ = None']}, {'name': '_get_palette', 'start_line': 244, 'end_line': 272, 'text': ['    def _get_palette(self, data, hue, hue_order, palette):', '        \"\"\"Get a list of colors for the hue variable.\"\"\"', '        if hue is None:', '            palette = color_palette(n_colors=1)', '', '        else:', '            hue_names = categorical_order(data[hue], hue_order)', '            n_colors = len(hue_names)', '', '            # By default use either the current color palette or HUSL', '            if palette is None:', '                current_palette = utils.get_color_cycle()', '                if n_colors > len(current_palette):', '                    colors = color_palette(\"husl\", n_colors)', '                else:', '                    colors = color_palette(n_colors=n_colors)', '', '            # Allow for palette to map from hue variable names', '            elif isinstance(palette, dict):', '                color_names = [palette[h] for h in hue_names]', '                colors = color_palette(color_names, n_colors)', '', '            # Otherwise act as if we just got a list of colors', '            else:', '                colors = color_palette(palette, n_colors)', '', '            palette = color_palette(colors, n_colors)', '', '        return palette']}, {'name': 'legend', 'start_line': 275, 'end_line': 280, 'text': ['    def legend(self):', '        \"\"\"The :class:`matplotlib.legend.Legend` object, if present.\"\"\"', '        try:', '            return self._legend', '        except AttributeError:', '            return None']}, {'name': 'tick_params', 'start_line': 282, 'end_line': 301, 'text': [\"    def tick_params(self, axis='both', **kwargs):\", '        \"\"\"Modify the ticks, tick labels, and gridlines.', '', '        Parameters', '        ----------', \"        axis : {'x', 'y', 'both'}\", '            The axis on which to apply the formatting.', '        kwargs : keyword arguments', '            Additional keyword arguments to pass to', '            :meth:`matplotlib.axes.Axes.tick_params`.', '', '        Returns', '        -------', '        self : Grid instance', '            Returns self for easy chaining.', '', '        \"\"\"', '        for ax in self.figure.axes:', '            ax.tick_params(axis=axis, **kwargs)', '        return self']}]}, {'name': 'FacetGrid', 'start_line': 363, 'end_line': 1169, 'text': ['class FacetGrid(Grid):', '    \"\"\"Multi-plot grid for plotting conditional relationships.\"\"\"', '', '    def __init__(', '        self, data, *,', '        row=None, col=None, hue=None, col_wrap=None,', '        sharex=True, sharey=True, height=3, aspect=1, palette=None,', '        row_order=None, col_order=None, hue_order=None, hue_kws=None,', '        dropna=False, legend_out=True, despine=True,', '        margin_titles=False, xlim=None, ylim=None, subplot_kws=None,', '        gridspec_kws=None,', '    ):', '', '        super().__init__()', '', '        # Determine the hue facet layer information', '        hue_var = hue', '        if hue is None:', '            hue_names = None', '        else:', '            hue_names = categorical_order(data[hue], hue_order)', '', '        colors = self._get_palette(data, hue, hue_order, palette)', '', '        # Set up the lists of names for the row and column facet variables', '        if row is None:', '            row_names = []', '        else:', '            row_names = categorical_order(data[row], row_order)', '', '        if col is None:', '            col_names = []', '        else:', '            col_names = categorical_order(data[col], col_order)', '', '        # Additional dict of kwarg -> list of values for mapping the hue var', '        hue_kws = hue_kws if hue_kws is not None else {}', '', '        # Make a boolean mask that is True anywhere there is an NA', '        # value in one of the faceting variables, but only if dropna is True', '        none_na = np.zeros(len(data), bool)', '        if dropna:', '            row_na = none_na if row is None else data[row].isnull()', '            col_na = none_na if col is None else data[col].isnull()', '            hue_na = none_na if hue is None else data[hue].isnull()', '            not_na = ~(row_na | col_na | hue_na)', '        else:', '            not_na = ~none_na', '', '        # Compute the grid shape', '        ncol = 1 if col is None else len(col_names)', '        nrow = 1 if row is None else len(row_names)', '        self._n_facets = ncol * nrow', '', '        self._col_wrap = col_wrap', '        if col_wrap is not None:', '            if row is not None:', '                err = \"Cannot use `row` and `col_wrap` together.\"', '                raise ValueError(err)', '            ncol = col_wrap', '            nrow = int(np.ceil(len(col_names) / col_wrap))', '        self._ncol = ncol', '        self._nrow = nrow', '', '        # Calculate the base figure size', '        # This can get stretched later by a legend', \"        # TODO this doesn't account for axis labels\", '        figsize = (ncol * height * aspect, nrow * height)', '', '        # Validate some inputs', '        if col_wrap is not None:', '            margin_titles = False', '', '        # Build the subplot keyword dictionary', '        subplot_kws = {} if subplot_kws is None else subplot_kws.copy()', '        gridspec_kws = {} if gridspec_kws is None else gridspec_kws.copy()', '        if xlim is not None:', '            subplot_kws[\"xlim\"] = xlim', '        if ylim is not None:', '            subplot_kws[\"ylim\"] = ylim', '', '        # --- Initialize the subplot grid', '', '        with _disable_autolayout():', '            fig = plt.figure(figsize=figsize)', '', '        if col_wrap is None:', '', '            kwargs = dict(squeeze=False,', '                          sharex=sharex, sharey=sharey,', '                          subplot_kw=subplot_kws,', '                          gridspec_kw=gridspec_kws)', '', '            axes = fig.subplots(nrow, ncol, **kwargs)', '', '            if col is None and row is None:', '                axes_dict = {}', '            elif col is None:', '                axes_dict = dict(zip(row_names, axes.flat))', '            elif row is None:', '                axes_dict = dict(zip(col_names, axes.flat))', '            else:', '                facet_product = product(row_names, col_names)', '                axes_dict = dict(zip(facet_product, axes.flat))', '', '        else:', '', '            # If wrapping the col variable we need to make the grid ourselves', '            if gridspec_kws:', '                warnings.warn(\"`gridspec_kws` ignored when using `col_wrap`\")', '', '            n_axes = len(col_names)', '            axes = np.empty(n_axes, object)', '            axes[0] = fig.add_subplot(nrow, ncol, 1, **subplot_kws)', '            if sharex:', '                subplot_kws[\"sharex\"] = axes[0]', '            if sharey:', '                subplot_kws[\"sharey\"] = axes[0]', '            for i in range(1, n_axes):', '                axes[i] = fig.add_subplot(nrow, ncol, i + 1, **subplot_kws)', '', '            axes_dict = dict(zip(col_names, axes))', '', '        # --- Set up the class attributes', '', '        # Attributes that are part of the public API but accessed through', '        # a  property so that Sphinx adds them to the auto class doc', '        self._figure = fig', '        self._axes = axes', '        self._axes_dict = axes_dict', '        self._legend = None', '', \"        # Public attributes that aren't explicitly documented\", \"        # (It's not obvious that having them be public was a good idea)\", '        self.data = data', '        self.row_names = row_names', '        self.col_names = col_names', '        self.hue_names = hue_names', '        self.hue_kws = hue_kws', '', '        # Next the private variables', '        self._nrow = nrow', '        self._row_var = row', '        self._ncol = ncol', '        self._col_var = col', '', '        self._margin_titles = margin_titles', '        self._margin_titles_texts = []', '        self._col_wrap = col_wrap', '        self._hue_var = hue_var', '        self._colors = colors', '        self._legend_out = legend_out', '        self._legend_data = {}', '        self._x_var = None', '        self._y_var = None', '        self._sharex = sharex', '        self._sharey = sharey', '        self._dropna = dropna', '        self._not_na = not_na', '', '        # --- Make the axes look good', '', '        self.set_titles()', '        self.tight_layout()', '', '        if despine:', '            self.despine()', '', \"        if sharex in [True, 'col']:\", '            for ax in self._not_bottom_axes:', '                for label in ax.get_xticklabels():', '                    label.set_visible(False)', '                ax.xaxis.offsetText.set_visible(False)', '                ax.xaxis.label.set_visible(False)', '', \"        if sharey in [True, 'row']:\", '            for ax in self._not_left_axes:', '                for label in ax.get_yticklabels():', '                    label.set_visible(False)', '                ax.yaxis.offsetText.set_visible(False)', '                ax.yaxis.label.set_visible(False)', '', '    __init__.__doc__ = dedent(\"\"\"\\\\', '        Initialize the matplotlib figure and FacetGrid object.', '', '        This class maps a dataset onto multiple axes arrayed in a grid of rows', '        and columns that correspond to *levels* of variables in the dataset.', '        The plots it produces are often called \"lattice\", \"trellis\", or', '        \"small-multiple\" graphics.', '', '        It can also represent levels of a third variable with the ``hue``', '        parameter, which plots different subsets of data in different colors.', '        This uses color to resolve elements on a third dimension, but only', '        draws subsets on top of each other and will not tailor the ``hue``', '        parameter for the specific visualization the way that axes-level', '        functions that accept ``hue`` will.', '', '        The basic workflow is to initialize the :class:`FacetGrid` object with', '        the dataset and the variables that are used to structure the grid. Then', '        one or more plotting functions can be applied to each subset by calling', '        :meth:`FacetGrid.map` or :meth:`FacetGrid.map_dataframe`. Finally, the', '        plot can be tweaked with other methods to do things like change the', '        axis labels, use different ticks, or add a legend. See the detailed', '        code examples below for more information.', '', '        .. warning::', '', '            When using seaborn functions that infer semantic mappings from a', '            dataset, care must be taken to synchronize those mappings across', '            facets (e.g., by defining the ``hue`` mapping with a palette dict or', '            setting the data type of the variables to ``category``). In most cases,', '            it will be better to use a figure-level function (e.g. :func:`relplot`', '            or :func:`catplot`) than to use :class:`FacetGrid` directly.', '', '        See the :ref:`tutorial <grid_tutorial>` for more information.', '', '        Parameters', '        ----------', '        {data}', '        row, col, hue : strings', '            Variables that define subsets of the data, which will be drawn on', '            separate facets in the grid. See the ``{{var}}_order`` parameters to', '            control the order of levels of this variable.', '        {col_wrap}', '        {share_xy}', '        {height}', '        {aspect}', '        {palette}', '        {{row,col,hue}}_order : lists', '            Order for the levels of the faceting variables. By default, this', '            will be the order that the levels appear in ``data`` or, if the', '            variables are pandas categoricals, the category order.', '        hue_kws : dictionary of param -> list of values mapping', '            Other keyword arguments to insert into the plotting call to let', '            other plot attributes vary across levels of the hue variable (e.g.', '            the markers in a scatterplot).', '        {legend_out}', '        despine : boolean', '            Remove the top and right spines from the plots.', '        {margin_titles}', '        {{x, y}}lim: tuples', '            Limits for each of the axes on each facet (only relevant when', '            share{{x, y}} is True).', '        subplot_kws : dict', '            Dictionary of keyword arguments passed to matplotlib subplot(s)', '            methods.', '        gridspec_kws : dict', '            Dictionary of keyword arguments passed to', '            :class:`matplotlib.gridspec.GridSpec`', '            (via :meth:`matplotlib.figure.Figure.subplots`).', '            Ignored if ``col_wrap`` is not ``None``.', '', '        See Also', '        --------', '        PairGrid : Subplot grid for plotting pairwise relationships', '        relplot : Combine a relational plot and a :class:`FacetGrid`', '        displot : Combine a distribution plot and a :class:`FacetGrid`', '        catplot : Combine a categorical plot and a :class:`FacetGrid`', '        lmplot : Combine a regression plot and a :class:`FacetGrid`', '', '        Examples', '        --------', '', '        .. note::', '', '            These examples use seaborn functions to demonstrate some of the', '            advanced features of the class, but in most cases you will want', '            to use figue-level functions (e.g. :func:`displot`, :func:`relplot`)', '            to make the plots shown here.', '', '        .. include:: ../docstrings/FacetGrid.rst', '', '        \"\"\").format(**_facet_docs)', '', '    def facet_data(self):', '        \"\"\"Generator for name indices and data subsets for each facet.', '', '        Yields', '        ------', '        (i, j, k), data_ijk : tuple of ints, DataFrame', '            The ints provide an index into the {row, col, hue}_names attribute,', '            and the dataframe contains a subset of the full data corresponding', '            to each facet. The generator yields subsets that correspond with', '            the self.axes.flat iterator, or self.axes[i, j] when `col_wrap`', '            is None.', '', '        \"\"\"', '        data = self.data', '', '        # Construct masks for the row variable', '        if self.row_names:', '            row_masks = [data[self._row_var] == n for n in self.row_names]', '        else:', '            row_masks = [np.repeat(True, len(self.data))]', '', '        # Construct masks for the column variable', '        if self.col_names:', '            col_masks = [data[self._col_var] == n for n in self.col_names]', '        else:', '            col_masks = [np.repeat(True, len(self.data))]', '', '        # Construct masks for the hue variable', '        if self.hue_names:', '            hue_masks = [data[self._hue_var] == n for n in self.hue_names]', '        else:', '            hue_masks = [np.repeat(True, len(self.data))]', '', '        # Here is the main generator loop', '        for (i, row), (j, col), (k, hue) in product(enumerate(row_masks),', '                                                    enumerate(col_masks),', '                                                    enumerate(hue_masks)):', '            data_ijk = data[row & col & hue & self._not_na]', '            yield (i, j, k), data_ijk', '', '    def map(self, func, *args, **kwargs):', '        \"\"\"Apply a plotting function to each facet\\'s subset of the data.', '', '        Parameters', '        ----------', '        func : callable', '            A plotting function that takes data and keyword arguments. It', '            must plot to the currently active matplotlib Axes and take a', '            `color` keyword argument. If faceting on the `hue` dimension,', '            it must also take a `label` keyword argument.', '        args : strings', '            Column names in self.data that identify variables with data to', '            plot. The data for each variable is passed to `func` in the', '            order the variables are specified in the call.', '        kwargs : keyword arguments', '            All keyword arguments are passed to the plotting function.', '', '        Returns', '        -------', '        self : object', '            Returns self.', '', '        \"\"\"', '        # If color was a keyword argument, grab it here', '        kw_color = kwargs.pop(\"color\", None)', '', '        # How we use the function depends on where it comes from', '        func_module = str(getattr(func, \"__module__\", \"\"))', '', '        # Check for categorical plots without order information', '        if func_module == \"seaborn.categorical\":', '            if \"order\" not in kwargs:', '                warning = (\"Using the {} function without specifying \"', '                           \"`order` is likely to produce an incorrect \"', '                           \"plot.\".format(func.__name__))', '                warnings.warn(warning)', '            if len(args) == 3 and \"hue_order\" not in kwargs:', '                warning = (\"Using the {} function without specifying \"', '                           \"`hue_order` is likely to produce an incorrect \"', '                           \"plot.\".format(func.__name__))', '                warnings.warn(warning)', '', '        # Iterate over the data subsets', '        for (row_i, col_j, hue_k), data_ijk in self.facet_data():', '', '            # If this subset is null, move on', '            if not data_ijk.values.size:', '                continue', '', '            # Get the current axis', '            modify_state = not func_module.startswith(\"seaborn\")', '            ax = self.facet_axis(row_i, col_j, modify_state)', '', '            # Decide what color to plot with', '            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)', '', '            # Insert the other hue aesthetics if appropriate', '            for kw, val_list in self.hue_kws.items():', '                kwargs[kw] = val_list[hue_k]', '', '            # Insert a label in the keyword arguments for the legend', '            if self._hue_var is not None:', '                kwargs[\"label\"] = utils.to_utf8(self.hue_names[hue_k])', '', '            # Get the actual data we are going to plot with', '            plot_data = data_ijk[list(args)]', '            if self._dropna:', '                plot_data = plot_data.dropna()', '            plot_args = [v for k, v in plot_data.items()]', '', \"            # Some matplotlib functions don't handle pandas objects correctly\", '            if func_module.startswith(\"matplotlib\"):', '                plot_args = [v.values for v in plot_args]', '', '            # Draw the plot', '            self._facet_plot(func, ax, plot_args, kwargs)', '', '        # Finalize the annotations and layout', '        self._finalize_grid(args[:2])', '', '        return self', '', '    def map_dataframe(self, func, *args, **kwargs):', '        \"\"\"Like ``.map`` but passes args as strings and inserts data in kwargs.', '', '        This method is suitable for plotting with functions that accept a', '        long-form DataFrame as a `data` keyword argument and access the', '        data in that DataFrame using string variable names.', '', '        Parameters', '        ----------', '        func : callable', '            A plotting function that takes data and keyword arguments. Unlike', '            the `map` method, a function used here must \"understand\" Pandas', '            objects. It also must plot to the currently active matplotlib Axes', '            and take a `color` keyword argument. If faceting on the `hue`', '            dimension, it must also take a `label` keyword argument.', '        args : strings', '            Column names in self.data that identify variables with data to', '            plot. The data for each variable is passed to `func` in the', '            order the variables are specified in the call.', '        kwargs : keyword arguments', '            All keyword arguments are passed to the plotting function.', '', '        Returns', '        -------', '        self : object', '            Returns self.', '', '        \"\"\"', '', '        # If color was a keyword argument, grab it here', '        kw_color = kwargs.pop(\"color\", None)', '', '        # Iterate over the data subsets', '        for (row_i, col_j, hue_k), data_ijk in self.facet_data():', '', '            # If this subset is null, move on', '            if not data_ijk.values.size:', '                continue', '', '            # Get the current axis', '            modify_state = not str(func.__module__).startswith(\"seaborn\")', '            ax = self.facet_axis(row_i, col_j, modify_state)', '', '            # Decide what color to plot with', '            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)', '', '            # Insert the other hue aesthetics if appropriate', '            for kw, val_list in self.hue_kws.items():', '                kwargs[kw] = val_list[hue_k]', '', '            # Insert a label in the keyword arguments for the legend', '            if self._hue_var is not None:', '                kwargs[\"label\"] = self.hue_names[hue_k]', '', '            # Stick the facet dataframe into the kwargs', '            if self._dropna:', '                data_ijk = data_ijk.dropna()', '            kwargs[\"data\"] = data_ijk', '', '            # Draw the plot', '            self._facet_plot(func, ax, args, kwargs)', '', '        # For axis labels, prefer to use positional args for backcompat', '        # but also extract the x/y kwargs and use if no corresponding arg', '        axis_labels = [kwargs.get(\"x\", None), kwargs.get(\"y\", None)]', '        for i, val in enumerate(args[:2]):', '            axis_labels[i] = val', '        self._finalize_grid(axis_labels)', '', '        return self', '', '    def _facet_color(self, hue_index, kw_color):', '', '        color = self._colors[hue_index]', '        if kw_color is not None:', '            return kw_color', '        elif color is not None:', '            return color', '', '    def _facet_plot(self, func, ax, plot_args, plot_kwargs):', '', '        # Draw the plot', '        if str(func.__module__).startswith(\"seaborn\"):', '            plot_kwargs = plot_kwargs.copy()', '            semantics = [\"x\", \"y\", \"hue\", \"size\", \"style\"]', '            for key, val in zip(semantics, plot_args):', '                plot_kwargs[key] = val', '            plot_args = []', '            plot_kwargs[\"ax\"] = ax', '        func(*plot_args, **plot_kwargs)', '', '        # Sort out the supporting information', '        self._update_legend_data(ax)', '', '    def _finalize_grid(self, axlabels):', '        \"\"\"Finalize the annotations and layout.\"\"\"', '        self.set_axis_labels(*axlabels)', '        self.tight_layout()', '', '    def facet_axis(self, row_i, col_j, modify_state=True):', '        \"\"\"Make the axis identified by these indices active and return it.\"\"\"', '', '        # Calculate the actual indices of the axes to plot on', '        if self._col_wrap is not None:', '            ax = self.axes.flat[col_j]', '        else:', '            ax = self.axes[row_i, col_j]', '', '        # Get a reference to the axes object we want, and make it active', '        if modify_state:', '            plt.sca(ax)', '        return ax', '', '    def despine(self, **kwargs):', '        \"\"\"Remove axis spines from the facets.\"\"\"', '        utils.despine(self._figure, **kwargs)', '        return self', '', '    def set_axis_labels(self, x_var=None, y_var=None, clear_inner=True, **kwargs):', '        \"\"\"Set axis labels on the left column and bottom row of the grid.\"\"\"', '        if x_var is not None:', '            self._x_var = x_var', '            self.set_xlabels(x_var, clear_inner=clear_inner, **kwargs)', '        if y_var is not None:', '            self._y_var = y_var', '            self.set_ylabels(y_var, clear_inner=clear_inner, **kwargs)', '', '        return self', '', '    def set_xlabels(self, label=None, clear_inner=True, **kwargs):', '        \"\"\"Label the x axis on the bottom row of the grid.\"\"\"', '        if label is None:', '            label = self._x_var', '        for ax in self._bottom_axes:', '            ax.set_xlabel(label, **kwargs)', '        if clear_inner:', '            for ax in self._not_bottom_axes:', '                ax.set_xlabel(\"\")', '        return self', '', '    def set_ylabels(self, label=None, clear_inner=True, **kwargs):', '        \"\"\"Label the y axis on the left column of the grid.\"\"\"', '        if label is None:', '            label = self._y_var', '        for ax in self._left_axes:', '            ax.set_ylabel(label, **kwargs)', '        if clear_inner:', '            for ax in self._not_left_axes:', '                ax.set_ylabel(\"\")', '        return self', '', '    def set_xticklabels(self, labels=None, step=None, **kwargs):', '        \"\"\"Set x axis tick labels of the grid.\"\"\"', '        for ax in self.axes.flat:', '            curr_ticks = ax.get_xticks()', '            ax.set_xticks(curr_ticks)', '            if labels is None:', '                curr_labels = [l.get_text() for l in ax.get_xticklabels()]', '                if step is not None:', '                    xticks = ax.get_xticks()[::step]', '                    curr_labels = curr_labels[::step]', '                    ax.set_xticks(xticks)', '                ax.set_xticklabels(curr_labels, **kwargs)', '            else:', '                ax.set_xticklabels(labels, **kwargs)', '        return self', '', '    def set_yticklabels(self, labels=None, **kwargs):', '        \"\"\"Set y axis tick labels on the left column of the grid.\"\"\"', '        for ax in self.axes.flat:', '            curr_ticks = ax.get_yticks()', '            ax.set_yticks(curr_ticks)', '            if labels is None:', '                curr_labels = [l.get_text() for l in ax.get_yticklabels()]', '                ax.set_yticklabels(curr_labels, **kwargs)', '            else:', '                ax.set_yticklabels(labels, **kwargs)', '        return self', '', '    def set_titles(self, template=None, row_template=None, col_template=None,', '                   **kwargs):', '        \"\"\"Draw titles either above each facet or on the grid margins.', '', '        Parameters', '        ----------', '        template : string', '            Template for all titles with the formatting keys {col_var} and', '            {col_name} (if using a `col` faceting variable) and/or {row_var}', '            and {row_name} (if using a `row` faceting variable).', '        row_template:', '            Template for the row variable when titles are drawn on the grid', '            margins. Must have {row_var} and {row_name} formatting keys.', '        col_template:', '            Template for the row variable when titles are drawn on the grid', '            margins. Must have {col_var} and {col_name} formatting keys.', '', '        Returns', '        -------', '        self: object', '            Returns self.', '', '        \"\"\"', '        args = dict(row_var=self._row_var, col_var=self._col_var)', '        kwargs[\"size\"] = kwargs.pop(\"size\", mpl.rcParams[\"axes.labelsize\"])', '', '        # Establish default templates', '        if row_template is None:', '            row_template = \"{row_var} = {row_name}\"', '        if col_template is None:', '            col_template = \"{col_var} = {col_name}\"', '        if template is None:', '            if self._row_var is None:', '                template = col_template', '            elif self._col_var is None:', '                template = row_template', '            else:', '                template = \" | \".join([row_template, col_template])', '', '        row_template = utils.to_utf8(row_template)', '        col_template = utils.to_utf8(col_template)', '        template = utils.to_utf8(template)', '', '        if self._margin_titles:', '', '            # Remove any existing title texts', '            for text in self._margin_titles_texts:', '                text.remove()', '            self._margin_titles_texts = []', '', '            if self.row_names is not None:', '                # Draw the row titles on the right edge of the grid', '                for i, row_name in enumerate(self.row_names):', '                    ax = self.axes[i, -1]', '                    args.update(dict(row_name=row_name))', '                    title = row_template.format(**args)', '                    text = ax.annotate(', '                        title, xy=(1.02, .5), xycoords=\"axes fraction\",', '                        rotation=270, ha=\"left\", va=\"center\",', '                        **kwargs', '                    )', '                    self._margin_titles_texts.append(text)', '', '            if self.col_names is not None:', '                # Draw the column titles  as normal titles', '                for j, col_name in enumerate(self.col_names):', '                    args.update(dict(col_name=col_name))', '                    title = col_template.format(**args)', '                    self.axes[0, j].set_title(title, **kwargs)', '', '            return self', '', '        # Otherwise title each facet with all the necessary information', '        if (self._row_var is not None) and (self._col_var is not None):', '            for i, row_name in enumerate(self.row_names):', '                for j, col_name in enumerate(self.col_names):', '                    args.update(dict(row_name=row_name, col_name=col_name))', '                    title = template.format(**args)', '                    self.axes[i, j].set_title(title, **kwargs)', '        elif self.row_names is not None and len(self.row_names):', '            for i, row_name in enumerate(self.row_names):', '                args.update(dict(row_name=row_name))', '                title = template.format(**args)', '                self.axes[i, 0].set_title(title, **kwargs)', '        elif self.col_names is not None and len(self.col_names):', '            for i, col_name in enumerate(self.col_names):', '                args.update(dict(col_name=col_name))', '                title = template.format(**args)', '                # Index the flat array so col_wrap works', '                self.axes.flat[i].set_title(title, **kwargs)', '        return self', '', \"    def refline(self, *, x=None, y=None, color='.5', linestyle='--', **line_kws):\", '        \"\"\"Add a reference line(s) to each facet.', '', '        Parameters', '        ----------', '        x, y : numeric', '            Value(s) to draw the line(s) at.', '        color : :mod:`matplotlib color <matplotlib.colors>`', '            Specifies the color of the reference line(s). Pass ``color=None`` to', '            use ``hue`` mapping.', '        linestyle : str', '            Specifies the style of the reference line(s).', '        line_kws : key, value mappings', '            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`', '            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``', '            is not None.', '', '        Returns', '        -------', '        :class:`FacetGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', \"        line_kws['color'] = color\", \"        line_kws['linestyle'] = linestyle\", '', '        if x is not None:', '            self.map(plt.axvline, x=x, **line_kws)', '', '        if y is not None:', '            self.map(plt.axhline, y=y, **line_kws)', '', '        return self', '', '    # ------ Properties that are part of the public API and documented by Sphinx', '', '    @property', '    def axes(self):', '        \"\"\"An array of the :class:`matplotlib.axes.Axes` objects in the grid.\"\"\"', '        return self._axes', '', '    @property', '    def ax(self):', '        \"\"\"The :class:`matplotlib.axes.Axes` when no faceting variables are assigned.\"\"\"', '        if self.axes.shape == (1, 1):', '            return self.axes[0, 0]', '        else:', '            err = (', '                \"Use the `.axes` attribute when facet variables are assigned.\"', '            )', '            raise AttributeError(err)', '', '    @property', '    def axes_dict(self):', '        \"\"\"A mapping of facet names to corresponding :class:`matplotlib.axes.Axes`.', '', '        If only one of ``row`` or ``col`` is assigned, each key is a string', '        representing a level of that variable. If both facet dimensions are', '        assigned, each key is a ``({row_level}, {col_level})`` tuple.', '', '        \"\"\"', '        return self._axes_dict', '', '    # ------ Private properties, that require some computation to get', '', '    @property', '    def _inner_axes(self):', '        \"\"\"Return a flat array of the inner axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:-1, 1:].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i % self._ncol', '                    and i < (self._ncol * (self._nrow - 1))', '                    and i < (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '    @property', '    def _left_axes(self):', '        \"\"\"Return a flat array of the left column of axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:, 0].flat', '        else:', '            axes = []', '            for i, ax in enumerate(self.axes):', '                if not i % self._ncol:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '    @property', '    def _not_left_axes(self):', '        \"\"\"Return a flat array of axes that aren\\'t on the left column.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:, 1:].flat', '        else:', '            axes = []', '            for i, ax in enumerate(self.axes):', '                if i % self._ncol:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '    @property', '    def _bottom_axes(self):', '        \"\"\"Return a flat array of the bottom row of axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[-1, :].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i >= (self._ncol * (self._nrow - 1))', '                    or i >= (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '    @property', '    def _not_bottom_axes(self):', '        \"\"\"Return a flat array of axes that aren\\'t on the bottom row.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:-1, :].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i < (self._ncol * (self._nrow - 1))', '                    and i < (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat'], 'methods': [{'name': '__init__', 'start_line': 366, 'end_line': 543, 'text': ['    def __init__(', '        self, data, *,', '        row=None, col=None, hue=None, col_wrap=None,', '        sharex=True, sharey=True, height=3, aspect=1, palette=None,', '        row_order=None, col_order=None, hue_order=None, hue_kws=None,', '        dropna=False, legend_out=True, despine=True,', '        margin_titles=False, xlim=None, ylim=None, subplot_kws=None,', '        gridspec_kws=None,', '    ):', '', '        super().__init__()', '', '        # Determine the hue facet layer information', '        hue_var = hue', '        if hue is None:', '            hue_names = None', '        else:', '            hue_names = categorical_order(data[hue], hue_order)', '', '        colors = self._get_palette(data, hue, hue_order, palette)', '', '        # Set up the lists of names for the row and column facet variables', '        if row is None:', '            row_names = []', '        else:', '            row_names = categorical_order(data[row], row_order)', '', '        if col is None:', '            col_names = []', '        else:', '            col_names = categorical_order(data[col], col_order)', '', '        # Additional dict of kwarg -> list of values for mapping the hue var', '        hue_kws = hue_kws if hue_kws is not None else {}', '', '        # Make a boolean mask that is True anywhere there is an NA', '        # value in one of the faceting variables, but only if dropna is True', '        none_na = np.zeros(len(data), bool)', '        if dropna:', '            row_na = none_na if row is None else data[row].isnull()', '            col_na = none_na if col is None else data[col].isnull()', '            hue_na = none_na if hue is None else data[hue].isnull()', '            not_na = ~(row_na | col_na | hue_na)', '        else:', '            not_na = ~none_na', '', '        # Compute the grid shape', '        ncol = 1 if col is None else len(col_names)', '        nrow = 1 if row is None else len(row_names)', '        self._n_facets = ncol * nrow', '', '        self._col_wrap = col_wrap', '        if col_wrap is not None:', '            if row is not None:', '                err = \"Cannot use `row` and `col_wrap` together.\"', '                raise ValueError(err)', '            ncol = col_wrap', '            nrow = int(np.ceil(len(col_names) / col_wrap))', '        self._ncol = ncol', '        self._nrow = nrow', '', '        # Calculate the base figure size', '        # This can get stretched later by a legend', \"        # TODO this doesn't account for axis labels\", '        figsize = (ncol * height * aspect, nrow * height)', '', '        # Validate some inputs', '        if col_wrap is not None:', '            margin_titles = False', '', '        # Build the subplot keyword dictionary', '        subplot_kws = {} if subplot_kws is None else subplot_kws.copy()', '        gridspec_kws = {} if gridspec_kws is None else gridspec_kws.copy()', '        if xlim is not None:', '            subplot_kws[\"xlim\"] = xlim', '        if ylim is not None:', '            subplot_kws[\"ylim\"] = ylim', '', '        # --- Initialize the subplot grid', '', '        with _disable_autolayout():', '            fig = plt.figure(figsize=figsize)', '', '        if col_wrap is None:', '', '            kwargs = dict(squeeze=False,', '                          sharex=sharex, sharey=sharey,', '                          subplot_kw=subplot_kws,', '                          gridspec_kw=gridspec_kws)', '', '            axes = fig.subplots(nrow, ncol, **kwargs)', '', '            if col is None and row is None:', '                axes_dict = {}', '            elif col is None:', '                axes_dict = dict(zip(row_names, axes.flat))', '            elif row is None:', '                axes_dict = dict(zip(col_names, axes.flat))', '            else:', '                facet_product = product(row_names, col_names)', '                axes_dict = dict(zip(facet_product, axes.flat))', '', '        else:', '', '            # If wrapping the col variable we need to make the grid ourselves', '            if gridspec_kws:', '                warnings.warn(\"`gridspec_kws` ignored when using `col_wrap`\")', '', '            n_axes = len(col_names)', '            axes = np.empty(n_axes, object)', '            axes[0] = fig.add_subplot(nrow, ncol, 1, **subplot_kws)', '            if sharex:', '                subplot_kws[\"sharex\"] = axes[0]', '            if sharey:', '                subplot_kws[\"sharey\"] = axes[0]', '            for i in range(1, n_axes):', '                axes[i] = fig.add_subplot(nrow, ncol, i + 1, **subplot_kws)', '', '            axes_dict = dict(zip(col_names, axes))', '', '        # --- Set up the class attributes', '', '        # Attributes that are part of the public API but accessed through', '        # a  property so that Sphinx adds them to the auto class doc', '        self._figure = fig', '        self._axes = axes', '        self._axes_dict = axes_dict', '        self._legend = None', '', \"        # Public attributes that aren't explicitly documented\", \"        # (It's not obvious that having them be public was a good idea)\", '        self.data = data', '        self.row_names = row_names', '        self.col_names = col_names', '        self.hue_names = hue_names', '        self.hue_kws = hue_kws', '', '        # Next the private variables', '        self._nrow = nrow', '        self._row_var = row', '        self._ncol = ncol', '        self._col_var = col', '', '        self._margin_titles = margin_titles', '        self._margin_titles_texts = []', '        self._col_wrap = col_wrap', '        self._hue_var = hue_var', '        self._colors = colors', '        self._legend_out = legend_out', '        self._legend_data = {}', '        self._x_var = None', '        self._y_var = None', '        self._sharex = sharex', '        self._sharey = sharey', '        self._dropna = dropna', '        self._not_na = not_na', '', '        # --- Make the axes look good', '', '        self.set_titles()', '        self.tight_layout()', '', '        if despine:', '            self.despine()', '', \"        if sharex in [True, 'col']:\", '            for ax in self._not_bottom_axes:', '                for label in ax.get_xticklabels():', '                    label.set_visible(False)', '                ax.xaxis.offsetText.set_visible(False)', '                ax.xaxis.label.set_visible(False)', '', \"        if sharey in [True, 'row']:\", '            for ax in self._not_left_axes:', '                for label in ax.get_yticklabels():', '                    label.set_visible(False)', '                ax.yaxis.offsetText.set_visible(False)', '                ax.yaxis.label.set_visible(False)']}, {'name': 'facet_data', 'start_line': 637, 'end_line': 675, 'text': ['    def facet_data(self):', '        \"\"\"Generator for name indices and data subsets for each facet.', '', '        Yields', '        ------', '        (i, j, k), data_ijk : tuple of ints, DataFrame', '            The ints provide an index into the {row, col, hue}_names attribute,', '            and the dataframe contains a subset of the full data corresponding', '            to each facet. The generator yields subsets that correspond with', '            the self.axes.flat iterator, or self.axes[i, j] when `col_wrap`', '            is None.', '', '        \"\"\"', '        data = self.data', '', '        # Construct masks for the row variable', '        if self.row_names:', '            row_masks = [data[self._row_var] == n for n in self.row_names]', '        else:', '            row_masks = [np.repeat(True, len(self.data))]', '', '        # Construct masks for the column variable', '        if self.col_names:', '            col_masks = [data[self._col_var] == n for n in self.col_names]', '        else:', '            col_masks = [np.repeat(True, len(self.data))]', '', '        # Construct masks for the hue variable', '        if self.hue_names:', '            hue_masks = [data[self._hue_var] == n for n in self.hue_names]', '        else:', '            hue_masks = [np.repeat(True, len(self.data))]', '', '        # Here is the main generator loop', '        for (i, row), (j, col), (k, hue) in product(enumerate(row_masks),', '                                                    enumerate(col_masks),', '                                                    enumerate(hue_masks)):', '            data_ijk = data[row & col & hue & self._not_na]', '            yield (i, j, k), data_ijk']}, {'name': 'map', 'start_line': 677, 'end_line': 757, 'text': ['    def map(self, func, *args, **kwargs):', '        \"\"\"Apply a plotting function to each facet\\'s subset of the data.', '', '        Parameters', '        ----------', '        func : callable', '            A plotting function that takes data and keyword arguments. It', '            must plot to the currently active matplotlib Axes and take a', '            `color` keyword argument. If faceting on the `hue` dimension,', '            it must also take a `label` keyword argument.', '        args : strings', '            Column names in self.data that identify variables with data to', '            plot. The data for each variable is passed to `func` in the', '            order the variables are specified in the call.', '        kwargs : keyword arguments', '            All keyword arguments are passed to the plotting function.', '', '        Returns', '        -------', '        self : object', '            Returns self.', '', '        \"\"\"', '        # If color was a keyword argument, grab it here', '        kw_color = kwargs.pop(\"color\", None)', '', '        # How we use the function depends on where it comes from', '        func_module = str(getattr(func, \"__module__\", \"\"))', '', '        # Check for categorical plots without order information', '        if func_module == \"seaborn.categorical\":', '            if \"order\" not in kwargs:', '                warning = (\"Using the {} function without specifying \"', '                           \"`order` is likely to produce an incorrect \"', '                           \"plot.\".format(func.__name__))', '                warnings.warn(warning)', '            if len(args) == 3 and \"hue_order\" not in kwargs:', '                warning = (\"Using the {} function without specifying \"', '                           \"`hue_order` is likely to produce an incorrect \"', '                           \"plot.\".format(func.__name__))', '                warnings.warn(warning)', '', '        # Iterate over the data subsets', '        for (row_i, col_j, hue_k), data_ijk in self.facet_data():', '', '            # If this subset is null, move on', '            if not data_ijk.values.size:', '                continue', '', '            # Get the current axis', '            modify_state = not func_module.startswith(\"seaborn\")', '            ax = self.facet_axis(row_i, col_j, modify_state)', '', '            # Decide what color to plot with', '            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)', '', '            # Insert the other hue aesthetics if appropriate', '            for kw, val_list in self.hue_kws.items():', '                kwargs[kw] = val_list[hue_k]', '', '            # Insert a label in the keyword arguments for the legend', '            if self._hue_var is not None:', '                kwargs[\"label\"] = utils.to_utf8(self.hue_names[hue_k])', '', '            # Get the actual data we are going to plot with', '            plot_data = data_ijk[list(args)]', '            if self._dropna:', '                plot_data = plot_data.dropna()', '            plot_args = [v for k, v in plot_data.items()]', '', \"            # Some matplotlib functions don't handle pandas objects correctly\", '            if func_module.startswith(\"matplotlib\"):', '                plot_args = [v.values for v in plot_args]', '', '            # Draw the plot', '            self._facet_plot(func, ax, plot_args, kwargs)', '', '        # Finalize the annotations and layout', '        self._finalize_grid(args[:2])', '', '        return self']}, {'name': 'map_dataframe', 'start_line': 759, 'end_line': 828, 'text': ['    def map_dataframe(self, func, *args, **kwargs):', '        \"\"\"Like ``.map`` but passes args as strings and inserts data in kwargs.', '', '        This method is suitable for plotting with functions that accept a', '        long-form DataFrame as a `data` keyword argument and access the', '        data in that DataFrame using string variable names.', '', '        Parameters', '        ----------', '        func : callable', '            A plotting function that takes data and keyword arguments. Unlike', '            the `map` method, a function used here must \"understand\" Pandas', '            objects. It also must plot to the currently active matplotlib Axes', '            and take a `color` keyword argument. If faceting on the `hue`', '            dimension, it must also take a `label` keyword argument.', '        args : strings', '            Column names in self.data that identify variables with data to', '            plot. The data for each variable is passed to `func` in the', '            order the variables are specified in the call.', '        kwargs : keyword arguments', '            All keyword arguments are passed to the plotting function.', '', '        Returns', '        -------', '        self : object', '            Returns self.', '', '        \"\"\"', '', '        # If color was a keyword argument, grab it here', '        kw_color = kwargs.pop(\"color\", None)', '', '        # Iterate over the data subsets', '        for (row_i, col_j, hue_k), data_ijk in self.facet_data():', '', '            # If this subset is null, move on', '            if not data_ijk.values.size:', '                continue', '', '            # Get the current axis', '            modify_state = not str(func.__module__).startswith(\"seaborn\")', '            ax = self.facet_axis(row_i, col_j, modify_state)', '', '            # Decide what color to plot with', '            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)', '', '            # Insert the other hue aesthetics if appropriate', '            for kw, val_list in self.hue_kws.items():', '                kwargs[kw] = val_list[hue_k]', '', '            # Insert a label in the keyword arguments for the legend', '            if self._hue_var is not None:', '                kwargs[\"label\"] = self.hue_names[hue_k]', '', '            # Stick the facet dataframe into the kwargs', '            if self._dropna:', '                data_ijk = data_ijk.dropna()', '            kwargs[\"data\"] = data_ijk', '', '            # Draw the plot', '            self._facet_plot(func, ax, args, kwargs)', '', '        # For axis labels, prefer to use positional args for backcompat', '        # but also extract the x/y kwargs and use if no corresponding arg', '        axis_labels = [kwargs.get(\"x\", None), kwargs.get(\"y\", None)]', '        for i, val in enumerate(args[:2]):', '            axis_labels[i] = val', '        self._finalize_grid(axis_labels)', '', '        return self']}, {'name': '_facet_color', 'start_line': 830, 'end_line': 836, 'text': ['    def _facet_color(self, hue_index, kw_color):', '', '        color = self._colors[hue_index]', '        if kw_color is not None:', '            return kw_color', '        elif color is not None:', '            return color']}, {'name': '_facet_plot', 'start_line': 838, 'end_line': 851, 'text': ['    def _facet_plot(self, func, ax, plot_args, plot_kwargs):', '', '        # Draw the plot', '        if str(func.__module__).startswith(\"seaborn\"):', '            plot_kwargs = plot_kwargs.copy()', '            semantics = [\"x\", \"y\", \"hue\", \"size\", \"style\"]', '            for key, val in zip(semantics, plot_args):', '                plot_kwargs[key] = val', '            plot_args = []', '            plot_kwargs[\"ax\"] = ax', '        func(*plot_args, **plot_kwargs)', '', '        # Sort out the supporting information', '        self._update_legend_data(ax)']}, {'name': '_finalize_grid', 'start_line': 853, 'end_line': 856, 'text': ['    def _finalize_grid(self, axlabels):', '        \"\"\"Finalize the annotations and layout.\"\"\"', '        self.set_axis_labels(*axlabels)', '        self.tight_layout()']}, {'name': 'facet_axis', 'start_line': 858, 'end_line': 870, 'text': ['    def facet_axis(self, row_i, col_j, modify_state=True):', '        \"\"\"Make the axis identified by these indices active and return it.\"\"\"', '', '        # Calculate the actual indices of the axes to plot on', '        if self._col_wrap is not None:', '            ax = self.axes.flat[col_j]', '        else:', '            ax = self.axes[row_i, col_j]', '', '        # Get a reference to the axes object we want, and make it active', '        if modify_state:', '            plt.sca(ax)', '        return ax']}, {'name': 'despine', 'start_line': 872, 'end_line': 875, 'text': ['    def despine(self, **kwargs):', '        \"\"\"Remove axis spines from the facets.\"\"\"', '        utils.despine(self._figure, **kwargs)', '        return self']}, {'name': 'set_axis_labels', 'start_line': 877, 'end_line': 886, 'text': ['    def set_axis_labels(self, x_var=None, y_var=None, clear_inner=True, **kwargs):', '        \"\"\"Set axis labels on the left column and bottom row of the grid.\"\"\"', '        if x_var is not None:', '            self._x_var = x_var', '            self.set_xlabels(x_var, clear_inner=clear_inner, **kwargs)', '        if y_var is not None:', '            self._y_var = y_var', '            self.set_ylabels(y_var, clear_inner=clear_inner, **kwargs)', '', '        return self']}, {'name': 'set_xlabels', 'start_line': 888, 'end_line': 897, 'text': ['    def set_xlabels(self, label=None, clear_inner=True, **kwargs):', '        \"\"\"Label the x axis on the bottom row of the grid.\"\"\"', '        if label is None:', '            label = self._x_var', '        for ax in self._bottom_axes:', '            ax.set_xlabel(label, **kwargs)', '        if clear_inner:', '            for ax in self._not_bottom_axes:', '                ax.set_xlabel(\"\")', '        return self']}, {'name': 'set_ylabels', 'start_line': 899, 'end_line': 908, 'text': ['    def set_ylabels(self, label=None, clear_inner=True, **kwargs):', '        \"\"\"Label the y axis on the left column of the grid.\"\"\"', '        if label is None:', '            label = self._y_var', '        for ax in self._left_axes:', '            ax.set_ylabel(label, **kwargs)', '        if clear_inner:', '            for ax in self._not_left_axes:', '                ax.set_ylabel(\"\")', '        return self']}, {'name': 'set_xticklabels', 'start_line': 910, 'end_line': 924, 'text': ['    def set_xticklabels(self, labels=None, step=None, **kwargs):', '        \"\"\"Set x axis tick labels of the grid.\"\"\"', '        for ax in self.axes.flat:', '            curr_ticks = ax.get_xticks()', '            ax.set_xticks(curr_ticks)', '            if labels is None:', '                curr_labels = [l.get_text() for l in ax.get_xticklabels()]', '                if step is not None:', '                    xticks = ax.get_xticks()[::step]', '                    curr_labels = curr_labels[::step]', '                    ax.set_xticks(xticks)', '                ax.set_xticklabels(curr_labels, **kwargs)', '            else:', '                ax.set_xticklabels(labels, **kwargs)', '        return self']}, {'name': 'set_yticklabels', 'start_line': 926, 'end_line': 936, 'text': ['    def set_yticklabels(self, labels=None, **kwargs):', '        \"\"\"Set y axis tick labels on the left column of the grid.\"\"\"', '        for ax in self.axes.flat:', '            curr_ticks = ax.get_yticks()', '            ax.set_yticks(curr_ticks)', '            if labels is None:', '                curr_labels = [l.get_text() for l in ax.get_yticklabels()]', '                ax.set_yticklabels(curr_labels, **kwargs)', '            else:', '                ax.set_yticklabels(labels, **kwargs)', '        return self']}, {'name': 'set_titles', 'start_line': 938, 'end_line': 1028, 'text': ['    def set_titles(self, template=None, row_template=None, col_template=None,', '                   **kwargs):', '        \"\"\"Draw titles either above each facet or on the grid margins.', '', '        Parameters', '        ----------', '        template : string', '            Template for all titles with the formatting keys {col_var} and', '            {col_name} (if using a `col` faceting variable) and/or {row_var}', '            and {row_name} (if using a `row` faceting variable).', '        row_template:', '            Template for the row variable when titles are drawn on the grid', '            margins. Must have {row_var} and {row_name} formatting keys.', '        col_template:', '            Template for the row variable when titles are drawn on the grid', '            margins. Must have {col_var} and {col_name} formatting keys.', '', '        Returns', '        -------', '        self: object', '            Returns self.', '', '        \"\"\"', '        args = dict(row_var=self._row_var, col_var=self._col_var)', '        kwargs[\"size\"] = kwargs.pop(\"size\", mpl.rcParams[\"axes.labelsize\"])', '', '        # Establish default templates', '        if row_template is None:', '            row_template = \"{row_var} = {row_name}\"', '        if col_template is None:', '            col_template = \"{col_var} = {col_name}\"', '        if template is None:', '            if self._row_var is None:', '                template = col_template', '            elif self._col_var is None:', '                template = row_template', '            else:', '                template = \" | \".join([row_template, col_template])', '', '        row_template = utils.to_utf8(row_template)', '        col_template = utils.to_utf8(col_template)', '        template = utils.to_utf8(template)', '', '        if self._margin_titles:', '', '            # Remove any existing title texts', '            for text in self._margin_titles_texts:', '                text.remove()', '            self._margin_titles_texts = []', '', '            if self.row_names is not None:', '                # Draw the row titles on the right edge of the grid', '                for i, row_name in enumerate(self.row_names):', '                    ax = self.axes[i, -1]', '                    args.update(dict(row_name=row_name))', '                    title = row_template.format(**args)', '                    text = ax.annotate(', '                        title, xy=(1.02, .5), xycoords=\"axes fraction\",', '                        rotation=270, ha=\"left\", va=\"center\",', '                        **kwargs', '                    )', '                    self._margin_titles_texts.append(text)', '', '            if self.col_names is not None:', '                # Draw the column titles  as normal titles', '                for j, col_name in enumerate(self.col_names):', '                    args.update(dict(col_name=col_name))', '                    title = col_template.format(**args)', '                    self.axes[0, j].set_title(title, **kwargs)', '', '            return self', '', '        # Otherwise title each facet with all the necessary information', '        if (self._row_var is not None) and (self._col_var is not None):', '            for i, row_name in enumerate(self.row_names):', '                for j, col_name in enumerate(self.col_names):', '                    args.update(dict(row_name=row_name, col_name=col_name))', '                    title = template.format(**args)', '                    self.axes[i, j].set_title(title, **kwargs)', '        elif self.row_names is not None and len(self.row_names):', '            for i, row_name in enumerate(self.row_names):', '                args.update(dict(row_name=row_name))', '                title = template.format(**args)', '                self.axes[i, 0].set_title(title, **kwargs)', '        elif self.col_names is not None and len(self.col_names):', '            for i, col_name in enumerate(self.col_names):', '                args.update(dict(col_name=col_name))', '                title = template.format(**args)', '                # Index the flat array so col_wrap works', '                self.axes.flat[i].set_title(title, **kwargs)', '        return self']}, {'name': 'refline', 'start_line': 1030, 'end_line': 1062, 'text': [\"    def refline(self, *, x=None, y=None, color='.5', linestyle='--', **line_kws):\", '        \"\"\"Add a reference line(s) to each facet.', '', '        Parameters', '        ----------', '        x, y : numeric', '            Value(s) to draw the line(s) at.', '        color : :mod:`matplotlib color <matplotlib.colors>`', '            Specifies the color of the reference line(s). Pass ``color=None`` to', '            use ``hue`` mapping.', '        linestyle : str', '            Specifies the style of the reference line(s).', '        line_kws : key, value mappings', '            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`', '            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``', '            is not None.', '', '        Returns', '        -------', '        :class:`FacetGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', \"        line_kws['color'] = color\", \"        line_kws['linestyle'] = linestyle\", '', '        if x is not None:', '            self.map(plt.axvline, x=x, **line_kws)', '', '        if y is not None:', '            self.map(plt.axhline, y=y, **line_kws)', '', '        return self']}, {'name': 'axes', 'start_line': 1067, 'end_line': 1069, 'text': ['    def axes(self):', '        \"\"\"An array of the :class:`matplotlib.axes.Axes` objects in the grid.\"\"\"', '        return self._axes']}, {'name': 'ax', 'start_line': 1072, 'end_line': 1080, 'text': ['    def ax(self):', '        \"\"\"The :class:`matplotlib.axes.Axes` when no faceting variables are assigned.\"\"\"', '        if self.axes.shape == (1, 1):', '            return self.axes[0, 0]', '        else:', '            err = (', '                \"Use the `.axes` attribute when facet variables are assigned.\"', '            )', '            raise AttributeError(err)']}, {'name': 'axes_dict', 'start_line': 1083, 'end_line': 1091, 'text': ['    def axes_dict(self):', '        \"\"\"A mapping of facet names to corresponding :class:`matplotlib.axes.Axes`.', '', '        If only one of ``row`` or ``col`` is assigned, each key is a string', '        representing a level of that variable. If both facet dimensions are', '        assigned, each key is a ``({row_level}, {col_level})`` tuple.', '', '        \"\"\"', '        return self._axes_dict']}, {'name': '_inner_axes', 'start_line': 1096, 'end_line': 1111, 'text': ['    def _inner_axes(self):', '        \"\"\"Return a flat array of the inner axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:-1, 1:].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i % self._ncol', '                    and i < (self._ncol * (self._nrow - 1))', '                    and i < (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat']}, {'name': '_left_axes', 'start_line': 1114, 'end_line': 1123, 'text': ['    def _left_axes(self):', '        \"\"\"Return a flat array of the left column of axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:, 0].flat', '        else:', '            axes = []', '            for i, ax in enumerate(self.axes):', '                if not i % self._ncol:', '                    axes.append(ax)', '            return np.array(axes, object).flat']}, {'name': '_not_left_axes', 'start_line': 1126, 'end_line': 1135, 'text': ['    def _not_left_axes(self):', '        \"\"\"Return a flat array of axes that aren\\'t on the left column.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:, 1:].flat', '        else:', '            axes = []', '            for i, ax in enumerate(self.axes):', '                if i % self._ncol:', '                    axes.append(ax)', '            return np.array(axes, object).flat']}, {'name': '_bottom_axes', 'start_line': 1138, 'end_line': 1152, 'text': ['    def _bottom_axes(self):', '        \"\"\"Return a flat array of the bottom row of axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[-1, :].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i >= (self._ncol * (self._nrow - 1))', '                    or i >= (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat']}, {'name': '_not_bottom_axes', 'start_line': 1155, 'end_line': 1169, 'text': ['    def _not_bottom_axes(self):', '        \"\"\"Return a flat array of axes that aren\\'t on the bottom row.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:-1, :].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i < (self._ncol * (self._nrow - 1))', '                    and i < (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat']}]}, {'name': 'PairGrid', 'start_line': 1172, 'end_line': 1670, 'text': ['class PairGrid(Grid):', '    \"\"\"Subplot grid for plotting pairwise relationships in a dataset.', '', '    This object maps each variable in a dataset onto a column and row in a', '    grid of multiple axes. Different axes-level plotting functions can be', '    used to draw bivariate plots in the upper and lower triangles, and the', '    marginal distribution of each variable can be shown on the diagonal.', '', '    Several different common plots can be generated in a single line using', '    :func:`pairplot`. Use :class:`PairGrid` when you need more flexibility.', '', '    See the :ref:`tutorial <grid_tutorial>` for more information.', '', '    \"\"\"', '    def __init__(', '        self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,', '        hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,', '        height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False,', '    ):', '        \"\"\"Initialize the plot figure and PairGrid object.', '', '        Parameters', '        ----------', '        data : DataFrame', '            Tidy (long-form) dataframe where each column is a variable and', '            each row is an observation.', '        hue : string (variable name)', '            Variable in ``data`` to map plot aspects to different colors. This', '            variable will be excluded from the default x and y variables.', '        vars : list of variable names', '            Variables within ``data`` to use, otherwise use every column with', '            a numeric datatype.', '        {x, y}_vars : lists of variable names', '            Variables within ``data`` to use separately for the rows and', '            columns of the figure; i.e. to make a non-square plot.', '        hue_order : list of strings', '            Order for the levels of the hue variable in the palette', '        palette : dict or seaborn color palette', '            Set of colors for mapping the ``hue`` variable. If a dict, keys', '            should be values  in the ``hue`` variable.', '        hue_kws : dictionary of param -> list of values mapping', '            Other keyword arguments to insert into the plotting call to let', '            other plot attributes vary across levels of the hue variable (e.g.', '            the markers in a scatterplot).', '        corner : bool', \"            If True, don't add axes to the upper (off-diagonal) triangle of the\", '            grid, making this a \"corner\" plot.', '        height : scalar', '            Height (in inches) of each facet.', '        aspect : scalar', '            Aspect * height gives the width (in inches) of each facet.', '        layout_pad : scalar', '            Padding between axes; passed to ``fig.tight_layout``.', '        despine : boolean', '            Remove the top and right spines from the plots.', '        dropna : boolean', '            Drop missing values from the data before plotting.', '', '        See Also', '        --------', '        pairplot : Easily drawing common uses of :class:`PairGrid`.', '        FacetGrid : Subplot grid for plotting conditional relationships.', '', '        Examples', '        --------', '', '        .. include:: ../docstrings/PairGrid.rst', '', '        \"\"\"', '', '        super().__init__()', '', '        # Sort out the variables that define the grid', '        numeric_cols = self._find_numeric_cols(data)', '        if hue in numeric_cols:', '            numeric_cols.remove(hue)', '        if vars is not None:', '            x_vars = list(vars)', '            y_vars = list(vars)', '        if x_vars is None:', '            x_vars = numeric_cols', '        if y_vars is None:', '            y_vars = numeric_cols', '', '        if np.isscalar(x_vars):', '            x_vars = [x_vars]', '        if np.isscalar(y_vars):', '            y_vars = [y_vars]', '', '        self.x_vars = x_vars = list(x_vars)', '        self.y_vars = y_vars = list(y_vars)', '        self.square_grid = self.x_vars == self.y_vars', '', '        if not x_vars:', '            raise ValueError(\"No variables found for grid columns.\")', '        if not y_vars:', '            raise ValueError(\"No variables found for grid rows.\")', '', '        # Create the figure and the array of subplots', '        figsize = len(x_vars) * height * aspect, len(y_vars) * height', '', '        with _disable_autolayout():', '            fig = plt.figure(figsize=figsize)', '', '        axes = fig.subplots(len(y_vars), len(x_vars),', '                            sharex=\"col\", sharey=\"row\",', '                            squeeze=False)', '', '        # Possibly remove upper axes to make a corner grid', '        # Note: setting up the axes is usually the most time-intensive part', '        # of using the PairGrid. We are foregoing the speed improvement that', '        # we would get by just not setting up the hidden axes so that we can', '        # avoid implementing fig.subplots ourselves. But worth thinking about.', '        self._corner = corner', '        if corner:', '            hide_indices = np.triu_indices_from(axes, 1)', '            for i, j in zip(*hide_indices):', '                axes[i, j].remove()', '                axes[i, j] = None', '', '        self._figure = fig', '        self.axes = axes', '        self.data = data', '', '        # Save what we are going to do with the diagonal', '        self.diag_sharey = diag_sharey', '        self.diag_vars = None', '        self.diag_axes = None', '', '        self._dropna = dropna', '', '        # Label the axes', '        self._add_axis_labels()', '', '        # Sort out the hue variable', '        self._hue_var = hue', '        if hue is None:', '            self.hue_names = hue_order = [\"_nolegend_\"]', '            self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),', '                                      index=data.index)', '        else:', '            # We need hue_order and hue_names because the former is used to control', '            # the order of drawing and the latter is used to control the order of', '            # the legend. hue_names can become string-typed while hue_order must', '            # retain the type of the input data. This is messy but results from', '            # the fact that PairGrid can implement the hue-mapping logic itself', '            # (and was originally written exclusively that way) but now can delegate', '            # to the axes-level functions, while always handling legend creation.', '            # See GH2307', '            hue_names = hue_order = categorical_order(data[hue], hue_order)', '            if dropna:', '                # Filter NA from the list of unique hue names', '                hue_names = list(filter(pd.notnull, hue_names))', '            self.hue_names = hue_names', '            self.hue_vals = data[hue]', '', '        # Additional dict of kwarg -> list of values for mapping the hue var', '        self.hue_kws = hue_kws if hue_kws is not None else {}', '', '        self._orig_palette = palette', '        self._hue_order = hue_order', '        self.palette = self._get_palette(data, hue, hue_order, palette)', '        self._legend_data = {}', '', '        # Make the plot look nice', '        for ax in axes[:-1, :].flat:', '            if ax is None:', '                continue', '            for label in ax.get_xticklabels():', '                label.set_visible(False)', '            ax.xaxis.offsetText.set_visible(False)', '            ax.xaxis.label.set_visible(False)', '', '        for ax in axes[:, 1:].flat:', '            if ax is None:', '                continue', '            for label in ax.get_yticklabels():', '                label.set_visible(False)', '            ax.yaxis.offsetText.set_visible(False)', '            ax.yaxis.label.set_visible(False)', '', '        self._tight_layout_rect = [.01, .01, .99, .99]', '        self._tight_layout_pad = layout_pad', '        self._despine = despine', '        if despine:', '            utils.despine(fig=fig)', '        self.tight_layout(pad=layout_pad)', '', '    def map(self, func, **kwargs):', '        \"\"\"Plot with the same function in every subplot.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        row_indices, col_indices = np.indices(self.axes.shape)', '        indices = zip(row_indices.flat, col_indices.flat)', '        self._map_bivariate(func, indices, **kwargs)', '', '        return self', '', '    def map_lower(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the lower diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        indices = zip(*np.tril_indices_from(self.axes, -1))', '        self._map_bivariate(func, indices, **kwargs)', '        return self', '', '    def map_upper(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the upper diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        indices = zip(*np.triu_indices_from(self.axes, 1))', '        self._map_bivariate(func, indices, **kwargs)', '        return self', '', '    def map_offdiag(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the off-diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        if self.square_grid:', '            self.map_lower(func, **kwargs)', '            if not self._corner:', '                self.map_upper(func, **kwargs)', '        else:', '            indices = []', '            for i, (y_var) in enumerate(self.y_vars):', '                for j, (x_var) in enumerate(self.x_vars):', '                    if x_var != y_var:', '                        indices.append((i, j))', '            self._map_bivariate(func, indices, **kwargs)', '        return self', '', '    def map_diag(self, func, **kwargs):', '        \"\"\"Plot with a univariate function on each diagonal subplot.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take an x array as a positional argument and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        # Add special diagonal axes for the univariate plot', '        if self.diag_axes is None:', '            diag_vars = []', '            diag_axes = []', '            for i, y_var in enumerate(self.y_vars):', '                for j, x_var in enumerate(self.x_vars):', '                    if x_var == y_var:', '', '                        # Make the density axes', '                        diag_vars.append(x_var)', '                        ax = self.axes[i, j]', '                        diag_ax = ax.twinx()', '                        diag_ax.set_axis_off()', '                        diag_axes.append(diag_ax)', '', '                        # Work around matplotlib bug', '                        # https://github.com/matplotlib/matplotlib/issues/15188', '                        if not plt.rcParams.get(\"ytick.left\", True):', '                            for tick in ax.yaxis.majorTicks:', '                                tick.tick1line.set_visible(False)', '', '                        # Remove main y axis from density axes in a corner plot', '                        if self._corner:', '                            ax.yaxis.set_visible(False)', '                            if self._despine:', '                                utils.despine(ax=ax, left=True)', '                            # TODO add optional density ticks (on the right)', '                            # when drawing a corner plot?', '', '            if self.diag_sharey and diag_axes:', '                for ax in diag_axes[1:]:', '                    share_axis(diag_axes[0], ax, \"y\")', '', '            self.diag_vars = np.array(diag_vars, np.object_)', '            self.diag_axes = np.array(diag_axes, np.object_)', '', '        if \"hue\" not in signature(func).parameters:', '            return self._map_diag_iter_hue(func, **kwargs)', '', '        # Loop over diagonal variables and axes, making one plot in each', '        for var, ax in zip(self.diag_vars, self.diag_axes):', '', '            plot_kwargs = kwargs.copy()', '            if str(func.__module__).startswith(\"seaborn\"):', '                plot_kwargs[\"ax\"] = ax', '            else:', '                plt.sca(ax)', '', '            vector = self.data[var]', '            if self._hue_var is not None:', '                hue = self.data[self._hue_var]', '            else:', '                hue = None', '', '            if self._dropna:', '                not_na = vector.notna()', '                if hue is not None:', '                    not_na &= hue.notna()', '                vector = vector[not_na]', '                if hue is not None:', '                    hue = hue[not_na]', '', '            plot_kwargs.setdefault(\"hue\", hue)', '            plot_kwargs.setdefault(\"hue_order\", self._hue_order)', '            plot_kwargs.setdefault(\"palette\", self._orig_palette)', '            func(x=vector, **plot_kwargs)', '            ax.legend_ = None', '', '        self._add_axis_labels()', '        return self', '', '    def _map_diag_iter_hue(self, func, **kwargs):', '        \"\"\"Put marginal plot on each diagonal axes, iterating over hue.\"\"\"', '        # Plot on each of the diagonal axes', '        fixed_color = kwargs.pop(\"color\", None)', '', '        for var, ax in zip(self.diag_vars, self.diag_axes):', '            hue_grouped = self.data[var].groupby(self.hue_vals)', '', '            plot_kwargs = kwargs.copy()', '            if str(func.__module__).startswith(\"seaborn\"):', '                plot_kwargs[\"ax\"] = ax', '            else:', '                plt.sca(ax)', '', '            for k, label_k in enumerate(self._hue_order):', '', '                # Attempt to get data for this level, allowing for empty', '                try:', '                    data_k = hue_grouped.get_group(label_k)', '                except KeyError:', '                    data_k = pd.Series([], dtype=float)', '', '                if fixed_color is None:', '                    color = self.palette[k]', '                else:', '                    color = fixed_color', '', '                if self._dropna:', '                    data_k = utils.remove_na(data_k)', '', '                if str(func.__module__).startswith(\"seaborn\"):', '                    func(x=data_k, label=label_k, color=color, **plot_kwargs)', '                else:', '                    func(data_k, label=label_k, color=color, **plot_kwargs)', '', '        self._add_axis_labels()', '', '        return self', '', '    def _map_bivariate(self, func, indices, **kwargs):', '        \"\"\"Draw a bivariate plot on the indicated axes.\"\"\"', \"        # This is a hack to handle the fact that new distribution plots don't add\", '        # their artists onto the axes. This is probably superior in general, but', \"        # we'll need a better way to handle it in the axisgrid functions.\", '        from .distributions import histplot, kdeplot', '        if func is histplot or func is kdeplot:', '            self._extract_legend_handles = True', '', '        kws = kwargs.copy()  # Use copy as we insert other kwargs', '        for i, j in indices:', '            x_var = self.x_vars[j]', '            y_var = self.y_vars[i]', '            ax = self.axes[i, j]', '            if ax is None:  # i.e. we are in corner mode', '                continue', '            self._plot_bivariate(x_var, y_var, ax, func, **kws)', '        self._add_axis_labels()', '', '        if \"hue\" in signature(func).parameters:', '            self.hue_names = list(self._legend_data)', '', '    def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):', '        \"\"\"Draw a bivariate plot on the specified axes.\"\"\"', '        if \"hue\" not in signature(func).parameters:', '            self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)', '            return', '', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = ax', '        else:', '            plt.sca(ax)', '', '        if x_var == y_var:', '            axes_vars = [x_var]', '        else:', '            axes_vars = [x_var, y_var]', '', '        if self._hue_var is not None and self._hue_var not in axes_vars:', '            axes_vars.append(self._hue_var)', '', '        data = self.data[axes_vars]', '        if self._dropna:', '            data = data.dropna()', '', '        x = data[x_var]', '        y = data[y_var]', '        if self._hue_var is None:', '            hue = None', '        else:', '            hue = data.get(self._hue_var)', '', '        if \"hue\" not in kwargs:', '            kwargs.update({', '                \"hue\": hue, \"hue_order\": self._hue_order, \"palette\": self._orig_palette,', '            })', '        func(x=x, y=y, **kwargs)', '', '        self._update_legend_data(ax)', '', '    def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):', '        \"\"\"Draw a bivariate plot while iterating over hue subsets.\"\"\"', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = ax', '        else:', '            plt.sca(ax)', '', '        if x_var == y_var:', '            axes_vars = [x_var]', '        else:', '            axes_vars = [x_var, y_var]', '', '        hue_grouped = self.data.groupby(self.hue_vals)', '        for k, label_k in enumerate(self._hue_order):', '', '            kws = kwargs.copy()', '', '            # Attempt to get data for this level, allowing for empty', '            try:', '                data_k = hue_grouped.get_group(label_k)', '            except KeyError:', '                data_k = pd.DataFrame(columns=axes_vars,', '                                      dtype=float)', '', '            if self._dropna:', '                data_k = data_k[axes_vars].dropna()', '', '            x = data_k[x_var]', '            y = data_k[y_var]', '', '            for kw, val_list in self.hue_kws.items():', '                kws[kw] = val_list[k]', '            kws.setdefault(\"color\", self.palette[k])', '            if self._hue_var is not None:', '                kws[\"label\"] = label_k', '', '            if str(func.__module__).startswith(\"seaborn\"):', '                func(x=x, y=y, **kws)', '            else:', '                func(x, y, **kws)', '', '        self._update_legend_data(ax)', '', '    def _add_axis_labels(self):', '        \"\"\"Add labels to the left and bottom Axes.\"\"\"', '        for ax, label in zip(self.axes[-1, :], self.x_vars):', '            ax.set_xlabel(label)', '        for ax, label in zip(self.axes[:, 0], self.y_vars):', '            ax.set_ylabel(label)', '', '    def _find_numeric_cols(self, data):', '        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"', '        numeric_cols = []', '        for col in data:', '            if variable_type(data[col]) == \"numeric\":', '                numeric_cols.append(col)', '        return numeric_cols'], 'methods': [{'name': '__init__', 'start_line': 1186, 'end_line': 1358, 'text': ['    def __init__(', '        self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,', '        hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,', '        height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False,', '    ):', '        \"\"\"Initialize the plot figure and PairGrid object.', '', '        Parameters', '        ----------', '        data : DataFrame', '            Tidy (long-form) dataframe where each column is a variable and', '            each row is an observation.', '        hue : string (variable name)', '            Variable in ``data`` to map plot aspects to different colors. This', '            variable will be excluded from the default x and y variables.', '        vars : list of variable names', '            Variables within ``data`` to use, otherwise use every column with', '            a numeric datatype.', '        {x, y}_vars : lists of variable names', '            Variables within ``data`` to use separately for the rows and', '            columns of the figure; i.e. to make a non-square plot.', '        hue_order : list of strings', '            Order for the levels of the hue variable in the palette', '        palette : dict or seaborn color palette', '            Set of colors for mapping the ``hue`` variable. If a dict, keys', '            should be values  in the ``hue`` variable.', '        hue_kws : dictionary of param -> list of values mapping', '            Other keyword arguments to insert into the plotting call to let', '            other plot attributes vary across levels of the hue variable (e.g.', '            the markers in a scatterplot).', '        corner : bool', \"            If True, don't add axes to the upper (off-diagonal) triangle of the\", '            grid, making this a \"corner\" plot.', '        height : scalar', '            Height (in inches) of each facet.', '        aspect : scalar', '            Aspect * height gives the width (in inches) of each facet.', '        layout_pad : scalar', '            Padding between axes; passed to ``fig.tight_layout``.', '        despine : boolean', '            Remove the top and right spines from the plots.', '        dropna : boolean', '            Drop missing values from the data before plotting.', '', '        See Also', '        --------', '        pairplot : Easily drawing common uses of :class:`PairGrid`.', '        FacetGrid : Subplot grid for plotting conditional relationships.', '', '        Examples', '        --------', '', '        .. include:: ../docstrings/PairGrid.rst', '', '        \"\"\"', '', '        super().__init__()', '', '        # Sort out the variables that define the grid', '        numeric_cols = self._find_numeric_cols(data)', '        if hue in numeric_cols:', '            numeric_cols.remove(hue)', '        if vars is not None:', '            x_vars = list(vars)', '            y_vars = list(vars)', '        if x_vars is None:', '            x_vars = numeric_cols', '        if y_vars is None:', '            y_vars = numeric_cols', '', '        if np.isscalar(x_vars):', '            x_vars = [x_vars]', '        if np.isscalar(y_vars):', '            y_vars = [y_vars]', '', '        self.x_vars = x_vars = list(x_vars)', '        self.y_vars = y_vars = list(y_vars)', '        self.square_grid = self.x_vars == self.y_vars', '', '        if not x_vars:', '            raise ValueError(\"No variables found for grid columns.\")', '        if not y_vars:', '            raise ValueError(\"No variables found for grid rows.\")', '', '        # Create the figure and the array of subplots', '        figsize = len(x_vars) * height * aspect, len(y_vars) * height', '', '        with _disable_autolayout():', '            fig = plt.figure(figsize=figsize)', '', '        axes = fig.subplots(len(y_vars), len(x_vars),', '                            sharex=\"col\", sharey=\"row\",', '                            squeeze=False)', '', '        # Possibly remove upper axes to make a corner grid', '        # Note: setting up the axes is usually the most time-intensive part', '        # of using the PairGrid. We are foregoing the speed improvement that', '        # we would get by just not setting up the hidden axes so that we can', '        # avoid implementing fig.subplots ourselves. But worth thinking about.', '        self._corner = corner', '        if corner:', '            hide_indices = np.triu_indices_from(axes, 1)', '            for i, j in zip(*hide_indices):', '                axes[i, j].remove()', '                axes[i, j] = None', '', '        self._figure = fig', '        self.axes = axes', '        self.data = data', '', '        # Save what we are going to do with the diagonal', '        self.diag_sharey = diag_sharey', '        self.diag_vars = None', '        self.diag_axes = None', '', '        self._dropna = dropna', '', '        # Label the axes', '        self._add_axis_labels()', '', '        # Sort out the hue variable', '        self._hue_var = hue', '        if hue is None:', '            self.hue_names = hue_order = [\"_nolegend_\"]', '            self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),', '                                      index=data.index)', '        else:', '            # We need hue_order and hue_names because the former is used to control', '            # the order of drawing and the latter is used to control the order of', '            # the legend. hue_names can become string-typed while hue_order must', '            # retain the type of the input data. This is messy but results from', '            # the fact that PairGrid can implement the hue-mapping logic itself', '            # (and was originally written exclusively that way) but now can delegate', '            # to the axes-level functions, while always handling legend creation.', '            # See GH2307', '            hue_names = hue_order = categorical_order(data[hue], hue_order)', '            if dropna:', '                # Filter NA from the list of unique hue names', '                hue_names = list(filter(pd.notnull, hue_names))', '            self.hue_names = hue_names', '            self.hue_vals = data[hue]', '', '        # Additional dict of kwarg -> list of values for mapping the hue var', '        self.hue_kws = hue_kws if hue_kws is not None else {}', '', '        self._orig_palette = palette', '        self._hue_order = hue_order', '        self.palette = self._get_palette(data, hue, hue_order, palette)', '        self._legend_data = {}', '', '        # Make the plot look nice', '        for ax in axes[:-1, :].flat:', '            if ax is None:', '                continue', '            for label in ax.get_xticklabels():', '                label.set_visible(False)', '            ax.xaxis.offsetText.set_visible(False)', '            ax.xaxis.label.set_visible(False)', '', '        for ax in axes[:, 1:].flat:', '            if ax is None:', '                continue', '            for label in ax.get_yticklabels():', '                label.set_visible(False)', '            ax.yaxis.offsetText.set_visible(False)', '            ax.yaxis.label.set_visible(False)', '', '        self._tight_layout_rect = [.01, .01, .99, .99]', '        self._tight_layout_pad = layout_pad', '        self._despine = despine', '        if despine:', '            utils.despine(fig=fig)', '        self.tight_layout(pad=layout_pad)']}, {'name': 'map', 'start_line': 1360, 'end_line': 1375, 'text': ['    def map(self, func, **kwargs):', '        \"\"\"Plot with the same function in every subplot.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        row_indices, col_indices = np.indices(self.axes.shape)', '        indices = zip(row_indices.flat, col_indices.flat)', '        self._map_bivariate(func, indices, **kwargs)', '', '        return self']}, {'name': 'map_lower', 'start_line': 1377, 'end_line': 1390, 'text': ['    def map_lower(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the lower diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        indices = zip(*np.tril_indices_from(self.axes, -1))', '        self._map_bivariate(func, indices, **kwargs)', '        return self']}, {'name': 'map_upper', 'start_line': 1392, 'end_line': 1405, 'text': ['    def map_upper(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the upper diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        indices = zip(*np.triu_indices_from(self.axes, 1))', '        self._map_bivariate(func, indices, **kwargs)', '        return self']}, {'name': 'map_offdiag', 'start_line': 1407, 'end_line': 1429, 'text': ['    def map_offdiag(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the off-diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        if self.square_grid:', '            self.map_lower(func, **kwargs)', '            if not self._corner:', '                self.map_upper(func, **kwargs)', '        else:', '            indices = []', '            for i, (y_var) in enumerate(self.y_vars):', '                for j, (x_var) in enumerate(self.x_vars):', '                    if x_var != y_var:', '                        indices.append((i, j))', '            self._map_bivariate(func, indices, **kwargs)', '        return self']}, {'name': 'map_diag', 'start_line': 1431, 'end_line': 1511, 'text': ['    def map_diag(self, func, **kwargs):', '        \"\"\"Plot with a univariate function on each diagonal subplot.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take an x array as a positional argument and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        # Add special diagonal axes for the univariate plot', '        if self.diag_axes is None:', '            diag_vars = []', '            diag_axes = []', '            for i, y_var in enumerate(self.y_vars):', '                for j, x_var in enumerate(self.x_vars):', '                    if x_var == y_var:', '', '                        # Make the density axes', '                        diag_vars.append(x_var)', '                        ax = self.axes[i, j]', '                        diag_ax = ax.twinx()', '                        diag_ax.set_axis_off()', '                        diag_axes.append(diag_ax)', '', '                        # Work around matplotlib bug', '                        # https://github.com/matplotlib/matplotlib/issues/15188', '                        if not plt.rcParams.get(\"ytick.left\", True):', '                            for tick in ax.yaxis.majorTicks:', '                                tick.tick1line.set_visible(False)', '', '                        # Remove main y axis from density axes in a corner plot', '                        if self._corner:', '                            ax.yaxis.set_visible(False)', '                            if self._despine:', '                                utils.despine(ax=ax, left=True)', '                            # TODO add optional density ticks (on the right)', '                            # when drawing a corner plot?', '', '            if self.diag_sharey and diag_axes:', '                for ax in diag_axes[1:]:', '                    share_axis(diag_axes[0], ax, \"y\")', '', '            self.diag_vars = np.array(diag_vars, np.object_)', '            self.diag_axes = np.array(diag_axes, np.object_)', '', '        if \"hue\" not in signature(func).parameters:', '            return self._map_diag_iter_hue(func, **kwargs)', '', '        # Loop over diagonal variables and axes, making one plot in each', '        for var, ax in zip(self.diag_vars, self.diag_axes):', '', '            plot_kwargs = kwargs.copy()', '            if str(func.__module__).startswith(\"seaborn\"):', '                plot_kwargs[\"ax\"] = ax', '            else:', '                plt.sca(ax)', '', '            vector = self.data[var]', '            if self._hue_var is not None:', '                hue = self.data[self._hue_var]', '            else:', '                hue = None', '', '            if self._dropna:', '                not_na = vector.notna()', '                if hue is not None:', '                    not_na &= hue.notna()', '                vector = vector[not_na]', '                if hue is not None:', '                    hue = hue[not_na]', '', '            plot_kwargs.setdefault(\"hue\", hue)', '            plot_kwargs.setdefault(\"hue_order\", self._hue_order)', '            plot_kwargs.setdefault(\"palette\", self._orig_palette)', '            func(x=vector, **plot_kwargs)', '            ax.legend_ = None', '', '        self._add_axis_labels()', '        return self']}, {'name': '_map_diag_iter_hue', 'start_line': 1513, 'end_line': 1550, 'text': ['    def _map_diag_iter_hue(self, func, **kwargs):', '        \"\"\"Put marginal plot on each diagonal axes, iterating over hue.\"\"\"', '        # Plot on each of the diagonal axes', '        fixed_color = kwargs.pop(\"color\", None)', '', '        for var, ax in zip(self.diag_vars, self.diag_axes):', '            hue_grouped = self.data[var].groupby(self.hue_vals)', '', '            plot_kwargs = kwargs.copy()', '            if str(func.__module__).startswith(\"seaborn\"):', '                plot_kwargs[\"ax\"] = ax', '            else:', '                plt.sca(ax)', '', '            for k, label_k in enumerate(self._hue_order):', '', '                # Attempt to get data for this level, allowing for empty', '                try:', '                    data_k = hue_grouped.get_group(label_k)', '                except KeyError:', '                    data_k = pd.Series([], dtype=float)', '', '                if fixed_color is None:', '                    color = self.palette[k]', '                else:', '                    color = fixed_color', '', '                if self._dropna:', '                    data_k = utils.remove_na(data_k)', '', '                if str(func.__module__).startswith(\"seaborn\"):', '                    func(x=data_k, label=label_k, color=color, **plot_kwargs)', '                else:', '                    func(data_k, label=label_k, color=color, **plot_kwargs)', '', '        self._add_axis_labels()', '', '        return self']}, {'name': '_map_bivariate', 'start_line': 1552, 'end_line': 1572, 'text': ['    def _map_bivariate(self, func, indices, **kwargs):', '        \"\"\"Draw a bivariate plot on the indicated axes.\"\"\"', \"        # This is a hack to handle the fact that new distribution plots don't add\", '        # their artists onto the axes. This is probably superior in general, but', \"        # we'll need a better way to handle it in the axisgrid functions.\", '        from .distributions import histplot, kdeplot', '        if func is histplot or func is kdeplot:', '            self._extract_legend_handles = True', '', '        kws = kwargs.copy()  # Use copy as we insert other kwargs', '        for i, j in indices:', '            x_var = self.x_vars[j]', '            y_var = self.y_vars[i]', '            ax = self.axes[i, j]', '            if ax is None:  # i.e. we are in corner mode', '                continue', '            self._plot_bivariate(x_var, y_var, ax, func, **kws)', '        self._add_axis_labels()', '', '        if \"hue\" in signature(func).parameters:', '            self.hue_names = list(self._legend_data)']}, {'name': '_plot_bivariate', 'start_line': 1574, 'end_line': 1611, 'text': ['    def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):', '        \"\"\"Draw a bivariate plot on the specified axes.\"\"\"', '        if \"hue\" not in signature(func).parameters:', '            self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)', '            return', '', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = ax', '        else:', '            plt.sca(ax)', '', '        if x_var == y_var:', '            axes_vars = [x_var]', '        else:', '            axes_vars = [x_var, y_var]', '', '        if self._hue_var is not None and self._hue_var not in axes_vars:', '            axes_vars.append(self._hue_var)', '', '        data = self.data[axes_vars]', '        if self._dropna:', '            data = data.dropna()', '', '        x = data[x_var]', '        y = data[y_var]', '        if self._hue_var is None:', '            hue = None', '        else:', '            hue = data.get(self._hue_var)', '', '        if \"hue\" not in kwargs:', '            kwargs.update({', '                \"hue\": hue, \"hue_order\": self._hue_order, \"palette\": self._orig_palette,', '            })', '        func(x=x, y=y, **kwargs)', '', '        self._update_legend_data(ax)']}, {'name': '_plot_bivariate_iter_hue', 'start_line': 1613, 'end_line': 1655, 'text': ['    def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):', '        \"\"\"Draw a bivariate plot while iterating over hue subsets.\"\"\"', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = ax', '        else:', '            plt.sca(ax)', '', '        if x_var == y_var:', '            axes_vars = [x_var]', '        else:', '            axes_vars = [x_var, y_var]', '', '        hue_grouped = self.data.groupby(self.hue_vals)', '        for k, label_k in enumerate(self._hue_order):', '', '            kws = kwargs.copy()', '', '            # Attempt to get data for this level, allowing for empty', '            try:', '                data_k = hue_grouped.get_group(label_k)', '            except KeyError:', '                data_k = pd.DataFrame(columns=axes_vars,', '                                      dtype=float)', '', '            if self._dropna:', '                data_k = data_k[axes_vars].dropna()', '', '            x = data_k[x_var]', '            y = data_k[y_var]', '', '            for kw, val_list in self.hue_kws.items():', '                kws[kw] = val_list[k]', '            kws.setdefault(\"color\", self.palette[k])', '            if self._hue_var is not None:', '                kws[\"label\"] = label_k', '', '            if str(func.__module__).startswith(\"seaborn\"):', '                func(x=x, y=y, **kws)', '            else:', '                func(x, y, **kws)', '', '        self._update_legend_data(ax)']}, {'name': '_add_axis_labels', 'start_line': 1657, 'end_line': 1662, 'text': ['    def _add_axis_labels(self):', '        \"\"\"Add labels to the left and bottom Axes.\"\"\"', '        for ax, label in zip(self.axes[-1, :], self.x_vars):', '            ax.set_xlabel(label)', '        for ax, label in zip(self.axes[:, 0], self.y_vars):', '            ax.set_ylabel(label)']}, {'name': '_find_numeric_cols', 'start_line': 1664, 'end_line': 1670, 'text': ['    def _find_numeric_cols(self, data):', '        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"', '        numeric_cols = []', '        for col in data:', '            if variable_type(data[col]) == \"numeric\":', '                numeric_cols.append(col)', '        return numeric_cols']}]}, {'name': 'JointGrid', 'start_line': 1673, 'end_line': 1958, 'text': ['class JointGrid(_BaseGrid):', '    \"\"\"Grid for drawing a bivariate plot with marginal univariate plots.', '', '    Many plots can be drawn by using the figure-level interface :func:`jointplot`.', '    Use this class directly when you need more flexibility.', '', '    \"\"\"', '', '    def __init__(', '        self, data=None, *,', '        x=None, y=None, hue=None,', '        height=6, ratio=5, space=.2,', '        palette=None, hue_order=None, hue_norm=None,', '        dropna=False, xlim=None, ylim=None, marginal_ticks=False,', '    ):', '', '        # Set up the subplot grid', '        f = plt.figure(figsize=(height, height))', '        gs = plt.GridSpec(ratio + 1, ratio + 1)', '', '        ax_joint = f.add_subplot(gs[1:, :-1])', '        ax_marg_x = f.add_subplot(gs[0, :-1], sharex=ax_joint)', '        ax_marg_y = f.add_subplot(gs[1:, -1], sharey=ax_joint)', '', '        self._figure = f', '        self.ax_joint = ax_joint', '        self.ax_marg_x = ax_marg_x', '        self.ax_marg_y = ax_marg_y', '', '        # Turn off tick visibility for the measure axis on the marginal plots', '        plt.setp(ax_marg_x.get_xticklabels(), visible=False)', '        plt.setp(ax_marg_y.get_yticklabels(), visible=False)', '        plt.setp(ax_marg_x.get_xticklabels(minor=True), visible=False)', '        plt.setp(ax_marg_y.get_yticklabels(minor=True), visible=False)', '', '        # Turn off the ticks on the density axis for the marginal plots', '        if not marginal_ticks:', '            plt.setp(ax_marg_x.yaxis.get_majorticklines(), visible=False)', '            plt.setp(ax_marg_x.yaxis.get_minorticklines(), visible=False)', '            plt.setp(ax_marg_y.xaxis.get_majorticklines(), visible=False)', '            plt.setp(ax_marg_y.xaxis.get_minorticklines(), visible=False)', '            plt.setp(ax_marg_x.get_yticklabels(), visible=False)', '            plt.setp(ax_marg_y.get_xticklabels(), visible=False)', '            plt.setp(ax_marg_x.get_yticklabels(minor=True), visible=False)', '            plt.setp(ax_marg_y.get_xticklabels(minor=True), visible=False)', '            ax_marg_x.yaxis.grid(False)', '            ax_marg_y.xaxis.grid(False)', '', '        # Process the input variables', '        p = VectorPlotter(data=data, variables=dict(x=x, y=y, hue=hue))', '        plot_data = p.plot_data.loc[:, p.plot_data.notna().any()]', '', '        # Possibly drop NA', '        if dropna:', '            plot_data = plot_data.dropna()', '', '        def get_var(var):', '            vector = plot_data.get(var, None)', '            if vector is not None:', '                vector = vector.rename(p.variables.get(var, None))', '            return vector', '', '        self.x = get_var(\"x\")', '        self.y = get_var(\"y\")', '        self.hue = get_var(\"hue\")', '', '        for axis in \"xy\":', '            name = p.variables.get(axis, None)', '            if name is not None:', '                getattr(ax_joint, f\"set_{axis}label\")(name)', '', '        if xlim is not None:', '            ax_joint.set_xlim(xlim)', '        if ylim is not None:', '            ax_joint.set_ylim(ylim)', '', '        # Store the semantic mapping parameters for axes-level functions', '        self._hue_params = dict(palette=palette, hue_order=hue_order, hue_norm=hue_norm)', '', '        # Make the grid look nice', '        utils.despine(f)', '        if not marginal_ticks:', '            utils.despine(ax=ax_marg_x, left=True)', '            utils.despine(ax=ax_marg_y, bottom=True)', '        for axes in [ax_marg_x, ax_marg_y]:', '            for axis in [axes.xaxis, axes.yaxis]:', '                axis.label.set_visible(False)', '        f.tight_layout()', '        f.subplots_adjust(hspace=space, wspace=space)', '', '    def _inject_kwargs(self, func, kws, params):', '        \"\"\"Add params to kws if they are accepted by func.\"\"\"', '        func_params = signature(func).parameters', '        for key, val in params.items():', '            if key in func_params:', '                kws.setdefault(key, val)', '', '    def plot(self, joint_func, marginal_func, **kwargs):', '        \"\"\"Draw the plot by passing functions for joint and marginal axes.', '', '        This method passes the ``kwargs`` dictionary to both functions. If you', '        need more control, call :meth:`JointGrid.plot_joint` and', '        :meth:`JointGrid.plot_marginals` directly with specific parameters.', '', '        Parameters', '        ----------', '        joint_func, marginal_func : callables', '            Functions to draw the bivariate and univariate plots. See methods', '            referenced above for information about the required characteristics', '            of these functions.', '        kwargs', '            Additional keyword arguments are passed to both functions.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        self.plot_marginals(marginal_func, **kwargs)', '        self.plot_joint(joint_func, **kwargs)', '        return self', '', '    def plot_joint(self, func, **kwargs):', '        \"\"\"Draw a bivariate plot on the joint axes of the grid.', '', '        Parameters', '        ----------', '        func : plotting callable', '            If a seaborn function, it should accept ``x`` and ``y``. Otherwise,', '            it must accept ``x`` and ``y`` vectors of data as the first two', '            positional arguments, and it must plot on the \"current\" axes.', '            If ``hue`` was defined in the class constructor, the function must', '            accept ``hue`` as a parameter.', '        kwargs', '            Keyword argument are passed to the plotting function.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = self.ax_joint', '        else:', '            plt.sca(self.ax_joint)', '        if self.hue is not None:', '            kwargs[\"hue\"] = self.hue', '            self._inject_kwargs(func, kwargs, self._hue_params)', '', '        if str(func.__module__).startswith(\"seaborn\"):', '            func(x=self.x, y=self.y, **kwargs)', '        else:', '            func(self.x, self.y, **kwargs)', '', '        return self', '', '    def plot_marginals(self, func, **kwargs):', '        \"\"\"Draw univariate plots on each marginal axes.', '', '        Parameters', '        ----------', '        func : plotting callable', '            If a seaborn function, it should  accept ``x`` and ``y`` and plot', '            when only one of them is defined. Otherwise, it must accept a vector', '            of data as the first positional argument and determine its orientation', '            using the ``vertical`` parameter, and it must plot on the \"current\" axes.', '            If ``hue`` was defined in the class constructor, it must accept ``hue``', '            as a parameter.', '        kwargs', '            Keyword argument are passed to the plotting function.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        seaborn_func = (', '            str(func.__module__).startswith(\"seaborn\")', '            # deprecated distplot has a legacy API, special case it', '            and not func.__name__ == \"distplot\"', '        )', '        func_params = signature(func).parameters', '        kwargs = kwargs.copy()', '        if self.hue is not None:', '            kwargs[\"hue\"] = self.hue', '            self._inject_kwargs(func, kwargs, self._hue_params)', '', '        if \"legend\" in func_params:', '            kwargs.setdefault(\"legend\", False)', '', '        if \"orientation\" in func_params:', '            # e.g. plt.hist', '            orient_kw_x = {\"orientation\": \"vertical\"}', '            orient_kw_y = {\"orientation\": \"horizontal\"}', '        elif \"vertical\" in func_params:', '            # e.g. sns.distplot (also how did this get backwards?)', '            orient_kw_x = {\"vertical\": False}', '            orient_kw_y = {\"vertical\": True}', '', '        if seaborn_func:', '            func(x=self.x, ax=self.ax_marg_x, **kwargs)', '        else:', '            plt.sca(self.ax_marg_x)', '            func(self.x, **orient_kw_x, **kwargs)', '', '        if seaborn_func:', '            func(y=self.y, ax=self.ax_marg_y, **kwargs)', '        else:', '            plt.sca(self.ax_marg_y)', '            func(self.y, **orient_kw_y, **kwargs)', '', '        self.ax_marg_x.yaxis.get_label().set_visible(False)', '        self.ax_marg_y.xaxis.get_label().set_visible(False)', '', '        return self', '', '    def refline(', '        self, *, x=None, y=None, joint=True, marginal=True,', \"        color='.5', linestyle='--', **line_kws\", '    ):', '        \"\"\"Add a reference line(s) to joint and/or marginal axes.', '', '        Parameters', '        ----------', '        x, y : numeric', '            Value(s) to draw the line(s) at.', '        joint, marginal : bools', '            Whether to add the reference line(s) to the joint/marginal axes.', '        color : :mod:`matplotlib color <matplotlib.colors>`', '            Specifies the color of the reference line(s).', '        linestyle : str', '            Specifies the style of the reference line(s).', '        line_kws : key, value mappings', '            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`', '            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``', '            is not None.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', \"        line_kws['color'] = color\", \"        line_kws['linestyle'] = linestyle\", '', '        if x is not None:', '            if joint:', '                self.ax_joint.axvline(x, **line_kws)', '            if marginal:', '                self.ax_marg_x.axvline(x, **line_kws)', '', '        if y is not None:', '            if joint:', '                self.ax_joint.axhline(y, **line_kws)', '            if marginal:', '                self.ax_marg_y.axhline(y, **line_kws)', '', '        return self', '', '    def set_axis_labels(self, xlabel=\"\", ylabel=\"\", **kwargs):', '        \"\"\"Set axis labels on the bivariate axes.', '', '        Parameters', '        ----------', '        xlabel, ylabel : strings', '            Label names for the x and y variables.', '        kwargs : key, value mappings', '            Other keyword arguments are passed to the following functions:', '', '            - :meth:`matplotlib.axes.Axes.set_xlabel`', '            - :meth:`matplotlib.axes.Axes.set_ylabel`', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        self.ax_joint.set_xlabel(xlabel, **kwargs)', '        self.ax_joint.set_ylabel(ylabel, **kwargs)', '        return self'], 'methods': [{'name': '__init__', 'start_line': 1681, 'end_line': 1761, 'text': ['    def __init__(', '        self, data=None, *,', '        x=None, y=None, hue=None,', '        height=6, ratio=5, space=.2,', '        palette=None, hue_order=None, hue_norm=None,', '        dropna=False, xlim=None, ylim=None, marginal_ticks=False,', '    ):', '', '        # Set up the subplot grid', '        f = plt.figure(figsize=(height, height))', '        gs = plt.GridSpec(ratio + 1, ratio + 1)', '', '        ax_joint = f.add_subplot(gs[1:, :-1])', '        ax_marg_x = f.add_subplot(gs[0, :-1], sharex=ax_joint)', '        ax_marg_y = f.add_subplot(gs[1:, -1], sharey=ax_joint)', '', '        self._figure = f', '        self.ax_joint = ax_joint', '        self.ax_marg_x = ax_marg_x', '        self.ax_marg_y = ax_marg_y', '', '        # Turn off tick visibility for the measure axis on the marginal plots', '        plt.setp(ax_marg_x.get_xticklabels(), visible=False)', '        plt.setp(ax_marg_y.get_yticklabels(), visible=False)', '        plt.setp(ax_marg_x.get_xticklabels(minor=True), visible=False)', '        plt.setp(ax_marg_y.get_yticklabels(minor=True), visible=False)', '', '        # Turn off the ticks on the density axis for the marginal plots', '        if not marginal_ticks:', '            plt.setp(ax_marg_x.yaxis.get_majorticklines(), visible=False)', '            plt.setp(ax_marg_x.yaxis.get_minorticklines(), visible=False)', '            plt.setp(ax_marg_y.xaxis.get_majorticklines(), visible=False)', '            plt.setp(ax_marg_y.xaxis.get_minorticklines(), visible=False)', '            plt.setp(ax_marg_x.get_yticklabels(), visible=False)', '            plt.setp(ax_marg_y.get_xticklabels(), visible=False)', '            plt.setp(ax_marg_x.get_yticklabels(minor=True), visible=False)', '            plt.setp(ax_marg_y.get_xticklabels(minor=True), visible=False)', '            ax_marg_x.yaxis.grid(False)', '            ax_marg_y.xaxis.grid(False)', '', '        # Process the input variables', '        p = VectorPlotter(data=data, variables=dict(x=x, y=y, hue=hue))', '        plot_data = p.plot_data.loc[:, p.plot_data.notna().any()]', '', '        # Possibly drop NA', '        if dropna:', '            plot_data = plot_data.dropna()', '', '        def get_var(var):', '            vector = plot_data.get(var, None)', '            if vector is not None:', '                vector = vector.rename(p.variables.get(var, None))', '            return vector', '', '        self.x = get_var(\"x\")', '        self.y = get_var(\"y\")', '        self.hue = get_var(\"hue\")', '', '        for axis in \"xy\":', '            name = p.variables.get(axis, None)', '            if name is not None:', '                getattr(ax_joint, f\"set_{axis}label\")(name)', '', '        if xlim is not None:', '            ax_joint.set_xlim(xlim)', '        if ylim is not None:', '            ax_joint.set_ylim(ylim)', '', '        # Store the semantic mapping parameters for axes-level functions', '        self._hue_params = dict(palette=palette, hue_order=hue_order, hue_norm=hue_norm)', '', '        # Make the grid look nice', '        utils.despine(f)', '        if not marginal_ticks:', '            utils.despine(ax=ax_marg_x, left=True)', '            utils.despine(ax=ax_marg_y, bottom=True)', '        for axes in [ax_marg_x, ax_marg_y]:', '            for axis in [axes.xaxis, axes.yaxis]:', '                axis.label.set_visible(False)', '        f.tight_layout()', '        f.subplots_adjust(hspace=space, wspace=space)']}, {'name': '_inject_kwargs', 'start_line': 1763, 'end_line': 1768, 'text': ['    def _inject_kwargs(self, func, kws, params):', '        \"\"\"Add params to kws if they are accepted by func.\"\"\"', '        func_params = signature(func).parameters', '        for key, val in params.items():', '            if key in func_params:', '                kws.setdefault(key, val)']}, {'name': 'plot', 'start_line': 1770, 'end_line': 1794, 'text': ['    def plot(self, joint_func, marginal_func, **kwargs):', '        \"\"\"Draw the plot by passing functions for joint and marginal axes.', '', '        This method passes the ``kwargs`` dictionary to both functions. If you', '        need more control, call :meth:`JointGrid.plot_joint` and', '        :meth:`JointGrid.plot_marginals` directly with specific parameters.', '', '        Parameters', '        ----------', '        joint_func, marginal_func : callables', '            Functions to draw the bivariate and univariate plots. See methods', '            referenced above for information about the required characteristics', '            of these functions.', '        kwargs', '            Additional keyword arguments are passed to both functions.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        self.plot_marginals(marginal_func, **kwargs)', '        self.plot_joint(joint_func, **kwargs)', '        return self']}, {'name': 'plot_joint', 'start_line': 1796, 'end_line': 1830, 'text': ['    def plot_joint(self, func, **kwargs):', '        \"\"\"Draw a bivariate plot on the joint axes of the grid.', '', '        Parameters', '        ----------', '        func : plotting callable', '            If a seaborn function, it should accept ``x`` and ``y``. Otherwise,', '            it must accept ``x`` and ``y`` vectors of data as the first two', '            positional arguments, and it must plot on the \"current\" axes.', '            If ``hue`` was defined in the class constructor, the function must', '            accept ``hue`` as a parameter.', '        kwargs', '            Keyword argument are passed to the plotting function.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = self.ax_joint', '        else:', '            plt.sca(self.ax_joint)', '        if self.hue is not None:', '            kwargs[\"hue\"] = self.hue', '            self._inject_kwargs(func, kwargs, self._hue_params)', '', '        if str(func.__module__).startswith(\"seaborn\"):', '            func(x=self.x, y=self.y, **kwargs)', '        else:', '            func(self.x, self.y, **kwargs)', '', '        return self']}, {'name': 'plot_marginals', 'start_line': 1832, 'end_line': 1891, 'text': ['    def plot_marginals(self, func, **kwargs):', '        \"\"\"Draw univariate plots on each marginal axes.', '', '        Parameters', '        ----------', '        func : plotting callable', '            If a seaborn function, it should  accept ``x`` and ``y`` and plot', '            when only one of them is defined. Otherwise, it must accept a vector', '            of data as the first positional argument and determine its orientation', '            using the ``vertical`` parameter, and it must plot on the \"current\" axes.', '            If ``hue`` was defined in the class constructor, it must accept ``hue``', '            as a parameter.', '        kwargs', '            Keyword argument are passed to the plotting function.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        seaborn_func = (', '            str(func.__module__).startswith(\"seaborn\")', '            # deprecated distplot has a legacy API, special case it', '            and not func.__name__ == \"distplot\"', '        )', '        func_params = signature(func).parameters', '        kwargs = kwargs.copy()', '        if self.hue is not None:', '            kwargs[\"hue\"] = self.hue', '            self._inject_kwargs(func, kwargs, self._hue_params)', '', '        if \"legend\" in func_params:', '            kwargs.setdefault(\"legend\", False)', '', '        if \"orientation\" in func_params:', '            # e.g. plt.hist', '            orient_kw_x = {\"orientation\": \"vertical\"}', '            orient_kw_y = {\"orientation\": \"horizontal\"}', '        elif \"vertical\" in func_params:', '            # e.g. sns.distplot (also how did this get backwards?)', '            orient_kw_x = {\"vertical\": False}', '            orient_kw_y = {\"vertical\": True}', '', '        if seaborn_func:', '            func(x=self.x, ax=self.ax_marg_x, **kwargs)', '        else:', '            plt.sca(self.ax_marg_x)', '            func(self.x, **orient_kw_x, **kwargs)', '', '        if seaborn_func:', '            func(y=self.y, ax=self.ax_marg_y, **kwargs)', '        else:', '            plt.sca(self.ax_marg_y)', '            func(self.y, **orient_kw_y, **kwargs)', '', '        self.ax_marg_x.yaxis.get_label().set_visible(False)', '        self.ax_marg_y.xaxis.get_label().set_visible(False)', '', '        return self']}, {'name': 'refline', 'start_line': 1893, 'end_line': 1935, 'text': ['    def refline(', '        self, *, x=None, y=None, joint=True, marginal=True,', \"        color='.5', linestyle='--', **line_kws\", '    ):', '        \"\"\"Add a reference line(s) to joint and/or marginal axes.', '', '        Parameters', '        ----------', '        x, y : numeric', '            Value(s) to draw the line(s) at.', '        joint, marginal : bools', '            Whether to add the reference line(s) to the joint/marginal axes.', '        color : :mod:`matplotlib color <matplotlib.colors>`', '            Specifies the color of the reference line(s).', '        linestyle : str', '            Specifies the style of the reference line(s).', '        line_kws : key, value mappings', '            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`', '            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``', '            is not None.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', \"        line_kws['color'] = color\", \"        line_kws['linestyle'] = linestyle\", '', '        if x is not None:', '            if joint:', '                self.ax_joint.axvline(x, **line_kws)', '            if marginal:', '                self.ax_marg_x.axvline(x, **line_kws)', '', '        if y is not None:', '            if joint:', '                self.ax_joint.axhline(y, **line_kws)', '            if marginal:', '                self.ax_marg_y.axhline(y, **line_kws)', '', '        return self']}, {'name': 'set_axis_labels', 'start_line': 1937, 'end_line': 1958, 'text': ['    def set_axis_labels(self, xlabel=\"\", ylabel=\"\", **kwargs):', '        \"\"\"Set axis labels on the bivariate axes.', '', '        Parameters', '        ----------', '        xlabel, ylabel : strings', '            Label names for the x and y variables.', '        kwargs : key, value mappings', '            Other keyword arguments are passed to the following functions:', '', '            - :meth:`matplotlib.axes.Axes.set_xlabel`', '            - :meth:`matplotlib.axes.Axes.set_ylabel`', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        self.ax_joint.set_xlabel(xlabel, **kwargs)', '        self.ax_joint.set_ylabel(ylabel, **kwargs)', '        return self']}]}], 'functions': [{'name': 'pairplot', 'start_line': 2005, 'end_line': 2176, 'text': ['def pairplot(', '    data, *,', '    hue=None, hue_order=None, palette=None,', '    vars=None, x_vars=None, y_vars=None,', '    kind=\"scatter\", diag_kind=\"auto\", markers=None,', '    height=2.5, aspect=1, corner=False, dropna=False,', '    plot_kws=None, diag_kws=None, grid_kws=None, size=None,', '):', '    \"\"\"Plot pairwise relationships in a dataset.', '', '    By default, this function will create a grid of Axes such that each numeric', '    variable in ``data`` will by shared across the y-axes across a single row and', '    the x-axes across a single column. The diagonal plots are treated', '    differently: a univariate distribution plot is drawn to show the marginal', '    distribution of the data in each column.', '', '    It is also possible to show a subset of variables or plot different', '    variables on the rows and columns.', '', '    This is a high-level interface for :class:`PairGrid` that is intended to', '    make it easy to draw a few common styles. You should use :class:`PairGrid`', '    directly if you need more flexibility.', '', '    Parameters', '    ----------', '    data : `pandas.DataFrame`', '        Tidy (long-form) dataframe where each column is a variable and', '        each row is an observation.', '    hue : name of variable in ``data``', '        Variable in ``data`` to map plot aspects to different colors.', '    hue_order : list of strings', '        Order for the levels of the hue variable in the palette', '    palette : dict or seaborn color palette', '        Set of colors for mapping the ``hue`` variable. If a dict, keys', '        should be values  in the ``hue`` variable.', '    vars : list of variable names', '        Variables within ``data`` to use, otherwise use every column with', '        a numeric datatype.', '    {x, y}_vars : lists of variable names', '        Variables within ``data`` to use separately for the rows and', '        columns of the figure; i.e. to make a non-square plot.', \"    kind : {'scatter', 'kde', 'hist', 'reg'}\", '        Kind of plot to make.', \"    diag_kind : {'auto', 'hist', 'kde', None}\", \"        Kind of plot for the diagonal subplots. If 'auto', choose based on\", '        whether or not ``hue`` is used.', '    markers : single matplotlib marker code or list', '        Either the marker to use for all scatterplot points or a list of markers', '        with a length the same as the number of levels in the hue variable so that', '        differently colored points will also have different scatterplot', '        markers.', '    height : scalar', '        Height (in inches) of each facet.', '    aspect : scalar', '        Aspect * height gives the width (in inches) of each facet.', '    corner : bool', \"        If True, don't add axes to the upper (off-diagonal) triangle of the\", '        grid, making this a \"corner\" plot.', '    dropna : boolean', '        Drop missing values from the data before plotting.', '    {plot, diag, grid}_kws : dicts', '        Dictionaries of keyword arguments. ``plot_kws`` are passed to the', '        bivariate plotting function, ``diag_kws`` are passed to the univariate', '        plotting function, and ``grid_kws`` are passed to the :class:`PairGrid`', '        constructor.', '', '    Returns', '    -------', '    grid : :class:`PairGrid`', '        Returns the underlying :class:`PairGrid` instance for further tweaking.', '', '    See Also', '    --------', '    PairGrid : Subplot grid for more flexible plotting of pairwise relationships.', '    JointGrid : Grid for plotting joint and marginal distributions of two variables.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/pairplot.rst', '', '    \"\"\"', '    # Avoid circular import', '    from .distributions import histplot, kdeplot', '', '    # Handle deprecations', '    if size is not None:', '        height = size', '        msg = (\"The `size` parameter has been renamed to `height`; \"', '               \"please update your code.\")', '        warnings.warn(msg, UserWarning)', '', '    if not isinstance(data, pd.DataFrame):', '        raise TypeError(', '            f\"\\'data\\' must be pandas DataFrame object, not: {type(data)}\")', '', '    plot_kws = {} if plot_kws is None else plot_kws.copy()', '    diag_kws = {} if diag_kws is None else diag_kws.copy()', '    grid_kws = {} if grid_kws is None else grid_kws.copy()', '', '    # Resolve \"auto\" diag kind', '    if diag_kind == \"auto\":', '        if hue is None:', '            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"', '        else:', '            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"', '', '    # Set up the PairGrid', '    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")', '    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,', '                    hue_order=hue_order, palette=palette, corner=corner,', '                    height=height, aspect=aspect, dropna=dropna, **grid_kws)', '', '    # Add the markers here as PairGrid has figured out how many levels of the', \"    # hue variable are needed and we don't want to duplicate that process\", '    if markers is not None:', '        if kind == \"reg\":', '            # Needed until regplot supports style', '            if grid.hue_names is None:', '                n_markers = 1', '            else:', '                n_markers = len(grid.hue_names)', '            if not isinstance(markers, list):', '                markers = [markers] * n_markers', '            if len(markers) != n_markers:', '                raise ValueError(\"markers must be a singleton or a list of \"', '                                 \"markers for each level of the hue variable\")', '            grid.hue_kws = {\"marker\": markers}', '        elif kind == \"scatter\":', '            if isinstance(markers, str):', '                plot_kws[\"marker\"] = markers', '            elif hue is not None:', '                plot_kws[\"style\"] = data[hue]', '                plot_kws[\"markers\"] = markers', '', '    # Draw the marginal plots on the diagonal', '    diag_kws = diag_kws.copy()', '    diag_kws.setdefault(\"legend\", False)', '    if diag_kind == \"hist\":', '        grid.map_diag(histplot, **diag_kws)', '    elif diag_kind == \"kde\":', '        diag_kws.setdefault(\"fill\", True)', '        diag_kws.setdefault(\"warn_singular\", False)', '        grid.map_diag(kdeplot, **diag_kws)', '', '    # Maybe plot on the off-diagonals', '    if diag_kind is not None:', '        plotter = grid.map_offdiag', '    else:', '        plotter = grid.map', '', '    if kind == \"scatter\":', '        from .relational import scatterplot  # Avoid circular import', '        plotter(scatterplot, **plot_kws)', '    elif kind == \"reg\":', '        from .regression import regplot  # Avoid circular import', '        plotter(regplot, **plot_kws)', '    elif kind == \"kde\":', '        from .distributions import kdeplot  # Avoid circular import', '        plot_kws.setdefault(\"warn_singular\", False)', '        plotter(kdeplot, **plot_kws)', '    elif kind == \"hist\":', '        from .distributions import histplot  # Avoid circular import', '        plotter(histplot, **plot_kws)', '', '    # Add a legend', '    if hue is not None:', '        grid.add_legend()', '', '    grid.tight_layout()', '', '    return grid']}, {'name': 'jointplot', 'start_line': 2179, 'end_line': 2339, 'text': ['def jointplot(', '    data=None, *, x=None, y=None, hue=None, kind=\"scatter\",', '    height=6, ratio=5, space=.2, dropna=False, xlim=None, ylim=None,', '    color=None, palette=None, hue_order=None, hue_norm=None, marginal_ticks=False,', '    joint_kws=None, marginal_kws=None,', '    **kwargs', '):', '    # Avoid circular imports', '    from .relational import scatterplot', '    from .regression import regplot, residplot', '    from .distributions import histplot, kdeplot, _freedman_diaconis_bins', '', '    if kwargs.pop(\"ax\", None) is not None:', '        msg = \"Ignoring `ax`; jointplot is a figure-level function.\"', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # Set up empty default kwarg dicts', '    joint_kws = {} if joint_kws is None else joint_kws.copy()', '    joint_kws.update(kwargs)', '    marginal_kws = {} if marginal_kws is None else marginal_kws.copy()', '', '    # Handle deprecations of distplot-specific kwargs', '    distplot_keys = [', '        \"rug\", \"fit\", \"hist_kws\", \"norm_hist\" \"hist_kws\", \"rug_kws\",', '    ]', '    unused_keys = []', '    for key in distplot_keys:', '        if key in marginal_kws:', '            unused_keys.append(key)', '            marginal_kws.pop(key)', '    if unused_keys and kind != \"kde\":', '        msg = (', '            \"The marginal plotting function has changed to `histplot`,\"', '            \" which does not accept the following argument(s): {}.\"', '        ).format(\", \".join(unused_keys))', '        warnings.warn(msg, UserWarning)', '', '    # Validate the plot kind', '    plot_kinds = [\"scatter\", \"hist\", \"hex\", \"kde\", \"reg\", \"resid\"]', '    _check_argument(\"kind\", plot_kinds, kind)', '', '    # Raise early if using `hue` with a kind that does not support it', '    if hue is not None and kind in [\"hex\", \"reg\", \"resid\"]:', '        msg = (', '            f\"Use of `hue` with `kind=\\'{kind}\\'` is not currently supported.\"', '        )', '        raise ValueError(msg)', '', '    # Make a colormap based off the plot color', '    # (Currently used only for kind=\"hex\")', '    if color is None:', '        color = \"C0\"', '    color_rgb = mpl.colors.colorConverter.to_rgb(color)', '    colors = [utils.set_hls_values(color_rgb, l=l)  # noqa', '              for l in np.linspace(1, 0, 12)]', '    cmap = blend_palette(colors, as_cmap=True)', '', \"    # Matplotlib's hexbin plot is not na-robust\", '    if kind == \"hex\":', '        dropna = True', '', '    # Initialize the JointGrid object', '    grid = JointGrid(', '        data=data, x=x, y=y, hue=hue,', '        palette=palette, hue_order=hue_order, hue_norm=hue_norm,', '        dropna=dropna, height=height, ratio=ratio, space=space,', '        xlim=xlim, ylim=ylim, marginal_ticks=marginal_ticks,', '    )', '', '    if grid.hue is not None:', '        marginal_kws.setdefault(\"legend\", False)', '', '    # Plot the data using the grid', '    if kind.startswith(\"scatter\"):', '', '        joint_kws.setdefault(\"color\", color)', '        grid.plot_joint(scatterplot, **joint_kws)', '', '        if grid.hue is None:', '            marg_func = histplot', '        else:', '            marg_func = kdeplot', '            marginal_kws.setdefault(\"warn_singular\", False)', '            marginal_kws.setdefault(\"fill\", True)', '', '        marginal_kws.setdefault(\"color\", color)', '        grid.plot_marginals(marg_func, **marginal_kws)', '', '    elif kind.startswith(\"hist\"):', '', '        # TODO process pair parameters for bins, etc. and pass', '        # to both joint and marginal plots', '', '        joint_kws.setdefault(\"color\", color)', '        grid.plot_joint(histplot, **joint_kws)', '', '        marginal_kws.setdefault(\"kde\", False)', '        marginal_kws.setdefault(\"color\", color)', '', '        marg_x_kws = marginal_kws.copy()', '        marg_y_kws = marginal_kws.copy()', '', '        pair_keys = \"bins\", \"binwidth\", \"binrange\"', '        for key in pair_keys:', '            if isinstance(joint_kws.get(key), tuple):', '                x_val, y_val = joint_kws[key]', '                marg_x_kws.setdefault(key, x_val)', '                marg_y_kws.setdefault(key, y_val)', '', '        histplot(data=data, x=x, hue=hue, **marg_x_kws, ax=grid.ax_marg_x)', '        histplot(data=data, y=y, hue=hue, **marg_y_kws, ax=grid.ax_marg_y)', '', '    elif kind.startswith(\"kde\"):', '', '        joint_kws.setdefault(\"color\", color)', '        joint_kws.setdefault(\"warn_singular\", False)', '        grid.plot_joint(kdeplot, **joint_kws)', '', '        marginal_kws.setdefault(\"color\", color)', '        if \"fill\" in joint_kws:', '            marginal_kws.setdefault(\"fill\", joint_kws[\"fill\"])', '', '        grid.plot_marginals(kdeplot, **marginal_kws)', '', '    elif kind.startswith(\"hex\"):', '', '        x_bins = min(_freedman_diaconis_bins(grid.x), 50)', '        y_bins = min(_freedman_diaconis_bins(grid.y), 50)', '        gridsize = int(np.mean([x_bins, y_bins]))', '', '        joint_kws.setdefault(\"gridsize\", gridsize)', '        joint_kws.setdefault(\"cmap\", cmap)', '        grid.plot_joint(plt.hexbin, **joint_kws)', '', '        marginal_kws.setdefault(\"kde\", False)', '        marginal_kws.setdefault(\"color\", color)', '        grid.plot_marginals(histplot, **marginal_kws)', '', '    elif kind.startswith(\"reg\"):', '', '        marginal_kws.setdefault(\"color\", color)', '        marginal_kws.setdefault(\"kde\", True)', '        grid.plot_marginals(histplot, **marginal_kws)', '', '        joint_kws.setdefault(\"color\", color)', '        grid.plot_joint(regplot, **joint_kws)', '', '    elif kind.startswith(\"resid\"):', '', '        joint_kws.setdefault(\"color\", color)', '        grid.plot_joint(residplot, **joint_kws)', '', '        x, y = grid.ax_joint.collections[0].get_offsets().T', '        marginal_kws.setdefault(\"color\", color)', '        histplot(x=x, hue=hue, ax=grid.ax_marg_x, **marginal_kws)', '        histplot(y=y, hue=hue, ax=grid.ax_marg_y, **marginal_kws)', '', '    # Make the main axes active in the matplotlib state machine', '    plt.sca(grid.ax_joint)', '', '    return grid']}, {'name': 'get_var', 'start_line': 1729, 'end_line': 1733, 'text': ['        def get_var(var):', '            vector = plot_data.get(var, None)', '            if vector is not None:', '                vector = vector.rename(p.variables.get(var, None))', '            return vector']}], 'text': ['from __future__ import annotations', 'from itertools import product', 'from inspect import signature', 'import warnings', 'from textwrap import dedent', '', 'import numpy as np', 'import pandas as pd', 'import matplotlib as mpl', 'import matplotlib.pyplot as plt', '', 'from ._oldcore import VectorPlotter, variable_type, categorical_order', 'from ._compat import share_axis', 'from . import utils', 'from .utils import (', '    adjust_legend_subtitles, _check_argument, _draw_figure, _disable_autolayout', ')', 'from .palettes import color_palette, blend_palette', 'from ._docstrings import (', '    DocstringComponents,', '    _core_docs,', ')', '', '__all__ = [\"FacetGrid\", \"PairGrid\", \"JointGrid\", \"pairplot\", \"jointplot\"]', '', '', '_param_docs = DocstringComponents.from_nested_components(', '    core=_core_docs[\"params\"],', ')', '', '', 'class _BaseGrid:', '    \"\"\"Base class for grids of subplots.\"\"\"', '', '    def set(self, **kwargs):', '        \"\"\"Set attributes on each subplot Axes.\"\"\"', '        for ax in self.axes.flat:', '            if ax is not None:  # Handle removed axes', '                ax.set(**kwargs)', '        return self', '', '    @property', '    def fig(self):', '        \"\"\"DEPRECATED: prefer the `figure` property.\"\"\"', '        # Grid.figure is preferred because it matches the Axes attribute name.', '        # But as the maintanace burden on having this property is minimal,', \"        # let's be slow about formally deprecating it. For now just note its deprecation\", '        # in the docstring; add a warning in version 0.13, and eventually remove it.', '        return self._figure', '', '    @property', '    def figure(self):', '        \"\"\"Access the :class:`matplotlib.figure.Figure` object underlying the grid.\"\"\"', '        return self._figure', '', '    def apply(self, func, *args, **kwargs):', '        \"\"\"', '        Pass the grid to a user-supplied function and return self.', '', '        The `func` must accept an object of this type for its first', '        positional argument. Additional arguments are passed through.', '        The return value of `func` is ignored; this method returns self.', '        See the `pipe` method if you want the return value.', '', '        Added in v0.12.0.', '', '        \"\"\"', '        func(self, *args, **kwargs)', '        return self', '', '    def pipe(self, func, *args, **kwargs):', '        \"\"\"', '        Pass the grid to a user-supplied function and return its value.', '', '        The `func` must accept an object of this type for its first', '        positional argument. Additional arguments are passed through.', '        The return value of `func` becomes the return value of this method.', '        See the `apply` method if you want to return self instead.', '', '        Added in v0.12.0.', '', '        \"\"\"', '        return func(self, *args, **kwargs)', '', '    def savefig(self, *args, **kwargs):', '        \"\"\"', '        Save an image of the plot.', '', '        This wraps :meth:`matplotlib.figure.Figure.savefig`, using bbox_inches=\"tight\"', '        by default. Parameters are passed through to the matplotlib function.', '', '        \"\"\"', '        kwargs = kwargs.copy()', '        kwargs.setdefault(\"bbox_inches\", \"tight\")', '        self.figure.savefig(*args, **kwargs)', '', '', 'class Grid(_BaseGrid):', '    \"\"\"A grid that can have multiple subplots and an external legend.\"\"\"', '    _margin_titles = False', '    _legend_out = True', '', '    def __init__(self):', '', '        self._tight_layout_rect = [0, 0, 1, 1]', '        self._tight_layout_pad = None', '', '        # This attribute is set externally and is a hack to handle newer functions that', \"        # don't add proxy artists onto the Axes. We need an overall cleaner approach.\", '        self._extract_legend_handles = False', '', '    def tight_layout(self, *args, **kwargs):', '        \"\"\"Call fig.tight_layout within rect that exclude the legend.\"\"\"', '        kwargs = kwargs.copy()', '        kwargs.setdefault(\"rect\", self._tight_layout_rect)', '        if self._tight_layout_pad is not None:', '            kwargs.setdefault(\"pad\", self._tight_layout_pad)', '        self._figure.tight_layout(*args, **kwargs)', '        return self', '', '    def add_legend(self, legend_data=None, title=None, label_order=None,', '                   adjust_subtitles=False, **kwargs):', '        \"\"\"Draw a legend, maybe placing it outside axes and resizing the figure.', '', '        Parameters', '        ----------', '        legend_data : dict', '            Dictionary mapping label names (or two-element tuples where the', '            second element is a label name) to matplotlib artist handles. The', '            default reads from ``self._legend_data``.', '        title : string', '            Title for the legend. The default reads from ``self._hue_var``.', '        label_order : list of labels', '            The order that the legend entries should appear in. The default', '            reads from ``self.hue_names``.', '        adjust_subtitles : bool', '            If True, modify entries with invisible artists to left-align', '            the labels and set the font size to that of a title.', '        kwargs : key, value pairings', '            Other keyword arguments are passed to the underlying legend methods', '            on the Figure or Axes object.', '', '        Returns', '        -------', '        self : Grid instance', '            Returns self for easy chaining.', '', '        \"\"\"', '        # Find the data for the legend', '        if legend_data is None:', '            legend_data = self._legend_data', '        if label_order is None:', '            if self.hue_names is None:', '                label_order = list(legend_data.keys())', '            else:', '                label_order = list(map(utils.to_utf8, self.hue_names))', '', '        blank_handle = mpl.patches.Patch(alpha=0, linewidth=0)', '        handles = [legend_data.get(l, blank_handle) for l in label_order]', '        title = self._hue_var if title is None else title', '        title_size = mpl.rcParams[\"legend.title_fontsize\"]', '', '        # Unpack nested labels from a hierarchical legend', '        labels = []', '        for entry in label_order:', '            if isinstance(entry, tuple):', '                _, label = entry', '            else:', '                label = entry', '            labels.append(label)', '', '        # Set default legend kwargs', '        kwargs.setdefault(\"scatterpoints\", 1)', '', '        if self._legend_out:', '', '            kwargs.setdefault(\"frameon\", False)', '            kwargs.setdefault(\"loc\", \"center right\")', '', '            # Draw a full-figure legend outside the grid', '            figlegend = self._figure.legend(handles, labels, **kwargs)', '', '            self._legend = figlegend', '            figlegend.set_title(title, prop={\"size\": title_size})', '', '            if adjust_subtitles:', '                adjust_legend_subtitles(figlegend)', '', '            # Draw the plot to set the bounding boxes correctly', '            _draw_figure(self._figure)', '', '            # Calculate and set the new width of the figure so the legend fits', '            legend_width = figlegend.get_window_extent().width / self._figure.dpi', '            fig_width, fig_height = self._figure.get_size_inches()', '            self._figure.set_size_inches(fig_width + legend_width, fig_height)', '', '            # Draw the plot again to get the new transformations', '            _draw_figure(self._figure)', '', '            # Now calculate how much space we need on the right side', '            legend_width = figlegend.get_window_extent().width / self._figure.dpi', '            space_needed = legend_width / (fig_width + legend_width)', '            margin = .04 if self._margin_titles else .01', '            self._space_needed = margin + space_needed', '            right = 1 - self._space_needed', '', '            # Place the subplot axes to give space for the legend', '            self._figure.subplots_adjust(right=right)', '            self._tight_layout_rect[2] = right', '', '        else:', '            # Draw a legend in the first axis', '            ax = self.axes.flat[0]', '            kwargs.setdefault(\"loc\", \"best\")', '', '            leg = ax.legend(handles, labels, **kwargs)', '            leg.set_title(title, prop={\"size\": title_size})', '            self._legend = leg', '', '            if adjust_subtitles:', '                adjust_legend_subtitles(leg)', '', '        return self', '', '    def _update_legend_data(self, ax):', '        \"\"\"Extract the legend data from an axes object and save it.\"\"\"', '        data = {}', '', '        # Get data directly from the legend, which is necessary', \"        # for newer functions that don't add labeled proxy artists\", '        if ax.legend_ is not None and self._extract_legend_handles:', '            handles = ax.legend_.legendHandles', '            labels = [t.get_text() for t in ax.legend_.texts]', '            data.update({l: h for h, l in zip(handles, labels)})', '', '        handles, labels = ax.get_legend_handles_labels()', '        data.update({l: h for h, l in zip(handles, labels)})', '', '        self._legend_data.update(data)', '', '        # Now clear the legend', '        ax.legend_ = None', '', '    def _get_palette(self, data, hue, hue_order, palette):', '        \"\"\"Get a list of colors for the hue variable.\"\"\"', '        if hue is None:', '            palette = color_palette(n_colors=1)', '', '        else:', '            hue_names = categorical_order(data[hue], hue_order)', '            n_colors = len(hue_names)', '', '            # By default use either the current color palette or HUSL', '            if palette is None:', '                current_palette = utils.get_color_cycle()', '                if n_colors > len(current_palette):', '                    colors = color_palette(\"husl\", n_colors)', '                else:', '                    colors = color_palette(n_colors=n_colors)', '', '            # Allow for palette to map from hue variable names', '            elif isinstance(palette, dict):', '                color_names = [palette[h] for h in hue_names]', '                colors = color_palette(color_names, n_colors)', '', '            # Otherwise act as if we just got a list of colors', '            else:', '                colors = color_palette(palette, n_colors)', '', '            palette = color_palette(colors, n_colors)', '', '        return palette', '', '    @property', '    def legend(self):', '        \"\"\"The :class:`matplotlib.legend.Legend` object, if present.\"\"\"', '        try:', '            return self._legend', '        except AttributeError:', '            return None', '', \"    def tick_params(self, axis='both', **kwargs):\", '        \"\"\"Modify the ticks, tick labels, and gridlines.', '', '        Parameters', '        ----------', \"        axis : {'x', 'y', 'both'}\", '            The axis on which to apply the formatting.', '        kwargs : keyword arguments', '            Additional keyword arguments to pass to', '            :meth:`matplotlib.axes.Axes.tick_params`.', '', '        Returns', '        -------', '        self : Grid instance', '            Returns self for easy chaining.', '', '        \"\"\"', '        for ax in self.figure.axes:', '            ax.tick_params(axis=axis, **kwargs)', '        return self', '', '', '_facet_docs = dict(', '', '    data=dedent(\"\"\"\\\\', '    data : DataFrame', '        Tidy (\"long-form\") dataframe where each column is a variable and each', '        row is an observation.\\\\', '    \"\"\"),', '    rowcol=dedent(\"\"\"\\\\', '    row, col : vectors or keys in ``data``', '        Variables that define subsets to plot on different facets.\\\\', '    \"\"\"),', '    rowcol_order=dedent(\"\"\"\\\\', '    {row,col}_order : vector of strings', '        Specify the order in which levels of the ``row`` and/or ``col`` variables', '        appear in the grid of subplots.\\\\', '    \"\"\"),', '    col_wrap=dedent(\"\"\"\\\\', '    col_wrap : int', '        \"Wrap\" the column variable at this width, so that the column facets', '        span multiple rows. Incompatible with a ``row`` facet.\\\\', '    \"\"\"),', '    share_xy=dedent(\"\"\"\\\\', \"    share{x,y} : bool, 'col', or 'row' optional\", '        If true, the facets will share y axes across columns and/or x axes', '        across rows.\\\\', '    \"\"\"),', '    height=dedent(\"\"\"\\\\', '    height : scalar', '        Height (in inches) of each facet. See also: ``aspect``.\\\\', '    \"\"\"),', '    aspect=dedent(\"\"\"\\\\', '    aspect : scalar', '        Aspect ratio of each facet, so that ``aspect * height`` gives the width', '        of each facet in inches.\\\\', '    \"\"\"),', '    palette=dedent(\"\"\"\\\\', '    palette : palette name, list, or dict', '        Colors to use for the different levels of the ``hue`` variable. Should', '        be something that can be interpreted by :func:`color_palette`, or a', '        dictionary mapping hue levels to matplotlib colors.\\\\', '    \"\"\"),', '    legend_out=dedent(\"\"\"\\\\', '    legend_out : bool', '        If ``True``, the figure size will be extended, and the legend will be', '        drawn outside the plot on the center right.\\\\', '    \"\"\"),', '    margin_titles=dedent(\"\"\"\\\\', '    margin_titles : bool', '        If ``True``, the titles for the row variable are drawn to the right of', '        the last column. This option is experimental and may not work in all', '        cases.\\\\', '    \"\"\"),', '    facet_kws=dedent(\"\"\"\\\\', '    facet_kws : dict', '        Additional parameters passed to :class:`FacetGrid`.', '    \"\"\"),', ')', '', '', 'class FacetGrid(Grid):', '    \"\"\"Multi-plot grid for plotting conditional relationships.\"\"\"', '', '    def __init__(', '        self, data, *,', '        row=None, col=None, hue=None, col_wrap=None,', '        sharex=True, sharey=True, height=3, aspect=1, palette=None,', '        row_order=None, col_order=None, hue_order=None, hue_kws=None,', '        dropna=False, legend_out=True, despine=True,', '        margin_titles=False, xlim=None, ylim=None, subplot_kws=None,', '        gridspec_kws=None,', '    ):', '', '        super().__init__()', '', '        # Determine the hue facet layer information', '        hue_var = hue', '        if hue is None:', '            hue_names = None', '        else:', '            hue_names = categorical_order(data[hue], hue_order)', '', '        colors = self._get_palette(data, hue, hue_order, palette)', '', '        # Set up the lists of names for the row and column facet variables', '        if row is None:', '            row_names = []', '        else:', '            row_names = categorical_order(data[row], row_order)', '', '        if col is None:', '            col_names = []', '        else:', '            col_names = categorical_order(data[col], col_order)', '', '        # Additional dict of kwarg -> list of values for mapping the hue var', '        hue_kws = hue_kws if hue_kws is not None else {}', '', '        # Make a boolean mask that is True anywhere there is an NA', '        # value in one of the faceting variables, but only if dropna is True', '        none_na = np.zeros(len(data), bool)', '        if dropna:', '            row_na = none_na if row is None else data[row].isnull()', '            col_na = none_na if col is None else data[col].isnull()', '            hue_na = none_na if hue is None else data[hue].isnull()', '            not_na = ~(row_na | col_na | hue_na)', '        else:', '            not_na = ~none_na', '', '        # Compute the grid shape', '        ncol = 1 if col is None else len(col_names)', '        nrow = 1 if row is None else len(row_names)', '        self._n_facets = ncol * nrow', '', '        self._col_wrap = col_wrap', '        if col_wrap is not None:', '            if row is not None:', '                err = \"Cannot use `row` and `col_wrap` together.\"', '                raise ValueError(err)', '            ncol = col_wrap', '            nrow = int(np.ceil(len(col_names) / col_wrap))', '        self._ncol = ncol', '        self._nrow = nrow', '', '        # Calculate the base figure size', '        # This can get stretched later by a legend', \"        # TODO this doesn't account for axis labels\", '        figsize = (ncol * height * aspect, nrow * height)', '', '        # Validate some inputs', '        if col_wrap is not None:', '            margin_titles = False', '', '        # Build the subplot keyword dictionary', '        subplot_kws = {} if subplot_kws is None else subplot_kws.copy()', '        gridspec_kws = {} if gridspec_kws is None else gridspec_kws.copy()', '        if xlim is not None:', '            subplot_kws[\"xlim\"] = xlim', '        if ylim is not None:', '            subplot_kws[\"ylim\"] = ylim', '', '        # --- Initialize the subplot grid', '', '        with _disable_autolayout():', '            fig = plt.figure(figsize=figsize)', '', '        if col_wrap is None:', '', '            kwargs = dict(squeeze=False,', '                          sharex=sharex, sharey=sharey,', '                          subplot_kw=subplot_kws,', '                          gridspec_kw=gridspec_kws)', '', '            axes = fig.subplots(nrow, ncol, **kwargs)', '', '            if col is None and row is None:', '                axes_dict = {}', '            elif col is None:', '                axes_dict = dict(zip(row_names, axes.flat))', '            elif row is None:', '                axes_dict = dict(zip(col_names, axes.flat))', '            else:', '                facet_product = product(row_names, col_names)', '                axes_dict = dict(zip(facet_product, axes.flat))', '', '        else:', '', '            # If wrapping the col variable we need to make the grid ourselves', '            if gridspec_kws:', '                warnings.warn(\"`gridspec_kws` ignored when using `col_wrap`\")', '', '            n_axes = len(col_names)', '            axes = np.empty(n_axes, object)', '            axes[0] = fig.add_subplot(nrow, ncol, 1, **subplot_kws)', '            if sharex:', '                subplot_kws[\"sharex\"] = axes[0]', '            if sharey:', '                subplot_kws[\"sharey\"] = axes[0]', '            for i in range(1, n_axes):', '                axes[i] = fig.add_subplot(nrow, ncol, i + 1, **subplot_kws)', '', '            axes_dict = dict(zip(col_names, axes))', '', '        # --- Set up the class attributes', '', '        # Attributes that are part of the public API but accessed through', '        # a  property so that Sphinx adds them to the auto class doc', '        self._figure = fig', '        self._axes = axes', '        self._axes_dict = axes_dict', '        self._legend = None', '', \"        # Public attributes that aren't explicitly documented\", \"        # (It's not obvious that having them be public was a good idea)\", '        self.data = data', '        self.row_names = row_names', '        self.col_names = col_names', '        self.hue_names = hue_names', '        self.hue_kws = hue_kws', '', '        # Next the private variables', '        self._nrow = nrow', '        self._row_var = row', '        self._ncol = ncol', '        self._col_var = col', '', '        self._margin_titles = margin_titles', '        self._margin_titles_texts = []', '        self._col_wrap = col_wrap', '        self._hue_var = hue_var', '        self._colors = colors', '        self._legend_out = legend_out', '        self._legend_data = {}', '        self._x_var = None', '        self._y_var = None', '        self._sharex = sharex', '        self._sharey = sharey', '        self._dropna = dropna', '        self._not_na = not_na', '', '        # --- Make the axes look good', '', '        self.set_titles()', '        self.tight_layout()', '', '        if despine:', '            self.despine()', '', \"        if sharex in [True, 'col']:\", '            for ax in self._not_bottom_axes:', '                for label in ax.get_xticklabels():', '                    label.set_visible(False)', '                ax.xaxis.offsetText.set_visible(False)', '                ax.xaxis.label.set_visible(False)', '', \"        if sharey in [True, 'row']:\", '            for ax in self._not_left_axes:', '                for label in ax.get_yticklabels():', '                    label.set_visible(False)', '                ax.yaxis.offsetText.set_visible(False)', '                ax.yaxis.label.set_visible(False)', '', '    __init__.__doc__ = dedent(\"\"\"\\\\', '        Initialize the matplotlib figure and FacetGrid object.', '', '        This class maps a dataset onto multiple axes arrayed in a grid of rows', '        and columns that correspond to *levels* of variables in the dataset.', '        The plots it produces are often called \"lattice\", \"trellis\", or', '        \"small-multiple\" graphics.', '', '        It can also represent levels of a third variable with the ``hue``', '        parameter, which plots different subsets of data in different colors.', '        This uses color to resolve elements on a third dimension, but only', '        draws subsets on top of each other and will not tailor the ``hue``', '        parameter for the specific visualization the way that axes-level', '        functions that accept ``hue`` will.', '', '        The basic workflow is to initialize the :class:`FacetGrid` object with', '        the dataset and the variables that are used to structure the grid. Then', '        one or more plotting functions can be applied to each subset by calling', '        :meth:`FacetGrid.map` or :meth:`FacetGrid.map_dataframe`. Finally, the', '        plot can be tweaked with other methods to do things like change the', '        axis labels, use different ticks, or add a legend. See the detailed', '        code examples below for more information.', '', '        .. warning::', '', '            When using seaborn functions that infer semantic mappings from a', '            dataset, care must be taken to synchronize those mappings across', '            facets (e.g., by defining the ``hue`` mapping with a palette dict or', '            setting the data type of the variables to ``category``). In most cases,', '            it will be better to use a figure-level function (e.g. :func:`relplot`', '            or :func:`catplot`) than to use :class:`FacetGrid` directly.', '', '        See the :ref:`tutorial <grid_tutorial>` for more information.', '', '        Parameters', '        ----------', '        {data}', '        row, col, hue : strings', '            Variables that define subsets of the data, which will be drawn on', '            separate facets in the grid. See the ``{{var}}_order`` parameters to', '            control the order of levels of this variable.', '        {col_wrap}', '        {share_xy}', '        {height}', '        {aspect}', '        {palette}', '        {{row,col,hue}}_order : lists', '            Order for the levels of the faceting variables. By default, this', '            will be the order that the levels appear in ``data`` or, if the', '            variables are pandas categoricals, the category order.', '        hue_kws : dictionary of param -> list of values mapping', '            Other keyword arguments to insert into the plotting call to let', '            other plot attributes vary across levels of the hue variable (e.g.', '            the markers in a scatterplot).', '        {legend_out}', '        despine : boolean', '            Remove the top and right spines from the plots.', '        {margin_titles}', '        {{x, y}}lim: tuples', '            Limits for each of the axes on each facet (only relevant when', '            share{{x, y}} is True).', '        subplot_kws : dict', '            Dictionary of keyword arguments passed to matplotlib subplot(s)', '            methods.', '        gridspec_kws : dict', '            Dictionary of keyword arguments passed to', '            :class:`matplotlib.gridspec.GridSpec`', '            (via :meth:`matplotlib.figure.Figure.subplots`).', '            Ignored if ``col_wrap`` is not ``None``.', '', '        See Also', '        --------', '        PairGrid : Subplot grid for plotting pairwise relationships', '        relplot : Combine a relational plot and a :class:`FacetGrid`', '        displot : Combine a distribution plot and a :class:`FacetGrid`', '        catplot : Combine a categorical plot and a :class:`FacetGrid`', '        lmplot : Combine a regression plot and a :class:`FacetGrid`', '', '        Examples', '        --------', '', '        .. note::', '', '            These examples use seaborn functions to demonstrate some of the', '            advanced features of the class, but in most cases you will want', '            to use figue-level functions (e.g. :func:`displot`, :func:`relplot`)', '            to make the plots shown here.', '', '        .. include:: ../docstrings/FacetGrid.rst', '', '        \"\"\").format(**_facet_docs)', '', '    def facet_data(self):', '        \"\"\"Generator for name indices and data subsets for each facet.', '', '        Yields', '        ------', '        (i, j, k), data_ijk : tuple of ints, DataFrame', '            The ints provide an index into the {row, col, hue}_names attribute,', '            and the dataframe contains a subset of the full data corresponding', '            to each facet. The generator yields subsets that correspond with', '            the self.axes.flat iterator, or self.axes[i, j] when `col_wrap`', '            is None.', '', '        \"\"\"', '        data = self.data', '', '        # Construct masks for the row variable', '        if self.row_names:', '            row_masks = [data[self._row_var] == n for n in self.row_names]', '        else:', '            row_masks = [np.repeat(True, len(self.data))]', '', '        # Construct masks for the column variable', '        if self.col_names:', '            col_masks = [data[self._col_var] == n for n in self.col_names]', '        else:', '            col_masks = [np.repeat(True, len(self.data))]', '', '        # Construct masks for the hue variable', '        if self.hue_names:', '            hue_masks = [data[self._hue_var] == n for n in self.hue_names]', '        else:', '            hue_masks = [np.repeat(True, len(self.data))]', '', '        # Here is the main generator loop', '        for (i, row), (j, col), (k, hue) in product(enumerate(row_masks),', '                                                    enumerate(col_masks),', '                                                    enumerate(hue_masks)):', '            data_ijk = data[row & col & hue & self._not_na]', '            yield (i, j, k), data_ijk', '', '    def map(self, func, *args, **kwargs):', '        \"\"\"Apply a plotting function to each facet\\'s subset of the data.', '', '        Parameters', '        ----------', '        func : callable', '            A plotting function that takes data and keyword arguments. It', '            must plot to the currently active matplotlib Axes and take a', '            `color` keyword argument. If faceting on the `hue` dimension,', '            it must also take a `label` keyword argument.', '        args : strings', '            Column names in self.data that identify variables with data to', '            plot. The data for each variable is passed to `func` in the', '            order the variables are specified in the call.', '        kwargs : keyword arguments', '            All keyword arguments are passed to the plotting function.', '', '        Returns', '        -------', '        self : object', '            Returns self.', '', '        \"\"\"', '        # If color was a keyword argument, grab it here', '        kw_color = kwargs.pop(\"color\", None)', '', '        # How we use the function depends on where it comes from', '        func_module = str(getattr(func, \"__module__\", \"\"))', '', '        # Check for categorical plots without order information', '        if func_module == \"seaborn.categorical\":', '            if \"order\" not in kwargs:', '                warning = (\"Using the {} function without specifying \"', '                           \"`order` is likely to produce an incorrect \"', '                           \"plot.\".format(func.__name__))', '                warnings.warn(warning)', '            if len(args) == 3 and \"hue_order\" not in kwargs:', '                warning = (\"Using the {} function without specifying \"', '                           \"`hue_order` is likely to produce an incorrect \"', '                           \"plot.\".format(func.__name__))', '                warnings.warn(warning)', '', '        # Iterate over the data subsets', '        for (row_i, col_j, hue_k), data_ijk in self.facet_data():', '', '            # If this subset is null, move on', '            if not data_ijk.values.size:', '                continue', '', '            # Get the current axis', '            modify_state = not func_module.startswith(\"seaborn\")', '            ax = self.facet_axis(row_i, col_j, modify_state)', '', '            # Decide what color to plot with', '            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)', '', '            # Insert the other hue aesthetics if appropriate', '            for kw, val_list in self.hue_kws.items():', '                kwargs[kw] = val_list[hue_k]', '', '            # Insert a label in the keyword arguments for the legend', '            if self._hue_var is not None:', '                kwargs[\"label\"] = utils.to_utf8(self.hue_names[hue_k])', '', '            # Get the actual data we are going to plot with', '            plot_data = data_ijk[list(args)]', '            if self._dropna:', '                plot_data = plot_data.dropna()', '            plot_args = [v for k, v in plot_data.items()]', '', \"            # Some matplotlib functions don't handle pandas objects correctly\", '            if func_module.startswith(\"matplotlib\"):', '                plot_args = [v.values for v in plot_args]', '', '            # Draw the plot', '            self._facet_plot(func, ax, plot_args, kwargs)', '', '        # Finalize the annotations and layout', '        self._finalize_grid(args[:2])', '', '        return self', '', '    def map_dataframe(self, func, *args, **kwargs):', '        \"\"\"Like ``.map`` but passes args as strings and inserts data in kwargs.', '', '        This method is suitable for plotting with functions that accept a', '        long-form DataFrame as a `data` keyword argument and access the', '        data in that DataFrame using string variable names.', '', '        Parameters', '        ----------', '        func : callable', '            A plotting function that takes data and keyword arguments. Unlike', '            the `map` method, a function used here must \"understand\" Pandas', '            objects. It also must plot to the currently active matplotlib Axes', '            and take a `color` keyword argument. If faceting on the `hue`', '            dimension, it must also take a `label` keyword argument.', '        args : strings', '            Column names in self.data that identify variables with data to', '            plot. The data for each variable is passed to `func` in the', '            order the variables are specified in the call.', '        kwargs : keyword arguments', '            All keyword arguments are passed to the plotting function.', '', '        Returns', '        -------', '        self : object', '            Returns self.', '', '        \"\"\"', '', '        # If color was a keyword argument, grab it here', '        kw_color = kwargs.pop(\"color\", None)', '', '        # Iterate over the data subsets', '        for (row_i, col_j, hue_k), data_ijk in self.facet_data():', '', '            # If this subset is null, move on', '            if not data_ijk.values.size:', '                continue', '', '            # Get the current axis', '            modify_state = not str(func.__module__).startswith(\"seaborn\")', '            ax = self.facet_axis(row_i, col_j, modify_state)', '', '            # Decide what color to plot with', '            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)', '', '            # Insert the other hue aesthetics if appropriate', '            for kw, val_list in self.hue_kws.items():', '                kwargs[kw] = val_list[hue_k]', '', '            # Insert a label in the keyword arguments for the legend', '            if self._hue_var is not None:', '                kwargs[\"label\"] = self.hue_names[hue_k]', '', '            # Stick the facet dataframe into the kwargs', '            if self._dropna:', '                data_ijk = data_ijk.dropna()', '            kwargs[\"data\"] = data_ijk', '', '            # Draw the plot', '            self._facet_plot(func, ax, args, kwargs)', '', '        # For axis labels, prefer to use positional args for backcompat', '        # but also extract the x/y kwargs and use if no corresponding arg', '        axis_labels = [kwargs.get(\"x\", None), kwargs.get(\"y\", None)]', '        for i, val in enumerate(args[:2]):', '            axis_labels[i] = val', '        self._finalize_grid(axis_labels)', '', '        return self', '', '    def _facet_color(self, hue_index, kw_color):', '', '        color = self._colors[hue_index]', '        if kw_color is not None:', '            return kw_color', '        elif color is not None:', '            return color', '', '    def _facet_plot(self, func, ax, plot_args, plot_kwargs):', '', '        # Draw the plot', '        if str(func.__module__).startswith(\"seaborn\"):', '            plot_kwargs = plot_kwargs.copy()', '            semantics = [\"x\", \"y\", \"hue\", \"size\", \"style\"]', '            for key, val in zip(semantics, plot_args):', '                plot_kwargs[key] = val', '            plot_args = []', '            plot_kwargs[\"ax\"] = ax', '        func(*plot_args, **plot_kwargs)', '', '        # Sort out the supporting information', '        self._update_legend_data(ax)', '', '    def _finalize_grid(self, axlabels):', '        \"\"\"Finalize the annotations and layout.\"\"\"', '        self.set_axis_labels(*axlabels)', '        self.tight_layout()', '', '    def facet_axis(self, row_i, col_j, modify_state=True):', '        \"\"\"Make the axis identified by these indices active and return it.\"\"\"', '', '        # Calculate the actual indices of the axes to plot on', '        if self._col_wrap is not None:', '            ax = self.axes.flat[col_j]', '        else:', '            ax = self.axes[row_i, col_j]', '', '        # Get a reference to the axes object we want, and make it active', '        if modify_state:', '            plt.sca(ax)', '        return ax', '', '    def despine(self, **kwargs):', '        \"\"\"Remove axis spines from the facets.\"\"\"', '        utils.despine(self._figure, **kwargs)', '        return self', '', '    def set_axis_labels(self, x_var=None, y_var=None, clear_inner=True, **kwargs):', '        \"\"\"Set axis labels on the left column and bottom row of the grid.\"\"\"', '        if x_var is not None:', '            self._x_var = x_var', '            self.set_xlabels(x_var, clear_inner=clear_inner, **kwargs)', '        if y_var is not None:', '            self._y_var = y_var', '            self.set_ylabels(y_var, clear_inner=clear_inner, **kwargs)', '', '        return self', '', '    def set_xlabels(self, label=None, clear_inner=True, **kwargs):', '        \"\"\"Label the x axis on the bottom row of the grid.\"\"\"', '        if label is None:', '            label = self._x_var', '        for ax in self._bottom_axes:', '            ax.set_xlabel(label, **kwargs)', '        if clear_inner:', '            for ax in self._not_bottom_axes:', '                ax.set_xlabel(\"\")', '        return self', '', '    def set_ylabels(self, label=None, clear_inner=True, **kwargs):', '        \"\"\"Label the y axis on the left column of the grid.\"\"\"', '        if label is None:', '            label = self._y_var', '        for ax in self._left_axes:', '            ax.set_ylabel(label, **kwargs)', '        if clear_inner:', '            for ax in self._not_left_axes:', '                ax.set_ylabel(\"\")', '        return self', '', '    def set_xticklabels(self, labels=None, step=None, **kwargs):', '        \"\"\"Set x axis tick labels of the grid.\"\"\"', '        for ax in self.axes.flat:', '            curr_ticks = ax.get_xticks()', '            ax.set_xticks(curr_ticks)', '            if labels is None:', '                curr_labels = [l.get_text() for l in ax.get_xticklabels()]', '                if step is not None:', '                    xticks = ax.get_xticks()[::step]', '                    curr_labels = curr_labels[::step]', '                    ax.set_xticks(xticks)', '                ax.set_xticklabels(curr_labels, **kwargs)', '            else:', '                ax.set_xticklabels(labels, **kwargs)', '        return self', '', '    def set_yticklabels(self, labels=None, **kwargs):', '        \"\"\"Set y axis tick labels on the left column of the grid.\"\"\"', '        for ax in self.axes.flat:', '            curr_ticks = ax.get_yticks()', '            ax.set_yticks(curr_ticks)', '            if labels is None:', '                curr_labels = [l.get_text() for l in ax.get_yticklabels()]', '                ax.set_yticklabels(curr_labels, **kwargs)', '            else:', '                ax.set_yticklabels(labels, **kwargs)', '        return self', '', '    def set_titles(self, template=None, row_template=None, col_template=None,', '                   **kwargs):', '        \"\"\"Draw titles either above each facet or on the grid margins.', '', '        Parameters', '        ----------', '        template : string', '            Template for all titles with the formatting keys {col_var} and', '            {col_name} (if using a `col` faceting variable) and/or {row_var}', '            and {row_name} (if using a `row` faceting variable).', '        row_template:', '            Template for the row variable when titles are drawn on the grid', '            margins. Must have {row_var} and {row_name} formatting keys.', '        col_template:', '            Template for the row variable when titles are drawn on the grid', '            margins. Must have {col_var} and {col_name} formatting keys.', '', '        Returns', '        -------', '        self: object', '            Returns self.', '', '        \"\"\"', '        args = dict(row_var=self._row_var, col_var=self._col_var)', '        kwargs[\"size\"] = kwargs.pop(\"size\", mpl.rcParams[\"axes.labelsize\"])', '', '        # Establish default templates', '        if row_template is None:', '            row_template = \"{row_var} = {row_name}\"', '        if col_template is None:', '            col_template = \"{col_var} = {col_name}\"', '        if template is None:', '            if self._row_var is None:', '                template = col_template', '            elif self._col_var is None:', '                template = row_template', '            else:', '                template = \" | \".join([row_template, col_template])', '', '        row_template = utils.to_utf8(row_template)', '        col_template = utils.to_utf8(col_template)', '        template = utils.to_utf8(template)', '', '        if self._margin_titles:', '', '            # Remove any existing title texts', '            for text in self._margin_titles_texts:', '                text.remove()', '            self._margin_titles_texts = []', '', '            if self.row_names is not None:', '                # Draw the row titles on the right edge of the grid', '                for i, row_name in enumerate(self.row_names):', '                    ax = self.axes[i, -1]', '                    args.update(dict(row_name=row_name))', '                    title = row_template.format(**args)', '                    text = ax.annotate(', '                        title, xy=(1.02, .5), xycoords=\"axes fraction\",', '                        rotation=270, ha=\"left\", va=\"center\",', '                        **kwargs', '                    )', '                    self._margin_titles_texts.append(text)', '', '            if self.col_names is not None:', '                # Draw the column titles  as normal titles', '                for j, col_name in enumerate(self.col_names):', '                    args.update(dict(col_name=col_name))', '                    title = col_template.format(**args)', '                    self.axes[0, j].set_title(title, **kwargs)', '', '            return self', '', '        # Otherwise title each facet with all the necessary information', '        if (self._row_var is not None) and (self._col_var is not None):', '            for i, row_name in enumerate(self.row_names):', '                for j, col_name in enumerate(self.col_names):', '                    args.update(dict(row_name=row_name, col_name=col_name))', '                    title = template.format(**args)', '                    self.axes[i, j].set_title(title, **kwargs)', '        elif self.row_names is not None and len(self.row_names):', '            for i, row_name in enumerate(self.row_names):', '                args.update(dict(row_name=row_name))', '                title = template.format(**args)', '                self.axes[i, 0].set_title(title, **kwargs)', '        elif self.col_names is not None and len(self.col_names):', '            for i, col_name in enumerate(self.col_names):', '                args.update(dict(col_name=col_name))', '                title = template.format(**args)', '                # Index the flat array so col_wrap works', '                self.axes.flat[i].set_title(title, **kwargs)', '        return self', '', \"    def refline(self, *, x=None, y=None, color='.5', linestyle='--', **line_kws):\", '        \"\"\"Add a reference line(s) to each facet.', '', '        Parameters', '        ----------', '        x, y : numeric', '            Value(s) to draw the line(s) at.', '        color : :mod:`matplotlib color <matplotlib.colors>`', '            Specifies the color of the reference line(s). Pass ``color=None`` to', '            use ``hue`` mapping.', '        linestyle : str', '            Specifies the style of the reference line(s).', '        line_kws : key, value mappings', '            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`', '            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``', '            is not None.', '', '        Returns', '        -------', '        :class:`FacetGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', \"        line_kws['color'] = color\", \"        line_kws['linestyle'] = linestyle\", '', '        if x is not None:', '            self.map(plt.axvline, x=x, **line_kws)', '', '        if y is not None:', '            self.map(plt.axhline, y=y, **line_kws)', '', '        return self', '', '    # ------ Properties that are part of the public API and documented by Sphinx', '', '    @property', '    def axes(self):', '        \"\"\"An array of the :class:`matplotlib.axes.Axes` objects in the grid.\"\"\"', '        return self._axes', '', '    @property', '    def ax(self):', '        \"\"\"The :class:`matplotlib.axes.Axes` when no faceting variables are assigned.\"\"\"', '        if self.axes.shape == (1, 1):', '            return self.axes[0, 0]', '        else:', '            err = (', '                \"Use the `.axes` attribute when facet variables are assigned.\"', '            )', '            raise AttributeError(err)', '', '    @property', '    def axes_dict(self):', '        \"\"\"A mapping of facet names to corresponding :class:`matplotlib.axes.Axes`.', '', '        If only one of ``row`` or ``col`` is assigned, each key is a string', '        representing a level of that variable. If both facet dimensions are', '        assigned, each key is a ``({row_level}, {col_level})`` tuple.', '', '        \"\"\"', '        return self._axes_dict', '', '    # ------ Private properties, that require some computation to get', '', '    @property', '    def _inner_axes(self):', '        \"\"\"Return a flat array of the inner axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:-1, 1:].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i % self._ncol', '                    and i < (self._ncol * (self._nrow - 1))', '                    and i < (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '    @property', '    def _left_axes(self):', '        \"\"\"Return a flat array of the left column of axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:, 0].flat', '        else:', '            axes = []', '            for i, ax in enumerate(self.axes):', '                if not i % self._ncol:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '    @property', '    def _not_left_axes(self):', '        \"\"\"Return a flat array of axes that aren\\'t on the left column.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:, 1:].flat', '        else:', '            axes = []', '            for i, ax in enumerate(self.axes):', '                if i % self._ncol:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '    @property', '    def _bottom_axes(self):', '        \"\"\"Return a flat array of the bottom row of axes.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[-1, :].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i >= (self._ncol * (self._nrow - 1))', '                    or i >= (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '    @property', '    def _not_bottom_axes(self):', '        \"\"\"Return a flat array of axes that aren\\'t on the bottom row.\"\"\"', '        if self._col_wrap is None:', '            return self.axes[:-1, :].flat', '        else:', '            axes = []', '            n_empty = self._nrow * self._ncol - self._n_facets', '            for i, ax in enumerate(self.axes):', '                append = (', '                    i < (self._ncol * (self._nrow - 1))', '                    and i < (self._ncol * (self._nrow - 1) - n_empty)', '                )', '                if append:', '                    axes.append(ax)', '            return np.array(axes, object).flat', '', '', 'class PairGrid(Grid):', '    \"\"\"Subplot grid for plotting pairwise relationships in a dataset.', '', '    This object maps each variable in a dataset onto a column and row in a', '    grid of multiple axes. Different axes-level plotting functions can be', '    used to draw bivariate plots in the upper and lower triangles, and the', '    marginal distribution of each variable can be shown on the diagonal.', '', '    Several different common plots can be generated in a single line using', '    :func:`pairplot`. Use :class:`PairGrid` when you need more flexibility.', '', '    See the :ref:`tutorial <grid_tutorial>` for more information.', '', '    \"\"\"', '    def __init__(', '        self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,', '        hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,', '        height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False,', '    ):', '        \"\"\"Initialize the plot figure and PairGrid object.', '', '        Parameters', '        ----------', '        data : DataFrame', '            Tidy (long-form) dataframe where each column is a variable and', '            each row is an observation.', '        hue : string (variable name)', '            Variable in ``data`` to map plot aspects to different colors. This', '            variable will be excluded from the default x and y variables.', '        vars : list of variable names', '            Variables within ``data`` to use, otherwise use every column with', '            a numeric datatype.', '        {x, y}_vars : lists of variable names', '            Variables within ``data`` to use separately for the rows and', '            columns of the figure; i.e. to make a non-square plot.', '        hue_order : list of strings', '            Order for the levels of the hue variable in the palette', '        palette : dict or seaborn color palette', '            Set of colors for mapping the ``hue`` variable. If a dict, keys', '            should be values  in the ``hue`` variable.', '        hue_kws : dictionary of param -> list of values mapping', '            Other keyword arguments to insert into the plotting call to let', '            other plot attributes vary across levels of the hue variable (e.g.', '            the markers in a scatterplot).', '        corner : bool', \"            If True, don't add axes to the upper (off-diagonal) triangle of the\", '            grid, making this a \"corner\" plot.', '        height : scalar', '            Height (in inches) of each facet.', '        aspect : scalar', '            Aspect * height gives the width (in inches) of each facet.', '        layout_pad : scalar', '            Padding between axes; passed to ``fig.tight_layout``.', '        despine : boolean', '            Remove the top and right spines from the plots.', '        dropna : boolean', '            Drop missing values from the data before plotting.', '', '        See Also', '        --------', '        pairplot : Easily drawing common uses of :class:`PairGrid`.', '        FacetGrid : Subplot grid for plotting conditional relationships.', '', '        Examples', '        --------', '', '        .. include:: ../docstrings/PairGrid.rst', '', '        \"\"\"', '', '        super().__init__()', '', '        # Sort out the variables that define the grid', '        numeric_cols = self._find_numeric_cols(data)', '        if hue in numeric_cols:', '            numeric_cols.remove(hue)', '        if vars is not None:', '            x_vars = list(vars)', '            y_vars = list(vars)', '        if x_vars is None:', '            x_vars = numeric_cols', '        if y_vars is None:', '            y_vars = numeric_cols', '', '        if np.isscalar(x_vars):', '            x_vars = [x_vars]', '        if np.isscalar(y_vars):', '            y_vars = [y_vars]', '', '        self.x_vars = x_vars = list(x_vars)', '        self.y_vars = y_vars = list(y_vars)', '        self.square_grid = self.x_vars == self.y_vars', '', '        if not x_vars:', '            raise ValueError(\"No variables found for grid columns.\")', '        if not y_vars:', '            raise ValueError(\"No variables found for grid rows.\")', '', '        # Create the figure and the array of subplots', '        figsize = len(x_vars) * height * aspect, len(y_vars) * height', '', '        with _disable_autolayout():', '            fig = plt.figure(figsize=figsize)', '', '        axes = fig.subplots(len(y_vars), len(x_vars),', '                            sharex=\"col\", sharey=\"row\",', '                            squeeze=False)', '', '        # Possibly remove upper axes to make a corner grid', '        # Note: setting up the axes is usually the most time-intensive part', '        # of using the PairGrid. We are foregoing the speed improvement that', '        # we would get by just not setting up the hidden axes so that we can', '        # avoid implementing fig.subplots ourselves. But worth thinking about.', '        self._corner = corner', '        if corner:', '            hide_indices = np.triu_indices_from(axes, 1)', '            for i, j in zip(*hide_indices):', '                axes[i, j].remove()', '                axes[i, j] = None', '', '        self._figure = fig', '        self.axes = axes', '        self.data = data', '', '        # Save what we are going to do with the diagonal', '        self.diag_sharey = diag_sharey', '        self.diag_vars = None', '        self.diag_axes = None', '', '        self._dropna = dropna', '', '        # Label the axes', '        self._add_axis_labels()', '', '        # Sort out the hue variable', '        self._hue_var = hue', '        if hue is None:', '            self.hue_names = hue_order = [\"_nolegend_\"]', '            self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),', '                                      index=data.index)', '        else:', '            # We need hue_order and hue_names because the former is used to control', '            # the order of drawing and the latter is used to control the order of', '            # the legend. hue_names can become string-typed while hue_order must', '            # retain the type of the input data. This is messy but results from', '            # the fact that PairGrid can implement the hue-mapping logic itself', '            # (and was originally written exclusively that way) but now can delegate', '            # to the axes-level functions, while always handling legend creation.', '            # See GH2307', '            hue_names = hue_order = categorical_order(data[hue], hue_order)', '            if dropna:', '                # Filter NA from the list of unique hue names', '                hue_names = list(filter(pd.notnull, hue_names))', '            self.hue_names = hue_names', '            self.hue_vals = data[hue]', '', '        # Additional dict of kwarg -> list of values for mapping the hue var', '        self.hue_kws = hue_kws if hue_kws is not None else {}', '', '        self._orig_palette = palette', '        self._hue_order = hue_order', '        self.palette = self._get_palette(data, hue, hue_order, palette)', '        self._legend_data = {}', '', '        # Make the plot look nice', '        for ax in axes[:-1, :].flat:', '            if ax is None:', '                continue', '            for label in ax.get_xticklabels():', '                label.set_visible(False)', '            ax.xaxis.offsetText.set_visible(False)', '            ax.xaxis.label.set_visible(False)', '', '        for ax in axes[:, 1:].flat:', '            if ax is None:', '                continue', '            for label in ax.get_yticklabels():', '                label.set_visible(False)', '            ax.yaxis.offsetText.set_visible(False)', '            ax.yaxis.label.set_visible(False)', '', '        self._tight_layout_rect = [.01, .01, .99, .99]', '        self._tight_layout_pad = layout_pad', '        self._despine = despine', '        if despine:', '            utils.despine(fig=fig)', '        self.tight_layout(pad=layout_pad)', '', '    def map(self, func, **kwargs):', '        \"\"\"Plot with the same function in every subplot.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        row_indices, col_indices = np.indices(self.axes.shape)', '        indices = zip(row_indices.flat, col_indices.flat)', '        self._map_bivariate(func, indices, **kwargs)', '', '        return self', '', '    def map_lower(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the lower diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        indices = zip(*np.tril_indices_from(self.axes, -1))', '        self._map_bivariate(func, indices, **kwargs)', '        return self', '', '    def map_upper(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the upper diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        indices = zip(*np.triu_indices_from(self.axes, 1))', '        self._map_bivariate(func, indices, **kwargs)', '        return self', '', '    def map_offdiag(self, func, **kwargs):', '        \"\"\"Plot with a bivariate function on the off-diagonal subplots.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take x, y arrays as positional arguments and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        if self.square_grid:', '            self.map_lower(func, **kwargs)', '            if not self._corner:', '                self.map_upper(func, **kwargs)', '        else:', '            indices = []', '            for i, (y_var) in enumerate(self.y_vars):', '                for j, (x_var) in enumerate(self.x_vars):', '                    if x_var != y_var:', '                        indices.append((i, j))', '            self._map_bivariate(func, indices, **kwargs)', '        return self', '', '    def map_diag(self, func, **kwargs):', '        \"\"\"Plot with a univariate function on each diagonal subplot.', '', '        Parameters', '        ----------', '        func : callable plotting function', '            Must take an x array as a positional argument and draw onto the', '            \"currently active\" matplotlib Axes. Also needs to accept kwargs', '            called ``color`` and  ``label``.', '', '        \"\"\"', '        # Add special diagonal axes for the univariate plot', '        if self.diag_axes is None:', '            diag_vars = []', '            diag_axes = []', '            for i, y_var in enumerate(self.y_vars):', '                for j, x_var in enumerate(self.x_vars):', '                    if x_var == y_var:', '', '                        # Make the density axes', '                        diag_vars.append(x_var)', '                        ax = self.axes[i, j]', '                        diag_ax = ax.twinx()', '                        diag_ax.set_axis_off()', '                        diag_axes.append(diag_ax)', '', '                        # Work around matplotlib bug', '                        # https://github.com/matplotlib/matplotlib/issues/15188', '                        if not plt.rcParams.get(\"ytick.left\", True):', '                            for tick in ax.yaxis.majorTicks:', '                                tick.tick1line.set_visible(False)', '', '                        # Remove main y axis from density axes in a corner plot', '                        if self._corner:', '                            ax.yaxis.set_visible(False)', '                            if self._despine:', '                                utils.despine(ax=ax, left=True)', '                            # TODO add optional density ticks (on the right)', '                            # when drawing a corner plot?', '', '            if self.diag_sharey and diag_axes:', '                for ax in diag_axes[1:]:', '                    share_axis(diag_axes[0], ax, \"y\")', '', '            self.diag_vars = np.array(diag_vars, np.object_)', '            self.diag_axes = np.array(diag_axes, np.object_)', '', '        if \"hue\" not in signature(func).parameters:', '            return self._map_diag_iter_hue(func, **kwargs)', '', '        # Loop over diagonal variables and axes, making one plot in each', '        for var, ax in zip(self.diag_vars, self.diag_axes):', '', '            plot_kwargs = kwargs.copy()', '            if str(func.__module__).startswith(\"seaborn\"):', '                plot_kwargs[\"ax\"] = ax', '            else:', '                plt.sca(ax)', '', '            vector = self.data[var]', '            if self._hue_var is not None:', '                hue = self.data[self._hue_var]', '            else:', '                hue = None', '', '            if self._dropna:', '                not_na = vector.notna()', '                if hue is not None:', '                    not_na &= hue.notna()', '                vector = vector[not_na]', '                if hue is not None:', '                    hue = hue[not_na]', '', '            plot_kwargs.setdefault(\"hue\", hue)', '            plot_kwargs.setdefault(\"hue_order\", self._hue_order)', '            plot_kwargs.setdefault(\"palette\", self._orig_palette)', '            func(x=vector, **plot_kwargs)', '            ax.legend_ = None', '', '        self._add_axis_labels()', '        return self', '', '    def _map_diag_iter_hue(self, func, **kwargs):', '        \"\"\"Put marginal plot on each diagonal axes, iterating over hue.\"\"\"', '        # Plot on each of the diagonal axes', '        fixed_color = kwargs.pop(\"color\", None)', '', '        for var, ax in zip(self.diag_vars, self.diag_axes):', '            hue_grouped = self.data[var].groupby(self.hue_vals)', '', '            plot_kwargs = kwargs.copy()', '            if str(func.__module__).startswith(\"seaborn\"):', '                plot_kwargs[\"ax\"] = ax', '            else:', '                plt.sca(ax)', '', '            for k, label_k in enumerate(self._hue_order):', '', '                # Attempt to get data for this level, allowing for empty', '                try:', '                    data_k = hue_grouped.get_group(label_k)', '                except KeyError:', '                    data_k = pd.Series([], dtype=float)', '', '                if fixed_color is None:', '                    color = self.palette[k]', '                else:', '                    color = fixed_color', '', '                if self._dropna:', '                    data_k = utils.remove_na(data_k)', '', '                if str(func.__module__).startswith(\"seaborn\"):', '                    func(x=data_k, label=label_k, color=color, **plot_kwargs)', '                else:', '                    func(data_k, label=label_k, color=color, **plot_kwargs)', '', '        self._add_axis_labels()', '', '        return self', '', '    def _map_bivariate(self, func, indices, **kwargs):', '        \"\"\"Draw a bivariate plot on the indicated axes.\"\"\"', \"        # This is a hack to handle the fact that new distribution plots don't add\", '        # their artists onto the axes. This is probably superior in general, but', \"        # we'll need a better way to handle it in the axisgrid functions.\", '        from .distributions import histplot, kdeplot', '        if func is histplot or func is kdeplot:', '            self._extract_legend_handles = True', '', '        kws = kwargs.copy()  # Use copy as we insert other kwargs', '        for i, j in indices:', '            x_var = self.x_vars[j]', '            y_var = self.y_vars[i]', '            ax = self.axes[i, j]', '            if ax is None:  # i.e. we are in corner mode', '                continue', '            self._plot_bivariate(x_var, y_var, ax, func, **kws)', '        self._add_axis_labels()', '', '        if \"hue\" in signature(func).parameters:', '            self.hue_names = list(self._legend_data)', '', '    def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):', '        \"\"\"Draw a bivariate plot on the specified axes.\"\"\"', '        if \"hue\" not in signature(func).parameters:', '            self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)', '            return', '', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = ax', '        else:', '            plt.sca(ax)', '', '        if x_var == y_var:', '            axes_vars = [x_var]', '        else:', '            axes_vars = [x_var, y_var]', '', '        if self._hue_var is not None and self._hue_var not in axes_vars:', '            axes_vars.append(self._hue_var)', '', '        data = self.data[axes_vars]', '        if self._dropna:', '            data = data.dropna()', '', '        x = data[x_var]', '        y = data[y_var]', '        if self._hue_var is None:', '            hue = None', '        else:', '            hue = data.get(self._hue_var)', '', '        if \"hue\" not in kwargs:', '            kwargs.update({', '                \"hue\": hue, \"hue_order\": self._hue_order, \"palette\": self._orig_palette,', '            })', '        func(x=x, y=y, **kwargs)', '', '        self._update_legend_data(ax)', '', '    def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):', '        \"\"\"Draw a bivariate plot while iterating over hue subsets.\"\"\"', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = ax', '        else:', '            plt.sca(ax)', '', '        if x_var == y_var:', '            axes_vars = [x_var]', '        else:', '            axes_vars = [x_var, y_var]', '', '        hue_grouped = self.data.groupby(self.hue_vals)', '        for k, label_k in enumerate(self._hue_order):', '', '            kws = kwargs.copy()', '', '            # Attempt to get data for this level, allowing for empty', '            try:', '                data_k = hue_grouped.get_group(label_k)', '            except KeyError:', '                data_k = pd.DataFrame(columns=axes_vars,', '                                      dtype=float)', '', '            if self._dropna:', '                data_k = data_k[axes_vars].dropna()', '', '            x = data_k[x_var]', '            y = data_k[y_var]', '', '            for kw, val_list in self.hue_kws.items():', '                kws[kw] = val_list[k]', '            kws.setdefault(\"color\", self.palette[k])', '            if self._hue_var is not None:', '                kws[\"label\"] = label_k', '', '            if str(func.__module__).startswith(\"seaborn\"):', '                func(x=x, y=y, **kws)', '            else:', '                func(x, y, **kws)', '', '        self._update_legend_data(ax)', '', '    def _add_axis_labels(self):', '        \"\"\"Add labels to the left and bottom Axes.\"\"\"', '        for ax, label in zip(self.axes[-1, :], self.x_vars):', '            ax.set_xlabel(label)', '        for ax, label in zip(self.axes[:, 0], self.y_vars):', '            ax.set_ylabel(label)', '', '    def _find_numeric_cols(self, data):', '        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"', '        numeric_cols = []', '        for col in data:', '            if variable_type(data[col]) == \"numeric\":', '                numeric_cols.append(col)', '        return numeric_cols', '', '', 'class JointGrid(_BaseGrid):', '    \"\"\"Grid for drawing a bivariate plot with marginal univariate plots.', '', '    Many plots can be drawn by using the figure-level interface :func:`jointplot`.', '    Use this class directly when you need more flexibility.', '', '    \"\"\"', '', '    def __init__(', '        self, data=None, *,', '        x=None, y=None, hue=None,', '        height=6, ratio=5, space=.2,', '        palette=None, hue_order=None, hue_norm=None,', '        dropna=False, xlim=None, ylim=None, marginal_ticks=False,', '    ):', '', '        # Set up the subplot grid', '        f = plt.figure(figsize=(height, height))', '        gs = plt.GridSpec(ratio + 1, ratio + 1)', '', '        ax_joint = f.add_subplot(gs[1:, :-1])', '        ax_marg_x = f.add_subplot(gs[0, :-1], sharex=ax_joint)', '        ax_marg_y = f.add_subplot(gs[1:, -1], sharey=ax_joint)', '', '        self._figure = f', '        self.ax_joint = ax_joint', '        self.ax_marg_x = ax_marg_x', '        self.ax_marg_y = ax_marg_y', '', '        # Turn off tick visibility for the measure axis on the marginal plots', '        plt.setp(ax_marg_x.get_xticklabels(), visible=False)', '        plt.setp(ax_marg_y.get_yticklabels(), visible=False)', '        plt.setp(ax_marg_x.get_xticklabels(minor=True), visible=False)', '        plt.setp(ax_marg_y.get_yticklabels(minor=True), visible=False)', '', '        # Turn off the ticks on the density axis for the marginal plots', '        if not marginal_ticks:', '            plt.setp(ax_marg_x.yaxis.get_majorticklines(), visible=False)', '            plt.setp(ax_marg_x.yaxis.get_minorticklines(), visible=False)', '            plt.setp(ax_marg_y.xaxis.get_majorticklines(), visible=False)', '            plt.setp(ax_marg_y.xaxis.get_minorticklines(), visible=False)', '            plt.setp(ax_marg_x.get_yticklabels(), visible=False)', '            plt.setp(ax_marg_y.get_xticklabels(), visible=False)', '            plt.setp(ax_marg_x.get_yticklabels(minor=True), visible=False)', '            plt.setp(ax_marg_y.get_xticklabels(minor=True), visible=False)', '            ax_marg_x.yaxis.grid(False)', '            ax_marg_y.xaxis.grid(False)', '', '        # Process the input variables', '        p = VectorPlotter(data=data, variables=dict(x=x, y=y, hue=hue))', '        plot_data = p.plot_data.loc[:, p.plot_data.notna().any()]', '', '        # Possibly drop NA', '        if dropna:', '            plot_data = plot_data.dropna()', '', '        def get_var(var):', '            vector = plot_data.get(var, None)', '            if vector is not None:', '                vector = vector.rename(p.variables.get(var, None))', '            return vector', '', '        self.x = get_var(\"x\")', '        self.y = get_var(\"y\")', '        self.hue = get_var(\"hue\")', '', '        for axis in \"xy\":', '            name = p.variables.get(axis, None)', '            if name is not None:', '                getattr(ax_joint, f\"set_{axis}label\")(name)', '', '        if xlim is not None:', '            ax_joint.set_xlim(xlim)', '        if ylim is not None:', '            ax_joint.set_ylim(ylim)', '', '        # Store the semantic mapping parameters for axes-level functions', '        self._hue_params = dict(palette=palette, hue_order=hue_order, hue_norm=hue_norm)', '', '        # Make the grid look nice', '        utils.despine(f)', '        if not marginal_ticks:', '            utils.despine(ax=ax_marg_x, left=True)', '            utils.despine(ax=ax_marg_y, bottom=True)', '        for axes in [ax_marg_x, ax_marg_y]:', '            for axis in [axes.xaxis, axes.yaxis]:', '                axis.label.set_visible(False)', '        f.tight_layout()', '        f.subplots_adjust(hspace=space, wspace=space)', '', '    def _inject_kwargs(self, func, kws, params):', '        \"\"\"Add params to kws if they are accepted by func.\"\"\"', '        func_params = signature(func).parameters', '        for key, val in params.items():', '            if key in func_params:', '                kws.setdefault(key, val)', '', '    def plot(self, joint_func, marginal_func, **kwargs):', '        \"\"\"Draw the plot by passing functions for joint and marginal axes.', '', '        This method passes the ``kwargs`` dictionary to both functions. If you', '        need more control, call :meth:`JointGrid.plot_joint` and', '        :meth:`JointGrid.plot_marginals` directly with specific parameters.', '', '        Parameters', '        ----------', '        joint_func, marginal_func : callables', '            Functions to draw the bivariate and univariate plots. See methods', '            referenced above for information about the required characteristics', '            of these functions.', '        kwargs', '            Additional keyword arguments are passed to both functions.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        self.plot_marginals(marginal_func, **kwargs)', '        self.plot_joint(joint_func, **kwargs)', '        return self', '', '    def plot_joint(self, func, **kwargs):', '        \"\"\"Draw a bivariate plot on the joint axes of the grid.', '', '        Parameters', '        ----------', '        func : plotting callable', '            If a seaborn function, it should accept ``x`` and ``y``. Otherwise,', '            it must accept ``x`` and ``y`` vectors of data as the first two', '            positional arguments, and it must plot on the \"current\" axes.', '            If ``hue`` was defined in the class constructor, the function must', '            accept ``hue`` as a parameter.', '        kwargs', '            Keyword argument are passed to the plotting function.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        kwargs = kwargs.copy()', '        if str(func.__module__).startswith(\"seaborn\"):', '            kwargs[\"ax\"] = self.ax_joint', '        else:', '            plt.sca(self.ax_joint)', '        if self.hue is not None:', '            kwargs[\"hue\"] = self.hue', '            self._inject_kwargs(func, kwargs, self._hue_params)', '', '        if str(func.__module__).startswith(\"seaborn\"):', '            func(x=self.x, y=self.y, **kwargs)', '        else:', '            func(self.x, self.y, **kwargs)', '', '        return self', '', '    def plot_marginals(self, func, **kwargs):', '        \"\"\"Draw univariate plots on each marginal axes.', '', '        Parameters', '        ----------', '        func : plotting callable', '            If a seaborn function, it should  accept ``x`` and ``y`` and plot', '            when only one of them is defined. Otherwise, it must accept a vector', '            of data as the first positional argument and determine its orientation', '            using the ``vertical`` parameter, and it must plot on the \"current\" axes.', '            If ``hue`` was defined in the class constructor, it must accept ``hue``', '            as a parameter.', '        kwargs', '            Keyword argument are passed to the plotting function.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        seaborn_func = (', '            str(func.__module__).startswith(\"seaborn\")', '            # deprecated distplot has a legacy API, special case it', '            and not func.__name__ == \"distplot\"', '        )', '        func_params = signature(func).parameters', '        kwargs = kwargs.copy()', '        if self.hue is not None:', '            kwargs[\"hue\"] = self.hue', '            self._inject_kwargs(func, kwargs, self._hue_params)', '', '        if \"legend\" in func_params:', '            kwargs.setdefault(\"legend\", False)', '', '        if \"orientation\" in func_params:', '            # e.g. plt.hist', '            orient_kw_x = {\"orientation\": \"vertical\"}', '            orient_kw_y = {\"orientation\": \"horizontal\"}', '        elif \"vertical\" in func_params:', '            # e.g. sns.distplot (also how did this get backwards?)', '            orient_kw_x = {\"vertical\": False}', '            orient_kw_y = {\"vertical\": True}', '', '        if seaborn_func:', '            func(x=self.x, ax=self.ax_marg_x, **kwargs)', '        else:', '            plt.sca(self.ax_marg_x)', '            func(self.x, **orient_kw_x, **kwargs)', '', '        if seaborn_func:', '            func(y=self.y, ax=self.ax_marg_y, **kwargs)', '        else:', '            plt.sca(self.ax_marg_y)', '            func(self.y, **orient_kw_y, **kwargs)', '', '        self.ax_marg_x.yaxis.get_label().set_visible(False)', '        self.ax_marg_y.xaxis.get_label().set_visible(False)', '', '        return self', '', '    def refline(', '        self, *, x=None, y=None, joint=True, marginal=True,', \"        color='.5', linestyle='--', **line_kws\", '    ):', '        \"\"\"Add a reference line(s) to joint and/or marginal axes.', '', '        Parameters', '        ----------', '        x, y : numeric', '            Value(s) to draw the line(s) at.', '        joint, marginal : bools', '            Whether to add the reference line(s) to the joint/marginal axes.', '        color : :mod:`matplotlib color <matplotlib.colors>`', '            Specifies the color of the reference line(s).', '        linestyle : str', '            Specifies the style of the reference line(s).', '        line_kws : key, value mappings', '            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`', '            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``', '            is not None.', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', \"        line_kws['color'] = color\", \"        line_kws['linestyle'] = linestyle\", '', '        if x is not None:', '            if joint:', '                self.ax_joint.axvline(x, **line_kws)', '            if marginal:', '                self.ax_marg_x.axvline(x, **line_kws)', '', '        if y is not None:', '            if joint:', '                self.ax_joint.axhline(y, **line_kws)', '            if marginal:', '                self.ax_marg_y.axhline(y, **line_kws)', '', '        return self', '', '    def set_axis_labels(self, xlabel=\"\", ylabel=\"\", **kwargs):', '        \"\"\"Set axis labels on the bivariate axes.', '', '        Parameters', '        ----------', '        xlabel, ylabel : strings', '            Label names for the x and y variables.', '        kwargs : key, value mappings', '            Other keyword arguments are passed to the following functions:', '', '            - :meth:`matplotlib.axes.Axes.set_xlabel`', '            - :meth:`matplotlib.axes.Axes.set_ylabel`', '', '        Returns', '        -------', '        :class:`JointGrid` instance', '            Returns ``self`` for easy method chaining.', '', '        \"\"\"', '        self.ax_joint.set_xlabel(xlabel, **kwargs)', '        self.ax_joint.set_ylabel(ylabel, **kwargs)', '        return self', '', '', 'JointGrid.__init__.__doc__ = \"\"\"\\\\', 'Set up the grid of subplots and store data internally for easy plotting.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', 'height : number', '    Size of each side of the figure in inches (it will be square).', 'ratio : number', '    Ratio of joint axes height to marginal axes height.', 'space : number', '    Space between the joint and marginal axes', 'dropna : bool', '    If True, remove missing observations before plotting.', '{{x, y}}lim : pairs of numbers', '    Set axis limits to these values before plotting.', 'marginal_ticks : bool', '    If False, suppress ticks on the count/density axis of the marginal plots.', '{params.core.hue}', '    Note: unlike in :class:`FacetGrid` or :class:`PairGrid`, the axes-level', '    functions must support ``hue`` to use it in :class:`JointGrid`.', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', '', 'See Also', '--------', '{seealso.jointplot}', '{seealso.pairgrid}', '{seealso.pairplot}', '', 'Examples', '--------', '', '.. include:: ../docstrings/JointGrid.rst', '', '\"\"\".format(', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')', '', '', 'def pairplot(', '    data, *,', '    hue=None, hue_order=None, palette=None,', '    vars=None, x_vars=None, y_vars=None,', '    kind=\"scatter\", diag_kind=\"auto\", markers=None,', '    height=2.5, aspect=1, corner=False, dropna=False,', '    plot_kws=None, diag_kws=None, grid_kws=None, size=None,', '):', '    \"\"\"Plot pairwise relationships in a dataset.', '', '    By default, this function will create a grid of Axes such that each numeric', '    variable in ``data`` will by shared across the y-axes across a single row and', '    the x-axes across a single column. The diagonal plots are treated', '    differently: a univariate distribution plot is drawn to show the marginal', '    distribution of the data in each column.', '', '    It is also possible to show a subset of variables or plot different', '    variables on the rows and columns.', '', '    This is a high-level interface for :class:`PairGrid` that is intended to', '    make it easy to draw a few common styles. You should use :class:`PairGrid`', '    directly if you need more flexibility.', '', '    Parameters', '    ----------', '    data : `pandas.DataFrame`', '        Tidy (long-form) dataframe where each column is a variable and', '        each row is an observation.', '    hue : name of variable in ``data``', '        Variable in ``data`` to map plot aspects to different colors.', '    hue_order : list of strings', '        Order for the levels of the hue variable in the palette', '    palette : dict or seaborn color palette', '        Set of colors for mapping the ``hue`` variable. If a dict, keys', '        should be values  in the ``hue`` variable.', '    vars : list of variable names', '        Variables within ``data`` to use, otherwise use every column with', '        a numeric datatype.', '    {x, y}_vars : lists of variable names', '        Variables within ``data`` to use separately for the rows and', '        columns of the figure; i.e. to make a non-square plot.', \"    kind : {'scatter', 'kde', 'hist', 'reg'}\", '        Kind of plot to make.', \"    diag_kind : {'auto', 'hist', 'kde', None}\", \"        Kind of plot for the diagonal subplots. If 'auto', choose based on\", '        whether or not ``hue`` is used.', '    markers : single matplotlib marker code or list', '        Either the marker to use for all scatterplot points or a list of markers', '        with a length the same as the number of levels in the hue variable so that', '        differently colored points will also have different scatterplot', '        markers.', '    height : scalar', '        Height (in inches) of each facet.', '    aspect : scalar', '        Aspect * height gives the width (in inches) of each facet.', '    corner : bool', \"        If True, don't add axes to the upper (off-diagonal) triangle of the\", '        grid, making this a \"corner\" plot.', '    dropna : boolean', '        Drop missing values from the data before plotting.', '    {plot, diag, grid}_kws : dicts', '        Dictionaries of keyword arguments. ``plot_kws`` are passed to the', '        bivariate plotting function, ``diag_kws`` are passed to the univariate', '        plotting function, and ``grid_kws`` are passed to the :class:`PairGrid`', '        constructor.', '', '    Returns', '    -------', '    grid : :class:`PairGrid`', '        Returns the underlying :class:`PairGrid` instance for further tweaking.', '', '    See Also', '    --------', '    PairGrid : Subplot grid for more flexible plotting of pairwise relationships.', '    JointGrid : Grid for plotting joint and marginal distributions of two variables.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/pairplot.rst', '', '    \"\"\"', '    # Avoid circular import', '    from .distributions import histplot, kdeplot', '', '    # Handle deprecations', '    if size is not None:', '        height = size', '        msg = (\"The `size` parameter has been renamed to `height`; \"', '               \"please update your code.\")', '        warnings.warn(msg, UserWarning)', '', '    if not isinstance(data, pd.DataFrame):', '        raise TypeError(', '            f\"\\'data\\' must be pandas DataFrame object, not: {type(data)}\")', '', '    plot_kws = {} if plot_kws is None else plot_kws.copy()', '    diag_kws = {} if diag_kws is None else diag_kws.copy()', '    grid_kws = {} if grid_kws is None else grid_kws.copy()', '', '    # Resolve \"auto\" diag kind', '    if diag_kind == \"auto\":', '        if hue is None:', '            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"', '        else:', '            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"', '', '    # Set up the PairGrid', '    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")', '    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,', '                    hue_order=hue_order, palette=palette, corner=corner,', '                    height=height, aspect=aspect, dropna=dropna, **grid_kws)', '', '    # Add the markers here as PairGrid has figured out how many levels of the', \"    # hue variable are needed and we don't want to duplicate that process\", '    if markers is not None:', '        if kind == \"reg\":', '            # Needed until regplot supports style', '            if grid.hue_names is None:', '                n_markers = 1', '            else:', '                n_markers = len(grid.hue_names)', '            if not isinstance(markers, list):', '                markers = [markers] * n_markers', '            if len(markers) != n_markers:', '                raise ValueError(\"markers must be a singleton or a list of \"', '                                 \"markers for each level of the hue variable\")', '            grid.hue_kws = {\"marker\": markers}', '        elif kind == \"scatter\":', '            if isinstance(markers, str):', '                plot_kws[\"marker\"] = markers', '            elif hue is not None:', '                plot_kws[\"style\"] = data[hue]', '                plot_kws[\"markers\"] = markers', '', '    # Draw the marginal plots on the diagonal', '    diag_kws = diag_kws.copy()', '    diag_kws.setdefault(\"legend\", False)', '    if diag_kind == \"hist\":', '        grid.map_diag(histplot, **diag_kws)', '    elif diag_kind == \"kde\":', '        diag_kws.setdefault(\"fill\", True)', '        diag_kws.setdefault(\"warn_singular\", False)', '        grid.map_diag(kdeplot, **diag_kws)', '', '    # Maybe plot on the off-diagonals', '    if diag_kind is not None:', '        plotter = grid.map_offdiag', '    else:', '        plotter = grid.map', '', '    if kind == \"scatter\":', '        from .relational import scatterplot  # Avoid circular import', '        plotter(scatterplot, **plot_kws)', '    elif kind == \"reg\":', '        from .regression import regplot  # Avoid circular import', '        plotter(regplot, **plot_kws)', '    elif kind == \"kde\":', '        from .distributions import kdeplot  # Avoid circular import', '        plot_kws.setdefault(\"warn_singular\", False)', '        plotter(kdeplot, **plot_kws)', '    elif kind == \"hist\":', '        from .distributions import histplot  # Avoid circular import', '        plotter(histplot, **plot_kws)', '', '    # Add a legend', '    if hue is not None:', '        grid.add_legend()', '', '    grid.tight_layout()', '', '    return grid', '', '', 'def jointplot(', '    data=None, *, x=None, y=None, hue=None, kind=\"scatter\",', '    height=6, ratio=5, space=.2, dropna=False, xlim=None, ylim=None,', '    color=None, palette=None, hue_order=None, hue_norm=None, marginal_ticks=False,', '    joint_kws=None, marginal_kws=None,', '    **kwargs', '):', '    # Avoid circular imports', '    from .relational import scatterplot', '    from .regression import regplot, residplot', '    from .distributions import histplot, kdeplot, _freedman_diaconis_bins', '', '    if kwargs.pop(\"ax\", None) is not None:', '        msg = \"Ignoring `ax`; jointplot is a figure-level function.\"', '        warnings.warn(msg, UserWarning, stacklevel=2)', '', '    # Set up empty default kwarg dicts', '    joint_kws = {} if joint_kws is None else joint_kws.copy()', '    joint_kws.update(kwargs)', '    marginal_kws = {} if marginal_kws is None else marginal_kws.copy()', '', '    # Handle deprecations of distplot-specific kwargs', '    distplot_keys = [', '        \"rug\", \"fit\", \"hist_kws\", \"norm_hist\" \"hist_kws\", \"rug_kws\",', '    ]', '    unused_keys = []', '    for key in distplot_keys:', '        if key in marginal_kws:', '            unused_keys.append(key)', '            marginal_kws.pop(key)', '    if unused_keys and kind != \"kde\":', '        msg = (', '            \"The marginal plotting function has changed to `histplot`,\"', '            \" which does not accept the following argument(s): {}.\"', '        ).format(\", \".join(unused_keys))', '        warnings.warn(msg, UserWarning)', '', '    # Validate the plot kind', '    plot_kinds = [\"scatter\", \"hist\", \"hex\", \"kde\", \"reg\", \"resid\"]', '    _check_argument(\"kind\", plot_kinds, kind)', '', '    # Raise early if using `hue` with a kind that does not support it', '    if hue is not None and kind in [\"hex\", \"reg\", \"resid\"]:', '        msg = (', '            f\"Use of `hue` with `kind=\\'{kind}\\'` is not currently supported.\"', '        )', '        raise ValueError(msg)', '', '    # Make a colormap based off the plot color', '    # (Currently used only for kind=\"hex\")', '    if color is None:', '        color = \"C0\"', '    color_rgb = mpl.colors.colorConverter.to_rgb(color)', '    colors = [utils.set_hls_values(color_rgb, l=l)  # noqa', '              for l in np.linspace(1, 0, 12)]', '    cmap = blend_palette(colors, as_cmap=True)', '', \"    # Matplotlib's hexbin plot is not na-robust\", '    if kind == \"hex\":', '        dropna = True', '', '    # Initialize the JointGrid object', '    grid = JointGrid(', '        data=data, x=x, y=y, hue=hue,', '        palette=palette, hue_order=hue_order, hue_norm=hue_norm,', '        dropna=dropna, height=height, ratio=ratio, space=space,', '        xlim=xlim, ylim=ylim, marginal_ticks=marginal_ticks,', '    )', '', '    if grid.hue is not None:', '        marginal_kws.setdefault(\"legend\", False)', '', '    # Plot the data using the grid', '    if kind.startswith(\"scatter\"):', '', '        joint_kws.setdefault(\"color\", color)', '        grid.plot_joint(scatterplot, **joint_kws)', '', '        if grid.hue is None:', '            marg_func = histplot', '        else:', '            marg_func = kdeplot', '            marginal_kws.setdefault(\"warn_singular\", False)', '            marginal_kws.setdefault(\"fill\", True)', '', '        marginal_kws.setdefault(\"color\", color)', '        grid.plot_marginals(marg_func, **marginal_kws)', '', '    elif kind.startswith(\"hist\"):', '', '        # TODO process pair parameters for bins, etc. and pass', '        # to both joint and marginal plots', '', '        joint_kws.setdefault(\"color\", color)', '        grid.plot_joint(histplot, **joint_kws)', '', '        marginal_kws.setdefault(\"kde\", False)', '        marginal_kws.setdefault(\"color\", color)', '', '        marg_x_kws = marginal_kws.copy()', '        marg_y_kws = marginal_kws.copy()', '', '        pair_keys = \"bins\", \"binwidth\", \"binrange\"', '        for key in pair_keys:', '            if isinstance(joint_kws.get(key), tuple):', '                x_val, y_val = joint_kws[key]', '                marg_x_kws.setdefault(key, x_val)', '                marg_y_kws.setdefault(key, y_val)', '', '        histplot(data=data, x=x, hue=hue, **marg_x_kws, ax=grid.ax_marg_x)', '        histplot(data=data, y=y, hue=hue, **marg_y_kws, ax=grid.ax_marg_y)', '', '    elif kind.startswith(\"kde\"):', '', '        joint_kws.setdefault(\"color\", color)', '        joint_kws.setdefault(\"warn_singular\", False)', '        grid.plot_joint(kdeplot, **joint_kws)', '', '        marginal_kws.setdefault(\"color\", color)', '        if \"fill\" in joint_kws:', '            marginal_kws.setdefault(\"fill\", joint_kws[\"fill\"])', '', '        grid.plot_marginals(kdeplot, **marginal_kws)', '', '    elif kind.startswith(\"hex\"):', '', '        x_bins = min(_freedman_diaconis_bins(grid.x), 50)', '        y_bins = min(_freedman_diaconis_bins(grid.y), 50)', '        gridsize = int(np.mean([x_bins, y_bins]))', '', '        joint_kws.setdefault(\"gridsize\", gridsize)', '        joint_kws.setdefault(\"cmap\", cmap)', '        grid.plot_joint(plt.hexbin, **joint_kws)', '', '        marginal_kws.setdefault(\"kde\", False)', '        marginal_kws.setdefault(\"color\", color)', '        grid.plot_marginals(histplot, **marginal_kws)', '', '    elif kind.startswith(\"reg\"):', '', '        marginal_kws.setdefault(\"color\", color)', '        marginal_kws.setdefault(\"kde\", True)', '        grid.plot_marginals(histplot, **marginal_kws)', '', '        joint_kws.setdefault(\"color\", color)', '        grid.plot_joint(regplot, **joint_kws)', '', '    elif kind.startswith(\"resid\"):', '', '        joint_kws.setdefault(\"color\", color)', '        grid.plot_joint(residplot, **joint_kws)', '', '        x, y = grid.ax_joint.collections[0].get_offsets().T', '        marginal_kws.setdefault(\"color\", color)', '        histplot(x=x, hue=hue, ax=grid.ax_marg_x, **marginal_kws)', '        histplot(y=y, hue=hue, ax=grid.ax_marg_y, **marginal_kws)', '', '    # Make the main axes active in the matplotlib state machine', '    plt.sca(grid.ax_joint)', '', '    return grid', '', '', 'jointplot.__doc__ = \"\"\"\\\\', 'Draw a plot of two variables with bivariate and univariate graphs.', '', 'This function provides a convenient interface to the :class:`JointGrid`', 'class, with several canned plot kinds. This is intended to be a fairly', 'lightweight wrapper; if you need more flexibility, you should use', ':class:`JointGrid` directly.', '', 'Parameters', '----------', '{params.core.data}', '{params.core.xy}', '{params.core.hue}', '    Semantic variable that is mapped to determine the color of plot elements.', 'kind : {{ \"scatter\" | \"kde\" | \"hist\" | \"hex\" | \"reg\" | \"resid\" }}', '    Kind of plot to draw. See the examples for references to the underlying functions.', 'height : numeric', '    Size of the figure (it will be square).', 'ratio : numeric', '    Ratio of joint axes height to marginal axes height.', 'space : numeric', '    Space between the joint and marginal axes', 'dropna : bool', '    If True, remove observations that are missing from ``x`` and ``y``.', '{{x, y}}lim : pairs of numbers', '    Axis limits to set before plotting.', '{params.core.color}', '{params.core.palette}', '{params.core.hue_order}', '{params.core.hue_norm}', 'marginal_ticks : bool', '    If False, suppress ticks on the count/density axis of the marginal plots.', '{{joint, marginal}}_kws : dicts', '    Additional keyword arguments for the plot components.', 'kwargs', '    Additional keyword arguments are passed to the function used to', '    draw the plot on the joint Axes, superseding items in the', '    ``joint_kws`` dictionary.', '', 'Returns', '-------', '{returns.jointgrid}', '', 'See Also', '--------', '{seealso.jointgrid}', '{seealso.pairgrid}', '{seealso.pairplot}', '', 'Examples', '--------', '', '.. include:: ../docstrings/jointplot.rst', '', '\"\"\".format(', '    params=_param_docs,', '    returns=_core_docs[\"returns\"],', '    seealso=_core_docs[\"seealso\"],', ')']}, '_decorators.py': {'classes': [], 'functions': [{'name': 'share_init_params_with_map', 'start_line': 4, 'end_line': 16, 'text': ['def share_init_params_with_map(cls):', '    \"\"\"Make cls.map a classmethod with same signature as cls.__init__.\"\"\"', '    map_sig = signature(cls.map)', '    init_sig = signature(cls.__init__)', '', '    new = [v for k, v in init_sig.parameters.items() if k != \"self\"]', '    new.insert(0, map_sig.parameters[\"cls\"])', '    cls.map.__signature__ = map_sig.replace(parameters=new)', '    cls.map.__doc__ = cls.__init__.__doc__', '', '    cls.map = classmethod(cls.map)', '', '    return cls']}], 'text': ['from inspect import signature', '', '', 'def share_init_params_with_map(cls):', '    \"\"\"Make cls.map a classmethod with same signature as cls.__init__.\"\"\"', '    map_sig = signature(cls.map)', '    init_sig = signature(cls.__init__)', '', '    new = [v for k, v in init_sig.parameters.items() if k != \"self\"]', '    new.insert(0, map_sig.parameters[\"cls\"])', '    cls.map.__signature__ = map_sig.replace(parameters=new)', '    cls.map.__doc__ = cls.__init__.__doc__', '', '    cls.map = classmethod(cls.map)', '', '    return cls']}, 'miscplot.py': {'classes': [], 'functions': [{'name': 'palplot', 'start_line': 9, 'end_line': 30, 'text': ['def palplot(pal, size=1):', '    \"\"\"Plot the values in a color palette as a horizontal array.', '', '    Parameters', '    ----------', '    pal : sequence of matplotlib colors', '        colors, i.e. as returned by seaborn.color_palette()', '    size :', '        scaling factor for size of plot', '', '    \"\"\"', '    n = len(pal)', '    f, ax = plt.subplots(1, 1, figsize=(n * size, size))', '    ax.imshow(np.arange(n).reshape(1, n),', '              cmap=mpl.colors.ListedColormap(list(pal)),', '              interpolation=\"nearest\", aspect=\"auto\")', '    ax.set_xticks(np.arange(n) - .5)', '    ax.set_yticks([-.5, .5])', '    # Ensure nice border between colors', '    ax.set_xticklabels([\"\" for _ in range(n)])', '    # The proper way to set no ticks', '    ax.yaxis.set_major_locator(ticker.NullLocator())']}, {'name': 'dogplot', 'start_line': 33, 'end_line': 48, 'text': ['def dogplot(*_, **__):', '    \"\"\"Who\\'s a good boy?\"\"\"', '    try:', '        from urllib.request import urlopen', '    except ImportError:', '        from urllib2 import urlopen', '    from io import BytesIO', '', '    url = \"https://github.com/mwaskom/seaborn-data/raw/master/png/img{}.png\"', '    pic = np.random.randint(2, 7)', '    data = BytesIO(urlopen(url.format(pic)).read())', '    img = plt.imread(data)', '    f, ax = plt.subplots(figsize=(5, 5), dpi=100)', '    f.subplots_adjust(0, 0, 1, 1)', '    ax.imshow(img)', '    ax.set_axis_off()']}], 'text': ['import numpy as np', 'import matplotlib as mpl', 'import matplotlib.pyplot as plt', 'import matplotlib.ticker as ticker', '', '__all__ = [\"palplot\", \"dogplot\"]', '', '', 'def palplot(pal, size=1):', '    \"\"\"Plot the values in a color palette as a horizontal array.', '', '    Parameters', '    ----------', '    pal : sequence of matplotlib colors', '        colors, i.e. as returned by seaborn.color_palette()', '    size :', '        scaling factor for size of plot', '', '    \"\"\"', '    n = len(pal)', '    f, ax = plt.subplots(1, 1, figsize=(n * size, size))', '    ax.imshow(np.arange(n).reshape(1, n),', '              cmap=mpl.colors.ListedColormap(list(pal)),', '              interpolation=\"nearest\", aspect=\"auto\")', '    ax.set_xticks(np.arange(n) - .5)', '    ax.set_yticks([-.5, .5])', '    # Ensure nice border between colors', '    ax.set_xticklabels([\"\" for _ in range(n)])', '    # The proper way to set no ticks', '    ax.yaxis.set_major_locator(ticker.NullLocator())', '', '', 'def dogplot(*_, **__):', '    \"\"\"Who\\'s a good boy?\"\"\"', '    try:', '        from urllib.request import urlopen', '    except ImportError:', '        from urllib2 import urlopen', '    from io import BytesIO', '', '    url = \"https://github.com/mwaskom/seaborn-data/raw/master/png/img{}.png\"', '    pic = np.random.randint(2, 7)', '    data = BytesIO(urlopen(url.format(pic)).read())', '    img = plt.imread(data)', '    f, ax = plt.subplots(figsize=(5, 5), dpi=100)', '    f.subplots_adjust(0, 0, 1, 1)', '    ax.imshow(img)', '    ax.set_axis_off()']}, 'rcmod.py': {'classes': [{'name': '_RCAesthetics', 'start_line': 473, 'end_line': 487, 'text': ['class _RCAesthetics(dict):', '    def __enter__(self):', '        rc = mpl.rcParams', '        self._orig = {k: rc[k] for k in self._keys}', '        self._set(self)', '', '    def __exit__(self, exc_type, exc_value, exc_tb):', '        self._set(self._orig)', '', '    def __call__(self, func):', '        @functools.wraps(func)', '        def wrapper(*args, **kwargs):', '            with self:', '                return func(*args, **kwargs)', '        return wrapper'], 'methods': [{'name': '__enter__', 'start_line': 474, 'end_line': 477, 'text': ['    def __enter__(self):', '        rc = mpl.rcParams', '        self._orig = {k: rc[k] for k in self._keys}', '        self._set(self)']}, {'name': '__exit__', 'start_line': 479, 'end_line': 480, 'text': ['    def __exit__(self, exc_type, exc_value, exc_tb):', '        self._set(self._orig)']}, {'name': '__call__', 'start_line': 482, 'end_line': 487, 'text': ['    def __call__(self, func):', '        @functools.wraps(func)', '        def wrapper(*args, **kwargs):', '            with self:', '                return func(*args, **kwargs)', '        return wrapper']}]}, {'name': '_AxesStyle', 'start_line': 490, 'end_line': 493, 'text': ['class _AxesStyle(_RCAesthetics):', '    \"\"\"Light wrapper on a dict to set style temporarily.\"\"\"', '    _keys = _style_keys', '    _set = staticmethod(set_style)'], 'methods': []}, {'name': '_PlottingContext', 'start_line': 496, 'end_line': 499, 'text': ['class _PlottingContext(_RCAesthetics):', '    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"', '    _keys = _context_keys', '    _set = staticmethod(set_context)'], 'methods': []}], 'functions': [{'name': 'set_theme', 'start_line': 82, 'end_line': 123, 'text': ['def set_theme(context=\"notebook\", style=\"darkgrid\", palette=\"deep\",', '              font=\"sans-serif\", font_scale=1, color_codes=True, rc=None):', '    \"\"\"', '    Set aspects of the visual theme for all matplotlib and seaborn plots.', '', '    This function changes the global defaults for all plots using the', '    matplotlib rcParams system. The themeing is decomposed into several distinct', '    sets of parameter values.', '', '    The options are illustrated in the :doc:`aesthetics <../tutorial/aesthetics>`', '    and :doc:`color palette <../tutorial/color_palettes>` tutorials.', '', '    Parameters', '    ----------', '    context : string or dict', '        Scaling parameters, see :func:`plotting_context`.', '    style : string or dict', '        Axes style parameters, see :func:`axes_style`.', '    palette : string or sequence', '        Color palette, see :func:`color_palette`.', '    font : string', '        Font family, see matplotlib font manager.', '    font_scale : float, optional', '        Separate scaling factor to independently scale the size of the', '        font elements.', '    color_codes : bool', '        If ``True`` and ``palette`` is a seaborn palette, remap the shorthand', '        color codes (e.g. \"b\", \"g\", \"r\", etc.) to the colors from this palette.', '    rc : dict or None', '        Dictionary of rc parameter mappings to override the above.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/set_theme.rst', '', '    \"\"\"', '    set_context(context, font_scale)', '    set_style(style, rc={\"font.family\": font})', '    set_palette(palette, color_codes=color_codes)', '    if rc is not None:', '        mpl.rcParams.update(rc)']}, {'name': 'set', 'start_line': 126, 'end_line': 132, 'text': ['def set(*args, **kwargs):', '    \"\"\"', '    Alias for :func:`set_theme`, which is the preferred interface.', '', '    This function may be removed in the future.', '    \"\"\"', '    set_theme(*args, **kwargs)']}, {'name': 'reset_defaults', 'start_line': 135, 'end_line': 137, 'text': ['def reset_defaults():', '    \"\"\"Restore all RC params to default settings.\"\"\"', '    mpl.rcParams.update(mpl.rcParamsDefault)']}, {'name': 'reset_orig', 'start_line': 140, 'end_line': 143, 'text': ['def reset_orig():', '    \"\"\"Restore all RC params to original settings (respects custom rc).\"\"\"', '    from . import _orig_rc_params', '    mpl.rcParams.update(_orig_rc_params)']}, {'name': 'axes_style', 'start_line': 146, 'end_line': 300, 'text': ['def axes_style(style=None, rc=None):', '    \"\"\"', '    Get the parameters that control the general style of the plots.', '', '    The style parameters control properties like the color of the background and', '    whether a grid is enabled by default. This is accomplished using the', '    matplotlib rcParams system.', '', '    The options are illustrated in the', '    :doc:`aesthetics tutorial <../tutorial/aesthetics>`.', '', '    This function can also be used as a context manager to temporarily', '    alter the global defaults. See :func:`set_theme` or :func:`set_style`', '    to modify the global defaults for all plots.', '', '    Parameters', '    ----------', '    style : None, dict, or one of {darkgrid, whitegrid, dark, white, ticks}', '        A dictionary of parameters or the name of a preconfigured style.', '    rc : dict, optional', '        Parameter mappings to override the values in the preset seaborn', '        style dictionaries. This only updates parameters that are', '        considered part of the style definition.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/axes_style.rst', '', '    \"\"\"', '    if style is None:', '        style_dict = {k: mpl.rcParams[k] for k in _style_keys}', '', '    elif isinstance(style, dict):', '        style_dict = style', '', '    else:', '        styles = [\"white\", \"dark\", \"whitegrid\", \"darkgrid\", \"ticks\"]', '        if style not in styles:', '            raise ValueError(f\"style must be one of {\\', \\'.join(styles)}\")', '', '        # Define colors here', '        dark_gray = \".15\"', '        light_gray = \".8\"', '', '        # Common parameters', '        style_dict = {', '', '            \"figure.facecolor\": \"white\",', '            \"axes.labelcolor\": dark_gray,', '', '            \"xtick.direction\": \"out\",', '            \"ytick.direction\": \"out\",', '            \"xtick.color\": dark_gray,', '            \"ytick.color\": dark_gray,', '', '            \"axes.axisbelow\": True,', '            \"grid.linestyle\": \"-\",', '', '', '            \"text.color\": dark_gray,', '            \"font.family\": [\"sans-serif\"],', '            \"font.sans-serif\": [\"Arial\", \"DejaVu Sans\", \"Liberation Sans\",', '                                \"Bitstream Vera Sans\", \"sans-serif\"],', '', '', '            \"lines.solid_capstyle\": \"round\",', '            \"patch.edgecolor\": \"w\",', '            \"patch.force_edgecolor\": True,', '', '            \"image.cmap\": \"rocket\",', '', '            \"xtick.top\": False,', '            \"ytick.right\": False,', '', '        }', '', '        # Set grid on or off', '        if \"grid\" in style:', '            style_dict.update({', '                \"axes.grid\": True,', '            })', '        else:', '            style_dict.update({', '                \"axes.grid\": False,', '            })', '', '        # Set the color of the background, spines, and grids', '        if style.startswith(\"dark\"):', '            style_dict.update({', '', '                \"axes.facecolor\": \"#EAEAF2\",', '                \"axes.edgecolor\": \"white\",', '                \"grid.color\": \"white\",', '', '                \"axes.spines.left\": True,', '                \"axes.spines.bottom\": True,', '                \"axes.spines.right\": True,', '                \"axes.spines.top\": True,', '', '            })', '', '        elif style == \"whitegrid\":', '            style_dict.update({', '', '                \"axes.facecolor\": \"white\",', '                \"axes.edgecolor\": light_gray,', '                \"grid.color\": light_gray,', '', '                \"axes.spines.left\": True,', '                \"axes.spines.bottom\": True,', '                \"axes.spines.right\": True,', '                \"axes.spines.top\": True,', '', '            })', '', '        elif style in [\"white\", \"ticks\"]:', '            style_dict.update({', '', '                \"axes.facecolor\": \"white\",', '                \"axes.edgecolor\": dark_gray,', '                \"grid.color\": light_gray,', '', '                \"axes.spines.left\": True,', '                \"axes.spines.bottom\": True,', '                \"axes.spines.right\": True,', '                \"axes.spines.top\": True,', '', '            })', '', '        # Show or hide the axes ticks', '        if style == \"ticks\":', '            style_dict.update({', '                \"xtick.bottom\": True,', '                \"ytick.left\": True,', '            })', '        else:', '            style_dict.update({', '                \"xtick.bottom\": False,', '                \"ytick.left\": False,', '            })', '', '    # Remove entries that are not defined in the base list of valid keys', '    # This lets us handle matplotlib <=/> 2.0', '    style_dict = {k: v for k, v in style_dict.items() if k in _style_keys}', '', '    # Override these settings with the provided rc dictionary', '    if rc is not None:', '        rc = {k: v for k, v in rc.items() if k in _style_keys}', '        style_dict.update(rc)', '', '    # Wrap in an _AxesStyle object so this can be used in a with statement', '    style_object = _AxesStyle(style_dict)', '', '    return style_object']}, {'name': 'set_style', 'start_line': 303, 'end_line': 332, 'text': ['def set_style(style=None, rc=None):', '    \"\"\"', '    Set the parameters that control the general style of the plots.', '', '    The style parameters control properties like the color of the background and', '    whether a grid is enabled by default. This is accomplished using the', '    matplotlib rcParams system.', '', '    The options are illustrated in the', '    :doc:`aesthetics tutorial <../tutorial/aesthetics>`.', '', '    See :func:`axes_style` to get the parameter values.', '', '    Parameters', '    ----------', '    style : dict, or one of {darkgrid, whitegrid, dark, white, ticks}', '        A dictionary of parameters or the name of a preconfigured style.', '    rc : dict, optional', '        Parameter mappings to override the values in the preset seaborn', '        style dictionaries. This only updates parameters that are', '        considered part of the style definition.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/set_style.rst', '', '    \"\"\"', '    style_object = axes_style(style, rc)', '    mpl.rcParams.update(style_object)']}, {'name': 'plotting_context', 'start_line': 335, 'end_line': 433, 'text': ['def plotting_context(context=None, font_scale=1, rc=None):', '    \"\"\"', '    Get the parameters that control the scaling of plot elements.', '', '    This affects things like the size of the labels, lines, and other elements', '    of the plot, but not the overall style. This is accomplished using the', '    matplotlib rcParams system.', '', '    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",', '    and \"poster\", which are version of the notebook parameters scaled by different', '    values. Font elements can also be scaled independently of (but relative to)', '    the other values.', '', '    This function can also be used as a context manager to temporarily', '    alter the global defaults. See :func:`set_theme` or :func:`set_context`', '    to modify the global defaults for all plots.', '', '    Parameters', '    ----------', '    context : None, dict, or one of {paper, notebook, talk, poster}', '        A dictionary of parameters or the name of a preconfigured set.', '    font_scale : float, optional', '        Separate scaling factor to independently scale the size of the', '        font elements.', '    rc : dict, optional', '        Parameter mappings to override the values in the preset seaborn', '        context dictionaries. This only updates parameters that are', '        considered part of the context definition.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/plotting_context.rst', '', '    \"\"\"', '    if context is None:', '        context_dict = {k: mpl.rcParams[k] for k in _context_keys}', '', '    elif isinstance(context, dict):', '        context_dict = context', '', '    else:', '', '        contexts = [\"paper\", \"notebook\", \"talk\", \"poster\"]', '        if context not in contexts:', '            raise ValueError(f\"context must be in {\\', \\'.join(contexts)}\")', '', '        # Set up dictionary of default parameters', '        texts_base_context = {', '', '            \"font.size\": 12,', '            \"axes.labelsize\": 12,', '            \"axes.titlesize\": 12,', '            \"xtick.labelsize\": 11,', '            \"ytick.labelsize\": 11,', '            \"legend.fontsize\": 11,', '            \"legend.title_fontsize\": 12,', '', '        }', '', '        base_context = {', '', '            \"axes.linewidth\": 1.25,', '            \"grid.linewidth\": 1,', '            \"lines.linewidth\": 1.5,', '            \"lines.markersize\": 6,', '            \"patch.linewidth\": 1,', '', '            \"xtick.major.width\": 1.25,', '            \"ytick.major.width\": 1.25,', '            \"xtick.minor.width\": 1,', '            \"ytick.minor.width\": 1,', '', '            \"xtick.major.size\": 6,', '            \"ytick.major.size\": 6,', '            \"xtick.minor.size\": 4,', '            \"ytick.minor.size\": 4,', '', '        }', '        base_context.update(texts_base_context)', '', '        # Scale all the parameters by the same factor depending on the context', '        scaling = dict(paper=.8, notebook=1, talk=1.5, poster=2)[context]', '        context_dict = {k: v * scaling for k, v in base_context.items()}', '', '        # Now independently scale the fonts', '        font_keys = texts_base_context.keys()', '        font_dict = {k: context_dict[k] * font_scale for k in font_keys}', '        context_dict.update(font_dict)', '', '    # Override these settings with the provided rc dictionary', '    if rc is not None:', '        rc = {k: v for k, v in rc.items() if k in _context_keys}', '        context_dict.update(rc)', '', '    # Wrap in a _PlottingContext object so this can be used in a with statement', '    context_object = _PlottingContext(context_dict)', '', '    return context_object']}, {'name': 'set_context', 'start_line': 436, 'end_line': 470, 'text': ['def set_context(context=None, font_scale=1, rc=None):', '    \"\"\"', '    Set the parameters that control the scaling of plot elements.', '', '    This affects things like the size of the labels, lines, and other elements', '    of the plot, but not the overall style. This is accomplished using the', '    matplotlib rcParams system.', '', '    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",', '    and \"poster\", which are version of the notebook parameters scaled by different', '    values. Font elements can also be scaled independently of (but relative to)', '    the other values.', '', '    See :func:`plotting_context` to get the parameter values.', '', '    Parameters', '    ----------', '    context : dict, or one of {paper, notebook, talk, poster}', '        A dictionary of parameters or the name of a preconfigured set.', '    font_scale : float, optional', '        Separate scaling factor to independently scale the size of the', '        font elements.', '    rc : dict, optional', '        Parameter mappings to override the values in the preset seaborn', '        context dictionaries. This only updates parameters that are', '        considered part of the context definition.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/set_context.rst', '', '    \"\"\"', '    context_object = plotting_context(context, font_scale, rc)', '    mpl.rcParams.update(context_object)']}, {'name': 'set_palette', 'start_line': 502, 'end_line': 534, 'text': ['def set_palette(palette, n_colors=None, desat=None, color_codes=False):', '    \"\"\"Set the matplotlib color cycle using a seaborn palette.', '', '    Parameters', '    ----------', '    palette : seaborn color paltte | matplotlib colormap | hls | husl', '        Palette definition. Should be something :func:`color_palette` can process.', '    n_colors : int', '        Number of colors in the cycle. The default number of colors will depend', '        on the format of ``palette``, see the :func:`color_palette`', '        documentation for more information.', '    desat : float', '        Proportion to desaturate each color by.', '    color_codes : bool', '        If ``True`` and ``palette`` is a seaborn palette, remap the shorthand', '        color codes (e.g. \"b\", \"g\", \"r\", etc.) to the colors from this palette.', '', '    See Also', '    --------', '    color_palette : build a color palette or set the color cycle temporarily', '                    in a ``with`` statement.', '    set_context : set parameters to scale plot elements', '    set_style : set the default parameters for figure style', '', '    \"\"\"', '    colors = palettes.color_palette(palette, n_colors, desat)', \"    cyl = cycler('color', colors)\", \"    mpl.rcParams['axes.prop_cycle'] = cyl\", '    if color_codes:', '        try:', '            palettes.set_color_codes(palette)', '        except (ValueError, TypeError):', '            pass']}, {'name': 'wrapper', 'start_line': 484, 'end_line': 486, 'text': ['        def wrapper(*args, **kwargs):', '            with self:', '                return func(*args, **kwargs)']}], 'text': ['\"\"\"Control plot style and scaling using the matplotlib rcParams interface.\"\"\"', 'import functools', 'import matplotlib as mpl', 'from cycler import cycler', 'from . import palettes', '', '', '__all__ = [\"set_theme\", \"set\", \"reset_defaults\", \"reset_orig\",', '           \"axes_style\", \"set_style\", \"plotting_context\", \"set_context\",', '           \"set_palette\"]', '', '', '_style_keys = [', '', '    \"axes.facecolor\",', '    \"axes.edgecolor\",', '    \"axes.grid\",', '    \"axes.axisbelow\",', '    \"axes.labelcolor\",', '', '    \"figure.facecolor\",', '', '    \"grid.color\",', '    \"grid.linestyle\",', '', '    \"text.color\",', '', '    \"xtick.color\",', '    \"ytick.color\",', '    \"xtick.direction\",', '    \"ytick.direction\",', '    \"lines.solid_capstyle\",', '', '    \"patch.edgecolor\",', '    \"patch.force_edgecolor\",', '', '    \"image.cmap\",', '    \"font.family\",', '    \"font.sans-serif\",', '', '    \"xtick.bottom\",', '    \"xtick.top\",', '    \"ytick.left\",', '    \"ytick.right\",', '', '    \"axes.spines.left\",', '    \"axes.spines.bottom\",', '    \"axes.spines.right\",', '    \"axes.spines.top\",', '', ']', '', '_context_keys = [', '', '    \"font.size\",', '    \"axes.labelsize\",', '    \"axes.titlesize\",', '    \"xtick.labelsize\",', '    \"ytick.labelsize\",', '    \"legend.fontsize\",', '    \"legend.title_fontsize\",', '', '    \"axes.linewidth\",', '    \"grid.linewidth\",', '    \"lines.linewidth\",', '    \"lines.markersize\",', '    \"patch.linewidth\",', '', '    \"xtick.major.width\",', '    \"ytick.major.width\",', '    \"xtick.minor.width\",', '    \"ytick.minor.width\",', '', '    \"xtick.major.size\",', '    \"ytick.major.size\",', '    \"xtick.minor.size\",', '    \"ytick.minor.size\",', '', ']', '', '', 'def set_theme(context=\"notebook\", style=\"darkgrid\", palette=\"deep\",', '              font=\"sans-serif\", font_scale=1, color_codes=True, rc=None):', '    \"\"\"', '    Set aspects of the visual theme for all matplotlib and seaborn plots.', '', '    This function changes the global defaults for all plots using the', '    matplotlib rcParams system. The themeing is decomposed into several distinct', '    sets of parameter values.', '', '    The options are illustrated in the :doc:`aesthetics <../tutorial/aesthetics>`', '    and :doc:`color palette <../tutorial/color_palettes>` tutorials.', '', '    Parameters', '    ----------', '    context : string or dict', '        Scaling parameters, see :func:`plotting_context`.', '    style : string or dict', '        Axes style parameters, see :func:`axes_style`.', '    palette : string or sequence', '        Color palette, see :func:`color_palette`.', '    font : string', '        Font family, see matplotlib font manager.', '    font_scale : float, optional', '        Separate scaling factor to independently scale the size of the', '        font elements.', '    color_codes : bool', '        If ``True`` and ``palette`` is a seaborn palette, remap the shorthand', '        color codes (e.g. \"b\", \"g\", \"r\", etc.) to the colors from this palette.', '    rc : dict or None', '        Dictionary of rc parameter mappings to override the above.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/set_theme.rst', '', '    \"\"\"', '    set_context(context, font_scale)', '    set_style(style, rc={\"font.family\": font})', '    set_palette(palette, color_codes=color_codes)', '    if rc is not None:', '        mpl.rcParams.update(rc)', '', '', 'def set(*args, **kwargs):', '    \"\"\"', '    Alias for :func:`set_theme`, which is the preferred interface.', '', '    This function may be removed in the future.', '    \"\"\"', '    set_theme(*args, **kwargs)', '', '', 'def reset_defaults():', '    \"\"\"Restore all RC params to default settings.\"\"\"', '    mpl.rcParams.update(mpl.rcParamsDefault)', '', '', 'def reset_orig():', '    \"\"\"Restore all RC params to original settings (respects custom rc).\"\"\"', '    from . import _orig_rc_params', '    mpl.rcParams.update(_orig_rc_params)', '', '', 'def axes_style(style=None, rc=None):', '    \"\"\"', '    Get the parameters that control the general style of the plots.', '', '    The style parameters control properties like the color of the background and', '    whether a grid is enabled by default. This is accomplished using the', '    matplotlib rcParams system.', '', '    The options are illustrated in the', '    :doc:`aesthetics tutorial <../tutorial/aesthetics>`.', '', '    This function can also be used as a context manager to temporarily', '    alter the global defaults. See :func:`set_theme` or :func:`set_style`', '    to modify the global defaults for all plots.', '', '    Parameters', '    ----------', '    style : None, dict, or one of {darkgrid, whitegrid, dark, white, ticks}', '        A dictionary of parameters or the name of a preconfigured style.', '    rc : dict, optional', '        Parameter mappings to override the values in the preset seaborn', '        style dictionaries. This only updates parameters that are', '        considered part of the style definition.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/axes_style.rst', '', '    \"\"\"', '    if style is None:', '        style_dict = {k: mpl.rcParams[k] for k in _style_keys}', '', '    elif isinstance(style, dict):', '        style_dict = style', '', '    else:', '        styles = [\"white\", \"dark\", \"whitegrid\", \"darkgrid\", \"ticks\"]', '        if style not in styles:', '            raise ValueError(f\"style must be one of {\\', \\'.join(styles)}\")', '', '        # Define colors here', '        dark_gray = \".15\"', '        light_gray = \".8\"', '', '        # Common parameters', '        style_dict = {', '', '            \"figure.facecolor\": \"white\",', '            \"axes.labelcolor\": dark_gray,', '', '            \"xtick.direction\": \"out\",', '            \"ytick.direction\": \"out\",', '            \"xtick.color\": dark_gray,', '            \"ytick.color\": dark_gray,', '', '            \"axes.axisbelow\": True,', '            \"grid.linestyle\": \"-\",', '', '', '            \"text.color\": dark_gray,', '            \"font.family\": [\"sans-serif\"],', '            \"font.sans-serif\": [\"Arial\", \"DejaVu Sans\", \"Liberation Sans\",', '                                \"Bitstream Vera Sans\", \"sans-serif\"],', '', '', '            \"lines.solid_capstyle\": \"round\",', '            \"patch.edgecolor\": \"w\",', '            \"patch.force_edgecolor\": True,', '', '            \"image.cmap\": \"rocket\",', '', '            \"xtick.top\": False,', '            \"ytick.right\": False,', '', '        }', '', '        # Set grid on or off', '        if \"grid\" in style:', '            style_dict.update({', '                \"axes.grid\": True,', '            })', '        else:', '            style_dict.update({', '                \"axes.grid\": False,', '            })', '', '        # Set the color of the background, spines, and grids', '        if style.startswith(\"dark\"):', '            style_dict.update({', '', '                \"axes.facecolor\": \"#EAEAF2\",', '                \"axes.edgecolor\": \"white\",', '                \"grid.color\": \"white\",', '', '                \"axes.spines.left\": True,', '                \"axes.spines.bottom\": True,', '                \"axes.spines.right\": True,', '                \"axes.spines.top\": True,', '', '            })', '', '        elif style == \"whitegrid\":', '            style_dict.update({', '', '                \"axes.facecolor\": \"white\",', '                \"axes.edgecolor\": light_gray,', '                \"grid.color\": light_gray,', '', '                \"axes.spines.left\": True,', '                \"axes.spines.bottom\": True,', '                \"axes.spines.right\": True,', '                \"axes.spines.top\": True,', '', '            })', '', '        elif style in [\"white\", \"ticks\"]:', '            style_dict.update({', '', '                \"axes.facecolor\": \"white\",', '                \"axes.edgecolor\": dark_gray,', '                \"grid.color\": light_gray,', '', '                \"axes.spines.left\": True,', '                \"axes.spines.bottom\": True,', '                \"axes.spines.right\": True,', '                \"axes.spines.top\": True,', '', '            })', '', '        # Show or hide the axes ticks', '        if style == \"ticks\":', '            style_dict.update({', '                \"xtick.bottom\": True,', '                \"ytick.left\": True,', '            })', '        else:', '            style_dict.update({', '                \"xtick.bottom\": False,', '                \"ytick.left\": False,', '            })', '', '    # Remove entries that are not defined in the base list of valid keys', '    # This lets us handle matplotlib <=/> 2.0', '    style_dict = {k: v for k, v in style_dict.items() if k in _style_keys}', '', '    # Override these settings with the provided rc dictionary', '    if rc is not None:', '        rc = {k: v for k, v in rc.items() if k in _style_keys}', '        style_dict.update(rc)', '', '    # Wrap in an _AxesStyle object so this can be used in a with statement', '    style_object = _AxesStyle(style_dict)', '', '    return style_object', '', '', 'def set_style(style=None, rc=None):', '    \"\"\"', '    Set the parameters that control the general style of the plots.', '', '    The style parameters control properties like the color of the background and', '    whether a grid is enabled by default. This is accomplished using the', '    matplotlib rcParams system.', '', '    The options are illustrated in the', '    :doc:`aesthetics tutorial <../tutorial/aesthetics>`.', '', '    See :func:`axes_style` to get the parameter values.', '', '    Parameters', '    ----------', '    style : dict, or one of {darkgrid, whitegrid, dark, white, ticks}', '        A dictionary of parameters or the name of a preconfigured style.', '    rc : dict, optional', '        Parameter mappings to override the values in the preset seaborn', '        style dictionaries. This only updates parameters that are', '        considered part of the style definition.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/set_style.rst', '', '    \"\"\"', '    style_object = axes_style(style, rc)', '    mpl.rcParams.update(style_object)', '', '', 'def plotting_context(context=None, font_scale=1, rc=None):', '    \"\"\"', '    Get the parameters that control the scaling of plot elements.', '', '    This affects things like the size of the labels, lines, and other elements', '    of the plot, but not the overall style. This is accomplished using the', '    matplotlib rcParams system.', '', '    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",', '    and \"poster\", which are version of the notebook parameters scaled by different', '    values. Font elements can also be scaled independently of (but relative to)', '    the other values.', '', '    This function can also be used as a context manager to temporarily', '    alter the global defaults. See :func:`set_theme` or :func:`set_context`', '    to modify the global defaults for all plots.', '', '    Parameters', '    ----------', '    context : None, dict, or one of {paper, notebook, talk, poster}', '        A dictionary of parameters or the name of a preconfigured set.', '    font_scale : float, optional', '        Separate scaling factor to independently scale the size of the', '        font elements.', '    rc : dict, optional', '        Parameter mappings to override the values in the preset seaborn', '        context dictionaries. This only updates parameters that are', '        considered part of the context definition.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/plotting_context.rst', '', '    \"\"\"', '    if context is None:', '        context_dict = {k: mpl.rcParams[k] for k in _context_keys}', '', '    elif isinstance(context, dict):', '        context_dict = context', '', '    else:', '', '        contexts = [\"paper\", \"notebook\", \"talk\", \"poster\"]', '        if context not in contexts:', '            raise ValueError(f\"context must be in {\\', \\'.join(contexts)}\")', '', '        # Set up dictionary of default parameters', '        texts_base_context = {', '', '            \"font.size\": 12,', '            \"axes.labelsize\": 12,', '            \"axes.titlesize\": 12,', '            \"xtick.labelsize\": 11,', '            \"ytick.labelsize\": 11,', '            \"legend.fontsize\": 11,', '            \"legend.title_fontsize\": 12,', '', '        }', '', '        base_context = {', '', '            \"axes.linewidth\": 1.25,', '            \"grid.linewidth\": 1,', '            \"lines.linewidth\": 1.5,', '            \"lines.markersize\": 6,', '            \"patch.linewidth\": 1,', '', '            \"xtick.major.width\": 1.25,', '            \"ytick.major.width\": 1.25,', '            \"xtick.minor.width\": 1,', '            \"ytick.minor.width\": 1,', '', '            \"xtick.major.size\": 6,', '            \"ytick.major.size\": 6,', '            \"xtick.minor.size\": 4,', '            \"ytick.minor.size\": 4,', '', '        }', '        base_context.update(texts_base_context)', '', '        # Scale all the parameters by the same factor depending on the context', '        scaling = dict(paper=.8, notebook=1, talk=1.5, poster=2)[context]', '        context_dict = {k: v * scaling for k, v in base_context.items()}', '', '        # Now independently scale the fonts', '        font_keys = texts_base_context.keys()', '        font_dict = {k: context_dict[k] * font_scale for k in font_keys}', '        context_dict.update(font_dict)', '', '    # Override these settings with the provided rc dictionary', '    if rc is not None:', '        rc = {k: v for k, v in rc.items() if k in _context_keys}', '        context_dict.update(rc)', '', '    # Wrap in a _PlottingContext object so this can be used in a with statement', '    context_object = _PlottingContext(context_dict)', '', '    return context_object', '', '', 'def set_context(context=None, font_scale=1, rc=None):', '    \"\"\"', '    Set the parameters that control the scaling of plot elements.', '', '    This affects things like the size of the labels, lines, and other elements', '    of the plot, but not the overall style. This is accomplished using the', '    matplotlib rcParams system.', '', '    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",', '    and \"poster\", which are version of the notebook parameters scaled by different', '    values. Font elements can also be scaled independently of (but relative to)', '    the other values.', '', '    See :func:`plotting_context` to get the parameter values.', '', '    Parameters', '    ----------', '    context : dict, or one of {paper, notebook, talk, poster}', '        A dictionary of parameters or the name of a preconfigured set.', '    font_scale : float, optional', '        Separate scaling factor to independently scale the size of the', '        font elements.', '    rc : dict, optional', '        Parameter mappings to override the values in the preset seaborn', '        context dictionaries. This only updates parameters that are', '        considered part of the context definition.', '', '    Examples', '    --------', '', '    .. include:: ../docstrings/set_context.rst', '', '    \"\"\"', '    context_object = plotting_context(context, font_scale, rc)', '    mpl.rcParams.update(context_object)', '', '', 'class _RCAesthetics(dict):', '    def __enter__(self):', '        rc = mpl.rcParams', '        self._orig = {k: rc[k] for k in self._keys}', '        self._set(self)', '', '    def __exit__(self, exc_type, exc_value, exc_tb):', '        self._set(self._orig)', '', '    def __call__(self, func):', '        @functools.wraps(func)', '        def wrapper(*args, **kwargs):', '            with self:', '                return func(*args, **kwargs)', '        return wrapper', '', '', 'class _AxesStyle(_RCAesthetics):', '    \"\"\"Light wrapper on a dict to set style temporarily.\"\"\"', '    _keys = _style_keys', '    _set = staticmethod(set_style)', '', '', 'class _PlottingContext(_RCAesthetics):', '    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"', '    _keys = _context_keys', '    _set = staticmethod(set_context)', '', '', 'def set_palette(palette, n_colors=None, desat=None, color_codes=False):', '    \"\"\"Set the matplotlib color cycle using a seaborn palette.', '', '    Parameters', '    ----------', '    palette : seaborn color paltte | matplotlib colormap | hls | husl', '        Palette definition. Should be something :func:`color_palette` can process.', '    n_colors : int', '        Number of colors in the cycle. The default number of colors will depend', '        on the format of ``palette``, see the :func:`color_palette`', '        documentation for more information.', '    desat : float', '        Proportion to desaturate each color by.', '    color_codes : bool', '        If ``True`` and ``palette`` is a seaborn palette, remap the shorthand', '        color codes (e.g. \"b\", \"g\", \"r\", etc.) to the colors from this palette.', '', '    See Also', '    --------', '    color_palette : build a color palette or set the color cycle temporarily', '                    in a ``with`` statement.', '    set_context : set parameters to scale plot elements', '    set_style : set the default parameters for figure style', '', '    \"\"\"', '    colors = palettes.color_palette(palette, n_colors, desat)', \"    cyl = cycler('color', colors)\", \"    mpl.rcParams['axes.prop_cycle'] = cyl\", '    if color_codes:', '        try:', '            palettes.set_color_codes(palette)', '        except (ValueError, TypeError):', '            pass']}, '_testing.py': {'classes': [], 'functions': [{'name': 'assert_artists_equal', 'start_line': 24, 'end_line': 47, 'text': ['def assert_artists_equal(list1, list2):', '', '    assert len(list1) == len(list2)', '    for a1, a2 in zip(list1, list2):', '        assert a1.__class__ == a2.__class__', '        prop1 = a1.properties()', '        prop2 = a2.properties()', '        for key in USE_PROPS:', '            if key not in prop1:', '                continue', '            v1 = prop1[key]', '            v2 = prop2[key]', '            if key == \"paths\":', '                for p1, p2 in zip(v1, v2):', '                    assert_array_equal(p1.vertices, p2.vertices)', '                    assert_array_equal(p1.codes, p2.codes)', '            elif key == \"color\":', '                v1 = mpl.colors.to_rgba(v1)', '                v2 = mpl.colors.to_rgba(v2)', '                assert v1 == v2', '            elif isinstance(v1, np.ndarray):', '                assert_array_equal(v1, v2)', '            else:', '                assert v1 == v2']}, {'name': 'assert_legends_equal', 'start_line': 50, 'end_line': 61, 'text': ['def assert_legends_equal(leg1, leg2):', '', '    assert leg1.get_title().get_text() == leg2.get_title().get_text()', '    for t1, t2 in zip(leg1.get_texts(), leg2.get_texts()):', '        assert t1.get_text() == t2.get_text()', '', '    assert_artists_equal(', '        leg1.get_patches(), leg2.get_patches(),', '    )', '    assert_artists_equal(', '        leg1.get_lines(), leg2.get_lines(),', '    )']}, {'name': 'assert_plots_equal', 'start_line': 64, 'end_line': 72, 'text': ['def assert_plots_equal(ax1, ax2, labels=True):', '', '    assert_artists_equal(ax1.patches, ax2.patches)', '    assert_artists_equal(ax1.lines, ax2.lines)', '    assert_artists_equal(ax1.collections, ax2.collections)', '', '    if labels:', '        assert ax1.get_xlabel() == ax2.get_xlabel()', '        assert ax1.get_ylabel() == ax2.get_ylabel()']}, {'name': 'assert_colors_equal', 'start_line': 75, 'end_line': 90, 'text': ['def assert_colors_equal(a, b, check_alpha=True):', '', '    def handle_array(x):', '', '        if isinstance(x, np.ndarray):', '            if x.ndim > 1:', '                x = np.unique(x, axis=0).squeeze()', '            if x.ndim > 1:', '                raise ValueError(\"Color arrays must be 1 dimensional\")', '        return x', '', '    a = handle_array(a)', '    b = handle_array(b)', '', '    f = to_rgba if check_alpha else to_rgb', '    assert f(a) == f(b)']}, {'name': 'handle_array', 'start_line': 77, 'end_line': 84, 'text': ['    def handle_array(x):', '', '        if isinstance(x, np.ndarray):', '            if x.ndim > 1:', '                x = np.unique(x, axis=0).squeeze()', '            if x.ndim > 1:', '                raise ValueError(\"Color arrays must be 1 dimensional\")', '        return x']}], 'text': ['import numpy as np', 'import matplotlib as mpl', 'from matplotlib.colors import to_rgb, to_rgba', 'from numpy.testing import assert_array_equal', '', '', 'USE_PROPS = [', '    \"alpha\",', '    \"edgecolor\",', '    \"facecolor\",', '    \"fill\",', '    \"hatch\",', '    \"height\",', '    \"linestyle\",', '    \"linewidth\",', '    \"paths\",', '    \"xy\",', '    \"xydata\",', '    \"sizes\",', '    \"zorder\",', ']', '', '', 'def assert_artists_equal(list1, list2):', '', '    assert len(list1) == len(list2)', '    for a1, a2 in zip(list1, list2):', '        assert a1.__class__ == a2.__class__', '        prop1 = a1.properties()', '        prop2 = a2.properties()', '        for key in USE_PROPS:', '            if key not in prop1:', '                continue', '            v1 = prop1[key]', '            v2 = prop2[key]', '            if key == \"paths\":', '                for p1, p2 in zip(v1, v2):', '                    assert_array_equal(p1.vertices, p2.vertices)', '                    assert_array_equal(p1.codes, p2.codes)', '            elif key == \"color\":', '                v1 = mpl.colors.to_rgba(v1)', '                v2 = mpl.colors.to_rgba(v2)', '                assert v1 == v2', '            elif isinstance(v1, np.ndarray):', '                assert_array_equal(v1, v2)', '            else:', '                assert v1 == v2', '', '', 'def assert_legends_equal(leg1, leg2):', '', '    assert leg1.get_title().get_text() == leg2.get_title().get_text()', '    for t1, t2 in zip(leg1.get_texts(), leg2.get_texts()):', '        assert t1.get_text() == t2.get_text()', '', '    assert_artists_equal(', '        leg1.get_patches(), leg2.get_patches(),', '    )', '    assert_artists_equal(', '        leg1.get_lines(), leg2.get_lines(),', '    )', '', '', 'def assert_plots_equal(ax1, ax2, labels=True):', '', '    assert_artists_equal(ax1.patches, ax2.patches)', '    assert_artists_equal(ax1.lines, ax2.lines)', '    assert_artists_equal(ax1.collections, ax2.collections)', '', '    if labels:', '        assert ax1.get_xlabel() == ax2.get_xlabel()', '        assert ax1.get_ylabel() == ax2.get_ylabel()', '', '', 'def assert_colors_equal(a, b, check_alpha=True):', '', '    def handle_array(x):', '', '        if isinstance(x, np.ndarray):', '            if x.ndim > 1:', '                x = np.unique(x, axis=0).squeeze()', '            if x.ndim > 1:', '                raise ValueError(\"Color arrays must be 1 dimensional\")', '        return x', '', '    a = handle_array(a)', '    b = handle_array(b)', '', '    f = to_rgba if check_alpha else to_rgb', '    assert f(a) == f(b)']}, 'algorithms.py': {'classes': [], 'functions': [{'name': 'bootstrap', 'start_line': 7, 'end_line': 99, 'text': ['def bootstrap(*args, **kwargs):', '    \"\"\"Resample one or more arrays with replacement and store aggregate values.', '', '    Positional arguments are a sequence of arrays to bootstrap along the first', '    axis and pass to a summary function.', '', '    Keyword arguments:', '        n_boot : int, default=10000', '            Number of iterations', '        axis : int, default=None', '            Will pass axis to ``func`` as a keyword argument.', '        units : array, default=None', '            Array of sampling unit IDs. When used the bootstrap resamples units', '            and then observations within units instead of individual', '            datapoints.', '        func : string or callable, default=\"mean\"', '            Function to call on the args that are passed in. If string, uses as', '            name of function in the numpy namespace. If nans are present in the', '            data, will try to use nan-aware version of named function.', '        seed : Generator | SeedSequence | RandomState | int | None', '            Seed for the random number generator; useful if you want', '            reproducible resamples.', '', '    Returns', '    -------', '    boot_dist: array', '        array of bootstrapped statistic values', '', '    \"\"\"', '    # Ensure list of arrays are same length', '    if len(np.unique(list(map(len, args)))) > 1:', '        raise ValueError(\"All input arrays must have the same length\")', '    n = len(args[0])', '', '    # Default keyword arguments', '    n_boot = kwargs.get(\"n_boot\", 10000)', '    func = kwargs.get(\"func\", \"mean\")', '    axis = kwargs.get(\"axis\", None)', '    units = kwargs.get(\"units\", None)', '    random_seed = kwargs.get(\"random_seed\", None)', '    if random_seed is not None:', '        msg = \"`random_seed` has been renamed to `seed` and will be removed\"', '        warnings.warn(msg)', '    seed = kwargs.get(\"seed\", random_seed)', '    if axis is None:', '        func_kwargs = dict()', '    else:', '        func_kwargs = dict(axis=axis)', '', '    # Initialize the resampler', '    rng = _handle_random_seed(seed)', '', '    # Coerce to arrays', '    args = list(map(np.asarray, args))', '    if units is not None:', '        units = np.asarray(units)', '', '    if isinstance(func, str):', '', '        # Allow named numpy functions', '        f = getattr(np, func)', '', '        # Try to use nan-aware version of function if necessary', '        missing_data = np.isnan(np.sum(np.column_stack(args)))', '', '        if missing_data and not func.startswith(\"nan\"):', '            nanf = getattr(np, f\"nan{func}\", None)', '            if nanf is None:', '                msg = f\"Data contain nans but no nan-aware version of `{func}` found\"', '                warnings.warn(msg, UserWarning)', '            else:', '                f = nanf', '', '    else:', '        f = func', '', '    # Handle numpy changes', '    try:', '        integers = rng.integers', '    except AttributeError:', '        integers = rng.randint', '', '    # Do the bootstrap', '    if units is not None:', '        return _structured_bootstrap(args, n_boot, units, f,', '                                     func_kwargs, integers)', '', '    boot_dist = []', '    for i in range(int(n_boot)):', '        resampler = integers(0, n, n, dtype=np.intp)  # intp is indexing dtype', '        sample = [a.take(resampler, axis=0) for a in args]', '        boot_dist.append(f(*sample, **func_kwargs))', '    return np.array(boot_dist)']}, {'name': '_structured_bootstrap', 'start_line': 102, 'end_line': 118, 'text': ['def _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):', '    \"\"\"Resample units instead of datapoints.\"\"\"', '    unique_units = np.unique(units)', '    n_units = len(unique_units)', '', '    args = [[a[units == unit] for unit in unique_units] for a in args]', '', '    boot_dist = []', '    for i in range(int(n_boot)):', '        resampler = integers(0, n_units, n_units, dtype=np.intp)', '        sample = [[a[i] for i in resampler] for a in args]', '        lengths = map(len, sample[0])', '        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]', '        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in sample]', '        sample = list(map(np.concatenate, sample))', '        boot_dist.append(func(*sample, **func_kwargs))', '    return np.array(boot_dist)']}, {'name': '_handle_random_seed', 'start_line': 121, 'end_line': 142, 'text': ['def _handle_random_seed(seed=None):', '    \"\"\"Given a seed in one of many formats, return a random number generator.', '', '    Generalizes across the numpy 1.17 changes, preferring newer functionality.', '', '    \"\"\"', '    if isinstance(seed, np.random.RandomState):', '        rng = seed', '    else:', '        try:', '            # General interface for seeding on numpy >= 1.17', '            rng = np.random.default_rng(seed)', '        except AttributeError:', '            # We are on numpy < 1.17, handle options ourselves', '            if isinstance(seed, (numbers.Integral, np.integer)):', '                rng = np.random.RandomState(seed)', '            elif seed is None:', '                rng = np.random.RandomState()', '            else:', '                err = \"{} cannot be used to seed the random number generator\"', '                raise ValueError(err.format(seed))', '    return rng']}], 'text': ['\"\"\"Algorithms to support fitting routines in seaborn plotting functions.\"\"\"', 'import numbers', 'import numpy as np', 'import warnings', '', '', 'def bootstrap(*args, **kwargs):', '    \"\"\"Resample one or more arrays with replacement and store aggregate values.', '', '    Positional arguments are a sequence of arrays to bootstrap along the first', '    axis and pass to a summary function.', '', '    Keyword arguments:', '        n_boot : int, default=10000', '            Number of iterations', '        axis : int, default=None', '            Will pass axis to ``func`` as a keyword argument.', '        units : array, default=None', '            Array of sampling unit IDs. When used the bootstrap resamples units', '            and then observations within units instead of individual', '            datapoints.', '        func : string or callable, default=\"mean\"', '            Function to call on the args that are passed in. If string, uses as', '            name of function in the numpy namespace. If nans are present in the', '            data, will try to use nan-aware version of named function.', '        seed : Generator | SeedSequence | RandomState | int | None', '            Seed for the random number generator; useful if you want', '            reproducible resamples.', '', '    Returns', '    -------', '    boot_dist: array', '        array of bootstrapped statistic values', '', '    \"\"\"', '    # Ensure list of arrays are same length', '    if len(np.unique(list(map(len, args)))) > 1:', '        raise ValueError(\"All input arrays must have the same length\")', '    n = len(args[0])', '', '    # Default keyword arguments', '    n_boot = kwargs.get(\"n_boot\", 10000)', '    func = kwargs.get(\"func\", \"mean\")', '    axis = kwargs.get(\"axis\", None)', '    units = kwargs.get(\"units\", None)', '    random_seed = kwargs.get(\"random_seed\", None)', '    if random_seed is not None:', '        msg = \"`random_seed` has been renamed to `seed` and will be removed\"', '        warnings.warn(msg)', '    seed = kwargs.get(\"seed\", random_seed)', '    if axis is None:', '        func_kwargs = dict()', '    else:', '        func_kwargs = dict(axis=axis)', '', '    # Initialize the resampler', '    rng = _handle_random_seed(seed)', '', '    # Coerce to arrays', '    args = list(map(np.asarray, args))', '    if units is not None:', '        units = np.asarray(units)', '', '    if isinstance(func, str):', '', '        # Allow named numpy functions', '        f = getattr(np, func)', '', '        # Try to use nan-aware version of function if necessary', '        missing_data = np.isnan(np.sum(np.column_stack(args)))', '', '        if missing_data and not func.startswith(\"nan\"):', '            nanf = getattr(np, f\"nan{func}\", None)', '            if nanf is None:', '                msg = f\"Data contain nans but no nan-aware version of `{func}` found\"', '                warnings.warn(msg, UserWarning)', '            else:', '                f = nanf', '', '    else:', '        f = func', '', '    # Handle numpy changes', '    try:', '        integers = rng.integers', '    except AttributeError:', '        integers = rng.randint', '', '    # Do the bootstrap', '    if units is not None:', '        return _structured_bootstrap(args, n_boot, units, f,', '                                     func_kwargs, integers)', '', '    boot_dist = []', '    for i in range(int(n_boot)):', '        resampler = integers(0, n, n, dtype=np.intp)  # intp is indexing dtype', '        sample = [a.take(resampler, axis=0) for a in args]', '        boot_dist.append(f(*sample, **func_kwargs))', '    return np.array(boot_dist)', '', '', 'def _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):', '    \"\"\"Resample units instead of datapoints.\"\"\"', '    unique_units = np.unique(units)', '    n_units = len(unique_units)', '', '    args = [[a[units == unit] for unit in unique_units] for a in args]', '', '    boot_dist = []', '    for i in range(int(n_boot)):', '        resampler = integers(0, n_units, n_units, dtype=np.intp)', '        sample = [[a[i] for i in resampler] for a in args]', '        lengths = map(len, sample[0])', '        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]', '        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in sample]', '        sample = list(map(np.concatenate, sample))', '        boot_dist.append(func(*sample, **func_kwargs))', '    return np.array(boot_dist)', '', '', 'def _handle_random_seed(seed=None):', '    \"\"\"Given a seed in one of many formats, return a random number generator.', '', '    Generalizes across the numpy 1.17 changes, preferring newer functionality.', '', '    \"\"\"', '    if isinstance(seed, np.random.RandomState):', '        rng = seed', '    else:', '        try:', '            # General interface for seeding on numpy >= 1.17', '            rng = np.random.default_rng(seed)', '        except AttributeError:', '            # We are on numpy < 1.17, handle options ourselves', '            if isinstance(seed, (numbers.Integral, np.integer)):', '                rng = np.random.RandomState(seed)', '            elif seed is None:', '                rng = np.random.RandomState()', '            else:', '                err = \"{} cannot be used to seed the random number generator\"', '                raise ValueError(err.format(seed))', '    return rng']}, '_core': {'data.py': {'classes': [{'name': 'PlotData', 'start_line': 15, 'end_line': 260, 'text': ['class PlotData:', '    \"\"\"', '    Data table with plot variable schema and mapping to original names.', '', '    Contains logic for parsing variable specification arguments and updating', '    the table with layer-specific data and/or mappings.', '', '    Parameters', '    ----------', '    data', '        Input data where variable names map to vector values.', '    variables', '        Keys are names of plot variables (x, y, ...) each value is one of:', '', '        - name of a column (or index level, or dictionary entry) in `data`', '        - vector in any format that can construct a :class:`pandas.DataFrame`', '', '    Attributes', '    ----------', '    frame', '        Data table with column names having defined plot variables.', '    names', '        Dictionary mapping plot variable names to names in source data structure(s).', '    ids', '        Dictionary mapping plot variable names to unique data source identifiers.', '', '    \"\"\"', '    frame: DataFrame', '    frames: dict[tuple, DataFrame]', '    names: dict[str, str | None]', '    ids: dict[str, str | int]', '    source_data: DataSource', '    source_vars: dict[str, VariableSpec]', '', '    def __init__(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ):', '', '        frame, names, ids = self._assign_variables(data, variables)', '', '        self.frame = frame', '        self.names = names', '        self.ids = ids', '', '        self.frames = {}  # TODO this is a hack, remove', '', '        self.source_data = data', '        self.source_vars = variables', '', '    def __contains__(self, key: str) -> bool:', '        \"\"\"Boolean check on whether a variable is defined in this dataset.\"\"\"', '        if self.frame is None:', '            return any(key in df for df in self.frames.values())', '        return key in self.frame', '', '    def join(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec] | None,', '    ) -> PlotData:', '        \"\"\"Add, replace, or drop variables and return as a new dataset.\"\"\"', '        # Inherit the original source of the upsteam data by default', '        if data is None:', '            data = self.source_data', '', '        # TODO allow `data` to be a function (that is called on the source data?)', '', '        if not variables:', '            variables = self.source_vars', '', '        # Passing var=None implies that we do not want that variable in this layer', '        disinherit = [k for k, v in variables.items() if v is None]', '', '        # Create a new dataset with just the info passed here', '        new = PlotData(data, variables)', '', '        # -- Update the inherited DataSource with this new information', '', '        drop_cols = [k for k in self.frame if k in new.frame or k in disinherit]', '        parts = [self.frame.drop(columns=drop_cols), new.frame]', '', '        # Because we are combining distinct columns, this is perhaps more', '        # naturally thought of as a \"merge\"/\"join\". But using concat because', '        # some simple testing suggests that it is marginally faster.', '        frame = pd.concat(parts, axis=1, sort=False, copy=False)', '', '        names = {k: v for k, v in self.names.items() if k not in disinherit}', '        names.update(new.names)', '', '        ids = {k: v for k, v in self.ids.items() if k not in disinherit}', '        ids.update(new.ids)', '', '        new.frame = frame', '        new.names = names', '        new.ids = ids', '', '        # Multiple chained operations should always inherit from the original object', '        new.source_data = self.source_data', '        new.source_vars = self.source_vars', '', '        return new', '', '    def _assign_variables(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ) -> tuple[DataFrame, dict[str, str | None], dict[str, str | int]]:', '        \"\"\"', '        Assign values for plot variables given long-form data and/or vector inputs.', '', '        Parameters', '        ----------', '        data', '            Input data where variable names map to vector values.', '        variables', '            Keys are names of plot variables (x, y, ...) each value is one of:', '', '            - name of a column (or index level, or dictionary entry) in `data`', '            - vector in any format that can construct a :class:`pandas.DataFrame`', '', '        Returns', '        -------', '        frame', '            Table mapping seaborn variables (x, y, color, ...) to data vectors.', '        names', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '        ids', '            Like the `names` dict, but `None` values are replaced by the `id()`', '            of the data object that defined the variable.', '', '        Raises', '        ------', '        ValueError', \"            When variables are strings that don't appear in `data`, or when they are\", '            non-indexed vector datatypes that have a different length from `data`.', '', '        \"\"\"', '        source_data: Mapping | DataFrame', '        frame: DataFrame', '        names: dict[str, str | None]', '        ids: dict[str, str | int]', '', '        plot_data = {}', '        names = {}', '        ids = {}', '', '        given_data = data is not None', '        if data is not None:', '            source_data = data', '        else:', '            # Data is optional; all variables can be defined as vectors', '            # But simplify downstream code by always having a usable source data object', '            source_data = {}', '', '        # TODO Generally interested in accepting a generic DataFrame interface', '        # Track https://data-apis.org/ for development', '', '        # Variables can also be extracted from the index of a DataFrame', '        if isinstance(source_data, pd.DataFrame):', '            index = source_data.index.to_frame().to_dict(\"series\")', '        else:', '            index = {}', '', '        for key, val in variables.items():', '', '            # Simply ignore variables with no specification', '            if val is None:', '                continue', '', '            # Try to treat the argument as a key for the data collection.', '            # But be flexible about what can be used as a key.', '            # Usually it will be a string, but allow other hashables when', '            # taking from the main data object. Allow only strings to reference', '            # fields in the index, because otherwise there is too much ambiguity.', '', '            # TODO this will be rendered unnecessary by the following pandas fix:', '            # https://github.com/pandas-dev/pandas/pull/41283', '            try:', '                hash(val)', '                val_is_hashable = True', '            except TypeError:', '                val_is_hashable = False', '', '            val_as_data_key = (', '                # See https://github.com/pandas-dev/pandas/pull/41283', '                # (isinstance(val, abc.Hashable) and val in source_data)', '                (val_is_hashable and val in source_data)', '                or (isinstance(val, str) and val in index)', '            )', '', '            if val_as_data_key:', '                val = cast(ColumnName, val)', '                if val in source_data:', '                    plot_data[key] = source_data[val]', '                elif val in index:', '                    plot_data[key] = index[val]', '                names[key] = ids[key] = str(val)', '', '            elif isinstance(val, str):', '', '                # This looks like a column name but, lookup failed.', '', '                err = f\"Could not interpret value `{val}` for `{key}`. \"', '                if not given_data:', '                    err += \"Value is a string, but `data` was not passed.\"', '                else:', '                    err += \"An entry with this name does not appear in `data`.\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, assume the value somehow represents data', '', '                # Ignore empty data structures', '                if isinstance(val, Sized) and len(val) == 0:', '                    continue', '', '                # If vector has no index, it must match length of data table', '                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):', '                    if isinstance(val, Sized) and len(data) != len(val):', '                        val_cls = val.__class__.__name__', '                        err = (', '                            f\"Length of {val_cls} vectors must match length of `data`\"', '                            f\" when both are used, but `data` has length {len(data)}\"', '                            f\" and the vector passed to `{key}` has length {len(val)}.\"', '                        )', '                        raise ValueError(err)', '', '                plot_data[key] = val', '', '                # Try to infer the original name using pandas-like metadata', '                if hasattr(val, \"name\"):', '                    names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424', '                else:', '                    names[key] = None', '                    ids[key] = id(val)', '', '        # Construct a tidy plot DataFrame. This will convert a number of', '        # types automatically, aligning on index in case of pandas objects', '        # TODO Note: this fails when variable specs *only* have scalars!', '        frame = pd.DataFrame(plot_data)', '', '        return frame, names, ids'], 'methods': [{'name': '__init__', 'start_line': 49, 'end_line': 64, 'text': ['    def __init__(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ):', '', '        frame, names, ids = self._assign_variables(data, variables)', '', '        self.frame = frame', '        self.names = names', '        self.ids = ids', '', '        self.frames = {}  # TODO this is a hack, remove', '', '        self.source_data = data', '        self.source_vars = variables']}, {'name': '__contains__', 'start_line': 66, 'end_line': 70, 'text': ['    def __contains__(self, key: str) -> bool:', '        \"\"\"Boolean check on whether a variable is defined in this dataset.\"\"\"', '        if self.frame is None:', '            return any(key in df for df in self.frames.values())', '        return key in self.frame']}, {'name': 'join', 'start_line': 72, 'end_line': 117, 'text': ['    def join(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec] | None,', '    ) -> PlotData:', '        \"\"\"Add, replace, or drop variables and return as a new dataset.\"\"\"', '        # Inherit the original source of the upsteam data by default', '        if data is None:', '            data = self.source_data', '', '        # TODO allow `data` to be a function (that is called on the source data?)', '', '        if not variables:', '            variables = self.source_vars', '', '        # Passing var=None implies that we do not want that variable in this layer', '        disinherit = [k for k, v in variables.items() if v is None]', '', '        # Create a new dataset with just the info passed here', '        new = PlotData(data, variables)', '', '        # -- Update the inherited DataSource with this new information', '', '        drop_cols = [k for k in self.frame if k in new.frame or k in disinherit]', '        parts = [self.frame.drop(columns=drop_cols), new.frame]', '', '        # Because we are combining distinct columns, this is perhaps more', '        # naturally thought of as a \"merge\"/\"join\". But using concat because', '        # some simple testing suggests that it is marginally faster.', '        frame = pd.concat(parts, axis=1, sort=False, copy=False)', '', '        names = {k: v for k, v in self.names.items() if k not in disinherit}', '        names.update(new.names)', '', '        ids = {k: v for k, v in self.ids.items() if k not in disinherit}', '        ids.update(new.ids)', '', '        new.frame = frame', '        new.names = names', '        new.ids = ids', '', '        # Multiple chained operations should always inherit from the original object', '        new.source_data = self.source_data', '        new.source_vars = self.source_vars', '', '        return new']}, {'name': '_assign_variables', 'start_line': 119, 'end_line': 260, 'text': ['    def _assign_variables(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ) -> tuple[DataFrame, dict[str, str | None], dict[str, str | int]]:', '        \"\"\"', '        Assign values for plot variables given long-form data and/or vector inputs.', '', '        Parameters', '        ----------', '        data', '            Input data where variable names map to vector values.', '        variables', '            Keys are names of plot variables (x, y, ...) each value is one of:', '', '            - name of a column (or index level, or dictionary entry) in `data`', '            - vector in any format that can construct a :class:`pandas.DataFrame`', '', '        Returns', '        -------', '        frame', '            Table mapping seaborn variables (x, y, color, ...) to data vectors.', '        names', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '        ids', '            Like the `names` dict, but `None` values are replaced by the `id()`', '            of the data object that defined the variable.', '', '        Raises', '        ------', '        ValueError', \"            When variables are strings that don't appear in `data`, or when they are\", '            non-indexed vector datatypes that have a different length from `data`.', '', '        \"\"\"', '        source_data: Mapping | DataFrame', '        frame: DataFrame', '        names: dict[str, str | None]', '        ids: dict[str, str | int]', '', '        plot_data = {}', '        names = {}', '        ids = {}', '', '        given_data = data is not None', '        if data is not None:', '            source_data = data', '        else:', '            # Data is optional; all variables can be defined as vectors', '            # But simplify downstream code by always having a usable source data object', '            source_data = {}', '', '        # TODO Generally interested in accepting a generic DataFrame interface', '        # Track https://data-apis.org/ for development', '', '        # Variables can also be extracted from the index of a DataFrame', '        if isinstance(source_data, pd.DataFrame):', '            index = source_data.index.to_frame().to_dict(\"series\")', '        else:', '            index = {}', '', '        for key, val in variables.items():', '', '            # Simply ignore variables with no specification', '            if val is None:', '                continue', '', '            # Try to treat the argument as a key for the data collection.', '            # But be flexible about what can be used as a key.', '            # Usually it will be a string, but allow other hashables when', '            # taking from the main data object. Allow only strings to reference', '            # fields in the index, because otherwise there is too much ambiguity.', '', '            # TODO this will be rendered unnecessary by the following pandas fix:', '            # https://github.com/pandas-dev/pandas/pull/41283', '            try:', '                hash(val)', '                val_is_hashable = True', '            except TypeError:', '                val_is_hashable = False', '', '            val_as_data_key = (', '                # See https://github.com/pandas-dev/pandas/pull/41283', '                # (isinstance(val, abc.Hashable) and val in source_data)', '                (val_is_hashable and val in source_data)', '                or (isinstance(val, str) and val in index)', '            )', '', '            if val_as_data_key:', '                val = cast(ColumnName, val)', '                if val in source_data:', '                    plot_data[key] = source_data[val]', '                elif val in index:', '                    plot_data[key] = index[val]', '                names[key] = ids[key] = str(val)', '', '            elif isinstance(val, str):', '', '                # This looks like a column name but, lookup failed.', '', '                err = f\"Could not interpret value `{val}` for `{key}`. \"', '                if not given_data:', '                    err += \"Value is a string, but `data` was not passed.\"', '                else:', '                    err += \"An entry with this name does not appear in `data`.\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, assume the value somehow represents data', '', '                # Ignore empty data structures', '                if isinstance(val, Sized) and len(val) == 0:', '                    continue', '', '                # If vector has no index, it must match length of data table', '                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):', '                    if isinstance(val, Sized) and len(data) != len(val):', '                        val_cls = val.__class__.__name__', '                        err = (', '                            f\"Length of {val_cls} vectors must match length of `data`\"', '                            f\" when both are used, but `data` has length {len(data)}\"', '                            f\" and the vector passed to `{key}` has length {len(val)}.\"', '                        )', '                        raise ValueError(err)', '', '                plot_data[key] = val', '', '                # Try to infer the original name using pandas-like metadata', '                if hasattr(val, \"name\"):', '                    names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424', '                else:', '                    names[key] = None', '                    ids[key] = id(val)', '', '        # Construct a tidy plot DataFrame. This will convert a number of', '        # types automatically, aligning on index in case of pandas objects', '        # TODO Note: this fails when variable specs *only* have scalars!', '        frame = pd.DataFrame(plot_data)', '', '        return frame, names, ids']}]}], 'functions': [], 'text': ['\"\"\"', 'Components for parsing variable assignments and internally representing plot data.', '\"\"\"', 'from __future__ import annotations', '', 'from collections.abc import Mapping, Sized', 'from typing import cast', '', 'import pandas as pd', 'from pandas import DataFrame', '', 'from seaborn._core.typing import DataSource, VariableSpec, ColumnName', '', '', 'class PlotData:', '    \"\"\"', '    Data table with plot variable schema and mapping to original names.', '', '    Contains logic for parsing variable specification arguments and updating', '    the table with layer-specific data and/or mappings.', '', '    Parameters', '    ----------', '    data', '        Input data where variable names map to vector values.', '    variables', '        Keys are names of plot variables (x, y, ...) each value is one of:', '', '        - name of a column (or index level, or dictionary entry) in `data`', '        - vector in any format that can construct a :class:`pandas.DataFrame`', '', '    Attributes', '    ----------', '    frame', '        Data table with column names having defined plot variables.', '    names', '        Dictionary mapping plot variable names to names in source data structure(s).', '    ids', '        Dictionary mapping plot variable names to unique data source identifiers.', '', '    \"\"\"', '    frame: DataFrame', '    frames: dict[tuple, DataFrame]', '    names: dict[str, str | None]', '    ids: dict[str, str | int]', '    source_data: DataSource', '    source_vars: dict[str, VariableSpec]', '', '    def __init__(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ):', '', '        frame, names, ids = self._assign_variables(data, variables)', '', '        self.frame = frame', '        self.names = names', '        self.ids = ids', '', '        self.frames = {}  # TODO this is a hack, remove', '', '        self.source_data = data', '        self.source_vars = variables', '', '    def __contains__(self, key: str) -> bool:', '        \"\"\"Boolean check on whether a variable is defined in this dataset.\"\"\"', '        if self.frame is None:', '            return any(key in df for df in self.frames.values())', '        return key in self.frame', '', '    def join(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec] | None,', '    ) -> PlotData:', '        \"\"\"Add, replace, or drop variables and return as a new dataset.\"\"\"', '        # Inherit the original source of the upsteam data by default', '        if data is None:', '            data = self.source_data', '', '        # TODO allow `data` to be a function (that is called on the source data?)', '', '        if not variables:', '            variables = self.source_vars', '', '        # Passing var=None implies that we do not want that variable in this layer', '        disinherit = [k for k, v in variables.items() if v is None]', '', '        # Create a new dataset with just the info passed here', '        new = PlotData(data, variables)', '', '        # -- Update the inherited DataSource with this new information', '', '        drop_cols = [k for k in self.frame if k in new.frame or k in disinherit]', '        parts = [self.frame.drop(columns=drop_cols), new.frame]', '', '        # Because we are combining distinct columns, this is perhaps more', '        # naturally thought of as a \"merge\"/\"join\". But using concat because', '        # some simple testing suggests that it is marginally faster.', '        frame = pd.concat(parts, axis=1, sort=False, copy=False)', '', '        names = {k: v for k, v in self.names.items() if k not in disinherit}', '        names.update(new.names)', '', '        ids = {k: v for k, v in self.ids.items() if k not in disinherit}', '        ids.update(new.ids)', '', '        new.frame = frame', '        new.names = names', '        new.ids = ids', '', '        # Multiple chained operations should always inherit from the original object', '        new.source_data = self.source_data', '        new.source_vars = self.source_vars', '', '        return new', '', '    def _assign_variables(', '        self,', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ) -> tuple[DataFrame, dict[str, str | None], dict[str, str | int]]:', '        \"\"\"', '        Assign values for plot variables given long-form data and/or vector inputs.', '', '        Parameters', '        ----------', '        data', '            Input data where variable names map to vector values.', '        variables', '            Keys are names of plot variables (x, y, ...) each value is one of:', '', '            - name of a column (or index level, or dictionary entry) in `data`', '            - vector in any format that can construct a :class:`pandas.DataFrame`', '', '        Returns', '        -------', '        frame', '            Table mapping seaborn variables (x, y, color, ...) to data vectors.', '        names', '            Keys are defined seaborn variables; values are names inferred from', '            the inputs (or None when no name can be determined).', '        ids', '            Like the `names` dict, but `None` values are replaced by the `id()`', '            of the data object that defined the variable.', '', '        Raises', '        ------', '        ValueError', \"            When variables are strings that don't appear in `data`, or when they are\", '            non-indexed vector datatypes that have a different length from `data`.', '', '        \"\"\"', '        source_data: Mapping | DataFrame', '        frame: DataFrame', '        names: dict[str, str | None]', '        ids: dict[str, str | int]', '', '        plot_data = {}', '        names = {}', '        ids = {}', '', '        given_data = data is not None', '        if data is not None:', '            source_data = data', '        else:', '            # Data is optional; all variables can be defined as vectors', '            # But simplify downstream code by always having a usable source data object', '            source_data = {}', '', '        # TODO Generally interested in accepting a generic DataFrame interface', '        # Track https://data-apis.org/ for development', '', '        # Variables can also be extracted from the index of a DataFrame', '        if isinstance(source_data, pd.DataFrame):', '            index = source_data.index.to_frame().to_dict(\"series\")', '        else:', '            index = {}', '', '        for key, val in variables.items():', '', '            # Simply ignore variables with no specification', '            if val is None:', '                continue', '', '            # Try to treat the argument as a key for the data collection.', '            # But be flexible about what can be used as a key.', '            # Usually it will be a string, but allow other hashables when', '            # taking from the main data object. Allow only strings to reference', '            # fields in the index, because otherwise there is too much ambiguity.', '', '            # TODO this will be rendered unnecessary by the following pandas fix:', '            # https://github.com/pandas-dev/pandas/pull/41283', '            try:', '                hash(val)', '                val_is_hashable = True', '            except TypeError:', '                val_is_hashable = False', '', '            val_as_data_key = (', '                # See https://github.com/pandas-dev/pandas/pull/41283', '                # (isinstance(val, abc.Hashable) and val in source_data)', '                (val_is_hashable and val in source_data)', '                or (isinstance(val, str) and val in index)', '            )', '', '            if val_as_data_key:', '                val = cast(ColumnName, val)', '                if val in source_data:', '                    plot_data[key] = source_data[val]', '                elif val in index:', '                    plot_data[key] = index[val]', '                names[key] = ids[key] = str(val)', '', '            elif isinstance(val, str):', '', '                # This looks like a column name but, lookup failed.', '', '                err = f\"Could not interpret value `{val}` for `{key}`. \"', '                if not given_data:', '                    err += \"Value is a string, but `data` was not passed.\"', '                else:', '                    err += \"An entry with this name does not appear in `data`.\"', '                raise ValueError(err)', '', '            else:', '', '                # Otherwise, assume the value somehow represents data', '', '                # Ignore empty data structures', '                if isinstance(val, Sized) and len(val) == 0:', '                    continue', '', '                # If vector has no index, it must match length of data table', '                if isinstance(data, pd.DataFrame) and not isinstance(val, pd.Series):', '                    if isinstance(val, Sized) and len(data) != len(val):', '                        val_cls = val.__class__.__name__', '                        err = (', '                            f\"Length of {val_cls} vectors must match length of `data`\"', '                            f\" when both are used, but `data` has length {len(data)}\"', '                            f\" and the vector passed to `{key}` has length {len(val)}.\"', '                        )', '                        raise ValueError(err)', '', '                plot_data[key] = val', '', '                # Try to infer the original name using pandas-like metadata', '                if hasattr(val, \"name\"):', '                    names[key] = ids[key] = str(val.name)  # type: ignore  # mypy/1424', '                else:', '                    names[key] = None', '                    ids[key] = id(val)', '', '        # Construct a tidy plot DataFrame. This will convert a number of', '        # types automatically, aligning on index in case of pandas objects', '        # TODO Note: this fails when variable specs *only* have scalars!', '        frame = pd.DataFrame(plot_data)', '', '        return frame, names, ids']}, 'plot.py': {'classes': [{'name': 'Layer', 'start_line': 62, 'end_line': 71, 'text': ['class Layer(TypedDict, total=False):', '', '    mark: Mark  # TODO allow list?', '    stat: Stat | None  # TODO allow list?', '    move: Move | list[Move] | None', '    data: PlotData', '    source: DataSource', '    vars: dict[str, VariableSpec]', '    orient: str', '    legend: bool'], 'methods': []}, {'name': 'FacetSpec', 'start_line': 74, 'end_line': 78, 'text': ['class FacetSpec(TypedDict, total=False):', '', '    variables: dict[str, VariableSpec]', '    structure: dict[str, list[str]]', '    wrap: int | None'], 'methods': []}, {'name': 'PairSpec', 'start_line': 81, 'end_line': 86, 'text': ['class PairSpec(TypedDict, total=False):', '', '    variables: dict[str, VariableSpec]', '    structure: dict[str, list[str]]', '    cross: bool', '    wrap: int | None'], 'methods': []}, {'name': 'Plot', 'start_line': 149, 'end_line': 856, 'text': ['class Plot:', '    \"\"\"', '    An interface for declaratively specifying statistical graphics.', '', '    Plots are constructed by initializing this class and adding one or more', '    layers, comprising a `Mark` and optional `Stat` or `Move`.  Additionally,', '    faceting variables or variable pairings may be defined to divide the space', '    into multiple subplots. The mappings from data values to visual properties', '    can be parametrized using scales, although the plot will try to infer good', '    defaults when scales are not explicitly defined.', '', '    The constructor accepts a data source (a :class:`pandas.DataFrame` or', '    dictionary with columnar values) and variable assignments. Variables can be', '    passed as keys to the data source or directly as data vectors.  If multiple', '    data-containing objects are provided, they will be index-aligned.', '', '    The data source and variables defined in the constructor will be used for', '    all layers in the plot, unless overridden or disabled when adding a layer.', '', '    The following variables can be defined in the constructor:', '        {known_properties}', '', '    The `data`, `x`, and `y` variables can be passed as positional arguments or', '    using keywords. Whether the first positional argument is interpreted as a', '    data source or `x` variable depends on its type.', '', '    The methods of this class return a copy of the instance; use chaining to', '    build up a plot through multiple calls. Methods can be called in any order.', '', '    Most methods only add information to the plot spec; no actual processing', '    happens until the plot is shown or saved. It is also possible to compile', '    the plot without rendering it to access the lower-level representation.', '', '    \"\"\"', '    _data: PlotData', '    _layers: list[Layer]', '', '    _scales: dict[str, Scale]', '    _shares: dict[str, bool | str]', '    _limits: dict[str, tuple[Any, Any]]', '    _labels: dict[str, str | Callable[[str], str]]', '    _theme: dict[str, Any]', '', '    _facet_spec: FacetSpec', '    _pair_spec: PairSpec', '', '    _figure_spec: dict[str, Any]', '    _subplot_spec: dict[str, Any]', '    _layout_spec: dict[str, Any]', '', '    def __init__(', '        self,', '        *args: DataSource | VariableSpec,', '        data: DataSource = None,', '        **variables: VariableSpec,', '    ):', '', '        if args:', '            data, variables = self._resolve_positionals(args, data, variables)', '', '        unknown = [x for x in variables if x not in PROPERTIES]', '        if unknown:', '            err = f\"Plot() got unexpected keyword argument(s): {\\', \\'.join(unknown)}\"', '            raise TypeError(err)', '', '        self._data = PlotData(data, variables)', '', '        self._layers = []', '', '        self._scales = {}', '        self._shares = {}', '        self._limits = {}', '        self._labels = {}', '        self._theme = {}', '', '        self._facet_spec = {}', '        self._pair_spec = {}', '', '        self._figure_spec = {}', '        self._subplot_spec = {}', '        self._layout_spec = {}', '', '        self._target = None', '', '    def _resolve_positionals(', '        self,', '        args: tuple[DataSource | VariableSpec, ...],', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ) -> tuple[DataSource, dict[str, VariableSpec]]:', '        \"\"\"Handle positional arguments, which may contain data / x / y.\"\"\"', '        if len(args) > 3:', '            err = \"Plot() accepts no more than 3 positional arguments (data, x, y).\"', '            raise TypeError(err)', '', '        # TODO need some clearer way to differentiate data / vector here', '        # (There might be an abstract DataFrame class to use here?)', '        if isinstance(args[0], (abc.Mapping, pd.DataFrame)):', '            if data is not None:', '                raise TypeError(\"`data` given by both name and position.\")', '            data, args = args[0], args[1:]', '', '        if len(args) == 2:', '            x, y = args', '        elif len(args) == 1:', '            x, y = *args, None', '        else:', '            x = y = None', '', '        for name, var in zip(\"yx\", (y, x)):', '            if var is not None:', '                if name in variables:', '                    raise TypeError(f\"`{name}` given by both name and position.\")', '                # Keep coordinates at the front of the variables dict', \"                # Cast type because we know this isn't a DataSource at this point\", '                variables = {name: cast(VariableSpec, var), **variables}', '', '        return data, variables', '', '    def __add__(self, other):', '', '        if isinstance(other, Mark) or isinstance(other, Stat):', '            raise TypeError(\"Sorry, this isn\\'t ggplot! Perhaps try Plot.add?\")', '', '        other_type = other.__class__.__name__', '        raise TypeError(f\"Unsupported operand type(s) for +: \\'Plot\\' and \\'{other_type}\")', '', '    def _repr_png_(self) -> tuple[bytes, dict[str, float]]:', '', '        return self.plot()._repr_png_()', '', '    # TODO _repr_svg_?', '', '    def _clone(self) -> Plot:', '        \"\"\"Generate a new object with the same information as the current spec.\"\"\"', '        new = Plot()', '', '        # TODO any way to enforce that data does not get mutated?', '        new._data = self._data', '', '        new._layers.extend(self._layers)', '', '        new._scales.update(self._scales)', '        new._shares.update(self._shares)', '        new._limits.update(self._limits)', '        new._labels.update(self._labels)', '        new._theme.update(self._theme)', '', '        new._facet_spec.update(self._facet_spec)', '        new._pair_spec.update(self._pair_spec)', '', '        new._figure_spec.update(self._figure_spec)', '        new._subplot_spec.update(self._subplot_spec)', '        new._layout_spec.update(self._layout_spec)', '', '        new._target = self._target', '', '        return new', '', '    def _theme_with_defaults(self) -> dict[str, Any]:', '', '        style_groups = [', '            \"axes\", \"figure\", \"font\", \"grid\", \"hatch\", \"legend\", \"lines\",', '            \"mathtext\", \"markers\", \"patch\", \"savefig\", \"scatter\",', '            \"xaxis\", \"xtick\", \"yaxis\", \"ytick\",', '        ]', '        base = {', '            k: mpl.rcParamsDefault[k] for k in mpl.rcParams', '            if any(k.startswith(p) for p in style_groups)', '        }', '        theme = {', '            **base,', '            **axes_style(\"darkgrid\"),', '            **plotting_context(\"notebook\"),', '            \"axes.prop_cycle\": cycler(\"color\", color_palette(\"deep\")),', '        }', '        theme.update(self._theme)', '        return theme', '', '    @property', '    def _variables(self) -> list[str]:', '', '        variables = (', '            list(self._data.frame)', '            + list(self._pair_spec.get(\"variables\", []))', '            + list(self._facet_spec.get(\"variables\", []))', '        )', '        for layer in self._layers:', '            variables.extend(v for v in layer[\"vars\"] if v not in variables)', '', '        # Coerce to str in return to appease mypy; we know these will only', \"        # ever be strings but I don't think we can type a DataFrame that way yet\", '        return [str(v) for v in variables]', '', '    def on(self, target: Axes | SubFigure | Figure) -> Plot:', '        \"\"\"', '        Provide existing Matplotlib figure or axes for drawing the plot.', '', '        When using this method, you will also need to explicitly call a method that', '        triggers compilation, such as :meth:`Plot.show` or :meth:`Plot.save`. If you', \"        want to postprocess using matplotlib, you'd need to call :meth:`Plot.plot`\", '        first to compile the plot without rendering it.', '', '        Parameters', '        ----------', '        target : Axes, SubFigure, or Figure', '            Matplotlib object to use. Passing :class:`matplotlib.axes.Axes` will add', '            artists without otherwise modifying the figure. Otherwise, subplots will be', '            created within the space of the given :class:`matplotlib.figure.Figure` or', '            :class:`matplotlib.figure.SubFigure`.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.on.rst', '', '        \"\"\"', '        accepted_types: tuple  # Allow tuple of various length', '        if hasattr(mpl.figure, \"SubFigure\"):  # Added in mpl 3.4', '            accepted_types = (', '                mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure', '            )', '            accepted_types_str = (', '                f\"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}\"', '            )', '        else:', '            accepted_types = mpl.axes.Axes, mpl.figure.Figure', '            accepted_types_str = f\"{mpl.axes.Axes} or {mpl.figure.Figure}\"', '', '        if not isinstance(target, accepted_types):', '            err = (', '                f\"The `Plot.on` target must be an instance of {accepted_types_str}. \"', '                f\"You passed an instance of {target.__class__} instead.\"', '            )', '            raise TypeError(err)', '', '        new = self._clone()', '        new._target = target', '', '        return new', '', '    def add(', '        self,', '        mark: Mark,', '        *transforms: Stat | Mark,', '        orient: str | None = None,', '        legend: bool = True,', '        data: DataSource = None,', '        **variables: VariableSpec,', '    ) -> Plot:', '        \"\"\"', '        Specify a layer of the visualization in terms of mark and data transform(s).', '', '        This is the main method for specifying how the data should be visualized.', '        It can be called multiple times with different arguments to define', '        a plot with multiple layers.', '', '        Parameters', '        ----------', '        mark : :class:`Mark`', '            The visual representation of the data to use in this layer.', '        transforms : :class:`Stat` or :class:`Move`', '            Objects representing transforms to be applied before plotting the data.', '            Currently, at most one :class:`Stat` can be used, and it', '            must be passed first. This constraint will be relaxed in the future.', '        orient : \"x\", \"y\", \"v\", or \"h\"', '            The orientation of the mark, which also affects how transforms are computed.', '            Typically corresponds to the axis that defines groups for aggregation.', '            The \"v\" (vertical) and \"h\" (horizontal) options are synonyms for \"x\" / \"y\",', '            but may be more intuitive with some marks. When not provided, an', '            orientation will be inferred from characteristics of the data and scales.', '        legend : bool', '            Option to suppress the mark/mappings for this layer from the legend.', '        data : DataFrame or dict', '            Data source to override the global source provided in the constructor.', '        variables : data vectors or identifiers', '            Additional layer-specific variables, including variables that will be', '            passed directly to the transforms without scaling.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.add.rst', '', '        \"\"\"', '        if not isinstance(mark, Mark):', '            msg = f\"mark must be a Mark instance, not {type(mark)!r}.\"', '            raise TypeError(msg)', '', '        # TODO This API for transforms was a late decision, and previously Plot.add', '        # accepted 0 or 1 Stat instances and 0, 1, or a list of Move instances.', '        # It will take some work to refactor the internals so that Stat and Move are', '        # treated identically, and until then well need to \"unpack\" the transforms', '        # here and enforce limitations on the order / types.', '', '        stat: Optional[Stat]', '        move: Optional[List[Move]]', '        error = False', '        if not transforms:', '            stat, move = None, None', '        elif isinstance(transforms[0], Stat):', '            stat = transforms[0]', '            move = [m for m in transforms[1:] if isinstance(m, Move)]', '            error = len(move) != len(transforms) - 1', '        else:', '            stat = None', '            move = [m for m in transforms if isinstance(m, Move)]', '            error = len(move) != len(transforms)', '', '        if error:', '            msg = \" \".join([', '                \"Transforms must have at most one Stat type (in the first position),\",', '                \"and all others must be a Move type. Given transform type(s):\",', '                \", \".join(str(type(t).__name__) for t in transforms) + \".\"', '            ])', '            raise TypeError(msg)', '', '        new = self._clone()', '        new._layers.append({', '            \"mark\": mark,', '            \"stat\": stat,', '            \"move\": move,', \"            # TODO it doesn't work to supply scalars to variables, but it should\", '            \"vars\": variables,', '            \"source\": data,', '            \"legend\": legend,', '            \"orient\": {\"v\": \"x\", \"h\": \"y\"}.get(orient, orient),  # type: ignore', '        })', '', '        return new', '', '    def pair(', '        self,', '        x: VariableSpecList = None,', '        y: VariableSpecList = None,', '        wrap: int | None = None,', '        cross: bool = True,', '    ) -> Plot:', '        \"\"\"', '        Produce subplots by pairing multiple `x` and/or `y` variables.', '', '        Parameters', '        ----------', '        x, y : sequence(s) of data vectors or identifiers', '            Variables that will define the grid of subplots.', '        wrap : int', '            When using only `x` or `y`, \"wrap\" subplots across a two-dimensional grid', '            with this many columns (when using `x`) or rows (when using `y`).', '        cross : bool', '            When False, zip the `x` and `y` lists such that the first subplot gets the', '            first pair, the second gets the second pair, etc. Otherwise, create a', '            two-dimensional grid from the cartesian product of the lists.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.pair.rst', '', '        \"\"\"', '        # TODO Add transpose= arg, which would then draw pair(y=[...]) across rows', '        # This may also be possible by setting `wrap=1`, but is that too unobvious?', '        # TODO PairGrid features not currently implemented: diagonals, corner', '', '        pair_spec: PairSpec = {}', '', '        axes = {\"x\": [] if x is None else x, \"y\": [] if y is None else y}', '        for axis, arg in axes.items():', '            if isinstance(arg, (str, int)):', '                err = f\"You must pass a sequence of variable keys to `{axis}`\"', '                raise TypeError(err)', '', '        pair_spec[\"variables\"] = {}', '        pair_spec[\"structure\"] = {}', '', '        for axis in \"xy\":', '            keys = []', '            for i, col in enumerate(axes[axis]):', '                key = f\"{axis}{i}\"', '                keys.append(key)', '                pair_spec[\"variables\"][key] = col', '', '            if keys:', '                pair_spec[\"structure\"][axis] = keys', '', '        if not cross and len(axes[\"x\"]) != len(axes[\"y\"]):', '            err = \"Lengths of the `x` and `y` lists must match with cross=False\"', '            raise ValueError(err)', '', '        pair_spec[\"cross\"] = cross', '        pair_spec[\"wrap\"] = wrap', '', '        new = self._clone()', '        new._pair_spec.update(pair_spec)', '        return new', '', '    def facet(', '        self,', '        col: VariableSpec = None,', '        row: VariableSpec = None,', '        order: OrderSpec | dict[str, OrderSpec] = None,', '        wrap: int | None = None,', '    ) -> Plot:', '        \"\"\"', '        Produce subplots with conditional subsets of the data.', '', '        Parameters', '        ----------', '        col, row : data vectors or identifiers', '            Variables used to define subsets along the columns and/or rows of the grid.', '            Can be references to the global data source passed in the constructor.', '        order : list of strings, or dict with dimensional keys', '            Define the order of the faceting variables.', '        wrap : int', '            When using only `col` or `row`, wrap subplots across a two-dimensional', '            grid with this many subplots on the faceting dimension.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.facet.rst', '', '        \"\"\"', '        variables: dict[str, VariableSpec] = {}', '        if col is not None:', '            variables[\"col\"] = col', '        if row is not None:', '            variables[\"row\"] = row', '', '        structure = {}', '        if isinstance(order, dict):', '            for dim in [\"col\", \"row\"]:', '                dim_order = order.get(dim)', '                if dim_order is not None:', '                    structure[dim] = list(dim_order)', '        elif order is not None:', '            if col is not None and row is not None:', '                err = \" \".join([', '                    \"When faceting on both col= and row=, passing `order` as a list\"', '                    \"is ambiguous. Use a dict with \\'col\\' and/or \\'row\\' keys instead.\"', '                ])', '                raise RuntimeError(err)', '            elif col is not None:', '                structure[\"col\"] = list(order)', '            elif row is not None:', '                structure[\"row\"] = list(order)', '', '        spec: FacetSpec = {', '            \"variables\": variables,', '            \"structure\": structure,', '            \"wrap\": wrap,', '        }', '', '        new = self._clone()', '        new._facet_spec.update(spec)', '', '        return new', '', '    # TODO def twin()?', '', '    def scale(self, **scales: Scale) -> Plot:', '        \"\"\"', '        Specify mappings from data units to visual properties.', '', '        Keywords correspond to variables defined in the plot, including coordinate', '        variables (`x`, `y`) and semantic variables (`color`, `pointsize`, etc.).', '', '        A number of \"magic\" arguments are accepted, including:', '            - The name of a transform (e.g., `\"log\"`, `\"sqrt\"`)', '            - The name of a palette (e.g., `\"viridis\"`, `\"muted\"`)', '            - A tuple of values, defining the output range (e.g. `(1, 5)`)', '            - A dict, implying a :class:`Nominal` scale (e.g. `{\"a\": .2, \"b\": .5}`)', '            - A list of values, implying a :class:`Nominal` scale (e.g. `[\"b\", \"r\"]`)', '', '        For more explicit control, pass a scale spec object such as :class:`Continuous`', '        or :class:`Nominal`. Or use `None` to use an \"identity\" scale, which treats data', '        values as literally encoding visual properties.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.scale.rst', '', '        \"\"\"', '        new = self._clone()', '        new._scales.update(scales)', '        return new', '', '    def share(self, **shares: bool | str) -> Plot:', '        \"\"\"', '        Control sharing of axis limits and ticks across subplots.', '', '        Keywords correspond to variables defined in the plot, and values can be', '        boolean (to share across all subplots), or one of \"row\" or \"col\" (to share', '        more selectively across one dimension of a grid).', '', '        Behavior for non-coordinate variables is currently undefined.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.share.rst', '', '        \"\"\"', '        new = self._clone()', '        new._shares.update(shares)', '        return new', '', '    def limit(self, **limits: tuple[Any, Any]) -> Plot:', '        \"\"\"', '        Control the range of visible data.', '', '        Keywords correspond to variables defined in the plot, and values are a', '        `(min, max)` tuple (where either can be `None` to leave unset).', '', '        Limits apply only to the axis; data outside the visible range are', '        still used for any stat transforms and added to the plot.', '', '        Behavior for non-coordinate variables is currently undefined.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.limit.rst', '', '        \"\"\"', '        new = self._clone()', '        new._limits.update(limits)', '        return new', '', '    def label(self, *, title=None, **variables: str | Callable[[str], str]) -> Plot:', '        \"\"\"', '        Control the labels and titles for axes, legends, and subplots.', '', '        Additional keywords correspond to variables defined in the plot.', '        Values can be one of the following types:', '', '        - string (used literally; pass \"\" to clear the default label)', '        - function (called on the default label)', '', '        For coordinate variables, the value sets the axis label.', '        For semantic variables, the value sets the legend title.', '        For faceting variables, `title=` modifies the subplot-specific label,', '        while `col=` and/or `row=` add a label for the faceting variable.', '        When using a single subplot, `title=` sets its title.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.label.rst', '', '', '        \"\"\"', '        new = self._clone()', '        if title is not None:', '            new._labels[\"title\"] = title', '        new._labels.update(variables)', '        return new', '', '    def layout(', '        self,', '        *,', '        size: tuple[float, float] | Default = default,', '        engine: str | None | Default = default,', '    ) -> Plot:', '        \"\"\"', '        Control the figure size and layout.', '', '        .. note::', '', '            Default figure sizes and the API for specifying the figure size are subject', '            to change in future \"experimental\" releases of the objects API. The default', '            layout engine may also change.', '', '        Parameters', '        ----------', '        size : (width, height)', '            Size of the resulting figure, in inches. Size is inclusive of legend when', '            using pyplot, but not otherwise.', '        engine : {{\"tight\", \"constrained\", None}}', '            Name of method for automatically adjusting the layout to remove overlap.', '            The default depends on whether :meth:`Plot.on` is used.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.layout.rst', '', '        \"\"\"', '        # TODO add an \"auto\" mode for figsize that roughly scales with the rcParams', '        # figsize (so that works), but expands to prevent subplots from being squished', '        # Also should we have height=, aspect=, exclusive with figsize? Or working', '        # with figsize when only one is defined?', '', '        new = self._clone()', '', '        if size is not default:', '            new._figure_spec[\"figsize\"] = size', '        if engine is not default:', '            new._layout_spec[\"engine\"] = engine', '', '        return new', '', '    # TODO def legend (ugh)', '', '    def theme(self, *args: dict[str, Any]) -> Plot:', '        \"\"\"', '        Control the default appearance of elements in the plot.', '', '        .. note::', '', '            The API for customizing plot appearance is not yet finalized.', '            Currently, the only valid argument is a dict of matplotlib rc parameters.', '            (This dict must be passed as a positional argument.)', '', '            It is likely that this method will be enhanced in future releases.', '', '        Matplotlib rc parameters are documented on the following page:', '        https://matplotlib.org/stable/tutorials/introductory/customizing.html', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.theme.rst', '', '        \"\"\"', '        new = self._clone()', '', '        # We can skip this whole block on Python 3.8+ with positional-only syntax', '        nargs = len(args)', '        if nargs != 1:', '            err = f\"theme() takes 1 positional argument, but {nargs} were given\"', '            raise TypeError(err)', '', '        rc = args[0]', '        new._theme.update(rc)', '', '        return new', '', '    def save(self, loc, **kwargs) -> Plot:', '        \"\"\"', '        Compile the plot and write it to a buffer or file on disk.', '', '        Parameters', '        ----------', '        loc : str, path, or buffer', '            Location on disk to save the figure, or a buffer to write into.', '        kwargs', '            Other keyword arguments are passed through to', '            :meth:`matplotlib.figure.Figure.savefig`.', '', '        \"\"\"', '        # TODO expose important keyword arguments in our signature?', '        with theme_context(self._theme_with_defaults()):', '            self._plot().save(loc, **kwargs)', '        return self', '', '    def show(self, **kwargs) -> None:', '        \"\"\"', '        Compile the plot and display it by hooking into pyplot.', '', '        Calling this method is not necessary to render a plot in notebook context,', '        but it may be in other environments (e.g., in a terminal). After compiling the', '        plot, it calls :func:`matplotlib.pyplot.show` (passing any keyword parameters).', '', '        Unlike other :class:`Plot` methods, there is no return value. This should be', '        the last method you call when specifying a plot.', '', '        \"\"\"', '        # TODO make pyplot configurable at the class level, and when not using,', '        # import IPython.display and call on self to populate cell output?', '', '        # Keep an eye on whether matplotlib implements \"attaching\" an existing', '        # figure to pyplot: https://github.com/matplotlib/matplotlib/pull/14024', '', '        self.plot(pyplot=True).show(**kwargs)', '', '    def plot(self, pyplot: bool = False) -> Plotter:', '        \"\"\"', '        Compile the plot spec and return the Plotter object.', '        \"\"\"', '        with theme_context(self._theme_with_defaults()):', '            return self._plot(pyplot)', '', '    def _plot(self, pyplot: bool = False) -> Plotter:', '', '        # TODO if we have _target object, pyplot should be determined by whether it', '        # is hooked into the pyplot state machine (how do we check?)', '', '        plotter = Plotter(pyplot=pyplot, theme=self._theme_with_defaults())', '', '        # Process the variable assignments and initialize the figure', '        common, layers = plotter._extract_data(self)', '        plotter._setup_figure(self, common, layers)', '', '        # Process the scale spec for coordinate variables and transform their data', '        coord_vars = [v for v in self._variables if re.match(r\"^x|y\", v)]', '        plotter._setup_scales(self, common, layers, coord_vars)', '', '        # Apply statistical transform(s)', '        plotter._compute_stats(self, layers)', '', '        # Process scale spec for semantic variables and coordinates computed by stat', '        plotter._setup_scales(self, common, layers)', '', '        # TODO Remove these after updating other methods', '        # ---- Maybe have debug= param that attaches these when True?', '        plotter._data = common', '        plotter._layers = layers', '', '        # Process the data for each layer and add matplotlib artists', '        for layer in layers:', '            plotter._plot_layer(self, layer)', '', '        # Add various figure decorations', '        plotter._make_legend(self)', '        plotter._finalize_figure(self)', '', '        return plotter'], 'methods': [{'name': '__init__', 'start_line': 199, 'end_line': 231, 'text': ['    def __init__(', '        self,', '        *args: DataSource | VariableSpec,', '        data: DataSource = None,', '        **variables: VariableSpec,', '    ):', '', '        if args:', '            data, variables = self._resolve_positionals(args, data, variables)', '', '        unknown = [x for x in variables if x not in PROPERTIES]', '        if unknown:', '            err = f\"Plot() got unexpected keyword argument(s): {\\', \\'.join(unknown)}\"', '            raise TypeError(err)', '', '        self._data = PlotData(data, variables)', '', '        self._layers = []', '', '        self._scales = {}', '        self._shares = {}', '        self._limits = {}', '        self._labels = {}', '        self._theme = {}', '', '        self._facet_spec = {}', '        self._pair_spec = {}', '', '        self._figure_spec = {}', '        self._subplot_spec = {}', '        self._layout_spec = {}', '', '        self._target = None']}, {'name': '_resolve_positionals', 'start_line': 233, 'end_line': 266, 'text': ['    def _resolve_positionals(', '        self,', '        args: tuple[DataSource | VariableSpec, ...],', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ) -> tuple[DataSource, dict[str, VariableSpec]]:', '        \"\"\"Handle positional arguments, which may contain data / x / y.\"\"\"', '        if len(args) > 3:', '            err = \"Plot() accepts no more than 3 positional arguments (data, x, y).\"', '            raise TypeError(err)', '', '        # TODO need some clearer way to differentiate data / vector here', '        # (There might be an abstract DataFrame class to use here?)', '        if isinstance(args[0], (abc.Mapping, pd.DataFrame)):', '            if data is not None:', '                raise TypeError(\"`data` given by both name and position.\")', '            data, args = args[0], args[1:]', '', '        if len(args) == 2:', '            x, y = args', '        elif len(args) == 1:', '            x, y = *args, None', '        else:', '            x = y = None', '', '        for name, var in zip(\"yx\", (y, x)):', '            if var is not None:', '                if name in variables:', '                    raise TypeError(f\"`{name}` given by both name and position.\")', '                # Keep coordinates at the front of the variables dict', \"                # Cast type because we know this isn't a DataSource at this point\", '                variables = {name: cast(VariableSpec, var), **variables}', '', '        return data, variables']}, {'name': '__add__', 'start_line': 268, 'end_line': 274, 'text': ['    def __add__(self, other):', '', '        if isinstance(other, Mark) or isinstance(other, Stat):', '            raise TypeError(\"Sorry, this isn\\'t ggplot! Perhaps try Plot.add?\")', '', '        other_type = other.__class__.__name__', '        raise TypeError(f\"Unsupported operand type(s) for +: \\'Plot\\' and \\'{other_type}\")']}, {'name': '_repr_png_', 'start_line': 276, 'end_line': 278, 'text': ['    def _repr_png_(self) -> tuple[bytes, dict[str, float]]:', '', '        return self.plot()._repr_png_()']}, {'name': '_clone', 'start_line': 282, 'end_line': 306, 'text': ['    def _clone(self) -> Plot:', '        \"\"\"Generate a new object with the same information as the current spec.\"\"\"', '        new = Plot()', '', '        # TODO any way to enforce that data does not get mutated?', '        new._data = self._data', '', '        new._layers.extend(self._layers)', '', '        new._scales.update(self._scales)', '        new._shares.update(self._shares)', '        new._limits.update(self._limits)', '        new._labels.update(self._labels)', '        new._theme.update(self._theme)', '', '        new._facet_spec.update(self._facet_spec)', '        new._pair_spec.update(self._pair_spec)', '', '        new._figure_spec.update(self._figure_spec)', '        new._subplot_spec.update(self._subplot_spec)', '        new._layout_spec.update(self._layout_spec)', '', '        new._target = self._target', '', '        return new']}, {'name': '_theme_with_defaults', 'start_line': 308, 'end_line': 326, 'text': ['    def _theme_with_defaults(self) -> dict[str, Any]:', '', '        style_groups = [', '            \"axes\", \"figure\", \"font\", \"grid\", \"hatch\", \"legend\", \"lines\",', '            \"mathtext\", \"markers\", \"patch\", \"savefig\", \"scatter\",', '            \"xaxis\", \"xtick\", \"yaxis\", \"ytick\",', '        ]', '        base = {', '            k: mpl.rcParamsDefault[k] for k in mpl.rcParams', '            if any(k.startswith(p) for p in style_groups)', '        }', '        theme = {', '            **base,', '            **axes_style(\"darkgrid\"),', '            **plotting_context(\"notebook\"),', '            \"axes.prop_cycle\": cycler(\"color\", color_palette(\"deep\")),', '        }', '        theme.update(self._theme)', '        return theme']}, {'name': '_variables', 'start_line': 329, 'end_line': 341, 'text': ['    def _variables(self) -> list[str]:', '', '        variables = (', '            list(self._data.frame)', '            + list(self._pair_spec.get(\"variables\", []))', '            + list(self._facet_spec.get(\"variables\", []))', '        )', '        for layer in self._layers:', '            variables.extend(v for v in layer[\"vars\"] if v not in variables)', '', '        # Coerce to str in return to appease mypy; we know these will only', \"        # ever be strings but I don't think we can type a DataFrame that way yet\", '        return [str(v) for v in variables]']}, {'name': 'on', 'start_line': 343, 'end_line': 387, 'text': ['    def on(self, target: Axes | SubFigure | Figure) -> Plot:', '        \"\"\"', '        Provide existing Matplotlib figure or axes for drawing the plot.', '', '        When using this method, you will also need to explicitly call a method that', '        triggers compilation, such as :meth:`Plot.show` or :meth:`Plot.save`. If you', \"        want to postprocess using matplotlib, you'd need to call :meth:`Plot.plot`\", '        first to compile the plot without rendering it.', '', '        Parameters', '        ----------', '        target : Axes, SubFigure, or Figure', '            Matplotlib object to use. Passing :class:`matplotlib.axes.Axes` will add', '            artists without otherwise modifying the figure. Otherwise, subplots will be', '            created within the space of the given :class:`matplotlib.figure.Figure` or', '            :class:`matplotlib.figure.SubFigure`.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.on.rst', '', '        \"\"\"', '        accepted_types: tuple  # Allow tuple of various length', '        if hasattr(mpl.figure, \"SubFigure\"):  # Added in mpl 3.4', '            accepted_types = (', '                mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure', '            )', '            accepted_types_str = (', '                f\"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}\"', '            )', '        else:', '            accepted_types = mpl.axes.Axes, mpl.figure.Figure', '            accepted_types_str = f\"{mpl.axes.Axes} or {mpl.figure.Figure}\"', '', '        if not isinstance(target, accepted_types):', '            err = (', '                f\"The `Plot.on` target must be an instance of {accepted_types_str}. \"', '                f\"You passed an instance of {target.__class__} instead.\"', '            )', '            raise TypeError(err)', '', '        new = self._clone()', '        new._target = target', '', '        return new']}, {'name': 'add', 'start_line': 389, 'end_line': 476, 'text': ['    def add(', '        self,', '        mark: Mark,', '        *transforms: Stat | Mark,', '        orient: str | None = None,', '        legend: bool = True,', '        data: DataSource = None,', '        **variables: VariableSpec,', '    ) -> Plot:', '        \"\"\"', '        Specify a layer of the visualization in terms of mark and data transform(s).', '', '        This is the main method for specifying how the data should be visualized.', '        It can be called multiple times with different arguments to define', '        a plot with multiple layers.', '', '        Parameters', '        ----------', '        mark : :class:`Mark`', '            The visual representation of the data to use in this layer.', '        transforms : :class:`Stat` or :class:`Move`', '            Objects representing transforms to be applied before plotting the data.', '            Currently, at most one :class:`Stat` can be used, and it', '            must be passed first. This constraint will be relaxed in the future.', '        orient : \"x\", \"y\", \"v\", or \"h\"', '            The orientation of the mark, which also affects how transforms are computed.', '            Typically corresponds to the axis that defines groups for aggregation.', '            The \"v\" (vertical) and \"h\" (horizontal) options are synonyms for \"x\" / \"y\",', '            but may be more intuitive with some marks. When not provided, an', '            orientation will be inferred from characteristics of the data and scales.', '        legend : bool', '            Option to suppress the mark/mappings for this layer from the legend.', '        data : DataFrame or dict', '            Data source to override the global source provided in the constructor.', '        variables : data vectors or identifiers', '            Additional layer-specific variables, including variables that will be', '            passed directly to the transforms without scaling.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.add.rst', '', '        \"\"\"', '        if not isinstance(mark, Mark):', '            msg = f\"mark must be a Mark instance, not {type(mark)!r}.\"', '            raise TypeError(msg)', '', '        # TODO This API for transforms was a late decision, and previously Plot.add', '        # accepted 0 or 1 Stat instances and 0, 1, or a list of Move instances.', '        # It will take some work to refactor the internals so that Stat and Move are', '        # treated identically, and until then well need to \"unpack\" the transforms', '        # here and enforce limitations on the order / types.', '', '        stat: Optional[Stat]', '        move: Optional[List[Move]]', '        error = False', '        if not transforms:', '            stat, move = None, None', '        elif isinstance(transforms[0], Stat):', '            stat = transforms[0]', '            move = [m for m in transforms[1:] if isinstance(m, Move)]', '            error = len(move) != len(transforms) - 1', '        else:', '            stat = None', '            move = [m for m in transforms if isinstance(m, Move)]', '            error = len(move) != len(transforms)', '', '        if error:', '            msg = \" \".join([', '                \"Transforms must have at most one Stat type (in the first position),\",', '                \"and all others must be a Move type. Given transform type(s):\",', '                \", \".join(str(type(t).__name__) for t in transforms) + \".\"', '            ])', '            raise TypeError(msg)', '', '        new = self._clone()', '        new._layers.append({', '            \"mark\": mark,', '            \"stat\": stat,', '            \"move\": move,', \"            # TODO it doesn't work to supply scalars to variables, but it should\", '            \"vars\": variables,', '            \"source\": data,', '            \"legend\": legend,', '            \"orient\": {\"v\": \"x\", \"h\": \"y\"}.get(orient, orient),  # type: ignore', '        })', '', '        return new']}, {'name': 'pair', 'start_line': 478, 'end_line': 539, 'text': ['    def pair(', '        self,', '        x: VariableSpecList = None,', '        y: VariableSpecList = None,', '        wrap: int | None = None,', '        cross: bool = True,', '    ) -> Plot:', '        \"\"\"', '        Produce subplots by pairing multiple `x` and/or `y` variables.', '', '        Parameters', '        ----------', '        x, y : sequence(s) of data vectors or identifiers', '            Variables that will define the grid of subplots.', '        wrap : int', '            When using only `x` or `y`, \"wrap\" subplots across a two-dimensional grid', '            with this many columns (when using `x`) or rows (when using `y`).', '        cross : bool', '            When False, zip the `x` and `y` lists such that the first subplot gets the', '            first pair, the second gets the second pair, etc. Otherwise, create a', '            two-dimensional grid from the cartesian product of the lists.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.pair.rst', '', '        \"\"\"', '        # TODO Add transpose= arg, which would then draw pair(y=[...]) across rows', '        # This may also be possible by setting `wrap=1`, but is that too unobvious?', '        # TODO PairGrid features not currently implemented: diagonals, corner', '', '        pair_spec: PairSpec = {}', '', '        axes = {\"x\": [] if x is None else x, \"y\": [] if y is None else y}', '        for axis, arg in axes.items():', '            if isinstance(arg, (str, int)):', '                err = f\"You must pass a sequence of variable keys to `{axis}`\"', '                raise TypeError(err)', '', '        pair_spec[\"variables\"] = {}', '        pair_spec[\"structure\"] = {}', '', '        for axis in \"xy\":', '            keys = []', '            for i, col in enumerate(axes[axis]):', '                key = f\"{axis}{i}\"', '                keys.append(key)', '                pair_spec[\"variables\"][key] = col', '', '            if keys:', '                pair_spec[\"structure\"][axis] = keys', '', '        if not cross and len(axes[\"x\"]) != len(axes[\"y\"]):', '            err = \"Lengths of the `x` and `y` lists must match with cross=False\"', '            raise ValueError(err)', '', '        pair_spec[\"cross\"] = cross', '        pair_spec[\"wrap\"] = wrap', '', '        new = self._clone()', '        new._pair_spec.update(pair_spec)', '        return new']}, {'name': 'facet', 'start_line': 541, 'end_line': 600, 'text': ['    def facet(', '        self,', '        col: VariableSpec = None,', '        row: VariableSpec = None,', '        order: OrderSpec | dict[str, OrderSpec] = None,', '        wrap: int | None = None,', '    ) -> Plot:', '        \"\"\"', '        Produce subplots with conditional subsets of the data.', '', '        Parameters', '        ----------', '        col, row : data vectors or identifiers', '            Variables used to define subsets along the columns and/or rows of the grid.', '            Can be references to the global data source passed in the constructor.', '        order : list of strings, or dict with dimensional keys', '            Define the order of the faceting variables.', '        wrap : int', '            When using only `col` or `row`, wrap subplots across a two-dimensional', '            grid with this many subplots on the faceting dimension.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.facet.rst', '', '        \"\"\"', '        variables: dict[str, VariableSpec] = {}', '        if col is not None:', '            variables[\"col\"] = col', '        if row is not None:', '            variables[\"row\"] = row', '', '        structure = {}', '        if isinstance(order, dict):', '            for dim in [\"col\", \"row\"]:', '                dim_order = order.get(dim)', '                if dim_order is not None:', '                    structure[dim] = list(dim_order)', '        elif order is not None:', '            if col is not None and row is not None:', '                err = \" \".join([', '                    \"When faceting on both col= and row=, passing `order` as a list\"', '                    \"is ambiguous. Use a dict with \\'col\\' and/or \\'row\\' keys instead.\"', '                ])', '                raise RuntimeError(err)', '            elif col is not None:', '                structure[\"col\"] = list(order)', '            elif row is not None:', '                structure[\"row\"] = list(order)', '', '        spec: FacetSpec = {', '            \"variables\": variables,', '            \"structure\": structure,', '            \"wrap\": wrap,', '        }', '', '        new = self._clone()', '        new._facet_spec.update(spec)', '', '        return new']}, {'name': 'scale', 'start_line': 604, 'end_line': 629, 'text': ['    def scale(self, **scales: Scale) -> Plot:', '        \"\"\"', '        Specify mappings from data units to visual properties.', '', '        Keywords correspond to variables defined in the plot, including coordinate', '        variables (`x`, `y`) and semantic variables (`color`, `pointsize`, etc.).', '', '        A number of \"magic\" arguments are accepted, including:', '            - The name of a transform (e.g., `\"log\"`, `\"sqrt\"`)', '            - The name of a palette (e.g., `\"viridis\"`, `\"muted\"`)', '            - A tuple of values, defining the output range (e.g. `(1, 5)`)', '            - A dict, implying a :class:`Nominal` scale (e.g. `{\"a\": .2, \"b\": .5}`)', '            - A list of values, implying a :class:`Nominal` scale (e.g. `[\"b\", \"r\"]`)', '', '        For more explicit control, pass a scale spec object such as :class:`Continuous`', '        or :class:`Nominal`. Or use `None` to use an \"identity\" scale, which treats data', '        values as literally encoding visual properties.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.scale.rst', '', '        \"\"\"', '        new = self._clone()', '        new._scales.update(scales)', '        return new']}, {'name': 'share', 'start_line': 631, 'end_line': 648, 'text': ['    def share(self, **shares: bool | str) -> Plot:', '        \"\"\"', '        Control sharing of axis limits and ticks across subplots.', '', '        Keywords correspond to variables defined in the plot, and values can be', '        boolean (to share across all subplots), or one of \"row\" or \"col\" (to share', '        more selectively across one dimension of a grid).', '', '        Behavior for non-coordinate variables is currently undefined.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.share.rst', '', '        \"\"\"', '        new = self._clone()', '        new._shares.update(shares)', '        return new']}, {'name': 'limit', 'start_line': 650, 'end_line': 669, 'text': ['    def limit(self, **limits: tuple[Any, Any]) -> Plot:', '        \"\"\"', '        Control the range of visible data.', '', '        Keywords correspond to variables defined in the plot, and values are a', '        `(min, max)` tuple (where either can be `None` to leave unset).', '', '        Limits apply only to the axis; data outside the visible range are', '        still used for any stat transforms and added to the plot.', '', '        Behavior for non-coordinate variables is currently undefined.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.limit.rst', '', '        \"\"\"', '        new = self._clone()', '        new._limits.update(limits)', '        return new']}, {'name': 'label', 'start_line': 671, 'end_line': 697, 'text': ['    def label(self, *, title=None, **variables: str | Callable[[str], str]) -> Plot:', '        \"\"\"', '        Control the labels and titles for axes, legends, and subplots.', '', '        Additional keywords correspond to variables defined in the plot.', '        Values can be one of the following types:', '', '        - string (used literally; pass \"\" to clear the default label)', '        - function (called on the default label)', '', '        For coordinate variables, the value sets the axis label.', '        For semantic variables, the value sets the legend title.', '        For faceting variables, `title=` modifies the subplot-specific label,', '        while `col=` and/or `row=` add a label for the faceting variable.', '        When using a single subplot, `title=` sets its title.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.label.rst', '', '', '        \"\"\"', '        new = self._clone()', '        if title is not None:', '            new._labels[\"title\"] = title', '        new._labels.update(variables)', '        return new']}, {'name': 'layout', 'start_line': 699, 'end_line': 740, 'text': ['    def layout(', '        self,', '        *,', '        size: tuple[float, float] | Default = default,', '        engine: str | None | Default = default,', '    ) -> Plot:', '        \"\"\"', '        Control the figure size and layout.', '', '        .. note::', '', '            Default figure sizes and the API for specifying the figure size are subject', '            to change in future \"experimental\" releases of the objects API. The default', '            layout engine may also change.', '', '        Parameters', '        ----------', '        size : (width, height)', '            Size of the resulting figure, in inches. Size is inclusive of legend when', '            using pyplot, but not otherwise.', '        engine : {{\"tight\", \"constrained\", None}}', '            Name of method for automatically adjusting the layout to remove overlap.', '            The default depends on whether :meth:`Plot.on` is used.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.layout.rst', '', '        \"\"\"', '        # TODO add an \"auto\" mode for figsize that roughly scales with the rcParams', '        # figsize (so that works), but expands to prevent subplots from being squished', '        # Also should we have height=, aspect=, exclusive with figsize? Or working', '        # with figsize when only one is defined?', '', '        new = self._clone()', '', '        if size is not default:', '            new._figure_spec[\"figsize\"] = size', '        if engine is not default:', '            new._layout_spec[\"engine\"] = engine', '', '        return new']}, {'name': 'theme', 'start_line': 744, 'end_line': 775, 'text': ['    def theme(self, *args: dict[str, Any]) -> Plot:', '        \"\"\"', '        Control the default appearance of elements in the plot.', '', '        .. note::', '', '            The API for customizing plot appearance is not yet finalized.', '            Currently, the only valid argument is a dict of matplotlib rc parameters.', '            (This dict must be passed as a positional argument.)', '', '            It is likely that this method will be enhanced in future releases.', '', '        Matplotlib rc parameters are documented on the following page:', '        https://matplotlib.org/stable/tutorials/introductory/customizing.html', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.theme.rst', '', '        \"\"\"', '        new = self._clone()', '', '        # We can skip this whole block on Python 3.8+ with positional-only syntax', '        nargs = len(args)', '        if nargs != 1:', '            err = f\"theme() takes 1 positional argument, but {nargs} were given\"', '            raise TypeError(err)', '', '        rc = args[0]', '        new._theme.update(rc)', '', '        return new']}, {'name': 'save', 'start_line': 777, 'end_line': 793, 'text': ['    def save(self, loc, **kwargs) -> Plot:', '        \"\"\"', '        Compile the plot and write it to a buffer or file on disk.', '', '        Parameters', '        ----------', '        loc : str, path, or buffer', '            Location on disk to save the figure, or a buffer to write into.', '        kwargs', '            Other keyword arguments are passed through to', '            :meth:`matplotlib.figure.Figure.savefig`.', '', '        \"\"\"', '        # TODO expose important keyword arguments in our signature?', '        with theme_context(self._theme_with_defaults()):', '            self._plot().save(loc, **kwargs)', '        return self']}, {'name': 'show', 'start_line': 795, 'end_line': 813, 'text': ['    def show(self, **kwargs) -> None:', '        \"\"\"', '        Compile the plot and display it by hooking into pyplot.', '', '        Calling this method is not necessary to render a plot in notebook context,', '        but it may be in other environments (e.g., in a terminal). After compiling the', '        plot, it calls :func:`matplotlib.pyplot.show` (passing any keyword parameters).', '', '        Unlike other :class:`Plot` methods, there is no return value. This should be', '        the last method you call when specifying a plot.', '', '        \"\"\"', '        # TODO make pyplot configurable at the class level, and when not using,', '        # import IPython.display and call on self to populate cell output?', '', '        # Keep an eye on whether matplotlib implements \"attaching\" an existing', '        # figure to pyplot: https://github.com/matplotlib/matplotlib/pull/14024', '', '        self.plot(pyplot=True).show(**kwargs)']}, {'name': 'plot', 'start_line': 815, 'end_line': 820, 'text': ['    def plot(self, pyplot: bool = False) -> Plotter:', '        \"\"\"', '        Compile the plot spec and return the Plotter object.', '        \"\"\"', '        with theme_context(self._theme_with_defaults()):', '            return self._plot(pyplot)']}, {'name': '_plot', 'start_line': 822, 'end_line': 856, 'text': ['    def _plot(self, pyplot: bool = False) -> Plotter:', '', '        # TODO if we have _target object, pyplot should be determined by whether it', '        # is hooked into the pyplot state machine (how do we check?)', '', '        plotter = Plotter(pyplot=pyplot, theme=self._theme_with_defaults())', '', '        # Process the variable assignments and initialize the figure', '        common, layers = plotter._extract_data(self)', '        plotter._setup_figure(self, common, layers)', '', '        # Process the scale spec for coordinate variables and transform their data', '        coord_vars = [v for v in self._variables if re.match(r\"^x|y\", v)]', '        plotter._setup_scales(self, common, layers, coord_vars)', '', '        # Apply statistical transform(s)', '        plotter._compute_stats(self, layers)', '', '        # Process scale spec for semantic variables and coordinates computed by stat', '        plotter._setup_scales(self, common, layers)', '', '        # TODO Remove these after updating other methods', '        # ---- Maybe have debug= param that attaches these when True?', '        plotter._data = common', '        plotter._layers = layers', '', '        # Process the data for each layer and add matplotlib artists', '        for layer in layers:', '            plotter._plot_layer(self, layer)', '', '        # Add various figure decorations', '        plotter._make_legend(self)', '        plotter._finalize_figure(self)', '', '        return plotter']}]}, {'name': 'Plotter', 'start_line': 862, 'end_line': 1649, 'text': ['class Plotter:', '    \"\"\"', '    Engine for compiling a :class:`Plot` spec into a Matplotlib figure.', '', '    This class is not intended to be instantiated directly by users.', '', '    \"\"\"', '    # TODO decide if we ever want these (Plot.plot(debug=True))?', '    _data: PlotData', '    _layers: list[Layer]', '    _figure: Figure', '', '    def __init__(self, pyplot: bool, theme: dict[str, Any]):', '', '        self._pyplot = pyplot', '        self._theme = theme', '        self._legend_contents: list[tuple[', '            tuple[str, str | int], list[Artist], list[str],', '        ]] = []', '        self._scales: dict[str, Scale] = {}', '', '    def save(self, loc, **kwargs) -> Plotter:  # TODO type args', '        kwargs.setdefault(\"dpi\", 96)', '        try:', '            loc = os.path.expanduser(loc)', '        except TypeError:', '            # loc may be a buffer in which case that would not work', '            pass', '        self._figure.savefig(loc, **kwargs)', '        return self', '', '    def show(self, **kwargs) -> None:', '        \"\"\"', '        Display the plot by hooking into pyplot.', '', '        This method calls :func:`matplotlib.pyplot.show` with any keyword parameters.', '', '        \"\"\"', '        # TODO if we did not create the Plotter with pyplot, is it possible to do this?', '        # If not we should clearly raise.', '        import matplotlib.pyplot as plt', '        with theme_context(self._theme):', '            plt.show(**kwargs)', '', '    # TODO API for accessing the underlying matplotlib objects', '    # TODO what else is useful in the public API for this class?', '', '    def _repr_png_(self) -> tuple[bytes, dict[str, float]]:', '', '        # TODO better to do this through a Jupyter hook? e.g.', '        # ipy = IPython.core.formatters.get_ipython()', '        # fmt = ipy.display_formatter.formatters[\"text/html\"]', '        # fmt.for_type(Plot, ...)', '        # Would like to have a svg option too, not sure how to make that flexible', '', '        # TODO use matplotlib backend directly instead of going through savefig?', '', '        # TODO perhaps have self.show() flip a switch to disable this, so that', '        # user does not end up with two versions of the figure in the output', '', '        # TODO use bbox_inches=\"tight\" like the inline backend?', '        # pro: better results,  con: (sometimes) confusing results', '        # Better solution would be to default (with option to change)', '        # to using constrained/tight layout.', '', '        # TODO need to decide what the right default behavior here is:', '        # - Use dpi=72 to match default InlineBackend figure size?', '        # - Accept a generic \"scaling\" somewhere and scale DPI from that,', '        #   either with 1x -> 72 or 1x -> 96 and the default scaling be .75?', '        # - Listen to rcParams? InlineBackend behavior makes that so complicated :(', '        # - Do we ever want to *not* use retina mode at this point?', '', '        from PIL import Image', '', '        dpi = 96', '        buffer = io.BytesIO()', '', '        with theme_context(self._theme):', '            self._figure.savefig(buffer, dpi=dpi * 2, format=\"png\", bbox_inches=\"tight\")', '        data = buffer.getvalue()', '', '        scaling = .85 / 2', '        w, h = Image.open(buffer).size', '        metadata = {\"width\": w * scaling, \"height\": h * scaling}', '        return data, metadata', '', '    def _extract_data(self, p: Plot) -> tuple[PlotData, list[Layer]]:', '', '        common_data = (', '            p._data', '            .join(None, p._facet_spec.get(\"variables\"))', '            .join(None, p._pair_spec.get(\"variables\"))', '        )', '', '        layers: list[Layer] = []', '        for layer in p._layers:', '            spec = layer.copy()', '            spec[\"data\"] = common_data.join(layer.get(\"source\"), layer.get(\"vars\"))', '            layers.append(spec)', '', '        return common_data, layers', '', '    def _resolve_label(self, p: Plot, var: str, auto_label: str | None) -> str:', '', '        label: str', '        if var in p._labels:', '            manual_label = p._labels[var]', '            if callable(manual_label) and auto_label is not None:', '                label = manual_label(auto_label)', '            else:', '                label = cast(str, manual_label)', '        elif auto_label is None:', '            label = \"\"', '        else:', '            label = auto_label', '        return label', '', '    def _setup_figure(self, p: Plot, common: PlotData, layers: list[Layer]) -> None:', '', '        # --- Parsing the faceting/pairing parameterization to specify figure grid', '', '        subplot_spec = p._subplot_spec.copy()', '        facet_spec = p._facet_spec.copy()', '        pair_spec = p._pair_spec.copy()', '', '        for axis in \"xy\":', '            if axis in p._shares:', '                subplot_spec[f\"share{axis}\"] = p._shares[axis]', '', '        for dim in [\"col\", \"row\"]:', '            if dim in common.frame and dim not in facet_spec[\"structure\"]:', '                order = categorical_order(common.frame[dim])', '                facet_spec[\"structure\"][dim] = order', '', '        self._subplots = subplots = Subplots(subplot_spec, facet_spec, pair_spec)', '', '        # --- Figure initialization', '        self._figure = subplots.init_figure(', '            pair_spec, self._pyplot, p._figure_spec, p._target,', '        )', '', '        # --- Figure annotation', '        for sub in subplots:', '            ax = sub[\"ax\"]', '            for axis in \"xy\":', '                axis_key = sub[axis]', '', '                # ~~ Axis labels', '', '                # TODO Should we make it possible to use only one x/y label for', '                # all rows/columns in a faceted plot? Maybe using sub{axis}label,', '                # although the alignments of the labels from that method leaves', \"                # something to be desired (in terms of how it defines 'centered').\", '                names = [', '                    common.names.get(axis_key),', '                    *(layer[\"data\"].names.get(axis_key) for layer in layers)', '                ]', '                auto_label = next((name for name in names if name is not None), None)', '                label = self._resolve_label(p, axis_key, auto_label)', '                ax.set(**{f\"{axis}label\": label})', '', '                # ~~ Decoration visibility', '', '                # TODO there should be some override (in Plot.layout?) so that', '                # axis / tick labels can be shown on interior shared axes if desired', '', '                axis_obj = getattr(ax, f\"{axis}axis\")', '                visible_side = {\"x\": \"bottom\", \"y\": \"left\"}.get(axis)', '                show_axis_label = (', '                    sub[visible_side]', '                    or not p._pair_spec.get(\"cross\", True)', '                    or (', '                        axis in p._pair_spec.get(\"structure\", {})', '                        and bool(p._pair_spec.get(\"wrap\"))', '                    )', '                )', '                axis_obj.get_label().set_visible(show_axis_label)', '', '                show_tick_labels = (', '                    show_axis_label', '                    or subplot_spec.get(f\"share{axis}\") not in (', '                        True, \"all\", {\"x\": \"col\", \"y\": \"row\"}[axis]', '                    )', '                )', '                for group in (\"major\", \"minor\"):', '                    for t in getattr(axis_obj, f\"get_{group}ticklabels\")():', '                        t.set_visible(show_tick_labels)', '', '            # TODO we want right-side titles for row facets in most cases?', '            # Let\\'s have what we currently call \"margin titles\" but properly using the', '            # ax.set_title interface (see my gist)', '            title_parts = []', '            for dim in [\"col\", \"row\"]:', '                if sub[dim] is not None:', '                    val = self._resolve_label(p, \"title\", f\"{sub[dim]}\")', '                    if dim in p._labels:', '                        key = self._resolve_label(p, dim, common.names.get(dim))', '                        val = f\"{key} {val}\"', '                    title_parts.append(val)', '', '            has_col = sub[\"col\"] is not None', '            has_row = sub[\"row\"] is not None', '            show_title = (', '                has_col and has_row', '                or (has_col or has_row) and p._facet_spec.get(\"wrap\")', '                or (has_col and sub[\"top\"])', '                # TODO or has_row and sub[\"right\"] and <right titles>', '                or has_row  # TODO and not <right titles>', '            )', '            if title_parts:', '                title = \" | \".join(title_parts)', '                title_text = ax.set_title(title)', '                title_text.set_visible(show_title)', '            elif not (has_col or has_row):', '                title = self._resolve_label(p, \"title\", None)', '                title_text = ax.set_title(title)', '', '    def _compute_stats(self, spec: Plot, layers: list[Layer]) -> None:', '', '        grouping_vars = [v for v in PROPERTIES if v not in \"xy\"]', '        grouping_vars += [\"col\", \"row\", \"group\"]', '', '        pair_vars = spec._pair_spec.get(\"structure\", {})', '', '        for layer in layers:', '', '            data = layer[\"data\"]', '            mark = layer[\"mark\"]', '            stat = layer[\"stat\"]', '', '            if stat is None:', '                continue', '', '            iter_axes = itertools.product(*[', '                pair_vars.get(axis, [axis]) for axis in \"xy\"', '            ])', '', '            old = data.frame', '', '            if pair_vars:', '                data.frames = {}', '                data.frame = data.frame.iloc[:0]  # TODO to simplify typing', '', '            for coord_vars in iter_axes:', '', '                pairings = \"xy\", coord_vars', '', '                df = old.copy()', '                scales = self._scales.copy()', '', '                for axis, var in zip(*pairings):', '                    if axis != var:', '                        df = df.rename(columns={var: axis})', '                        drop_cols = [x for x in df if re.match(rf\"{axis}\\\\d+\", str(x))]', '                        df = df.drop(drop_cols, axis=1)', '                        scales[axis] = scales[var]', '', '                orient = layer[\"orient\"] or mark._infer_orient(scales)', '', '                if stat.group_by_orient:', '                    grouper = [orient, *grouping_vars]', '                else:', '                    grouper = grouping_vars', '                groupby = GroupBy(grouper)', '                res = stat(df, groupby, orient, scales)', '', '                if pair_vars:', '                    data.frames[coord_vars] = res', '                else:', '                    data.frame = res', '', '    def _get_scale(', '        self, spec: Plot, var: str, prop: Property, values: Series', '    ) -> Scale:', '', '        if var in spec._scales:', '            arg = spec._scales[var]', '            if arg is None or isinstance(arg, Scale):', '                scale = arg', '            else:', '                scale = prop.infer_scale(arg, values)', '        else:', '            scale = prop.default_scale(values)', '', '        return scale', '', '    def _get_subplot_data(self, df, var, view, share_state):', '', '        if share_state in [True, \"all\"]:', '            # The all-shared case is easiest, every subplot sees all the data', '            seed_values = df[var]', '        else:', '            # Otherwise, we need to setup separate scales for different subplots', '            if share_state in [False, \"none\"]:', \"                # Fully independent axes are also easy: use each subplot's data\", '                idx = self._get_subplot_index(df, view)', '            elif share_state in df:', '                # Sharing within row/col is more complicated', '                use_rows = df[share_state] == view[share_state]', '                idx = df.index[use_rows]', '            else:', \"                # This configuration doesn't make much sense, but it's fine\", '                idx = df.index', '', '            seed_values = df.loc[idx, var]', '', '        return seed_values', '', '    def _setup_scales(', '        self, p: Plot,', '        common: PlotData,', '        layers: list[Layer],', '        variables: list[str] | None = None,', '    ) -> None:', '', '        if variables is None:', '            # Add variables that have data but not a scale, which happens', '            # because this method can be called multiple time, to handle', '            # variables added during the Stat transform.', '            variables = []', '            for layer in layers:', '                variables.extend(layer[\"data\"].frame.columns)', '                for df in layer[\"data\"].frames.values():', '                    variables.extend(str(v) for v in df if v not in variables)', '            variables = [v for v in variables if v not in self._scales]', '', '        for var in variables:', '', '            # Determine whether this is a coordinate variable', '            # (i.e., x/y, paired x/y, or derivative such as xmax)', '            m = re.match(r\"^(?P<coord>(?P<axis>x|y)\\\\d*).*\", var)', '            if m is None:', '                coord = axis = None', '            else:', '                coord = m[\"coord\"]', '                axis = m[\"axis\"]', '', '            # Get keys that handle things like x0, xmax, properly where relevant', '            prop_key = var if axis is None else axis', '            scale_key = var if coord is None else coord', '', '            if prop_key not in PROPERTIES:', '                continue', '', '            # Concatenate layers, using only the relevant coordinate and faceting vars,', '            # This is unnecessarily wasteful, as layer data will often be redundant.', '            # But figuring out the minimal amount we need is more complicated.', '            cols = [var, \"col\", \"row\"]', '            parts = [common.frame.filter(cols)]', '            for layer in layers:', '                parts.append(layer[\"data\"].frame.filter(cols))', '                for df in layer[\"data\"].frames.values():', '                    parts.append(df.filter(cols))', '            var_df = pd.concat(parts, ignore_index=True)', '', '            prop = PROPERTIES[prop_key]', '            scale = self._get_scale(p, scale_key, prop, var_df[var])', '', '            if scale_key not in p._variables:', '                # TODO this implies that the variable was added by the stat', '                # It allows downstream orientation inference to work properly.', '                # But it feels rather hacky, so ideally revisit.', '                scale._priority = 0  # type: ignore', '', '            if axis is None:', '                # We could think about having a broader concept of (un)shared properties', '                # In general, not something you want to do (different scales in facets)', '                # But could make sense e.g. with paired plots. Build later.', '                share_state = None', '                subplots = []', '            else:', '                share_state = self._subplots.subplot_spec[f\"share{axis}\"]', '                subplots = [view for view in self._subplots if view[axis] == coord]', '', '            # Shared categorical axes are broken on matplotlib<3.4.0.', '            # https://github.com/matplotlib/matplotlib/pull/18308', '            # This only affects us when sharing *paired* axes. This is a novel/niche', '            # behavior, so we will raise rather than hack together a workaround.', '            if axis is not None and Version(mpl.__version__) < Version(\"3.4.0\"):', '                from seaborn._core.scales import Nominal', '                paired_axis = axis in p._pair_spec.get(\"structure\", {})', '                cat_scale = isinstance(scale, Nominal)', '                ok_dim = {\"x\": \"col\", \"y\": \"row\"}[axis]', '                shared_axes = share_state not in [False, \"none\", ok_dim]', '                if paired_axis and cat_scale and shared_axes:', '                    err = \"Sharing paired categorical axes requires matplotlib>=3.4.0\"', '                    raise RuntimeError(err)', '', '            if scale is None:', '                self._scales[var] = Scale._identity()', '            else:', '                self._scales[var] = scale._setup(var_df[var], prop)', '', '            # Everything below here applies only to coordinate variables', \"            # We additionally skip it when we're working with a value\", \"            # that is derived from a coordinate we've already processed.\", '            # e.g., the Stat consumed y and added ymin/ymax. In that case,', \"            # we've already setup the y scale and ymin/max are in scale space.\", '            if axis is None or (var != coord and coord in p._variables):', '                continue', '', '            # Set up an empty series to receive the transformed values.', '            # We need this to handle piecemeal transforms of categories -> floats.', '            transformed_data = []', '            for layer in layers:', '                index = layer[\"data\"].frame.index', '                empty_series = pd.Series(dtype=float, index=index, name=var)', '                transformed_data.append(empty_series)', '', '            for view in subplots:', '', '                axis_obj = getattr(view[\"ax\"], f\"{axis}axis\")', '                seed_values = self._get_subplot_data(var_df, var, view, share_state)', '                view_scale = scale._setup(seed_values, prop, axis=axis_obj)', '                set_scale_obj(view[\"ax\"], axis, view_scale._matplotlib_scale)', '', '                for layer, new_series in zip(layers, transformed_data):', '                    layer_df = layer[\"data\"].frame', '                    if var in layer_df:', '                        idx = self._get_subplot_index(layer_df, view)', '                        new_series.loc[idx] = view_scale(layer_df.loc[idx, var])', '', '            # Now the transformed data series are complete, set update the layer data', '            for layer, new_series in zip(layers, transformed_data):', '                layer_df = layer[\"data\"].frame', '                if var in layer_df:', '                    layer_df[var] = new_series', '', '    def _plot_layer(self, p: Plot, layer: Layer) -> None:', '', '        data = layer[\"data\"]', '        mark = layer[\"mark\"]', '        move = layer[\"move\"]', '', '        default_grouping_vars = [\"col\", \"row\", \"group\"]  # TODO where best to define?', '        grouping_properties = [v for v in PROPERTIES if v[0] not in \"xy\"]', '', '        pair_variables = p._pair_spec.get(\"structure\", {})', '', '        for subplots, df, scales in self._generate_pairings(data, pair_variables):', '', '            orient = layer[\"orient\"] or mark._infer_orient(scales)', '', '            def get_order(var):', '                # Ignore order for x/y: they have been scaled to numeric indices,', '                # so any original order is no longer valid. Default ordering rules', '                # sorted unique numbers will correctly reconstruct intended order', '                # TODO This is tricky, make sure we add some tests for this', '                if var not in \"xy\" and var in scales:', '                    return getattr(scales[var], \"order\", None)', '', '            if \"width\" in mark._mappable_props:', '                width = mark._resolve(df, \"width\", None)', '            else:', '                width = 0.8 if \"width\" not in df else df[\"width\"]  # TODO what default?', '            if orient in df:', '                df[\"width\"] = width * scales[orient]._spacing(df[orient])', '', '            if \"baseline\" in mark._mappable_props:', '                # TODO what marks should have this?', '                # If we can set baseline with, e.g., Bar(), then the', '                # \"other\" (e.g. y for x oriented bars) parameterization', '                # is somewhat ambiguous.', '                baseline = mark._resolve(df, \"baseline\", None)', '            else:', '                # TODO unlike width, we might not want to add baseline to data', \"                # if the mark doesn't use it. Practically, there is a concern about\", '                # Mark abstraction like Area / Ribbon', '                baseline = 0 if \"baseline\" not in df else df[\"baseline\"]', '            df[\"baseline\"] = baseline', '', '            if move is not None:', '                moves = move if isinstance(move, list) else [move]', '                for move_step in moves:', '                    move_by = getattr(move_step, \"by\", None)', '                    if move_by is None:', '                        move_by = grouping_properties', '                    move_groupers = [*move_by, *default_grouping_vars]', '                    if move_step.group_by_orient:', '                        move_groupers.insert(0, orient)', '                    order = {var: get_order(var) for var in move_groupers}', '                    groupby = GroupBy(order)', '                    df = move_step(df, groupby, orient, scales)', '', '            df = self._unscale_coords(subplots, df, orient)', '', '            grouping_vars = mark._grouping_props + default_grouping_vars', '            split_generator = self._setup_split_generator(grouping_vars, df, subplots)', '', '            mark._plot(split_generator, scales, orient)', '', '        # TODO is this the right place for this?', '        for view in self._subplots:', '            view[\"ax\"].autoscale_view()', '', '        if layer[\"legend\"]:', '            self._update_legend_contents(p, mark, data, scales)', '', '    def _unscale_coords(', '        self, subplots: list[dict], df: DataFrame, orient: str,', '    ) -> DataFrame:', '        # TODO do we still have numbers in the variable name at this point?', '        coord_cols = [c for c in df if re.match(r\"^[xy]\\\\D*$\", str(c))]', '        drop_cols = [*coord_cols, \"width\"] if \"width\" in df else coord_cols', '        out_df = (', '            df', '            .drop(drop_cols, axis=1)', '            .reindex(df.columns, axis=1)  # So unscaled columns retain their place', '            .copy(deep=False)', '        )', '', '        for view in subplots:', '            view_df = self._filter_subplot_data(df, view)', '            axes_df = view_df[coord_cols]', '            for var, values in axes_df.items():', '', '                axis = getattr(view[\"ax\"], f\"{str(var)[0]}axis\")', '                # TODO see https://github.com/matplotlib/matplotlib/issues/22713', '                transform = axis.get_transform().inverted().transform', '                inverted = transform(values)', '                out_df.loc[values.index, str(var)] = inverted', '', '                if var == orient and \"width\" in view_df:', '                    width = view_df[\"width\"]', '                    out_df.loc[values.index, \"width\"] = (', '                        transform(values + width / 2) - transform(values - width / 2)', '                    )', '', '        return out_df', '', '    def _generate_pairings(', '        self, data: PlotData, pair_variables: dict,', '    ) -> Generator[', '        tuple[list[dict], DataFrame, dict[str, Scale]], None, None', '    ]:', '        # TODO retype return with subplot_spec or similar', '', '        iter_axes = itertools.product(*[', '            pair_variables.get(axis, [axis]) for axis in \"xy\"', '        ])', '', '        for x, y in iter_axes:', '', '            subplots = []', '            for view in self._subplots:', '                if (view[\"x\"] == x) and (view[\"y\"] == y):', '                    subplots.append(view)', '', '            if data.frame.empty and data.frames:', '                out_df = data.frames[(x, y)].copy()', '            elif not pair_variables:', '                out_df = data.frame.copy()', '            else:', '                if data.frame.empty and data.frames:', '                    out_df = data.frames[(x, y)].copy()', '                else:', '                    out_df = data.frame.copy()', '', '            scales = self._scales.copy()', '            if x in out_df:', '                scales[\"x\"] = self._scales[x]', '            if y in out_df:', '                scales[\"y\"] = self._scales[y]', '', '            for axis, var in zip(\"xy\", (x, y)):', '                if axis != var:', '                    out_df = out_df.rename(columns={var: axis})', '                    cols = [col for col in out_df if re.match(rf\"{axis}\\\\d+\", str(col))]', '                    out_df = out_df.drop(cols, axis=1)', '', '            yield subplots, out_df, scales', '', '    def _get_subplot_index(self, df: DataFrame, subplot: dict) -> Index:', '', '        dims = df.columns.intersection([\"col\", \"row\"])', '        if dims.empty:', '            return df.index', '', '        keep_rows = pd.Series(True, df.index, dtype=bool)', '        for dim in dims:', '            keep_rows &= df[dim] == subplot[dim]', '        return df.index[keep_rows]', '', '    def _filter_subplot_data(self, df: DataFrame, subplot: dict) -> DataFrame:', '        # TODO note redundancies with preceding function ... needs refactoring', '        dims = df.columns.intersection([\"col\", \"row\"])', '        if dims.empty:', '            return df', '', '        keep_rows = pd.Series(True, df.index, dtype=bool)', '        for dim in dims:', '            keep_rows &= df[dim] == subplot[dim]', '        return df[keep_rows]', '', '    def _setup_split_generator(', '        self, grouping_vars: list[str], df: DataFrame, subplots: list[dict[str, Any]],', '    ) -> Callable[[], Generator]:', '', '        allow_empty = False  # TODO will need to recreate previous categorical plots', '', '        grouping_keys = []', '        grouping_vars = [', '            v for v in grouping_vars if v in df and v not in [\"col\", \"row\"]', '        ]', '        for var in grouping_vars:', '            order = getattr(self._scales[var], \"order\", None)', '            if order is None:', '                order = categorical_order(df[var])', '            grouping_keys.append(order)', '', '        def split_generator(keep_na=False) -> Generator:', '', '            for view in subplots:', '', '                axes_df = self._filter_subplot_data(df, view)', '', '                with pd.option_context(\"mode.use_inf_as_null\", True):', '                    if keep_na:', '                        # The simpler thing to do would be x.dropna().reindex(x.index).', \"                        # But that doesn't work with the way that the subset iteration\", '                        # is written below, which assumes data for grouping vars.', '                        # Matplotlib (usually?) masks nan data, so this should \"work\".', '                        # Downstream code can also drop these rows, at some speed cost.', '                        present = axes_df.notna().all(axis=1)', '                        nulled = {}', '                        for axis in \"xy\":', '                            if axis in axes_df:', '                                nulled[axis] = axes_df[axis].where(present)', '                        axes_df = axes_df.assign(**nulled)', '                    else:', '                        axes_df = axes_df.dropna()', '', '                subplot_keys = {}', '                for dim in [\"col\", \"row\"]:', '                    if view[dim] is not None:', '                        subplot_keys[dim] = view[dim]', '', '                if not grouping_vars or not any(grouping_keys):', '                    yield subplot_keys, axes_df.copy(), view[\"ax\"]', '                    continue', '', '                grouped_df = axes_df.groupby(grouping_vars, sort=False, as_index=False)', '', '                for key in itertools.product(*grouping_keys):', '', '                    # Pandas fails with singleton tuple inputs', '                    pd_key = key[0] if len(key) == 1 else key', '', '                    try:', '                        df_subset = grouped_df.get_group(pd_key)', '                    except KeyError:', '                        # TODO (from initial work on categorical plots refactor)', '                        # We are adding this to allow backwards compatability', '                        # with the empty artists that old categorical plots would', '                        # add (before 0.12), which we may decide to break, in which', '                        # case this option could be removed', '                        df_subset = axes_df.loc[[]]', '', '                    if df_subset.empty and not allow_empty:', '                        continue', '', '                    sub_vars = dict(zip(grouping_vars, key))', '                    sub_vars.update(subplot_keys)', '', '                    # TODO need copy(deep=...) policy (here, above, anywhere else?)', '                    yield sub_vars, df_subset.copy(), view[\"ax\"]', '', '        return split_generator', '', '    def _update_legend_contents(', '        self,', '        p: Plot,', '        mark: Mark,', '        data: PlotData,', '        scales: dict[str, Scale],', '    ) -> None:', '        \"\"\"Add legend artists / labels for one layer in the plot.\"\"\"', '        if data.frame.empty and data.frames:', '            legend_vars: list[str] = []', '            for frame in data.frames.values():', '                frame_vars = frame.columns.intersection(list(scales))', '                legend_vars.extend(v for v in frame_vars if v not in legend_vars)', '        else:', '            legend_vars = list(data.frame.columns.intersection(list(scales)))', '', '        # First pass: Identify the values that will be shown for each variable', '        schema: list[tuple[', '            tuple[str, str | int], list[str], tuple[list, list[str]]', '        ]] = []', '        schema = []', '        for var in legend_vars:', '            var_legend = scales[var]._legend', '            if var_legend is not None:', '                values, labels = var_legend', '                for (_, part_id), part_vars, _ in schema:', '                    if data.ids[var] == part_id:', '                        # Allow multiple plot semantics to represent same data variable', '                        part_vars.append(var)', '                        break', '                else:', '                    title = self._resolve_label(p, var, data.names[var])', '                    entry = (title, data.ids[var]), [var], (values, labels)', '                    schema.append(entry)', '', '        # Second pass, generate an artist corresponding to each value', '        contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []', '        for key, variables, (values, labels) in schema:', '            artists = []', '            for val in values:', '                artist = mark._legend_artist(variables, val, scales)', '                if artist is not None:', '                    artists.append(artist)', '            if artists:', '                contents.append((key, artists, labels))', '', '        self._legend_contents.extend(contents)', '', '    def _make_legend(self, p: Plot) -> None:', '        \"\"\"Create the legend artist(s) and add onto the figure.\"\"\"', '        # Combine artists representing same information across layers', '        # Input list has an entry for each distinct variable in each layer', '        # Output dict has an entry for each distinct variable', '        merged_contents: dict[', '            tuple[str, str | int], tuple[list[Artist], list[str]],', '        ] = {}', '        for key, new_artists, labels in self._legend_contents:', '            # Key is (name, id); we need the id to resolve variable uniqueness,', '            # but will need the name in the next step to title the legend', '            if key in merged_contents:', \"                # Copy so inplace updates don't propagate back to legend_contents\", '                existing_artists = merged_contents[key][0]', '                for i, artist in enumerate(existing_artists):', '                    # Matplotlib accepts a tuple of artists and will overlay them', '                    if isinstance(artist, tuple):', '                        artist += new_artists[i],', '                    else:', '                        existing_artists[i] = artist, new_artists[i]', '            else:', '                merged_contents[key] = new_artists.copy(), labels', '', '        # TODO explain', '        loc = \"center right\" if self._pyplot else \"center left\"', '', '        base_legend = None', '        for (name, _), (handles, labels) in merged_contents.items():', '', '            legend = mpl.legend.Legend(', '                self._figure,', '                handles,', '                labels,', '                title=name,', '                loc=loc,', '                bbox_to_anchor=(.98, .55),', '            )', '', '            if base_legend:', '                # Matplotlib has no public API for this so it is a bit of a hack.', \"                # Ideally we'd define our own legend class with more flexibility,\", '                # but that is a lot of work!', '                base_legend_box = base_legend.get_children()[0]', '                this_legend_box = legend.get_children()[0]', '                base_legend_box.get_children().extend(this_legend_box.get_children())', '            else:', '                base_legend = legend', '                self._figure.legends.append(legend)', '', '    def _finalize_figure(self, p: Plot) -> None:', '', '        for sub in self._subplots:', '            ax = sub[\"ax\"]', '            for axis in \"xy\":', '                axis_key = sub[axis]', '', '                # Axis limits', '                if axis_key in p._limits:', '                    convert_units = getattr(ax, f\"{axis}axis\").convert_units', '                    a, b = p._limits[axis_key]', '                    lo = a if a is None else convert_units(a)', '                    hi = b if b is None else convert_units(b)', '                    if isinstance(a, str):', '                        lo = cast(float, lo) - 0.5', '                    if isinstance(b, str):', '                        hi = cast(float, hi) + 0.5', '                    ax.set(**{f\"{axis}lim\": (lo, hi)})', '', '        engine_default = None if p._target is not None else \"tight\"', '        layout_engine = p._layout_spec.get(\"engine\", engine_default)', '        set_layout_engine(self._figure, layout_engine)'], 'methods': [{'name': '__init__', 'start_line': 874, 'end_line': 881, 'text': ['    def __init__(self, pyplot: bool, theme: dict[str, Any]):', '', '        self._pyplot = pyplot', '        self._theme = theme', '        self._legend_contents: list[tuple[', '            tuple[str, str | int], list[Artist], list[str],', '        ]] = []', '        self._scales: dict[str, Scale] = {}']}, {'name': 'save', 'start_line': 883, 'end_line': 891, 'text': ['    def save(self, loc, **kwargs) -> Plotter:  # TODO type args', '        kwargs.setdefault(\"dpi\", 96)', '        try:', '            loc = os.path.expanduser(loc)', '        except TypeError:', '            # loc may be a buffer in which case that would not work', '            pass', '        self._figure.savefig(loc, **kwargs)', '        return self']}, {'name': 'show', 'start_line': 893, 'end_line': 904, 'text': ['    def show(self, **kwargs) -> None:', '        \"\"\"', '        Display the plot by hooking into pyplot.', '', '        This method calls :func:`matplotlib.pyplot.show` with any keyword parameters.', '', '        \"\"\"', '        # TODO if we did not create the Plotter with pyplot, is it possible to do this?', '        # If not we should clearly raise.', '        import matplotlib.pyplot as plt', '        with theme_context(self._theme):', '            plt.show(**kwargs)']}, {'name': '_repr_png_', 'start_line': 909, 'end_line': 946, 'text': ['    def _repr_png_(self) -> tuple[bytes, dict[str, float]]:', '', '        # TODO better to do this through a Jupyter hook? e.g.', '        # ipy = IPython.core.formatters.get_ipython()', '        # fmt = ipy.display_formatter.formatters[\"text/html\"]', '        # fmt.for_type(Plot, ...)', '        # Would like to have a svg option too, not sure how to make that flexible', '', '        # TODO use matplotlib backend directly instead of going through savefig?', '', '        # TODO perhaps have self.show() flip a switch to disable this, so that', '        # user does not end up with two versions of the figure in the output', '', '        # TODO use bbox_inches=\"tight\" like the inline backend?', '        # pro: better results,  con: (sometimes) confusing results', '        # Better solution would be to default (with option to change)', '        # to using constrained/tight layout.', '', '        # TODO need to decide what the right default behavior here is:', '        # - Use dpi=72 to match default InlineBackend figure size?', '        # - Accept a generic \"scaling\" somewhere and scale DPI from that,', '        #   either with 1x -> 72 or 1x -> 96 and the default scaling be .75?', '        # - Listen to rcParams? InlineBackend behavior makes that so complicated :(', '        # - Do we ever want to *not* use retina mode at this point?', '', '        from PIL import Image', '', '        dpi = 96', '        buffer = io.BytesIO()', '', '        with theme_context(self._theme):', '            self._figure.savefig(buffer, dpi=dpi * 2, format=\"png\", bbox_inches=\"tight\")', '        data = buffer.getvalue()', '', '        scaling = .85 / 2', '        w, h = Image.open(buffer).size', '        metadata = {\"width\": w * scaling, \"height\": h * scaling}', '        return data, metadata']}, {'name': '_extract_data', 'start_line': 948, 'end_line': 962, 'text': ['    def _extract_data(self, p: Plot) -> tuple[PlotData, list[Layer]]:', '', '        common_data = (', '            p._data', '            .join(None, p._facet_spec.get(\"variables\"))', '            .join(None, p._pair_spec.get(\"variables\"))', '        )', '', '        layers: list[Layer] = []', '        for layer in p._layers:', '            spec = layer.copy()', '            spec[\"data\"] = common_data.join(layer.get(\"source\"), layer.get(\"vars\"))', '            layers.append(spec)', '', '        return common_data, layers']}, {'name': '_resolve_label', 'start_line': 964, 'end_line': 977, 'text': ['    def _resolve_label(self, p: Plot, var: str, auto_label: str | None) -> str:', '', '        label: str', '        if var in p._labels:', '            manual_label = p._labels[var]', '            if callable(manual_label) and auto_label is not None:', '                label = manual_label(auto_label)', '            else:', '                label = cast(str, manual_label)', '        elif auto_label is None:', '            label = \"\"', '        else:', '            label = auto_label', '        return label']}, {'name': '_setup_figure', 'start_line': 979, 'end_line': 1077, 'text': ['    def _setup_figure(self, p: Plot, common: PlotData, layers: list[Layer]) -> None:', '', '        # --- Parsing the faceting/pairing parameterization to specify figure grid', '', '        subplot_spec = p._subplot_spec.copy()', '        facet_spec = p._facet_spec.copy()', '        pair_spec = p._pair_spec.copy()', '', '        for axis in \"xy\":', '            if axis in p._shares:', '                subplot_spec[f\"share{axis}\"] = p._shares[axis]', '', '        for dim in [\"col\", \"row\"]:', '            if dim in common.frame and dim not in facet_spec[\"structure\"]:', '                order = categorical_order(common.frame[dim])', '                facet_spec[\"structure\"][dim] = order', '', '        self._subplots = subplots = Subplots(subplot_spec, facet_spec, pair_spec)', '', '        # --- Figure initialization', '        self._figure = subplots.init_figure(', '            pair_spec, self._pyplot, p._figure_spec, p._target,', '        )', '', '        # --- Figure annotation', '        for sub in subplots:', '            ax = sub[\"ax\"]', '            for axis in \"xy\":', '                axis_key = sub[axis]', '', '                # ~~ Axis labels', '', '                # TODO Should we make it possible to use only one x/y label for', '                # all rows/columns in a faceted plot? Maybe using sub{axis}label,', '                # although the alignments of the labels from that method leaves', \"                # something to be desired (in terms of how it defines 'centered').\", '                names = [', '                    common.names.get(axis_key),', '                    *(layer[\"data\"].names.get(axis_key) for layer in layers)', '                ]', '                auto_label = next((name for name in names if name is not None), None)', '                label = self._resolve_label(p, axis_key, auto_label)', '                ax.set(**{f\"{axis}label\": label})', '', '                # ~~ Decoration visibility', '', '                # TODO there should be some override (in Plot.layout?) so that', '                # axis / tick labels can be shown on interior shared axes if desired', '', '                axis_obj = getattr(ax, f\"{axis}axis\")', '                visible_side = {\"x\": \"bottom\", \"y\": \"left\"}.get(axis)', '                show_axis_label = (', '                    sub[visible_side]', '                    or not p._pair_spec.get(\"cross\", True)', '                    or (', '                        axis in p._pair_spec.get(\"structure\", {})', '                        and bool(p._pair_spec.get(\"wrap\"))', '                    )', '                )', '                axis_obj.get_label().set_visible(show_axis_label)', '', '                show_tick_labels = (', '                    show_axis_label', '                    or subplot_spec.get(f\"share{axis}\") not in (', '                        True, \"all\", {\"x\": \"col\", \"y\": \"row\"}[axis]', '                    )', '                )', '                for group in (\"major\", \"minor\"):', '                    for t in getattr(axis_obj, f\"get_{group}ticklabels\")():', '                        t.set_visible(show_tick_labels)', '', '            # TODO we want right-side titles for row facets in most cases?', '            # Let\\'s have what we currently call \"margin titles\" but properly using the', '            # ax.set_title interface (see my gist)', '            title_parts = []', '            for dim in [\"col\", \"row\"]:', '                if sub[dim] is not None:', '                    val = self._resolve_label(p, \"title\", f\"{sub[dim]}\")', '                    if dim in p._labels:', '                        key = self._resolve_label(p, dim, common.names.get(dim))', '                        val = f\"{key} {val}\"', '                    title_parts.append(val)', '', '            has_col = sub[\"col\"] is not None', '            has_row = sub[\"row\"] is not None', '            show_title = (', '                has_col and has_row', '                or (has_col or has_row) and p._facet_spec.get(\"wrap\")', '                or (has_col and sub[\"top\"])', '                # TODO or has_row and sub[\"right\"] and <right titles>', '                or has_row  # TODO and not <right titles>', '            )', '            if title_parts:', '                title = \" | \".join(title_parts)', '                title_text = ax.set_title(title)', '                title_text.set_visible(show_title)', '            elif not (has_col or has_row):', '                title = self._resolve_label(p, \"title\", None)', '                title_text = ax.set_title(title)']}, {'name': '_compute_stats', 'start_line': 1079, 'end_line': 1131, 'text': ['    def _compute_stats(self, spec: Plot, layers: list[Layer]) -> None:', '', '        grouping_vars = [v for v in PROPERTIES if v not in \"xy\"]', '        grouping_vars += [\"col\", \"row\", \"group\"]', '', '        pair_vars = spec._pair_spec.get(\"structure\", {})', '', '        for layer in layers:', '', '            data = layer[\"data\"]', '            mark = layer[\"mark\"]', '            stat = layer[\"stat\"]', '', '            if stat is None:', '                continue', '', '            iter_axes = itertools.product(*[', '                pair_vars.get(axis, [axis]) for axis in \"xy\"', '            ])', '', '            old = data.frame', '', '            if pair_vars:', '                data.frames = {}', '                data.frame = data.frame.iloc[:0]  # TODO to simplify typing', '', '            for coord_vars in iter_axes:', '', '                pairings = \"xy\", coord_vars', '', '                df = old.copy()', '                scales = self._scales.copy()', '', '                for axis, var in zip(*pairings):', '                    if axis != var:', '                        df = df.rename(columns={var: axis})', '                        drop_cols = [x for x in df if re.match(rf\"{axis}\\\\d+\", str(x))]', '                        df = df.drop(drop_cols, axis=1)', '                        scales[axis] = scales[var]', '', '                orient = layer[\"orient\"] or mark._infer_orient(scales)', '', '                if stat.group_by_orient:', '                    grouper = [orient, *grouping_vars]', '                else:', '                    grouper = grouping_vars', '                groupby = GroupBy(grouper)', '                res = stat(df, groupby, orient, scales)', '', '                if pair_vars:', '                    data.frames[coord_vars] = res', '                else:', '                    data.frame = res']}, {'name': '_get_scale', 'start_line': 1133, 'end_line': 1146, 'text': ['    def _get_scale(', '        self, spec: Plot, var: str, prop: Property, values: Series', '    ) -> Scale:', '', '        if var in spec._scales:', '            arg = spec._scales[var]', '            if arg is None or isinstance(arg, Scale):', '                scale = arg', '            else:', '                scale = prop.infer_scale(arg, values)', '        else:', '            scale = prop.default_scale(values)', '', '        return scale']}, {'name': '_get_subplot_data', 'start_line': 1148, 'end_line': 1168, 'text': ['    def _get_subplot_data(self, df, var, view, share_state):', '', '        if share_state in [True, \"all\"]:', '            # The all-shared case is easiest, every subplot sees all the data', '            seed_values = df[var]', '        else:', '            # Otherwise, we need to setup separate scales for different subplots', '            if share_state in [False, \"none\"]:', \"                # Fully independent axes are also easy: use each subplot's data\", '                idx = self._get_subplot_index(df, view)', '            elif share_state in df:', '                # Sharing within row/col is more complicated', '                use_rows = df[share_state] == view[share_state]', '                idx = df.index[use_rows]', '            else:', \"                # This configuration doesn't make much sense, but it's fine\", '                idx = df.index', '', '            seed_values = df.loc[idx, var]', '', '        return seed_values']}, {'name': '_setup_scales', 'start_line': 1170, 'end_line': 1288, 'text': ['    def _setup_scales(', '        self, p: Plot,', '        common: PlotData,', '        layers: list[Layer],', '        variables: list[str] | None = None,', '    ) -> None:', '', '        if variables is None:', '            # Add variables that have data but not a scale, which happens', '            # because this method can be called multiple time, to handle', '            # variables added during the Stat transform.', '            variables = []', '            for layer in layers:', '                variables.extend(layer[\"data\"].frame.columns)', '                for df in layer[\"data\"].frames.values():', '                    variables.extend(str(v) for v in df if v not in variables)', '            variables = [v for v in variables if v not in self._scales]', '', '        for var in variables:', '', '            # Determine whether this is a coordinate variable', '            # (i.e., x/y, paired x/y, or derivative such as xmax)', '            m = re.match(r\"^(?P<coord>(?P<axis>x|y)\\\\d*).*\", var)', '            if m is None:', '                coord = axis = None', '            else:', '                coord = m[\"coord\"]', '                axis = m[\"axis\"]', '', '            # Get keys that handle things like x0, xmax, properly where relevant', '            prop_key = var if axis is None else axis', '            scale_key = var if coord is None else coord', '', '            if prop_key not in PROPERTIES:', '                continue', '', '            # Concatenate layers, using only the relevant coordinate and faceting vars,', '            # This is unnecessarily wasteful, as layer data will often be redundant.', '            # But figuring out the minimal amount we need is more complicated.', '            cols = [var, \"col\", \"row\"]', '            parts = [common.frame.filter(cols)]', '            for layer in layers:', '                parts.append(layer[\"data\"].frame.filter(cols))', '                for df in layer[\"data\"].frames.values():', '                    parts.append(df.filter(cols))', '            var_df = pd.concat(parts, ignore_index=True)', '', '            prop = PROPERTIES[prop_key]', '            scale = self._get_scale(p, scale_key, prop, var_df[var])', '', '            if scale_key not in p._variables:', '                # TODO this implies that the variable was added by the stat', '                # It allows downstream orientation inference to work properly.', '                # But it feels rather hacky, so ideally revisit.', '                scale._priority = 0  # type: ignore', '', '            if axis is None:', '                # We could think about having a broader concept of (un)shared properties', '                # In general, not something you want to do (different scales in facets)', '                # But could make sense e.g. with paired plots. Build later.', '                share_state = None', '                subplots = []', '            else:', '                share_state = self._subplots.subplot_spec[f\"share{axis}\"]', '                subplots = [view for view in self._subplots if view[axis] == coord]', '', '            # Shared categorical axes are broken on matplotlib<3.4.0.', '            # https://github.com/matplotlib/matplotlib/pull/18308', '            # This only affects us when sharing *paired* axes. This is a novel/niche', '            # behavior, so we will raise rather than hack together a workaround.', '            if axis is not None and Version(mpl.__version__) < Version(\"3.4.0\"):', '                from seaborn._core.scales import Nominal', '                paired_axis = axis in p._pair_spec.get(\"structure\", {})', '                cat_scale = isinstance(scale, Nominal)', '                ok_dim = {\"x\": \"col\", \"y\": \"row\"}[axis]', '                shared_axes = share_state not in [False, \"none\", ok_dim]', '                if paired_axis and cat_scale and shared_axes:', '                    err = \"Sharing paired categorical axes requires matplotlib>=3.4.0\"', '                    raise RuntimeError(err)', '', '            if scale is None:', '                self._scales[var] = Scale._identity()', '            else:', '                self._scales[var] = scale._setup(var_df[var], prop)', '', '            # Everything below here applies only to coordinate variables', \"            # We additionally skip it when we're working with a value\", \"            # that is derived from a coordinate we've already processed.\", '            # e.g., the Stat consumed y and added ymin/ymax. In that case,', \"            # we've already setup the y scale and ymin/max are in scale space.\", '            if axis is None or (var != coord and coord in p._variables):', '                continue', '', '            # Set up an empty series to receive the transformed values.', '            # We need this to handle piecemeal transforms of categories -> floats.', '            transformed_data = []', '            for layer in layers:', '                index = layer[\"data\"].frame.index', '                empty_series = pd.Series(dtype=float, index=index, name=var)', '                transformed_data.append(empty_series)', '', '            for view in subplots:', '', '                axis_obj = getattr(view[\"ax\"], f\"{axis}axis\")', '                seed_values = self._get_subplot_data(var_df, var, view, share_state)', '                view_scale = scale._setup(seed_values, prop, axis=axis_obj)', '                set_scale_obj(view[\"ax\"], axis, view_scale._matplotlib_scale)', '', '                for layer, new_series in zip(layers, transformed_data):', '                    layer_df = layer[\"data\"].frame', '                    if var in layer_df:', '                        idx = self._get_subplot_index(layer_df, view)', '                        new_series.loc[idx] = view_scale(layer_df.loc[idx, var])', '', '            # Now the transformed data series are complete, set update the layer data', '            for layer, new_series in zip(layers, transformed_data):', '                layer_df = layer[\"data\"].frame', '                if var in layer_df:', '                    layer_df[var] = new_series']}, {'name': '_plot_layer', 'start_line': 1290, 'end_line': 1358, 'text': ['    def _plot_layer(self, p: Plot, layer: Layer) -> None:', '', '        data = layer[\"data\"]', '        mark = layer[\"mark\"]', '        move = layer[\"move\"]', '', '        default_grouping_vars = [\"col\", \"row\", \"group\"]  # TODO where best to define?', '        grouping_properties = [v for v in PROPERTIES if v[0] not in \"xy\"]', '', '        pair_variables = p._pair_spec.get(\"structure\", {})', '', '        for subplots, df, scales in self._generate_pairings(data, pair_variables):', '', '            orient = layer[\"orient\"] or mark._infer_orient(scales)', '', '            def get_order(var):', '                # Ignore order for x/y: they have been scaled to numeric indices,', '                # so any original order is no longer valid. Default ordering rules', '                # sorted unique numbers will correctly reconstruct intended order', '                # TODO This is tricky, make sure we add some tests for this', '                if var not in \"xy\" and var in scales:', '                    return getattr(scales[var], \"order\", None)', '', '            if \"width\" in mark._mappable_props:', '                width = mark._resolve(df, \"width\", None)', '            else:', '                width = 0.8 if \"width\" not in df else df[\"width\"]  # TODO what default?', '            if orient in df:', '                df[\"width\"] = width * scales[orient]._spacing(df[orient])', '', '            if \"baseline\" in mark._mappable_props:', '                # TODO what marks should have this?', '                # If we can set baseline with, e.g., Bar(), then the', '                # \"other\" (e.g. y for x oriented bars) parameterization', '                # is somewhat ambiguous.', '                baseline = mark._resolve(df, \"baseline\", None)', '            else:', '                # TODO unlike width, we might not want to add baseline to data', \"                # if the mark doesn't use it. Practically, there is a concern about\", '                # Mark abstraction like Area / Ribbon', '                baseline = 0 if \"baseline\" not in df else df[\"baseline\"]', '            df[\"baseline\"] = baseline', '', '            if move is not None:', '                moves = move if isinstance(move, list) else [move]', '                for move_step in moves:', '                    move_by = getattr(move_step, \"by\", None)', '                    if move_by is None:', '                        move_by = grouping_properties', '                    move_groupers = [*move_by, *default_grouping_vars]', '                    if move_step.group_by_orient:', '                        move_groupers.insert(0, orient)', '                    order = {var: get_order(var) for var in move_groupers}', '                    groupby = GroupBy(order)', '                    df = move_step(df, groupby, orient, scales)', '', '            df = self._unscale_coords(subplots, df, orient)', '', '            grouping_vars = mark._grouping_props + default_grouping_vars', '            split_generator = self._setup_split_generator(grouping_vars, df, subplots)', '', '            mark._plot(split_generator, scales, orient)', '', '        # TODO is this the right place for this?', '        for view in self._subplots:', '            view[\"ax\"].autoscale_view()', '', '        if layer[\"legend\"]:', '            self._update_legend_contents(p, mark, data, scales)']}, {'name': '_unscale_coords', 'start_line': 1360, 'end_line': 1390, 'text': ['    def _unscale_coords(', '        self, subplots: list[dict], df: DataFrame, orient: str,', '    ) -> DataFrame:', '        # TODO do we still have numbers in the variable name at this point?', '        coord_cols = [c for c in df if re.match(r\"^[xy]\\\\D*$\", str(c))]', '        drop_cols = [*coord_cols, \"width\"] if \"width\" in df else coord_cols', '        out_df = (', '            df', '            .drop(drop_cols, axis=1)', '            .reindex(df.columns, axis=1)  # So unscaled columns retain their place', '            .copy(deep=False)', '        )', '', '        for view in subplots:', '            view_df = self._filter_subplot_data(df, view)', '            axes_df = view_df[coord_cols]', '            for var, values in axes_df.items():', '', '                axis = getattr(view[\"ax\"], f\"{str(var)[0]}axis\")', '                # TODO see https://github.com/matplotlib/matplotlib/issues/22713', '                transform = axis.get_transform().inverted().transform', '                inverted = transform(values)', '                out_df.loc[values.index, str(var)] = inverted', '', '                if var == orient and \"width\" in view_df:', '                    width = view_df[\"width\"]', '                    out_df.loc[values.index, \"width\"] = (', '                        transform(values + width / 2) - transform(values - width / 2)', '                    )', '', '        return out_df']}, {'name': '_generate_pairings', 'start_line': 1392, 'end_line': 1432, 'text': ['    def _generate_pairings(', '        self, data: PlotData, pair_variables: dict,', '    ) -> Generator[', '        tuple[list[dict], DataFrame, dict[str, Scale]], None, None', '    ]:', '        # TODO retype return with subplot_spec or similar', '', '        iter_axes = itertools.product(*[', '            pair_variables.get(axis, [axis]) for axis in \"xy\"', '        ])', '', '        for x, y in iter_axes:', '', '            subplots = []', '            for view in self._subplots:', '                if (view[\"x\"] == x) and (view[\"y\"] == y):', '                    subplots.append(view)', '', '            if data.frame.empty and data.frames:', '                out_df = data.frames[(x, y)].copy()', '            elif not pair_variables:', '                out_df = data.frame.copy()', '            else:', '                if data.frame.empty and data.frames:', '                    out_df = data.frames[(x, y)].copy()', '                else:', '                    out_df = data.frame.copy()', '', '            scales = self._scales.copy()', '            if x in out_df:', '                scales[\"x\"] = self._scales[x]', '            if y in out_df:', '                scales[\"y\"] = self._scales[y]', '', '            for axis, var in zip(\"xy\", (x, y)):', '                if axis != var:', '                    out_df = out_df.rename(columns={var: axis})', '                    cols = [col for col in out_df if re.match(rf\"{axis}\\\\d+\", str(col))]', '                    out_df = out_df.drop(cols, axis=1)', '', '            yield subplots, out_df, scales']}, {'name': '_get_subplot_index', 'start_line': 1434, 'end_line': 1443, 'text': ['    def _get_subplot_index(self, df: DataFrame, subplot: dict) -> Index:', '', '        dims = df.columns.intersection([\"col\", \"row\"])', '        if dims.empty:', '            return df.index', '', '        keep_rows = pd.Series(True, df.index, dtype=bool)', '        for dim in dims:', '            keep_rows &= df[dim] == subplot[dim]', '        return df.index[keep_rows]']}, {'name': '_filter_subplot_data', 'start_line': 1445, 'end_line': 1454, 'text': ['    def _filter_subplot_data(self, df: DataFrame, subplot: dict) -> DataFrame:', '        # TODO note redundancies with preceding function ... needs refactoring', '        dims = df.columns.intersection([\"col\", \"row\"])', '        if dims.empty:', '            return df', '', '        keep_rows = pd.Series(True, df.index, dtype=bool)', '        for dim in dims:', '            keep_rows &= df[dim] == subplot[dim]', '        return df[keep_rows]']}, {'name': '_setup_split_generator', 'start_line': 1456, 'end_line': 1529, 'text': ['    def _setup_split_generator(', '        self, grouping_vars: list[str], df: DataFrame, subplots: list[dict[str, Any]],', '    ) -> Callable[[], Generator]:', '', '        allow_empty = False  # TODO will need to recreate previous categorical plots', '', '        grouping_keys = []', '        grouping_vars = [', '            v for v in grouping_vars if v in df and v not in [\"col\", \"row\"]', '        ]', '        for var in grouping_vars:', '            order = getattr(self._scales[var], \"order\", None)', '            if order is None:', '                order = categorical_order(df[var])', '            grouping_keys.append(order)', '', '        def split_generator(keep_na=False) -> Generator:', '', '            for view in subplots:', '', '                axes_df = self._filter_subplot_data(df, view)', '', '                with pd.option_context(\"mode.use_inf_as_null\", True):', '                    if keep_na:', '                        # The simpler thing to do would be x.dropna().reindex(x.index).', \"                        # But that doesn't work with the way that the subset iteration\", '                        # is written below, which assumes data for grouping vars.', '                        # Matplotlib (usually?) masks nan data, so this should \"work\".', '                        # Downstream code can also drop these rows, at some speed cost.', '                        present = axes_df.notna().all(axis=1)', '                        nulled = {}', '                        for axis in \"xy\":', '                            if axis in axes_df:', '                                nulled[axis] = axes_df[axis].where(present)', '                        axes_df = axes_df.assign(**nulled)', '                    else:', '                        axes_df = axes_df.dropna()', '', '                subplot_keys = {}', '                for dim in [\"col\", \"row\"]:', '                    if view[dim] is not None:', '                        subplot_keys[dim] = view[dim]', '', '                if not grouping_vars or not any(grouping_keys):', '                    yield subplot_keys, axes_df.copy(), view[\"ax\"]', '                    continue', '', '                grouped_df = axes_df.groupby(grouping_vars, sort=False, as_index=False)', '', '                for key in itertools.product(*grouping_keys):', '', '                    # Pandas fails with singleton tuple inputs', '                    pd_key = key[0] if len(key) == 1 else key', '', '                    try:', '                        df_subset = grouped_df.get_group(pd_key)', '                    except KeyError:', '                        # TODO (from initial work on categorical plots refactor)', '                        # We are adding this to allow backwards compatability', '                        # with the empty artists that old categorical plots would', '                        # add (before 0.12), which we may decide to break, in which', '                        # case this option could be removed', '                        df_subset = axes_df.loc[[]]', '', '                    if df_subset.empty and not allow_empty:', '                        continue', '', '                    sub_vars = dict(zip(grouping_vars, key))', '                    sub_vars.update(subplot_keys)', '', '                    # TODO need copy(deep=...) policy (here, above, anywhere else?)', '                    yield sub_vars, df_subset.copy(), view[\"ax\"]', '', '        return split_generator']}, {'name': '_update_legend_contents', 'start_line': 1531, 'end_line': 1577, 'text': ['    def _update_legend_contents(', '        self,', '        p: Plot,', '        mark: Mark,', '        data: PlotData,', '        scales: dict[str, Scale],', '    ) -> None:', '        \"\"\"Add legend artists / labels for one layer in the plot.\"\"\"', '        if data.frame.empty and data.frames:', '            legend_vars: list[str] = []', '            for frame in data.frames.values():', '                frame_vars = frame.columns.intersection(list(scales))', '                legend_vars.extend(v for v in frame_vars if v not in legend_vars)', '        else:', '            legend_vars = list(data.frame.columns.intersection(list(scales)))', '', '        # First pass: Identify the values that will be shown for each variable', '        schema: list[tuple[', '            tuple[str, str | int], list[str], tuple[list, list[str]]', '        ]] = []', '        schema = []', '        for var in legend_vars:', '            var_legend = scales[var]._legend', '            if var_legend is not None:', '                values, labels = var_legend', '                for (_, part_id), part_vars, _ in schema:', '                    if data.ids[var] == part_id:', '                        # Allow multiple plot semantics to represent same data variable', '                        part_vars.append(var)', '                        break', '                else:', '                    title = self._resolve_label(p, var, data.names[var])', '                    entry = (title, data.ids[var]), [var], (values, labels)', '                    schema.append(entry)', '', '        # Second pass, generate an artist corresponding to each value', '        contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []', '        for key, variables, (values, labels) in schema:', '            artists = []', '            for val in values:', '                artist = mark._legend_artist(variables, val, scales)', '                if artist is not None:', '                    artists.append(artist)', '            if artists:', '                contents.append((key, artists, labels))', '', '        self._legend_contents.extend(contents)']}, {'name': '_make_legend', 'start_line': 1579, 'end_line': 1626, 'text': ['    def _make_legend(self, p: Plot) -> None:', '        \"\"\"Create the legend artist(s) and add onto the figure.\"\"\"', '        # Combine artists representing same information across layers', '        # Input list has an entry for each distinct variable in each layer', '        # Output dict has an entry for each distinct variable', '        merged_contents: dict[', '            tuple[str, str | int], tuple[list[Artist], list[str]],', '        ] = {}', '        for key, new_artists, labels in self._legend_contents:', '            # Key is (name, id); we need the id to resolve variable uniqueness,', '            # but will need the name in the next step to title the legend', '            if key in merged_contents:', \"                # Copy so inplace updates don't propagate back to legend_contents\", '                existing_artists = merged_contents[key][0]', '                for i, artist in enumerate(existing_artists):', '                    # Matplotlib accepts a tuple of artists and will overlay them', '                    if isinstance(artist, tuple):', '                        artist += new_artists[i],', '                    else:', '                        existing_artists[i] = artist, new_artists[i]', '            else:', '                merged_contents[key] = new_artists.copy(), labels', '', '        # TODO explain', '        loc = \"center right\" if self._pyplot else \"center left\"', '', '        base_legend = None', '        for (name, _), (handles, labels) in merged_contents.items():', '', '            legend = mpl.legend.Legend(', '                self._figure,', '                handles,', '                labels,', '                title=name,', '                loc=loc,', '                bbox_to_anchor=(.98, .55),', '            )', '', '            if base_legend:', '                # Matplotlib has no public API for this so it is a bit of a hack.', \"                # Ideally we'd define our own legend class with more flexibility,\", '                # but that is a lot of work!', '                base_legend_box = base_legend.get_children()[0]', '                this_legend_box = legend.get_children()[0]', '                base_legend_box.get_children().extend(this_legend_box.get_children())', '            else:', '                base_legend = legend', '                self._figure.legends.append(legend)']}, {'name': '_finalize_figure', 'start_line': 1628, 'end_line': 1649, 'text': ['    def _finalize_figure(self, p: Plot) -> None:', '', '        for sub in self._subplots:', '            ax = sub[\"ax\"]', '            for axis in \"xy\":', '                axis_key = sub[axis]', '', '                # Axis limits', '                if axis_key in p._limits:', '                    convert_units = getattr(ax, f\"{axis}axis\").convert_units', '                    a, b = p._limits[axis_key]', '                    lo = a if a is None else convert_units(a)', '                    hi = b if b is None else convert_units(b)', '                    if isinstance(a, str):', '                        lo = cast(float, lo) - 0.5', '                    if isinstance(b, str):', '                        hi = cast(float, hi) + 0.5', '                    ax.set(**{f\"{axis}lim\": (lo, hi)})', '', '        engine_default = None if p._target is not None else \"tight\"', '        layout_engine = p._layout_spec.get(\"engine\", engine_default)', '        set_layout_engine(self._figure, layout_engine)']}]}], 'functions': [{'name': 'theme_context', 'start_line': 93, 'end_line': 110, 'text': ['def theme_context(params: dict[str, Any]) -> Generator:', '    \"\"\"Temporarily modify specifc matplotlib rcParams.\"\"\"', '    orig_params = {k: mpl.rcParams[k] for k in params}', '    color_codes = \"bgrmyck\"', '    nice_colors = [*color_palette(\"deep6\"), (.15, .15, .15)]', '    orig_colors = [mpl.colors.colorConverter.colors[x] for x in color_codes]', '    # TODO how to allow this to reflect the color cycle when relevant?', '    try:', '        mpl.rcParams.update(params)', '        for (code, color) in zip(color_codes, nice_colors):', '            mpl.colors.colorConverter.colors[code] = color', '            mpl.colors.colorConverter.cache[code] = color', '        yield', '    finally:', '        mpl.rcParams.update(orig_params)', '        for (code, color) in zip(color_codes, orig_colors):', '            mpl.colors.colorConverter.colors[code] = color', '            mpl.colors.colorConverter.cache[code] = color']}, {'name': 'build_plot_signature', 'start_line': 113, 'end_line': 142, 'text': ['def build_plot_signature(cls):', '    \"\"\"', '    Decorator function for giving Plot a useful signature.', '', '    Currently this mostly saves us some duplicated typing, but we would', '    like eventually to have a way of registering new semantic properties,', '    at which point dynamic signature generation would become more important.', '', '    \"\"\"', '    sig = inspect.signature(cls)', '    params = [', '        inspect.Parameter(\"args\", inspect.Parameter.VAR_POSITIONAL),', '        inspect.Parameter(\"data\", inspect.Parameter.KEYWORD_ONLY, default=None)', '    ]', '    params.extend([', '        inspect.Parameter(name, inspect.Parameter.KEYWORD_ONLY, default=None)', '        for name in PROPERTIES', '    ])', '    new_sig = sig.replace(parameters=params)', '    cls.__signature__ = new_sig', '', '    known_properties = textwrap.fill(', '        \", \".join([f\"|{p}|\" for p in PROPERTIES]),', '        width=78, subsequent_indent=\" \" * 8,', '    )', '', '    if cls.__doc__ is not None:  # support python -OO mode', '        cls.__doc__ = cls.__doc__.format(known_properties=known_properties)', '', '    return cls']}, {'name': 'split_generator', 'start_line': 1472, 'end_line': 1527, 'text': ['        def split_generator(keep_na=False) -> Generator:', '', '            for view in subplots:', '', '                axes_df = self._filter_subplot_data(df, view)', '', '                with pd.option_context(\"mode.use_inf_as_null\", True):', '                    if keep_na:', '                        # The simpler thing to do would be x.dropna().reindex(x.index).', \"                        # But that doesn't work with the way that the subset iteration\", '                        # is written below, which assumes data for grouping vars.', '                        # Matplotlib (usually?) masks nan data, so this should \"work\".', '                        # Downstream code can also drop these rows, at some speed cost.', '                        present = axes_df.notna().all(axis=1)', '                        nulled = {}', '                        for axis in \"xy\":', '                            if axis in axes_df:', '                                nulled[axis] = axes_df[axis].where(present)', '                        axes_df = axes_df.assign(**nulled)', '                    else:', '                        axes_df = axes_df.dropna()', '', '                subplot_keys = {}', '                for dim in [\"col\", \"row\"]:', '                    if view[dim] is not None:', '                        subplot_keys[dim] = view[dim]', '', '                if not grouping_vars or not any(grouping_keys):', '                    yield subplot_keys, axes_df.copy(), view[\"ax\"]', '                    continue', '', '                grouped_df = axes_df.groupby(grouping_vars, sort=False, as_index=False)', '', '                for key in itertools.product(*grouping_keys):', '', '                    # Pandas fails with singleton tuple inputs', '                    pd_key = key[0] if len(key) == 1 else key', '', '                    try:', '                        df_subset = grouped_df.get_group(pd_key)', '                    except KeyError:', '                        # TODO (from initial work on categorical plots refactor)', '                        # We are adding this to allow backwards compatability', '                        # with the empty artists that old categorical plots would', '                        # add (before 0.12), which we may decide to break, in which', '                        # case this option could be removed', '                        df_subset = axes_df.loc[[]]', '', '                    if df_subset.empty and not allow_empty:', '                        continue', '', '                    sub_vars = dict(zip(grouping_vars, key))', '                    sub_vars.update(subplot_keys)', '', '                    # TODO need copy(deep=...) policy (here, above, anywhere else?)', '                    yield sub_vars, df_subset.copy(), view[\"ax\"]']}, {'name': 'get_order', 'start_line': 1305, 'end_line': 1311, 'text': ['            def get_order(var):', '                # Ignore order for x/y: they have been scaled to numeric indices,', '                # so any original order is no longer valid. Default ordering rules', '                # sorted unique numbers will correctly reconstruct intended order', '                # TODO This is tricky, make sure we add some tests for this', '                if var not in \"xy\" and var in scales:', '                    return getattr(scales[var], \"order\", None)']}], 'text': ['\"\"\"The classes for specifying and compiling a declarative visualization.\"\"\"', 'from __future__ import annotations', '', 'import io', 'import os', 'import re', 'import sys', 'import inspect', 'import itertools', 'import textwrap', 'from contextlib import contextmanager', 'from collections import abc', 'from collections.abc import Callable, Generator', 'from typing import Any, List, Optional, cast', '', 'from cycler import cycler', 'import pandas as pd', 'from pandas import DataFrame, Series, Index', 'import matplotlib as mpl', 'from matplotlib.axes import Axes', 'from matplotlib.artist import Artist', 'from matplotlib.figure import Figure', '', 'from seaborn._marks.base import Mark', 'from seaborn._stats.base import Stat', 'from seaborn._core.data import PlotData', 'from seaborn._core.moves import Move', 'from seaborn._core.scales import Scale', 'from seaborn._core.subplots import Subplots', 'from seaborn._core.groupby import GroupBy', 'from seaborn._core.properties import PROPERTIES, Property', 'from seaborn._core.typing import (', '    DataSource,', '    VariableSpec,', '    VariableSpecList,', '    OrderSpec,', '    Default,', ')', 'from seaborn._core.rules import categorical_order', 'from seaborn._compat import set_scale_obj, set_layout_engine', 'from seaborn.rcmod import axes_style, plotting_context', 'from seaborn.palettes import color_palette', 'from seaborn.external.version import Version', '', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:', '    from matplotlib.figure import SubFigure', '', '', 'if sys.version_info >= (3, 8):', '    from typing import TypedDict', 'else:', '    from typing_extensions import TypedDict', '', '', 'default = Default()', '', '', '# ---- Definitions for internal specs --------------------------------- #', '', '', 'class Layer(TypedDict, total=False):', '', '    mark: Mark  # TODO allow list?', '    stat: Stat | None  # TODO allow list?', '    move: Move | list[Move] | None', '    data: PlotData', '    source: DataSource', '    vars: dict[str, VariableSpec]', '    orient: str', '    legend: bool', '', '', 'class FacetSpec(TypedDict, total=False):', '', '    variables: dict[str, VariableSpec]', '    structure: dict[str, list[str]]', '    wrap: int | None', '', '', 'class PairSpec(TypedDict, total=False):', '', '    variables: dict[str, VariableSpec]', '    structure: dict[str, list[str]]', '    cross: bool', '    wrap: int | None', '', '', '# --- Local helpers ----------------------------------------------------------------', '', '', '@contextmanager', 'def theme_context(params: dict[str, Any]) -> Generator:', '    \"\"\"Temporarily modify specifc matplotlib rcParams.\"\"\"', '    orig_params = {k: mpl.rcParams[k] for k in params}', '    color_codes = \"bgrmyck\"', '    nice_colors = [*color_palette(\"deep6\"), (.15, .15, .15)]', '    orig_colors = [mpl.colors.colorConverter.colors[x] for x in color_codes]', '    # TODO how to allow this to reflect the color cycle when relevant?', '    try:', '        mpl.rcParams.update(params)', '        for (code, color) in zip(color_codes, nice_colors):', '            mpl.colors.colorConverter.colors[code] = color', '            mpl.colors.colorConverter.cache[code] = color', '        yield', '    finally:', '        mpl.rcParams.update(orig_params)', '        for (code, color) in zip(color_codes, orig_colors):', '            mpl.colors.colorConverter.colors[code] = color', '            mpl.colors.colorConverter.cache[code] = color', '', '', 'def build_plot_signature(cls):', '    \"\"\"', '    Decorator function for giving Plot a useful signature.', '', '    Currently this mostly saves us some duplicated typing, but we would', '    like eventually to have a way of registering new semantic properties,', '    at which point dynamic signature generation would become more important.', '', '    \"\"\"', '    sig = inspect.signature(cls)', '    params = [', '        inspect.Parameter(\"args\", inspect.Parameter.VAR_POSITIONAL),', '        inspect.Parameter(\"data\", inspect.Parameter.KEYWORD_ONLY, default=None)', '    ]', '    params.extend([', '        inspect.Parameter(name, inspect.Parameter.KEYWORD_ONLY, default=None)', '        for name in PROPERTIES', '    ])', '    new_sig = sig.replace(parameters=params)', '    cls.__signature__ = new_sig', '', '    known_properties = textwrap.fill(', '        \", \".join([f\"|{p}|\" for p in PROPERTIES]),', '        width=78, subsequent_indent=\" \" * 8,', '    )', '', '    if cls.__doc__ is not None:  # support python -OO mode', '        cls.__doc__ = cls.__doc__.format(known_properties=known_properties)', '', '    return cls', '', '', '# ---- The main interface for declarative plotting -------------------- #', '', '', '@build_plot_signature', 'class Plot:', '    \"\"\"', '    An interface for declaratively specifying statistical graphics.', '', '    Plots are constructed by initializing this class and adding one or more', '    layers, comprising a `Mark` and optional `Stat` or `Move`.  Additionally,', '    faceting variables or variable pairings may be defined to divide the space', '    into multiple subplots. The mappings from data values to visual properties', '    can be parametrized using scales, although the plot will try to infer good', '    defaults when scales are not explicitly defined.', '', '    The constructor accepts a data source (a :class:`pandas.DataFrame` or', '    dictionary with columnar values) and variable assignments. Variables can be', '    passed as keys to the data source or directly as data vectors.  If multiple', '    data-containing objects are provided, they will be index-aligned.', '', '    The data source and variables defined in the constructor will be used for', '    all layers in the plot, unless overridden or disabled when adding a layer.', '', '    The following variables can be defined in the constructor:', '        {known_properties}', '', '    The `data`, `x`, and `y` variables can be passed as positional arguments or', '    using keywords. Whether the first positional argument is interpreted as a', '    data source or `x` variable depends on its type.', '', '    The methods of this class return a copy of the instance; use chaining to', '    build up a plot through multiple calls. Methods can be called in any order.', '', '    Most methods only add information to the plot spec; no actual processing', '    happens until the plot is shown or saved. It is also possible to compile', '    the plot without rendering it to access the lower-level representation.', '', '    \"\"\"', '    _data: PlotData', '    _layers: list[Layer]', '', '    _scales: dict[str, Scale]', '    _shares: dict[str, bool | str]', '    _limits: dict[str, tuple[Any, Any]]', '    _labels: dict[str, str | Callable[[str], str]]', '    _theme: dict[str, Any]', '', '    _facet_spec: FacetSpec', '    _pair_spec: PairSpec', '', '    _figure_spec: dict[str, Any]', '    _subplot_spec: dict[str, Any]', '    _layout_spec: dict[str, Any]', '', '    def __init__(', '        self,', '        *args: DataSource | VariableSpec,', '        data: DataSource = None,', '        **variables: VariableSpec,', '    ):', '', '        if args:', '            data, variables = self._resolve_positionals(args, data, variables)', '', '        unknown = [x for x in variables if x not in PROPERTIES]', '        if unknown:', '            err = f\"Plot() got unexpected keyword argument(s): {\\', \\'.join(unknown)}\"', '            raise TypeError(err)', '', '        self._data = PlotData(data, variables)', '', '        self._layers = []', '', '        self._scales = {}', '        self._shares = {}', '        self._limits = {}', '        self._labels = {}', '        self._theme = {}', '', '        self._facet_spec = {}', '        self._pair_spec = {}', '', '        self._figure_spec = {}', '        self._subplot_spec = {}', '        self._layout_spec = {}', '', '        self._target = None', '', '    def _resolve_positionals(', '        self,', '        args: tuple[DataSource | VariableSpec, ...],', '        data: DataSource,', '        variables: dict[str, VariableSpec],', '    ) -> tuple[DataSource, dict[str, VariableSpec]]:', '        \"\"\"Handle positional arguments, which may contain data / x / y.\"\"\"', '        if len(args) > 3:', '            err = \"Plot() accepts no more than 3 positional arguments (data, x, y).\"', '            raise TypeError(err)', '', '        # TODO need some clearer way to differentiate data / vector here', '        # (There might be an abstract DataFrame class to use here?)', '        if isinstance(args[0], (abc.Mapping, pd.DataFrame)):', '            if data is not None:', '                raise TypeError(\"`data` given by both name and position.\")', '            data, args = args[0], args[1:]', '', '        if len(args) == 2:', '            x, y = args', '        elif len(args) == 1:', '            x, y = *args, None', '        else:', '            x = y = None', '', '        for name, var in zip(\"yx\", (y, x)):', '            if var is not None:', '                if name in variables:', '                    raise TypeError(f\"`{name}` given by both name and position.\")', '                # Keep coordinates at the front of the variables dict', \"                # Cast type because we know this isn't a DataSource at this point\", '                variables = {name: cast(VariableSpec, var), **variables}', '', '        return data, variables', '', '    def __add__(self, other):', '', '        if isinstance(other, Mark) or isinstance(other, Stat):', '            raise TypeError(\"Sorry, this isn\\'t ggplot! Perhaps try Plot.add?\")', '', '        other_type = other.__class__.__name__', '        raise TypeError(f\"Unsupported operand type(s) for +: \\'Plot\\' and \\'{other_type}\")', '', '    def _repr_png_(self) -> tuple[bytes, dict[str, float]]:', '', '        return self.plot()._repr_png_()', '', '    # TODO _repr_svg_?', '', '    def _clone(self) -> Plot:', '        \"\"\"Generate a new object with the same information as the current spec.\"\"\"', '        new = Plot()', '', '        # TODO any way to enforce that data does not get mutated?', '        new._data = self._data', '', '        new._layers.extend(self._layers)', '', '        new._scales.update(self._scales)', '        new._shares.update(self._shares)', '        new._limits.update(self._limits)', '        new._labels.update(self._labels)', '        new._theme.update(self._theme)', '', '        new._facet_spec.update(self._facet_spec)', '        new._pair_spec.update(self._pair_spec)', '', '        new._figure_spec.update(self._figure_spec)', '        new._subplot_spec.update(self._subplot_spec)', '        new._layout_spec.update(self._layout_spec)', '', '        new._target = self._target', '', '        return new', '', '    def _theme_with_defaults(self) -> dict[str, Any]:', '', '        style_groups = [', '            \"axes\", \"figure\", \"font\", \"grid\", \"hatch\", \"legend\", \"lines\",', '            \"mathtext\", \"markers\", \"patch\", \"savefig\", \"scatter\",', '            \"xaxis\", \"xtick\", \"yaxis\", \"ytick\",', '        ]', '        base = {', '            k: mpl.rcParamsDefault[k] for k in mpl.rcParams', '            if any(k.startswith(p) for p in style_groups)', '        }', '        theme = {', '            **base,', '            **axes_style(\"darkgrid\"),', '            **plotting_context(\"notebook\"),', '            \"axes.prop_cycle\": cycler(\"color\", color_palette(\"deep\")),', '        }', '        theme.update(self._theme)', '        return theme', '', '    @property', '    def _variables(self) -> list[str]:', '', '        variables = (', '            list(self._data.frame)', '            + list(self._pair_spec.get(\"variables\", []))', '            + list(self._facet_spec.get(\"variables\", []))', '        )', '        for layer in self._layers:', '            variables.extend(v for v in layer[\"vars\"] if v not in variables)', '', '        # Coerce to str in return to appease mypy; we know these will only', \"        # ever be strings but I don't think we can type a DataFrame that way yet\", '        return [str(v) for v in variables]', '', '    def on(self, target: Axes | SubFigure | Figure) -> Plot:', '        \"\"\"', '        Provide existing Matplotlib figure or axes for drawing the plot.', '', '        When using this method, you will also need to explicitly call a method that', '        triggers compilation, such as :meth:`Plot.show` or :meth:`Plot.save`. If you', \"        want to postprocess using matplotlib, you'd need to call :meth:`Plot.plot`\", '        first to compile the plot without rendering it.', '', '        Parameters', '        ----------', '        target : Axes, SubFigure, or Figure', '            Matplotlib object to use. Passing :class:`matplotlib.axes.Axes` will add', '            artists without otherwise modifying the figure. Otherwise, subplots will be', '            created within the space of the given :class:`matplotlib.figure.Figure` or', '            :class:`matplotlib.figure.SubFigure`.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.on.rst', '', '        \"\"\"', '        accepted_types: tuple  # Allow tuple of various length', '        if hasattr(mpl.figure, \"SubFigure\"):  # Added in mpl 3.4', '            accepted_types = (', '                mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure', '            )', '            accepted_types_str = (', '                f\"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}\"', '            )', '        else:', '            accepted_types = mpl.axes.Axes, mpl.figure.Figure', '            accepted_types_str = f\"{mpl.axes.Axes} or {mpl.figure.Figure}\"', '', '        if not isinstance(target, accepted_types):', '            err = (', '                f\"The `Plot.on` target must be an instance of {accepted_types_str}. \"', '                f\"You passed an instance of {target.__class__} instead.\"', '            )', '            raise TypeError(err)', '', '        new = self._clone()', '        new._target = target', '', '        return new', '', '    def add(', '        self,', '        mark: Mark,', '        *transforms: Stat | Mark,', '        orient: str | None = None,', '        legend: bool = True,', '        data: DataSource = None,', '        **variables: VariableSpec,', '    ) -> Plot:', '        \"\"\"', '        Specify a layer of the visualization in terms of mark and data transform(s).', '', '        This is the main method for specifying how the data should be visualized.', '        It can be called multiple times with different arguments to define', '        a plot with multiple layers.', '', '        Parameters', '        ----------', '        mark : :class:`Mark`', '            The visual representation of the data to use in this layer.', '        transforms : :class:`Stat` or :class:`Move`', '            Objects representing transforms to be applied before plotting the data.', '            Currently, at most one :class:`Stat` can be used, and it', '            must be passed first. This constraint will be relaxed in the future.', '        orient : \"x\", \"y\", \"v\", or \"h\"', '            The orientation of the mark, which also affects how transforms are computed.', '            Typically corresponds to the axis that defines groups for aggregation.', '            The \"v\" (vertical) and \"h\" (horizontal) options are synonyms for \"x\" / \"y\",', '            but may be more intuitive with some marks. When not provided, an', '            orientation will be inferred from characteristics of the data and scales.', '        legend : bool', '            Option to suppress the mark/mappings for this layer from the legend.', '        data : DataFrame or dict', '            Data source to override the global source provided in the constructor.', '        variables : data vectors or identifiers', '            Additional layer-specific variables, including variables that will be', '            passed directly to the transforms without scaling.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.add.rst', '', '        \"\"\"', '        if not isinstance(mark, Mark):', '            msg = f\"mark must be a Mark instance, not {type(mark)!r}.\"', '            raise TypeError(msg)', '', '        # TODO This API for transforms was a late decision, and previously Plot.add', '        # accepted 0 or 1 Stat instances and 0, 1, or a list of Move instances.', '        # It will take some work to refactor the internals so that Stat and Move are', '        # treated identically, and until then well need to \"unpack\" the transforms', '        # here and enforce limitations on the order / types.', '', '        stat: Optional[Stat]', '        move: Optional[List[Move]]', '        error = False', '        if not transforms:', '            stat, move = None, None', '        elif isinstance(transforms[0], Stat):', '            stat = transforms[0]', '            move = [m for m in transforms[1:] if isinstance(m, Move)]', '            error = len(move) != len(transforms) - 1', '        else:', '            stat = None', '            move = [m for m in transforms if isinstance(m, Move)]', '            error = len(move) != len(transforms)', '', '        if error:', '            msg = \" \".join([', '                \"Transforms must have at most one Stat type (in the first position),\",', '                \"and all others must be a Move type. Given transform type(s):\",', '                \", \".join(str(type(t).__name__) for t in transforms) + \".\"', '            ])', '            raise TypeError(msg)', '', '        new = self._clone()', '        new._layers.append({', '            \"mark\": mark,', '            \"stat\": stat,', '            \"move\": move,', \"            # TODO it doesn't work to supply scalars to variables, but it should\", '            \"vars\": variables,', '            \"source\": data,', '            \"legend\": legend,', '            \"orient\": {\"v\": \"x\", \"h\": \"y\"}.get(orient, orient),  # type: ignore', '        })', '', '        return new', '', '    def pair(', '        self,', '        x: VariableSpecList = None,', '        y: VariableSpecList = None,', '        wrap: int | None = None,', '        cross: bool = True,', '    ) -> Plot:', '        \"\"\"', '        Produce subplots by pairing multiple `x` and/or `y` variables.', '', '        Parameters', '        ----------', '        x, y : sequence(s) of data vectors or identifiers', '            Variables that will define the grid of subplots.', '        wrap : int', '            When using only `x` or `y`, \"wrap\" subplots across a two-dimensional grid', '            with this many columns (when using `x`) or rows (when using `y`).', '        cross : bool', '            When False, zip the `x` and `y` lists such that the first subplot gets the', '            first pair, the second gets the second pair, etc. Otherwise, create a', '            two-dimensional grid from the cartesian product of the lists.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.pair.rst', '', '        \"\"\"', '        # TODO Add transpose= arg, which would then draw pair(y=[...]) across rows', '        # This may also be possible by setting `wrap=1`, but is that too unobvious?', '        # TODO PairGrid features not currently implemented: diagonals, corner', '', '        pair_spec: PairSpec = {}', '', '        axes = {\"x\": [] if x is None else x, \"y\": [] if y is None else y}', '        for axis, arg in axes.items():', '            if isinstance(arg, (str, int)):', '                err = f\"You must pass a sequence of variable keys to `{axis}`\"', '                raise TypeError(err)', '', '        pair_spec[\"variables\"] = {}', '        pair_spec[\"structure\"] = {}', '', '        for axis in \"xy\":', '            keys = []', '            for i, col in enumerate(axes[axis]):', '                key = f\"{axis}{i}\"', '                keys.append(key)', '                pair_spec[\"variables\"][key] = col', '', '            if keys:', '                pair_spec[\"structure\"][axis] = keys', '', '        if not cross and len(axes[\"x\"]) != len(axes[\"y\"]):', '            err = \"Lengths of the `x` and `y` lists must match with cross=False\"', '            raise ValueError(err)', '', '        pair_spec[\"cross\"] = cross', '        pair_spec[\"wrap\"] = wrap', '', '        new = self._clone()', '        new._pair_spec.update(pair_spec)', '        return new', '', '    def facet(', '        self,', '        col: VariableSpec = None,', '        row: VariableSpec = None,', '        order: OrderSpec | dict[str, OrderSpec] = None,', '        wrap: int | None = None,', '    ) -> Plot:', '        \"\"\"', '        Produce subplots with conditional subsets of the data.', '', '        Parameters', '        ----------', '        col, row : data vectors or identifiers', '            Variables used to define subsets along the columns and/or rows of the grid.', '            Can be references to the global data source passed in the constructor.', '        order : list of strings, or dict with dimensional keys', '            Define the order of the faceting variables.', '        wrap : int', '            When using only `col` or `row`, wrap subplots across a two-dimensional', '            grid with this many subplots on the faceting dimension.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.facet.rst', '', '        \"\"\"', '        variables: dict[str, VariableSpec] = {}', '        if col is not None:', '            variables[\"col\"] = col', '        if row is not None:', '            variables[\"row\"] = row', '', '        structure = {}', '        if isinstance(order, dict):', '            for dim in [\"col\", \"row\"]:', '                dim_order = order.get(dim)', '                if dim_order is not None:', '                    structure[dim] = list(dim_order)', '        elif order is not None:', '            if col is not None and row is not None:', '                err = \" \".join([', '                    \"When faceting on both col= and row=, passing `order` as a list\"', '                    \"is ambiguous. Use a dict with \\'col\\' and/or \\'row\\' keys instead.\"', '                ])', '                raise RuntimeError(err)', '            elif col is not None:', '                structure[\"col\"] = list(order)', '            elif row is not None:', '                structure[\"row\"] = list(order)', '', '        spec: FacetSpec = {', '            \"variables\": variables,', '            \"structure\": structure,', '            \"wrap\": wrap,', '        }', '', '        new = self._clone()', '        new._facet_spec.update(spec)', '', '        return new', '', '    # TODO def twin()?', '', '    def scale(self, **scales: Scale) -> Plot:', '        \"\"\"', '        Specify mappings from data units to visual properties.', '', '        Keywords correspond to variables defined in the plot, including coordinate', '        variables (`x`, `y`) and semantic variables (`color`, `pointsize`, etc.).', '', '        A number of \"magic\" arguments are accepted, including:', '            - The name of a transform (e.g., `\"log\"`, `\"sqrt\"`)', '            - The name of a palette (e.g., `\"viridis\"`, `\"muted\"`)', '            - A tuple of values, defining the output range (e.g. `(1, 5)`)', '            - A dict, implying a :class:`Nominal` scale (e.g. `{\"a\": .2, \"b\": .5}`)', '            - A list of values, implying a :class:`Nominal` scale (e.g. `[\"b\", \"r\"]`)', '', '        For more explicit control, pass a scale spec object such as :class:`Continuous`', '        or :class:`Nominal`. Or use `None` to use an \"identity\" scale, which treats data', '        values as literally encoding visual properties.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.scale.rst', '', '        \"\"\"', '        new = self._clone()', '        new._scales.update(scales)', '        return new', '', '    def share(self, **shares: bool | str) -> Plot:', '        \"\"\"', '        Control sharing of axis limits and ticks across subplots.', '', '        Keywords correspond to variables defined in the plot, and values can be', '        boolean (to share across all subplots), or one of \"row\" or \"col\" (to share', '        more selectively across one dimension of a grid).', '', '        Behavior for non-coordinate variables is currently undefined.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.share.rst', '', '        \"\"\"', '        new = self._clone()', '        new._shares.update(shares)', '        return new', '', '    def limit(self, **limits: tuple[Any, Any]) -> Plot:', '        \"\"\"', '        Control the range of visible data.', '', '        Keywords correspond to variables defined in the plot, and values are a', '        `(min, max)` tuple (where either can be `None` to leave unset).', '', '        Limits apply only to the axis; data outside the visible range are', '        still used for any stat transforms and added to the plot.', '', '        Behavior for non-coordinate variables is currently undefined.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.limit.rst', '', '        \"\"\"', '        new = self._clone()', '        new._limits.update(limits)', '        return new', '', '    def label(self, *, title=None, **variables: str | Callable[[str], str]) -> Plot:', '        \"\"\"', '        Control the labels and titles for axes, legends, and subplots.', '', '        Additional keywords correspond to variables defined in the plot.', '        Values can be one of the following types:', '', '        - string (used literally; pass \"\" to clear the default label)', '        - function (called on the default label)', '', '        For coordinate variables, the value sets the axis label.', '        For semantic variables, the value sets the legend title.', '        For faceting variables, `title=` modifies the subplot-specific label,', '        while `col=` and/or `row=` add a label for the faceting variable.', '        When using a single subplot, `title=` sets its title.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.label.rst', '', '', '        \"\"\"', '        new = self._clone()', '        if title is not None:', '            new._labels[\"title\"] = title', '        new._labels.update(variables)', '        return new', '', '    def layout(', '        self,', '        *,', '        size: tuple[float, float] | Default = default,', '        engine: str | None | Default = default,', '    ) -> Plot:', '        \"\"\"', '        Control the figure size and layout.', '', '        .. note::', '', '            Default figure sizes and the API for specifying the figure size are subject', '            to change in future \"experimental\" releases of the objects API. The default', '            layout engine may also change.', '', '        Parameters', '        ----------', '        size : (width, height)', '            Size of the resulting figure, in inches. Size is inclusive of legend when', '            using pyplot, but not otherwise.', '        engine : {{\"tight\", \"constrained\", None}}', '            Name of method for automatically adjusting the layout to remove overlap.', '            The default depends on whether :meth:`Plot.on` is used.', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.layout.rst', '', '        \"\"\"', '        # TODO add an \"auto\" mode for figsize that roughly scales with the rcParams', '        # figsize (so that works), but expands to prevent subplots from being squished', '        # Also should we have height=, aspect=, exclusive with figsize? Or working', '        # with figsize when only one is defined?', '', '        new = self._clone()', '', '        if size is not default:', '            new._figure_spec[\"figsize\"] = size', '        if engine is not default:', '            new._layout_spec[\"engine\"] = engine', '', '        return new', '', '    # TODO def legend (ugh)', '', '    def theme(self, *args: dict[str, Any]) -> Plot:', '        \"\"\"', '        Control the default appearance of elements in the plot.', '', '        .. note::', '', '            The API for customizing plot appearance is not yet finalized.', '            Currently, the only valid argument is a dict of matplotlib rc parameters.', '            (This dict must be passed as a positional argument.)', '', '            It is likely that this method will be enhanced in future releases.', '', '        Matplotlib rc parameters are documented on the following page:', '        https://matplotlib.org/stable/tutorials/introductory/customizing.html', '', '        Examples', '        --------', '        .. include:: ../docstrings/objects.Plot.theme.rst', '', '        \"\"\"', '        new = self._clone()', '', '        # We can skip this whole block on Python 3.8+ with positional-only syntax', '        nargs = len(args)', '        if nargs != 1:', '            err = f\"theme() takes 1 positional argument, but {nargs} were given\"', '            raise TypeError(err)', '', '        rc = args[0]', '        new._theme.update(rc)', '', '        return new', '', '    def save(self, loc, **kwargs) -> Plot:', '        \"\"\"', '        Compile the plot and write it to a buffer or file on disk.', '', '        Parameters', '        ----------', '        loc : str, path, or buffer', '            Location on disk to save the figure, or a buffer to write into.', '        kwargs', '            Other keyword arguments are passed through to', '            :meth:`matplotlib.figure.Figure.savefig`.', '', '        \"\"\"', '        # TODO expose important keyword arguments in our signature?', '        with theme_context(self._theme_with_defaults()):', '            self._plot().save(loc, **kwargs)', '        return self', '', '    def show(self, **kwargs) -> None:', '        \"\"\"', '        Compile the plot and display it by hooking into pyplot.', '', '        Calling this method is not necessary to render a plot in notebook context,', '        but it may be in other environments (e.g., in a terminal). After compiling the', '        plot, it calls :func:`matplotlib.pyplot.show` (passing any keyword parameters).', '', '        Unlike other :class:`Plot` methods, there is no return value. This should be', '        the last method you call when specifying a plot.', '', '        \"\"\"', '        # TODO make pyplot configurable at the class level, and when not using,', '        # import IPython.display and call on self to populate cell output?', '', '        # Keep an eye on whether matplotlib implements \"attaching\" an existing', '        # figure to pyplot: https://github.com/matplotlib/matplotlib/pull/14024', '', '        self.plot(pyplot=True).show(**kwargs)', '', '    def plot(self, pyplot: bool = False) -> Plotter:', '        \"\"\"', '        Compile the plot spec and return the Plotter object.', '        \"\"\"', '        with theme_context(self._theme_with_defaults()):', '            return self._plot(pyplot)', '', '    def _plot(self, pyplot: bool = False) -> Plotter:', '', '        # TODO if we have _target object, pyplot should be determined by whether it', '        # is hooked into the pyplot state machine (how do we check?)', '', '        plotter = Plotter(pyplot=pyplot, theme=self._theme_with_defaults())', '', '        # Process the variable assignments and initialize the figure', '        common, layers = plotter._extract_data(self)', '        plotter._setup_figure(self, common, layers)', '', '        # Process the scale spec for coordinate variables and transform their data', '        coord_vars = [v for v in self._variables if re.match(r\"^x|y\", v)]', '        plotter._setup_scales(self, common, layers, coord_vars)', '', '        # Apply statistical transform(s)', '        plotter._compute_stats(self, layers)', '', '        # Process scale spec for semantic variables and coordinates computed by stat', '        plotter._setup_scales(self, common, layers)', '', '        # TODO Remove these after updating other methods', '        # ---- Maybe have debug= param that attaches these when True?', '        plotter._data = common', '        plotter._layers = layers', '', '        # Process the data for each layer and add matplotlib artists', '        for layer in layers:', '            plotter._plot_layer(self, layer)', '', '        # Add various figure decorations', '        plotter._make_legend(self)', '        plotter._finalize_figure(self)', '', '        return plotter', '', '', '# ---- The plot compilation engine ---------------------------------------------- #', '', '', 'class Plotter:', '    \"\"\"', '    Engine for compiling a :class:`Plot` spec into a Matplotlib figure.', '', '    This class is not intended to be instantiated directly by users.', '', '    \"\"\"', '    # TODO decide if we ever want these (Plot.plot(debug=True))?', '    _data: PlotData', '    _layers: list[Layer]', '    _figure: Figure', '', '    def __init__(self, pyplot: bool, theme: dict[str, Any]):', '', '        self._pyplot = pyplot', '        self._theme = theme', '        self._legend_contents: list[tuple[', '            tuple[str, str | int], list[Artist], list[str],', '        ]] = []', '        self._scales: dict[str, Scale] = {}', '', '    def save(self, loc, **kwargs) -> Plotter:  # TODO type args', '        kwargs.setdefault(\"dpi\", 96)', '        try:', '            loc = os.path.expanduser(loc)', '        except TypeError:', '            # loc may be a buffer in which case that would not work', '            pass', '        self._figure.savefig(loc, **kwargs)', '        return self', '', '    def show(self, **kwargs) -> None:', '        \"\"\"', '        Display the plot by hooking into pyplot.', '', '        This method calls :func:`matplotlib.pyplot.show` with any keyword parameters.', '', '        \"\"\"', '        # TODO if we did not create the Plotter with pyplot, is it possible to do this?', '        # If not we should clearly raise.', '        import matplotlib.pyplot as plt', '        with theme_context(self._theme):', '            plt.show(**kwargs)', '', '    # TODO API for accessing the underlying matplotlib objects', '    # TODO what else is useful in the public API for this class?', '', '    def _repr_png_(self) -> tuple[bytes, dict[str, float]]:', '', '        # TODO better to do this through a Jupyter hook? e.g.', '        # ipy = IPython.core.formatters.get_ipython()', '        # fmt = ipy.display_formatter.formatters[\"text/html\"]', '        # fmt.for_type(Plot, ...)', '        # Would like to have a svg option too, not sure how to make that flexible', '', '        # TODO use matplotlib backend directly instead of going through savefig?', '', '        # TODO perhaps have self.show() flip a switch to disable this, so that', '        # user does not end up with two versions of the figure in the output', '', '        # TODO use bbox_inches=\"tight\" like the inline backend?', '        # pro: better results,  con: (sometimes) confusing results', '        # Better solution would be to default (with option to change)', '        # to using constrained/tight layout.', '', '        # TODO need to decide what the right default behavior here is:', '        # - Use dpi=72 to match default InlineBackend figure size?', '        # - Accept a generic \"scaling\" somewhere and scale DPI from that,', '        #   either with 1x -> 72 or 1x -> 96 and the default scaling be .75?', '        # - Listen to rcParams? InlineBackend behavior makes that so complicated :(', '        # - Do we ever want to *not* use retina mode at this point?', '', '        from PIL import Image', '', '        dpi = 96', '        buffer = io.BytesIO()', '', '        with theme_context(self._theme):', '            self._figure.savefig(buffer, dpi=dpi * 2, format=\"png\", bbox_inches=\"tight\")', '        data = buffer.getvalue()', '', '        scaling = .85 / 2', '        w, h = Image.open(buffer).size', '        metadata = {\"width\": w * scaling, \"height\": h * scaling}', '        return data, metadata', '', '    def _extract_data(self, p: Plot) -> tuple[PlotData, list[Layer]]:', '', '        common_data = (', '            p._data', '            .join(None, p._facet_spec.get(\"variables\"))', '            .join(None, p._pair_spec.get(\"variables\"))', '        )', '', '        layers: list[Layer] = []', '        for layer in p._layers:', '            spec = layer.copy()', '            spec[\"data\"] = common_data.join(layer.get(\"source\"), layer.get(\"vars\"))', '            layers.append(spec)', '', '        return common_data, layers', '', '    def _resolve_label(self, p: Plot, var: str, auto_label: str | None) -> str:', '', '        label: str', '        if var in p._labels:', '            manual_label = p._labels[var]', '            if callable(manual_label) and auto_label is not None:', '                label = manual_label(auto_label)', '            else:', '                label = cast(str, manual_label)', '        elif auto_label is None:', '            label = \"\"', '        else:', '            label = auto_label', '        return label', '', '    def _setup_figure(self, p: Plot, common: PlotData, layers: list[Layer]) -> None:', '', '        # --- Parsing the faceting/pairing parameterization to specify figure grid', '', '        subplot_spec = p._subplot_spec.copy()', '        facet_spec = p._facet_spec.copy()', '        pair_spec = p._pair_spec.copy()', '', '        for axis in \"xy\":', '            if axis in p._shares:', '                subplot_spec[f\"share{axis}\"] = p._shares[axis]', '', '        for dim in [\"col\", \"row\"]:', '            if dim in common.frame and dim not in facet_spec[\"structure\"]:', '                order = categorical_order(common.frame[dim])', '                facet_spec[\"structure\"][dim] = order', '', '        self._subplots = subplots = Subplots(subplot_spec, facet_spec, pair_spec)', '', '        # --- Figure initialization', '        self._figure = subplots.init_figure(', '            pair_spec, self._pyplot, p._figure_spec, p._target,', '        )', '', '        # --- Figure annotation', '        for sub in subplots:', '            ax = sub[\"ax\"]', '            for axis in \"xy\":', '                axis_key = sub[axis]', '', '                # ~~ Axis labels', '', '                # TODO Should we make it possible to use only one x/y label for', '                # all rows/columns in a faceted plot? Maybe using sub{axis}label,', '                # although the alignments of the labels from that method leaves', \"                # something to be desired (in terms of how it defines 'centered').\", '                names = [', '                    common.names.get(axis_key),', '                    *(layer[\"data\"].names.get(axis_key) for layer in layers)', '                ]', '                auto_label = next((name for name in names if name is not None), None)', '                label = self._resolve_label(p, axis_key, auto_label)', '                ax.set(**{f\"{axis}label\": label})', '', '                # ~~ Decoration visibility', '', '                # TODO there should be some override (in Plot.layout?) so that', '                # axis / tick labels can be shown on interior shared axes if desired', '', '                axis_obj = getattr(ax, f\"{axis}axis\")', '                visible_side = {\"x\": \"bottom\", \"y\": \"left\"}.get(axis)', '                show_axis_label = (', '                    sub[visible_side]', '                    or not p._pair_spec.get(\"cross\", True)', '                    or (', '                        axis in p._pair_spec.get(\"structure\", {})', '                        and bool(p._pair_spec.get(\"wrap\"))', '                    )', '                )', '                axis_obj.get_label().set_visible(show_axis_label)', '', '                show_tick_labels = (', '                    show_axis_label', '                    or subplot_spec.get(f\"share{axis}\") not in (', '                        True, \"all\", {\"x\": \"col\", \"y\": \"row\"}[axis]', '                    )', '                )', '                for group in (\"major\", \"minor\"):', '                    for t in getattr(axis_obj, f\"get_{group}ticklabels\")():', '                        t.set_visible(show_tick_labels)', '', '            # TODO we want right-side titles for row facets in most cases?', '            # Let\\'s have what we currently call \"margin titles\" but properly using the', '            # ax.set_title interface (see my gist)', '            title_parts = []', '            for dim in [\"col\", \"row\"]:', '                if sub[dim] is not None:', '                    val = self._resolve_label(p, \"title\", f\"{sub[dim]}\")', '                    if dim in p._labels:', '                        key = self._resolve_label(p, dim, common.names.get(dim))', '                        val = f\"{key} {val}\"', '                    title_parts.append(val)', '', '            has_col = sub[\"col\"] is not None', '            has_row = sub[\"row\"] is not None', '            show_title = (', '                has_col and has_row', '                or (has_col or has_row) and p._facet_spec.get(\"wrap\")', '                or (has_col and sub[\"top\"])', '                # TODO or has_row and sub[\"right\"] and <right titles>', '                or has_row  # TODO and not <right titles>', '            )', '            if title_parts:', '                title = \" | \".join(title_parts)', '                title_text = ax.set_title(title)', '                title_text.set_visible(show_title)', '            elif not (has_col or has_row):', '                title = self._resolve_label(p, \"title\", None)', '                title_text = ax.set_title(title)', '', '    def _compute_stats(self, spec: Plot, layers: list[Layer]) -> None:', '', '        grouping_vars = [v for v in PROPERTIES if v not in \"xy\"]', '        grouping_vars += [\"col\", \"row\", \"group\"]', '', '        pair_vars = spec._pair_spec.get(\"structure\", {})', '', '        for layer in layers:', '', '            data = layer[\"data\"]', '            mark = layer[\"mark\"]', '            stat = layer[\"stat\"]', '', '            if stat is None:', '                continue', '', '            iter_axes = itertools.product(*[', '                pair_vars.get(axis, [axis]) for axis in \"xy\"', '            ])', '', '            old = data.frame', '', '            if pair_vars:', '                data.frames = {}', '                data.frame = data.frame.iloc[:0]  # TODO to simplify typing', '', '            for coord_vars in iter_axes:', '', '                pairings = \"xy\", coord_vars', '', '                df = old.copy()', '                scales = self._scales.copy()', '', '                for axis, var in zip(*pairings):', '                    if axis != var:', '                        df = df.rename(columns={var: axis})', '                        drop_cols = [x for x in df if re.match(rf\"{axis}\\\\d+\", str(x))]', '                        df = df.drop(drop_cols, axis=1)', '                        scales[axis] = scales[var]', '', '                orient = layer[\"orient\"] or mark._infer_orient(scales)', '', '                if stat.group_by_orient:', '                    grouper = [orient, *grouping_vars]', '                else:', '                    grouper = grouping_vars', '                groupby = GroupBy(grouper)', '                res = stat(df, groupby, orient, scales)', '', '                if pair_vars:', '                    data.frames[coord_vars] = res', '                else:', '                    data.frame = res', '', '    def _get_scale(', '        self, spec: Plot, var: str, prop: Property, values: Series', '    ) -> Scale:', '', '        if var in spec._scales:', '            arg = spec._scales[var]', '            if arg is None or isinstance(arg, Scale):', '                scale = arg', '            else:', '                scale = prop.infer_scale(arg, values)', '        else:', '            scale = prop.default_scale(values)', '', '        return scale', '', '    def _get_subplot_data(self, df, var, view, share_state):', '', '        if share_state in [True, \"all\"]:', '            # The all-shared case is easiest, every subplot sees all the data', '            seed_values = df[var]', '        else:', '            # Otherwise, we need to setup separate scales for different subplots', '            if share_state in [False, \"none\"]:', \"                # Fully independent axes are also easy: use each subplot's data\", '                idx = self._get_subplot_index(df, view)', '            elif share_state in df:', '                # Sharing within row/col is more complicated', '                use_rows = df[share_state] == view[share_state]', '                idx = df.index[use_rows]', '            else:', \"                # This configuration doesn't make much sense, but it's fine\", '                idx = df.index', '', '            seed_values = df.loc[idx, var]', '', '        return seed_values', '', '    def _setup_scales(', '        self, p: Plot,', '        common: PlotData,', '        layers: list[Layer],', '        variables: list[str] | None = None,', '    ) -> None:', '', '        if variables is None:', '            # Add variables that have data but not a scale, which happens', '            # because this method can be called multiple time, to handle', '            # variables added during the Stat transform.', '            variables = []', '            for layer in layers:', '                variables.extend(layer[\"data\"].frame.columns)', '                for df in layer[\"data\"].frames.values():', '                    variables.extend(str(v) for v in df if v not in variables)', '            variables = [v for v in variables if v not in self._scales]', '', '        for var in variables:', '', '            # Determine whether this is a coordinate variable', '            # (i.e., x/y, paired x/y, or derivative such as xmax)', '            m = re.match(r\"^(?P<coord>(?P<axis>x|y)\\\\d*).*\", var)', '            if m is None:', '                coord = axis = None', '            else:', '                coord = m[\"coord\"]', '                axis = m[\"axis\"]', '', '            # Get keys that handle things like x0, xmax, properly where relevant', '            prop_key = var if axis is None else axis', '            scale_key = var if coord is None else coord', '', '            if prop_key not in PROPERTIES:', '                continue', '', '            # Concatenate layers, using only the relevant coordinate and faceting vars,', '            # This is unnecessarily wasteful, as layer data will often be redundant.', '            # But figuring out the minimal amount we need is more complicated.', '            cols = [var, \"col\", \"row\"]', '            parts = [common.frame.filter(cols)]', '            for layer in layers:', '                parts.append(layer[\"data\"].frame.filter(cols))', '                for df in layer[\"data\"].frames.values():', '                    parts.append(df.filter(cols))', '            var_df = pd.concat(parts, ignore_index=True)', '', '            prop = PROPERTIES[prop_key]', '            scale = self._get_scale(p, scale_key, prop, var_df[var])', '', '            if scale_key not in p._variables:', '                # TODO this implies that the variable was added by the stat', '                # It allows downstream orientation inference to work properly.', '                # But it feels rather hacky, so ideally revisit.', '                scale._priority = 0  # type: ignore', '', '            if axis is None:', '                # We could think about having a broader concept of (un)shared properties', '                # In general, not something you want to do (different scales in facets)', '                # But could make sense e.g. with paired plots. Build later.', '                share_state = None', '                subplots = []', '            else:', '                share_state = self._subplots.subplot_spec[f\"share{axis}\"]', '                subplots = [view for view in self._subplots if view[axis] == coord]', '', '            # Shared categorical axes are broken on matplotlib<3.4.0.', '            # https://github.com/matplotlib/matplotlib/pull/18308', '            # This only affects us when sharing *paired* axes. This is a novel/niche', '            # behavior, so we will raise rather than hack together a workaround.', '            if axis is not None and Version(mpl.__version__) < Version(\"3.4.0\"):', '                from seaborn._core.scales import Nominal', '                paired_axis = axis in p._pair_spec.get(\"structure\", {})', '                cat_scale = isinstance(scale, Nominal)', '                ok_dim = {\"x\": \"col\", \"y\": \"row\"}[axis]', '                shared_axes = share_state not in [False, \"none\", ok_dim]', '                if paired_axis and cat_scale and shared_axes:', '                    err = \"Sharing paired categorical axes requires matplotlib>=3.4.0\"', '                    raise RuntimeError(err)', '', '            if scale is None:', '                self._scales[var] = Scale._identity()', '            else:', '                self._scales[var] = scale._setup(var_df[var], prop)', '', '            # Everything below here applies only to coordinate variables', \"            # We additionally skip it when we're working with a value\", \"            # that is derived from a coordinate we've already processed.\", '            # e.g., the Stat consumed y and added ymin/ymax. In that case,', \"            # we've already setup the y scale and ymin/max are in scale space.\", '            if axis is None or (var != coord and coord in p._variables):', '                continue', '', '            # Set up an empty series to receive the transformed values.', '            # We need this to handle piecemeal transforms of categories -> floats.', '            transformed_data = []', '            for layer in layers:', '                index = layer[\"data\"].frame.index', '                empty_series = pd.Series(dtype=float, index=index, name=var)', '                transformed_data.append(empty_series)', '', '            for view in subplots:', '', '                axis_obj = getattr(view[\"ax\"], f\"{axis}axis\")', '                seed_values = self._get_subplot_data(var_df, var, view, share_state)', '                view_scale = scale._setup(seed_values, prop, axis=axis_obj)', '                set_scale_obj(view[\"ax\"], axis, view_scale._matplotlib_scale)', '', '                for layer, new_series in zip(layers, transformed_data):', '                    layer_df = layer[\"data\"].frame', '                    if var in layer_df:', '                        idx = self._get_subplot_index(layer_df, view)', '                        new_series.loc[idx] = view_scale(layer_df.loc[idx, var])', '', '            # Now the transformed data series are complete, set update the layer data', '            for layer, new_series in zip(layers, transformed_data):', '                layer_df = layer[\"data\"].frame', '                if var in layer_df:', '                    layer_df[var] = new_series', '', '    def _plot_layer(self, p: Plot, layer: Layer) -> None:', '', '        data = layer[\"data\"]', '        mark = layer[\"mark\"]', '        move = layer[\"move\"]', '', '        default_grouping_vars = [\"col\", \"row\", \"group\"]  # TODO where best to define?', '        grouping_properties = [v for v in PROPERTIES if v[0] not in \"xy\"]', '', '        pair_variables = p._pair_spec.get(\"structure\", {})', '', '        for subplots, df, scales in self._generate_pairings(data, pair_variables):', '', '            orient = layer[\"orient\"] or mark._infer_orient(scales)', '', '            def get_order(var):', '                # Ignore order for x/y: they have been scaled to numeric indices,', '                # so any original order is no longer valid. Default ordering rules', '                # sorted unique numbers will correctly reconstruct intended order', '                # TODO This is tricky, make sure we add some tests for this', '                if var not in \"xy\" and var in scales:', '                    return getattr(scales[var], \"order\", None)', '', '            if \"width\" in mark._mappable_props:', '                width = mark._resolve(df, \"width\", None)', '            else:', '                width = 0.8 if \"width\" not in df else df[\"width\"]  # TODO what default?', '            if orient in df:', '                df[\"width\"] = width * scales[orient]._spacing(df[orient])', '', '            if \"baseline\" in mark._mappable_props:', '                # TODO what marks should have this?', '                # If we can set baseline with, e.g., Bar(), then the', '                # \"other\" (e.g. y for x oriented bars) parameterization', '                # is somewhat ambiguous.', '                baseline = mark._resolve(df, \"baseline\", None)', '            else:', '                # TODO unlike width, we might not want to add baseline to data', \"                # if the mark doesn't use it. Practically, there is a concern about\", '                # Mark abstraction like Area / Ribbon', '                baseline = 0 if \"baseline\" not in df else df[\"baseline\"]', '            df[\"baseline\"] = baseline', '', '            if move is not None:', '                moves = move if isinstance(move, list) else [move]', '                for move_step in moves:', '                    move_by = getattr(move_step, \"by\", None)', '                    if move_by is None:', '                        move_by = grouping_properties', '                    move_groupers = [*move_by, *default_grouping_vars]', '                    if move_step.group_by_orient:', '                        move_groupers.insert(0, orient)', '                    order = {var: get_order(var) for var in move_groupers}', '                    groupby = GroupBy(order)', '                    df = move_step(df, groupby, orient, scales)', '', '            df = self._unscale_coords(subplots, df, orient)', '', '            grouping_vars = mark._grouping_props + default_grouping_vars', '            split_generator = self._setup_split_generator(grouping_vars, df, subplots)', '', '            mark._plot(split_generator, scales, orient)', '', '        # TODO is this the right place for this?', '        for view in self._subplots:', '            view[\"ax\"].autoscale_view()', '', '        if layer[\"legend\"]:', '            self._update_legend_contents(p, mark, data, scales)', '', '    def _unscale_coords(', '        self, subplots: list[dict], df: DataFrame, orient: str,', '    ) -> DataFrame:', '        # TODO do we still have numbers in the variable name at this point?', '        coord_cols = [c for c in df if re.match(r\"^[xy]\\\\D*$\", str(c))]', '        drop_cols = [*coord_cols, \"width\"] if \"width\" in df else coord_cols', '        out_df = (', '            df', '            .drop(drop_cols, axis=1)', '            .reindex(df.columns, axis=1)  # So unscaled columns retain their place', '            .copy(deep=False)', '        )', '', '        for view in subplots:', '            view_df = self._filter_subplot_data(df, view)', '            axes_df = view_df[coord_cols]', '            for var, values in axes_df.items():', '', '                axis = getattr(view[\"ax\"], f\"{str(var)[0]}axis\")', '                # TODO see https://github.com/matplotlib/matplotlib/issues/22713', '                transform = axis.get_transform().inverted().transform', '                inverted = transform(values)', '                out_df.loc[values.index, str(var)] = inverted', '', '                if var == orient and \"width\" in view_df:', '                    width = view_df[\"width\"]', '                    out_df.loc[values.index, \"width\"] = (', '                        transform(values + width / 2) - transform(values - width / 2)', '                    )', '', '        return out_df', '', '    def _generate_pairings(', '        self, data: PlotData, pair_variables: dict,', '    ) -> Generator[', '        tuple[list[dict], DataFrame, dict[str, Scale]], None, None', '    ]:', '        # TODO retype return with subplot_spec or similar', '', '        iter_axes = itertools.product(*[', '            pair_variables.get(axis, [axis]) for axis in \"xy\"', '        ])', '', '        for x, y in iter_axes:', '', '            subplots = []', '            for view in self._subplots:', '                if (view[\"x\"] == x) and (view[\"y\"] == y):', '                    subplots.append(view)', '', '            if data.frame.empty and data.frames:', '                out_df = data.frames[(x, y)].copy()', '            elif not pair_variables:', '                out_df = data.frame.copy()', '            else:', '                if data.frame.empty and data.frames:', '                    out_df = data.frames[(x, y)].copy()', '                else:', '                    out_df = data.frame.copy()', '', '            scales = self._scales.copy()', '            if x in out_df:', '                scales[\"x\"] = self._scales[x]', '            if y in out_df:', '                scales[\"y\"] = self._scales[y]', '', '            for axis, var in zip(\"xy\", (x, y)):', '                if axis != var:', '                    out_df = out_df.rename(columns={var: axis})', '                    cols = [col for col in out_df if re.match(rf\"{axis}\\\\d+\", str(col))]', '                    out_df = out_df.drop(cols, axis=1)', '', '            yield subplots, out_df, scales', '', '    def _get_subplot_index(self, df: DataFrame, subplot: dict) -> Index:', '', '        dims = df.columns.intersection([\"col\", \"row\"])', '        if dims.empty:', '            return df.index', '', '        keep_rows = pd.Series(True, df.index, dtype=bool)', '        for dim in dims:', '            keep_rows &= df[dim] == subplot[dim]', '        return df.index[keep_rows]', '', '    def _filter_subplot_data(self, df: DataFrame, subplot: dict) -> DataFrame:', '        # TODO note redundancies with preceding function ... needs refactoring', '        dims = df.columns.intersection([\"col\", \"row\"])', '        if dims.empty:', '            return df', '', '        keep_rows = pd.Series(True, df.index, dtype=bool)', '        for dim in dims:', '            keep_rows &= df[dim] == subplot[dim]', '        return df[keep_rows]', '', '    def _setup_split_generator(', '        self, grouping_vars: list[str], df: DataFrame, subplots: list[dict[str, Any]],', '    ) -> Callable[[], Generator]:', '', '        allow_empty = False  # TODO will need to recreate previous categorical plots', '', '        grouping_keys = []', '        grouping_vars = [', '            v for v in grouping_vars if v in df and v not in [\"col\", \"row\"]', '        ]', '        for var in grouping_vars:', '            order = getattr(self._scales[var], \"order\", None)', '            if order is None:', '                order = categorical_order(df[var])', '            grouping_keys.append(order)', '', '        def split_generator(keep_na=False) -> Generator:', '', '            for view in subplots:', '', '                axes_df = self._filter_subplot_data(df, view)', '', '                with pd.option_context(\"mode.use_inf_as_null\", True):', '                    if keep_na:', '                        # The simpler thing to do would be x.dropna().reindex(x.index).', \"                        # But that doesn't work with the way that the subset iteration\", '                        # is written below, which assumes data for grouping vars.', '                        # Matplotlib (usually?) masks nan data, so this should \"work\".', '                        # Downstream code can also drop these rows, at some speed cost.', '                        present = axes_df.notna().all(axis=1)', '                        nulled = {}', '                        for axis in \"xy\":', '                            if axis in axes_df:', '                                nulled[axis] = axes_df[axis].where(present)', '                        axes_df = axes_df.assign(**nulled)', '                    else:', '                        axes_df = axes_df.dropna()', '', '                subplot_keys = {}', '                for dim in [\"col\", \"row\"]:', '                    if view[dim] is not None:', '                        subplot_keys[dim] = view[dim]', '', '                if not grouping_vars or not any(grouping_keys):', '                    yield subplot_keys, axes_df.copy(), view[\"ax\"]', '                    continue', '', '                grouped_df = axes_df.groupby(grouping_vars, sort=False, as_index=False)', '', '                for key in itertools.product(*grouping_keys):', '', '                    # Pandas fails with singleton tuple inputs', '                    pd_key = key[0] if len(key) == 1 else key', '', '                    try:', '                        df_subset = grouped_df.get_group(pd_key)', '                    except KeyError:', '                        # TODO (from initial work on categorical plots refactor)', '                        # We are adding this to allow backwards compatability', '                        # with the empty artists that old categorical plots would', '                        # add (before 0.12), which we may decide to break, in which', '                        # case this option could be removed', '                        df_subset = axes_df.loc[[]]', '', '                    if df_subset.empty and not allow_empty:', '                        continue', '', '                    sub_vars = dict(zip(grouping_vars, key))', '                    sub_vars.update(subplot_keys)', '', '                    # TODO need copy(deep=...) policy (here, above, anywhere else?)', '                    yield sub_vars, df_subset.copy(), view[\"ax\"]', '', '        return split_generator', '', '    def _update_legend_contents(', '        self,', '        p: Plot,', '        mark: Mark,', '        data: PlotData,', '        scales: dict[str, Scale],', '    ) -> None:', '        \"\"\"Add legend artists / labels for one layer in the plot.\"\"\"', '        if data.frame.empty and data.frames:', '            legend_vars: list[str] = []', '            for frame in data.frames.values():', '                frame_vars = frame.columns.intersection(list(scales))', '                legend_vars.extend(v for v in frame_vars if v not in legend_vars)', '        else:', '            legend_vars = list(data.frame.columns.intersection(list(scales)))', '', '        # First pass: Identify the values that will be shown for each variable', '        schema: list[tuple[', '            tuple[str, str | int], list[str], tuple[list, list[str]]', '        ]] = []', '        schema = []', '        for var in legend_vars:', '            var_legend = scales[var]._legend', '            if var_legend is not None:', '                values, labels = var_legend', '                for (_, part_id), part_vars, _ in schema:', '                    if data.ids[var] == part_id:', '                        # Allow multiple plot semantics to represent same data variable', '                        part_vars.append(var)', '                        break', '                else:', '                    title = self._resolve_label(p, var, data.names[var])', '                    entry = (title, data.ids[var]), [var], (values, labels)', '                    schema.append(entry)', '', '        # Second pass, generate an artist corresponding to each value', '        contents: list[tuple[tuple[str, str | int], Any, list[str]]] = []', '        for key, variables, (values, labels) in schema:', '            artists = []', '            for val in values:', '                artist = mark._legend_artist(variables, val, scales)', '                if artist is not None:', '                    artists.append(artist)', '            if artists:', '                contents.append((key, artists, labels))', '', '        self._legend_contents.extend(contents)', '', '    def _make_legend(self, p: Plot) -> None:', '        \"\"\"Create the legend artist(s) and add onto the figure.\"\"\"', '        # Combine artists representing same information across layers', '        # Input list has an entry for each distinct variable in each layer', '        # Output dict has an entry for each distinct variable', '        merged_contents: dict[', '            tuple[str, str | int], tuple[list[Artist], list[str]],', '        ] = {}', '        for key, new_artists, labels in self._legend_contents:', '            # Key is (name, id); we need the id to resolve variable uniqueness,', '            # but will need the name in the next step to title the legend', '            if key in merged_contents:', \"                # Copy so inplace updates don't propagate back to legend_contents\", '                existing_artists = merged_contents[key][0]', '                for i, artist in enumerate(existing_artists):', '                    # Matplotlib accepts a tuple of artists and will overlay them', '                    if isinstance(artist, tuple):', '                        artist += new_artists[i],', '                    else:', '                        existing_artists[i] = artist, new_artists[i]', '            else:', '                merged_contents[key] = new_artists.copy(), labels', '', '        # TODO explain', '        loc = \"center right\" if self._pyplot else \"center left\"', '', '        base_legend = None', '        for (name, _), (handles, labels) in merged_contents.items():', '', '            legend = mpl.legend.Legend(', '                self._figure,', '                handles,', '                labels,', '                title=name,', '                loc=loc,', '                bbox_to_anchor=(.98, .55),', '            )', '', '            if base_legend:', '                # Matplotlib has no public API for this so it is a bit of a hack.', \"                # Ideally we'd define our own legend class with more flexibility,\", '                # but that is a lot of work!', '                base_legend_box = base_legend.get_children()[0]', '                this_legend_box = legend.get_children()[0]', '                base_legend_box.get_children().extend(this_legend_box.get_children())', '            else:', '                base_legend = legend', '                self._figure.legends.append(legend)', '', '    def _finalize_figure(self, p: Plot) -> None:', '', '        for sub in self._subplots:', '            ax = sub[\"ax\"]', '            for axis in \"xy\":', '                axis_key = sub[axis]', '', '                # Axis limits', '                if axis_key in p._limits:', '                    convert_units = getattr(ax, f\"{axis}axis\").convert_units', '                    a, b = p._limits[axis_key]', '                    lo = a if a is None else convert_units(a)', '                    hi = b if b is None else convert_units(b)', '                    if isinstance(a, str):', '                        lo = cast(float, lo) - 0.5', '                    if isinstance(b, str):', '                        hi = cast(float, hi) + 0.5', '                    ax.set(**{f\"{axis}lim\": (lo, hi)})', '', '        engine_default = None if p._target is not None else \"tight\"', '        layout_engine = p._layout_spec.get(\"engine\", engine_default)', '        set_layout_engine(self._figure, layout_engine)']}, '__init__.py': {'classes': [], 'functions': [], 'text': []}, 'groupby.py': {'classes': [{'name': 'GroupBy', 'start_line': 16, 'end_line': 129, 'text': ['class GroupBy:', '    \"\"\"', '    Interface for Pandas GroupBy operations allowing specified group order.', '', '    Writing our own class to do this has a few advantages:', '    - It constrains the interface between Plot and Stat/Move objects', '    - It allows control over the row order of the GroupBy result, which is', '      important when using in the context of some Move operations (dodge, stack, ...)', '    - It simplifies some complexities regarding the return type and Index contents', '      one encounters with Pandas, especially for DataFrame -> DataFrame applies', '    - It increases future flexibility regarding alternate DataFrame libraries', '', '    \"\"\"', '    def __init__(self, order: list[str] | dict[str, list | None]):', '        \"\"\"', '        Initialize the GroupBy from grouping variables and optional level orders.', '', '        Parameters', '        ----------', '        order', '            List of variable names or dict mapping names to desired level orders.', '            Level order values can be None to use default ordering rules. The', '            variables can include names that are not expected to appear in the', '            data; these will be dropped before the groups are defined.', '', '        \"\"\"', '        if not order:', '            raise ValueError(\"GroupBy requires at least one grouping variable\")', '', '        if isinstance(order, list):', '            order = {k: None for k in order}', '        self.order = order', '', '    def _get_groups(', '        self, data: DataFrame', '    ) -> tuple[str | list[str], Index | MultiIndex]:', '        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"', '        levels = {}', '        for var, order in self.order.items():', '            if var in data:', '                if order is None:', '                    order = categorical_order(data[var])', '                levels[var] = order', '', '        grouper: str | list[str]', '        groups: Index | MultiIndex', '        if not levels:', '            grouper = []', '            groups = pd.Index([])', '        elif len(levels) > 1:', '            grouper = list(levels)', '            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)', '        else:', '            grouper, = list(levels)', '            groups = pd.Index(levels[grouper], name=grouper)', '        return grouper, groups', '', '    def _reorder_columns(self, res, data):', '        \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"', '        cols = [c for c in data if c in res]', '        cols += [c for c in res if c not in data]', '        return res.reindex(columns=pd.Index(cols))', '', '    def agg(self, data: DataFrame, *args, **kwargs) -> DataFrame:', '        \"\"\"', '        Reduce each group to a single row in the output.', '', '        The output will have a row for each unique combination of the grouping', '        variable levels with null values for the aggregated variable(s) where', '        those combinations do not appear in the dataset.', '', '        \"\"\"', '        grouper, groups = self._get_groups(data)', '', '        if not grouper:', '            # We will need to see whether there are valid usecases that end up here', '            raise ValueError(\"No grouping variables are present in dataframe\")', '', '        res = (', '            data', '            .groupby(grouper, sort=False, observed=True)', '            .agg(*args, **kwargs)', '            .reindex(groups)', '            .reset_index()', '            .pipe(self._reorder_columns, data)', '        )', '', '        return res', '', '    def apply(', '        self, data: DataFrame, func: Callable[..., DataFrame],', '        *args, **kwargs,', '    ) -> DataFrame:', '        \"\"\"Apply a DataFrame -> DataFrame mapping to each group.\"\"\"', '        grouper, groups = self._get_groups(data)', '', '        if not grouper:', '            return self._reorder_columns(func(data, *args, **kwargs), data)', '', '        parts = {}', '        for key, part_df in data.groupby(grouper, sort=False):', '            parts[key] = func(part_df, *args, **kwargs)', '        stack = []', '        for key in groups:', '            if key in parts:', '                if isinstance(grouper, list):', '                    # Implies that we had a MultiIndex so key is iterable', '                    group_ids = dict(zip(grouper, cast(Iterable, key)))', '                else:', '                    group_ids = {grouper: key}', '                stack.append(parts[key].assign(**group_ids))', '', '        res = pd.concat(stack, ignore_index=True)', '        return self._reorder_columns(res, data)'], 'methods': [{'name': '__init__', 'start_line': 29, 'end_line': 47, 'text': ['    def __init__(self, order: list[str] | dict[str, list | None]):', '        \"\"\"', '        Initialize the GroupBy from grouping variables and optional level orders.', '', '        Parameters', '        ----------', '        order', '            List of variable names or dict mapping names to desired level orders.', '            Level order values can be None to use default ordering rules. The', '            variables can include names that are not expected to appear in the', '            data; these will be dropped before the groups are defined.', '', '        \"\"\"', '        if not order:', '            raise ValueError(\"GroupBy requires at least one grouping variable\")', '', '        if isinstance(order, list):', '            order = {k: None for k in order}', '        self.order = order']}, {'name': '_get_groups', 'start_line': 49, 'end_line': 71, 'text': ['    def _get_groups(', '        self, data: DataFrame', '    ) -> tuple[str | list[str], Index | MultiIndex]:', '        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"', '        levels = {}', '        for var, order in self.order.items():', '            if var in data:', '                if order is None:', '                    order = categorical_order(data[var])', '                levels[var] = order', '', '        grouper: str | list[str]', '        groups: Index | MultiIndex', '        if not levels:', '            grouper = []', '            groups = pd.Index([])', '        elif len(levels) > 1:', '            grouper = list(levels)', '            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)', '        else:', '            grouper, = list(levels)', '            groups = pd.Index(levels[grouper], name=grouper)', '        return grouper, groups']}, {'name': '_reorder_columns', 'start_line': 73, 'end_line': 77, 'text': ['    def _reorder_columns(self, res, data):', '        \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"', '        cols = [c for c in data if c in res]', '        cols += [c for c in res if c not in data]', '        return res.reindex(columns=pd.Index(cols))']}, {'name': 'agg', 'start_line': 79, 'end_line': 103, 'text': ['    def agg(self, data: DataFrame, *args, **kwargs) -> DataFrame:', '        \"\"\"', '        Reduce each group to a single row in the output.', '', '        The output will have a row for each unique combination of the grouping', '        variable levels with null values for the aggregated variable(s) where', '        those combinations do not appear in the dataset.', '', '        \"\"\"', '        grouper, groups = self._get_groups(data)', '', '        if not grouper:', '            # We will need to see whether there are valid usecases that end up here', '            raise ValueError(\"No grouping variables are present in dataframe\")', '', '        res = (', '            data', '            .groupby(grouper, sort=False, observed=True)', '            .agg(*args, **kwargs)', '            .reindex(groups)', '            .reset_index()', '            .pipe(self._reorder_columns, data)', '        )', '', '        return res']}, {'name': 'apply', 'start_line': 105, 'end_line': 129, 'text': ['    def apply(', '        self, data: DataFrame, func: Callable[..., DataFrame],', '        *args, **kwargs,', '    ) -> DataFrame:', '        \"\"\"Apply a DataFrame -> DataFrame mapping to each group.\"\"\"', '        grouper, groups = self._get_groups(data)', '', '        if not grouper:', '            return self._reorder_columns(func(data, *args, **kwargs), data)', '', '        parts = {}', '        for key, part_df in data.groupby(grouper, sort=False):', '            parts[key] = func(part_df, *args, **kwargs)', '        stack = []', '        for key in groups:', '            if key in parts:', '                if isinstance(grouper, list):', '                    # Implies that we had a MultiIndex so key is iterable', '                    group_ids = dict(zip(grouper, cast(Iterable, key)))', '                else:', '                    group_ids = {grouper: key}', '                stack.append(parts[key].assign(**group_ids))', '', '        res = pd.concat(stack, ignore_index=True)', '        return self._reorder_columns(res, data)']}]}], 'functions': [], 'text': ['\"\"\"Simplified split-apply-combine paradigm on dataframes for internal use.\"\"\"', 'from __future__ import annotations', '', 'from typing import cast, Iterable', '', 'import pandas as pd', '', 'from seaborn._core.rules import categorical_order', '', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:', '    from typing import Callable', '    from pandas import DataFrame, MultiIndex, Index', '', '', 'class GroupBy:', '    \"\"\"', '    Interface for Pandas GroupBy operations allowing specified group order.', '', '    Writing our own class to do this has a few advantages:', '    - It constrains the interface between Plot and Stat/Move objects', '    - It allows control over the row order of the GroupBy result, which is', '      important when using in the context of some Move operations (dodge, stack, ...)', '    - It simplifies some complexities regarding the return type and Index contents', '      one encounters with Pandas, especially for DataFrame -> DataFrame applies', '    - It increases future flexibility regarding alternate DataFrame libraries', '', '    \"\"\"', '    def __init__(self, order: list[str] | dict[str, list | None]):', '        \"\"\"', '        Initialize the GroupBy from grouping variables and optional level orders.', '', '        Parameters', '        ----------', '        order', '            List of variable names or dict mapping names to desired level orders.', '            Level order values can be None to use default ordering rules. The', '            variables can include names that are not expected to appear in the', '            data; these will be dropped before the groups are defined.', '', '        \"\"\"', '        if not order:', '            raise ValueError(\"GroupBy requires at least one grouping variable\")', '', '        if isinstance(order, list):', '            order = {k: None for k in order}', '        self.order = order', '', '    def _get_groups(', '        self, data: DataFrame', '    ) -> tuple[str | list[str], Index | MultiIndex]:', '        \"\"\"Return index with Cartesian product of ordered grouping variable levels.\"\"\"', '        levels = {}', '        for var, order in self.order.items():', '            if var in data:', '                if order is None:', '                    order = categorical_order(data[var])', '                levels[var] = order', '', '        grouper: str | list[str]', '        groups: Index | MultiIndex', '        if not levels:', '            grouper = []', '            groups = pd.Index([])', '        elif len(levels) > 1:', '            grouper = list(levels)', '            groups = pd.MultiIndex.from_product(levels.values(), names=grouper)', '        else:', '            grouper, = list(levels)', '            groups = pd.Index(levels[grouper], name=grouper)', '        return grouper, groups', '', '    def _reorder_columns(self, res, data):', '        \"\"\"Reorder result columns to match original order with new columns appended.\"\"\"', '        cols = [c for c in data if c in res]', '        cols += [c for c in res if c not in data]', '        return res.reindex(columns=pd.Index(cols))', '', '    def agg(self, data: DataFrame, *args, **kwargs) -> DataFrame:', '        \"\"\"', '        Reduce each group to a single row in the output.', '', '        The output will have a row for each unique combination of the grouping', '        variable levels with null values for the aggregated variable(s) where', '        those combinations do not appear in the dataset.', '', '        \"\"\"', '        grouper, groups = self._get_groups(data)', '', '        if not grouper:', '            # We will need to see whether there are valid usecases that end up here', '            raise ValueError(\"No grouping variables are present in dataframe\")', '', '        res = (', '            data', '            .groupby(grouper, sort=False, observed=True)', '            .agg(*args, **kwargs)', '            .reindex(groups)', '            .reset_index()', '            .pipe(self._reorder_columns, data)', '        )', '', '        return res', '', '    def apply(', '        self, data: DataFrame, func: Callable[..., DataFrame],', '        *args, **kwargs,', '    ) -> DataFrame:', '        \"\"\"Apply a DataFrame -> DataFrame mapping to each group.\"\"\"', '        grouper, groups = self._get_groups(data)', '', '        if not grouper:', '            return self._reorder_columns(func(data, *args, **kwargs), data)', '', '        parts = {}', '        for key, part_df in data.groupby(grouper, sort=False):', '            parts[key] = func(part_df, *args, **kwargs)', '        stack = []', '        for key in groups:', '            if key in parts:', '                if isinstance(grouper, list):', '                    # Implies that we had a MultiIndex so key is iterable', '                    group_ids = dict(zip(grouper, cast(Iterable, key)))', '                else:', '                    group_ids = {grouper: key}', '                stack.append(parts[key].assign(**group_ids))', '', '        res = pd.concat(stack, ignore_index=True)', '        return self._reorder_columns(res, data)']}, 'properties.py': {'classes': [{'name': 'Property', 'start_line': 47, 'end_line': 140, 'text': ['class Property:', '    \"\"\"Base class for visual properties that can be set directly or be data scaling.\"\"\"', '', '    # When True, scales for this property will populate the legend by default', '    legend = False', '', '    # When True, scales for this property normalize data to [0, 1] before mapping', '    normed = False', '', '    def __init__(self, variable: str | None = None):', '        \"\"\"Initialize the property with the name of the corresponding plot variable.\"\"\"', '        if not variable:', '            variable = self.__class__.__name__.lower()', '        self.variable = variable', '', '    def default_scale(self, data: Series) -> Scale:', '        \"\"\"Given data, initialize appropriate scale class.\"\"\"', '        # TODO allow variable_type to be \"boolean\" if that\\'s a scale?', '        # TODO how will this handle data with units that can be treated as numeric', '        # if passed through a registered matplotlib converter?', '        var_type = variable_type(data, boolean_type=\"numeric\")', '        if var_type == \"numeric\":', '            return Continuous()', '        elif var_type == \"datetime\":', '            return Temporal()', '        # TODO others', '        # time-based (TimeStamp, TimeDelta, Period)', '        # boolean scale?', '        else:', '            return Nominal()', '', '    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '        # TODO put these somewhere external for validation', \"        # TODO putting this here won't pick it up if subclasses define infer_scale\", '        # (e.g. color). How best to handle that? One option is to call super after', '        # handling property-specific possibilities (e.g. for color check that the', '        # arg is not a valid palette name) but that could get tricky.', '        trans_args = [\"log\", \"symlog\", \"logit\", \"pow\", \"sqrt\"]', '        if isinstance(arg, str):', '            if any(arg.startswith(k) for k in trans_args):', '                # TODO validate numeric type? That should happen centrally somewhere', '                return Continuous(trans=arg)', '            else:', '                msg = f\"Unknown magic arg for {self.variable} scale: \\'{arg}\\'.\"', '                raise ValueError(msg)', '        else:', '            arg_type = type(arg).__name__', '            msg = f\"Magic arg for {self.variable} scale must be str, not {arg_type}.\"', '            raise TypeError(msg)', '', '    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to property range.\"\"\"', '        def identity(x):', '            return x', '        return identity', '', '    def standardize(self, val: Any) -> Any:', '        \"\"\"Coerce flexible property value to standardized representation.\"\"\"', '        return val', '', '    def _check_dict_entries(self, levels: list, values: dict) -> None:', '        \"\"\"Input check when values are provided as a dictionary.\"\"\"', '        missing = set(levels) - set(values)', '        if missing:', '            formatted = \", \".join(map(repr, sorted(missing, key=str)))', '            err = f\"No entry in {self.variable} dictionary for {formatted}\"', '            raise ValueError(err)', '', '    def _check_list_length(self, levels: list, values: list) -> list:', '        \"\"\"Input check when values are provided as a list.\"\"\"', '        message = \"\"', '        if len(levels) > len(values):', '            message = \" \".join([', '                f\"\\\\nThe {self.variable} list has fewer values ({len(values)})\",', '                f\"than needed ({len(levels)}) and will cycle, which may\",', '                \"produce an uninterpretable plot.\"', '            ])', '            values = [x for _, x in zip(levels, itertools.cycle(values))]', '', '        elif len(values) > len(levels):', '            message = \" \".join([', '                f\"The {self.variable} list has more values ({len(values)})\",', '                f\"than needed ({len(levels)}), which may not be intended.\",', '            ])', '            values = values[:len(levels)]', '', '        # TODO look into custom PlotSpecWarning with better formatting', '        if message:', '            warnings.warn(message, UserWarning)', '', '        return values'], 'methods': [{'name': '__init__', 'start_line': 56, 'end_line': 60, 'text': ['    def __init__(self, variable: str | None = None):', '        \"\"\"Initialize the property with the name of the corresponding plot variable.\"\"\"', '        if not variable:', '            variable = self.__class__.__name__.lower()', '        self.variable = variable']}, {'name': 'default_scale', 'start_line': 62, 'end_line': 76, 'text': ['    def default_scale(self, data: Series) -> Scale:', '        \"\"\"Given data, initialize appropriate scale class.\"\"\"', '        # TODO allow variable_type to be \"boolean\" if that\\'s a scale?', '        # TODO how will this handle data with units that can be treated as numeric', '        # if passed through a registered matplotlib converter?', '        var_type = variable_type(data, boolean_type=\"numeric\")', '        if var_type == \"numeric\":', '            return Continuous()', '        elif var_type == \"datetime\":', '            return Temporal()', '        # TODO others', '        # time-based (TimeStamp, TimeDelta, Period)', '        # boolean scale?', '        else:', '            return Nominal()']}, {'name': 'infer_scale', 'start_line': 78, 'end_line': 96, 'text': ['    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '        # TODO put these somewhere external for validation', \"        # TODO putting this here won't pick it up if subclasses define infer_scale\", '        # (e.g. color). How best to handle that? One option is to call super after', '        # handling property-specific possibilities (e.g. for color check that the', '        # arg is not a valid palette name) but that could get tricky.', '        trans_args = [\"log\", \"symlog\", \"logit\", \"pow\", \"sqrt\"]', '        if isinstance(arg, str):', '            if any(arg.startswith(k) for k in trans_args):', '                # TODO validate numeric type? That should happen centrally somewhere', '                return Continuous(trans=arg)', '            else:', '                msg = f\"Unknown magic arg for {self.variable} scale: \\'{arg}\\'.\"', '                raise ValueError(msg)', '        else:', '            arg_type = type(arg).__name__', '            msg = f\"Magic arg for {self.variable} scale must be str, not {arg_type}.\"', '            raise TypeError(msg)']}, {'name': 'get_mapping', 'start_line': 98, 'end_line': 104, 'text': ['    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to property range.\"\"\"', '        def identity(x):', '            return x', '        return identity']}, {'name': 'standardize', 'start_line': 106, 'end_line': 108, 'text': ['    def standardize(self, val: Any) -> Any:', '        \"\"\"Coerce flexible property value to standardized representation.\"\"\"', '        return val']}, {'name': '_check_dict_entries', 'start_line': 110, 'end_line': 116, 'text': ['    def _check_dict_entries(self, levels: list, values: dict) -> None:', '        \"\"\"Input check when values are provided as a dictionary.\"\"\"', '        missing = set(levels) - set(values)', '        if missing:', '            formatted = \", \".join(map(repr, sorted(missing, key=str)))', '            err = f\"No entry in {self.variable} dictionary for {formatted}\"', '            raise ValueError(err)']}, {'name': '_check_list_length', 'start_line': 118, 'end_line': 140, 'text': ['    def _check_list_length(self, levels: list, values: list) -> list:', '        \"\"\"Input check when values are provided as a list.\"\"\"', '        message = \"\"', '        if len(levels) > len(values):', '            message = \" \".join([', '                f\"\\\\nThe {self.variable} list has fewer values ({len(values)})\",', '                f\"than needed ({len(levels)}) and will cycle, which may\",', '                \"produce an uninterpretable plot.\"', '            ])', '            values = [x for _, x in zip(levels, itertools.cycle(values))]', '', '        elif len(values) > len(levels):', '            message = \" \".join([', '                f\"The {self.variable} list has more values ({len(values)})\",', '                f\"than needed ({len(levels)}), which may not be intended.\",', '            ])', '            values = values[:len(levels)]', '', '        # TODO look into custom PlotSpecWarning with better formatting', '        if message:', '            warnings.warn(message, UserWarning)', '', '        return values']}]}, {'name': 'Coordinate', 'start_line': 148, 'end_line': 151, 'text': ['class Coordinate(Property):', '    \"\"\"The position of visual marks with respect to the axes of the plot.\"\"\"', '    legend = False', '    normed = False'], 'methods': []}, {'name': 'IntervalProperty', 'start_line': 159, 'end_line': 256, 'text': ['class IntervalProperty(Property):', '    \"\"\"A numeric property where scale range can be defined as an interval.\"\"\"', '    legend = True', '    normed = True', '', '    _default_range: tuple[float, float] = (0, 1)', '', '    @property', '    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        return self._default_range', '', '    def _forward(self, values: ArrayLike) -> ArrayLike:', '        \"\"\"Transform applied to native values before linear mapping into interval.\"\"\"', '        return values', '', '    def _inverse(self, values: ArrayLike) -> ArrayLike:', '        \"\"\"Transform applied to results of mapping that returns to native values.\"\"\"', '        return values', '', '    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '', '        # TODO infer continuous based on log/sqrt etc?', '', '        if isinstance(arg, (list, dict)):', '            return Nominal(arg)', '        elif variable_type(data) == \"categorical\":', '            return Nominal(arg)', '        elif variable_type(data) == \"datetime\":', '            return Temporal(arg)', '        # TODO other variable types', '        else:', '            return Continuous(arg)', '', '    def get_mapping(', '        self, scale: Scale, data: ArrayLike', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to property range.\"\"\"', '        if isinstance(scale, Nominal):', '            return self._get_categorical_mapping(scale, data)', '', '        if scale.values is None:', '            vmin, vmax = self._forward(self.default_range)', '        elif isinstance(scale.values, tuple) and len(scale.values) == 2:', '            vmin, vmax = self._forward(scale.values)', '        else:', '            if isinstance(scale.values, tuple):', '                actual = f\"{len(scale.values)}-tuple\"', '            else:', '                actual = str(type(scale.values))', '            scale_class = scale.__class__.__name__', '            err = \" \".join([', '                f\"Values for {self.variable} variables with {scale_class} scale\",', '                f\"must be 2-tuple; not {actual}.\",', '            ])', '            raise TypeError(err)', '', '        def mapping(x):', '            return self._inverse(np.multiply(x, vmax - vmin) + vmin)', '', '        return mapping', '', '    def _get_categorical_mapping(', '        self, scale: Nominal, data: ArrayLike', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Identify evenly-spaced values using interval or explicit mapping.\"\"\"', '        levels = categorical_order(data, scale.order)', '', '        if isinstance(scale.values, dict):', '            self._check_dict_entries(levels, scale.values)', '            values = [scale.values[x] for x in levels]', '        elif isinstance(scale.values, list):', '            values = self._check_list_length(levels, scale.values)', '        else:', '            if scale.values is None:', '                vmin, vmax = self.default_range', '            elif isinstance(scale.values, tuple):', '                vmin, vmax = scale.values', '            else:', '                scale_class = scale.__class__.__name__', '                err = \" \".join([', '                    f\"Values for {self.variable} variables with {scale_class} scale\",', '                    f\"must be a dict, list or tuple; not {type(scale.values)}\",', '                ])', '                raise TypeError(err)', '', '            vmin, vmax = self._forward([vmin, vmax])', '            values = self._inverse(np.linspace(vmax, vmin, len(levels)))', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            out = np.full(len(x), np.nan)', '            use = np.isfinite(x)', '            out[use] = np.take(values, ixs[use])', '            return out', '', '        return mapping'], 'methods': [{'name': 'default_range', 'start_line': 167, 'end_line': 169, 'text': ['    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        return self._default_range']}, {'name': '_forward', 'start_line': 171, 'end_line': 173, 'text': ['    def _forward(self, values: ArrayLike) -> ArrayLike:', '        \"\"\"Transform applied to native values before linear mapping into interval.\"\"\"', '        return values']}, {'name': '_inverse', 'start_line': 175, 'end_line': 177, 'text': ['    def _inverse(self, values: ArrayLike) -> ArrayLike:', '        \"\"\"Transform applied to results of mapping that returns to native values.\"\"\"', '        return values']}, {'name': 'infer_scale', 'start_line': 179, 'end_line': 192, 'text': ['    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '', '        # TODO infer continuous based on log/sqrt etc?', '', '        if isinstance(arg, (list, dict)):', '            return Nominal(arg)', '        elif variable_type(data) == \"categorical\":', '            return Nominal(arg)', '        elif variable_type(data) == \"datetime\":', '            return Temporal(arg)', '        # TODO other variable types', '        else:', '            return Continuous(arg)']}, {'name': 'get_mapping', 'start_line': 194, 'end_line': 220, 'text': ['    def get_mapping(', '        self, scale: Scale, data: ArrayLike', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to property range.\"\"\"', '        if isinstance(scale, Nominal):', '            return self._get_categorical_mapping(scale, data)', '', '        if scale.values is None:', '            vmin, vmax = self._forward(self.default_range)', '        elif isinstance(scale.values, tuple) and len(scale.values) == 2:', '            vmin, vmax = self._forward(scale.values)', '        else:', '            if isinstance(scale.values, tuple):', '                actual = f\"{len(scale.values)}-tuple\"', '            else:', '                actual = str(type(scale.values))', '            scale_class = scale.__class__.__name__', '            err = \" \".join([', '                f\"Values for {self.variable} variables with {scale_class} scale\",', '                f\"must be 2-tuple; not {actual}.\",', '            ])', '            raise TypeError(err)', '', '        def mapping(x):', '            return self._inverse(np.multiply(x, vmax - vmin) + vmin)', '', '        return mapping']}, {'name': '_get_categorical_mapping', 'start_line': 222, 'end_line': 256, 'text': ['    def _get_categorical_mapping(', '        self, scale: Nominal, data: ArrayLike', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Identify evenly-spaced values using interval or explicit mapping.\"\"\"', '        levels = categorical_order(data, scale.order)', '', '        if isinstance(scale.values, dict):', '            self._check_dict_entries(levels, scale.values)', '            values = [scale.values[x] for x in levels]', '        elif isinstance(scale.values, list):', '            values = self._check_list_length(levels, scale.values)', '        else:', '            if scale.values is None:', '                vmin, vmax = self.default_range', '            elif isinstance(scale.values, tuple):', '                vmin, vmax = scale.values', '            else:', '                scale_class = scale.__class__.__name__', '                err = \" \".join([', '                    f\"Values for {self.variable} variables with {scale_class} scale\",', '                    f\"must be a dict, list or tuple; not {type(scale.values)}\",', '                ])', '                raise TypeError(err)', '', '            vmin, vmax = self._forward([vmin, vmax])', '            values = self._inverse(np.linspace(vmax, vmin, len(levels)))', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            out = np.full(len(x), np.nan)', '            use = np.isfinite(x)', '            out[use] = np.take(values, ixs[use])', '            return out', '', '        return mapping']}]}, {'name': 'PointSize', 'start_line': 259, 'end_line': 269, 'text': ['class PointSize(IntervalProperty):', '    \"\"\"Size (diameter) of a point mark, in points, with scaling by area.\"\"\"', '    _default_range = 2, 8  # TODO use rcparams?', '', '    def _forward(self, values):', '        \"\"\"Square native values to implement linear scaling of point area.\"\"\"', '        return np.square(values)', '', '    def _inverse(self, values):', '        \"\"\"Invert areal values back to point diameter.\"\"\"', '        return np.sqrt(values)'], 'methods': [{'name': '_forward', 'start_line': 263, 'end_line': 265, 'text': ['    def _forward(self, values):', '        \"\"\"Square native values to implement linear scaling of point area.\"\"\"', '        return np.square(values)']}, {'name': '_inverse', 'start_line': 267, 'end_line': 269, 'text': ['    def _inverse(self, values):', '        \"\"\"Invert areal values back to point diameter.\"\"\"', '        return np.sqrt(values)']}]}, {'name': 'LineWidth', 'start_line': 272, 'end_line': 278, 'text': ['class LineWidth(IntervalProperty):', '    \"\"\"Thickness of a line mark, in points.\"\"\"', '    @property', '    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"lines.linewidth\"]', '        return base * .5, base * 2'], 'methods': [{'name': 'default_range', 'start_line': 275, 'end_line': 278, 'text': ['    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"lines.linewidth\"]', '        return base * .5, base * 2']}]}, {'name': 'EdgeWidth', 'start_line': 281, 'end_line': 287, 'text': ['class EdgeWidth(IntervalProperty):', '    \"\"\"Thickness of the edges on a patch mark, in points.\"\"\"', '    @property', '    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"patch.linewidth\"]', '        return base * .5, base * 2'], 'methods': [{'name': 'default_range', 'start_line': 284, 'end_line': 287, 'text': ['    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"patch.linewidth\"]', '        return base * .5, base * 2']}]}, {'name': 'Stroke', 'start_line': 290, 'end_line': 292, 'text': ['class Stroke(IntervalProperty):', '    \"\"\"Thickness of lines that define point glyphs.\"\"\"', '    _default_range = .25, 2.5'], 'methods': []}, {'name': 'Alpha', 'start_line': 295, 'end_line': 297, 'text': ['class Alpha(IntervalProperty):', '    \"\"\"Opacity of the color values for an arbitrary mark.\"\"\"', '    _default_range = .3, .95'], 'methods': []}, {'name': 'Offset', 'start_line': 301, 'end_line': 304, 'text': ['class Offset(IntervalProperty):', '    \"\"\"Offset for edge-aligned text, in point units.\"\"\"', '    _default_range = 0, 5', '    _legend = False'], 'methods': []}, {'name': 'FontSize', 'start_line': 307, 'end_line': 315, 'text': ['class FontSize(IntervalProperty):', '    \"\"\"Font size for textual marks, in points.\"\"\"', '    _legend = False', '', '    @property', '    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"font.size\"]', '        return base * .5, base * 2'], 'methods': [{'name': 'default_range', 'start_line': 312, 'end_line': 315, 'text': ['    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"font.size\"]', '        return base * .5, base * 2']}]}, {'name': 'ObjectProperty', 'start_line': 323, 'end_line': 372, 'text': ['class ObjectProperty(Property):', '    \"\"\"A property defined by arbitrary an object, with inherently nominal scaling.\"\"\"', '    legend = True', '    normed = False', '', '    # Object representing null data, should appear invisible when drawn by matplotlib', '    # Note that we now drop nulls in Plot._plot_layer and thus may not need this', '    null_value: Any = None', '', '    def _default_values(self, n: int) -> list:', '        raise NotImplementedError()', '', '    def default_scale(self, data: Series) -> Nominal:', '        return Nominal()', '', '    def infer_scale(self, arg: Any, data: Series) -> Nominal:', '        return Nominal(arg)', '', '    def get_mapping(', '        self, scale: Scale, data: Series,', '    ) -> Callable[[ArrayLike], list]:', '        \"\"\"Define mapping as lookup into list of object values.\"\"\"', '        order = getattr(scale, \"order\", None)', '        levels = categorical_order(data, order)', '        n = len(levels)', '', '        if isinstance(scale.values, dict):', '            self._check_dict_entries(levels, scale.values)', '            values = [scale.values[x] for x in levels]', '        elif isinstance(scale.values, list):', '            values = self._check_list_length(levels, scale.values)', '        elif scale.values is None:', '            values = self._default_values(n)', '        else:', '            msg = \" \".join([', '                f\"Scale values for a {self.variable} variable must be provided\",', '                f\"in a dict or list; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        values = [self.standardize(x) for x in values]', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            return [', '                values[ix] if np.isfinite(x_i) else self.null_value', '                for x_i, ix in zip(x, ixs)', '            ]', '', '        return mapping'], 'methods': [{'name': '_default_values', 'start_line': 332, 'end_line': 333, 'text': ['    def _default_values(self, n: int) -> list:', '        raise NotImplementedError()']}, {'name': 'default_scale', 'start_line': 335, 'end_line': 336, 'text': ['    def default_scale(self, data: Series) -> Nominal:', '        return Nominal()']}, {'name': 'infer_scale', 'start_line': 338, 'end_line': 339, 'text': ['    def infer_scale(self, arg: Any, data: Series) -> Nominal:', '        return Nominal(arg)']}, {'name': 'get_mapping', 'start_line': 341, 'end_line': 372, 'text': ['    def get_mapping(', '        self, scale: Scale, data: Series,', '    ) -> Callable[[ArrayLike], list]:', '        \"\"\"Define mapping as lookup into list of object values.\"\"\"', '        order = getattr(scale, \"order\", None)', '        levels = categorical_order(data, order)', '        n = len(levels)', '', '        if isinstance(scale.values, dict):', '            self._check_dict_entries(levels, scale.values)', '            values = [scale.values[x] for x in levels]', '        elif isinstance(scale.values, list):', '            values = self._check_list_length(levels, scale.values)', '        elif scale.values is None:', '            values = self._default_values(n)', '        else:', '            msg = \" \".join([', '                f\"Scale values for a {self.variable} variable must be provided\",', '                f\"in a dict or list; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        values = [self.standardize(x) for x in values]', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            return [', '                values[ix] if np.isfinite(x_i) else self.null_value', '                for x_i, ix in zip(x, ixs)', '            ]', '', '        return mapping']}]}, {'name': 'Marker', 'start_line': 375, 'end_line': 416, 'text': ['class Marker(ObjectProperty):', '    \"\"\"Shape of points in scatter-type marks or lines with data points marked.\"\"\"', '    null_value = MarkerStyle(\"\")', '', '    # TODO should we have named marker \"palettes\"? (e.g. see d3 options)', '', '    # TODO need some sort of \"require_scale\" functionality', '    # to raise when we get the wrong kind explicitly specified', '', '    def standardize(self, val: MarkerPattern) -> MarkerStyle:', '        return MarkerStyle(val)', '', '    def _default_values(self, n: int) -> list[MarkerStyle]:', '        \"\"\"Build an arbitrarily long list of unique marker styles.', '', '        Parameters', '        ----------', '        n : int', '            Number of unique marker specs to generate.', '', '        Returns', '        -------', '        markers : list of string or tuples', '            Values for defining :class:`matplotlib.markers.MarkerStyle` objects.', '            All markers will be filled.', '', '        \"\"\"', '        # Start with marker specs that are well distinguishable', '        markers = [', '            \"o\", \"X\", (4, 0, 45), \"P\", (4, 0, 0), (4, 1, 0), \"^\", (4, 1, 45), \"v\",', '        ]', '', '        # Now generate more from regular polygons of increasing order', '        s = 5', '        while len(markers) < n:', '            a = 360 / (s + 1) / 2', '            markers.extend([(s + 1, 1, a), (s + 1, 0, a), (s, 1, 0), (s, 0, 0)])', '            s += 1', '', '        markers = [MarkerStyle(m) for m in markers[:n]]', '', '        return markers'], 'methods': [{'name': 'standardize', 'start_line': 384, 'end_line': 385, 'text': ['    def standardize(self, val: MarkerPattern) -> MarkerStyle:', '        return MarkerStyle(val)']}, {'name': '_default_values', 'start_line': 387, 'end_line': 416, 'text': ['    def _default_values(self, n: int) -> list[MarkerStyle]:', '        \"\"\"Build an arbitrarily long list of unique marker styles.', '', '        Parameters', '        ----------', '        n : int', '            Number of unique marker specs to generate.', '', '        Returns', '        -------', '        markers : list of string or tuples', '            Values for defining :class:`matplotlib.markers.MarkerStyle` objects.', '            All markers will be filled.', '', '        \"\"\"', '        # Start with marker specs that are well distinguishable', '        markers = [', '            \"o\", \"X\", (4, 0, 45), \"P\", (4, 0, 0), (4, 1, 0), \"^\", (4, 1, 45), \"v\",', '        ]', '', '        # Now generate more from regular polygons of increasing order', '        s = 5', '        while len(markers) < n:', '            a = 360 / (s + 1) / 2', '            markers.extend([(s + 1, 1, a), (s + 1, 0, a), (s, 1, 0), (s, 0, 0)])', '            s += 1', '', '        markers = [MarkerStyle(m) for m in markers[:n]]', '', '        return markers']}]}, {'name': 'LineStyle', 'start_line': 419, 'end_line': 513, 'text': ['class LineStyle(ObjectProperty):', '    \"\"\"Dash pattern for line-type marks.\"\"\"', '    null_value = \"\"', '', '    def standardize(self, val: str | DashPattern) -> DashPatternWithOffset:', '        return self._get_dash_pattern(val)', '', '    def _default_values(self, n: int) -> list[DashPatternWithOffset]:', '        \"\"\"Build an arbitrarily long list of unique dash styles for lines.', '', '        Parameters', '        ----------', '        n : int', '            Number of unique dash specs to generate.', '', '        Returns', '        -------', '        dashes : list of strings or tuples', '            Valid arguments for the ``dashes`` parameter on', '            :class:`matplotlib.lines.Line2D`. The first spec is a solid', '            line (``\"\"``), the remainder are sequences of long and short', '            dashes.', '', '        \"\"\"', '        # Start with dash specs that are well distinguishable', '        dashes: list[str | DashPattern] = [', '            \"-\", (4, 1.5), (1, 1), (3, 1.25, 1.5, 1.25), (5, 1, 1, 1),', '        ]', '', '        # Now programmatically build as many as we need', '        p = 3', '        while len(dashes) < n:', '', '            # Take combinations of long and short dashes', '            a = itertools.combinations_with_replacement([3, 1.25], p)', '            b = itertools.combinations_with_replacement([4, 1], p)', '', '            # Interleave the combinations, reversing one of the streams', '            segment_list = itertools.chain(*zip(list(a)[1:-1][::-1], list(b)[1:-1]))', '', '            # Now insert the gaps', '            for segments in segment_list:', '                gap = min(segments)', '                spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))', '                dashes.append(spec)', '', '            p += 1', '', '        return [self._get_dash_pattern(x) for x in dashes]', '', '    @staticmethod', '    def _get_dash_pattern(style: str | DashPattern) -> DashPatternWithOffset:', '        \"\"\"Convert linestyle arguments to dash pattern with offset.\"\"\"', '        # Copied and modified from Matplotlib 3.4', '        # go from short hand -> full strings', '        ls_mapper = {\"-\": \"solid\", \"--\": \"dashed\", \"-.\": \"dashdot\", \":\": \"dotted\"}', '        if isinstance(style, str):', '            style = ls_mapper.get(style, style)', '            # un-dashed styles', '            if style in [\"solid\", \"none\", \"None\"]:', '                offset = 0', '                dashes = None', '            # dashed styles', '            elif style in [\"dashed\", \"dashdot\", \"dotted\"]:', '                offset = 0', '                dashes = tuple(mpl.rcParams[f\"lines.{style}_pattern\"])', '            else:', '                options = [*ls_mapper.values(), *ls_mapper.keys()]', '                msg = f\"Linestyle string must be one of {options}, not {repr(style)}.\"', '                raise ValueError(msg)', '', '        elif isinstance(style, tuple):', '            if len(style) > 1 and isinstance(style[1], tuple):', '                offset, dashes = style', '            elif len(style) > 1 and style[1] is None:', '                offset, dashes = style', '            else:', '                offset = 0', '                dashes = style', '        else:', '            val_type = type(style).__name__', '            msg = f\"Linestyle must be str or tuple, not {val_type}.\"', '            raise TypeError(msg)', '', '        # Normalize offset to be positive and shorter than the dash cycle', '        if dashes is not None:', '            try:', '                dsum = sum(dashes)', '            except TypeError as err:', '                msg = f\"Invalid dash pattern: {dashes}\"', '                raise TypeError(msg) from err', '            if dsum:', '                offset %= dsum', '', '        return offset, dashes'], 'methods': [{'name': 'standardize', 'start_line': 423, 'end_line': 424, 'text': ['    def standardize(self, val: str | DashPattern) -> DashPatternWithOffset:', '        return self._get_dash_pattern(val)']}, {'name': '_default_values', 'start_line': 426, 'end_line': 467, 'text': ['    def _default_values(self, n: int) -> list[DashPatternWithOffset]:', '        \"\"\"Build an arbitrarily long list of unique dash styles for lines.', '', '        Parameters', '        ----------', '        n : int', '            Number of unique dash specs to generate.', '', '        Returns', '        -------', '        dashes : list of strings or tuples', '            Valid arguments for the ``dashes`` parameter on', '            :class:`matplotlib.lines.Line2D`. The first spec is a solid', '            line (``\"\"``), the remainder are sequences of long and short', '            dashes.', '', '        \"\"\"', '        # Start with dash specs that are well distinguishable', '        dashes: list[str | DashPattern] = [', '            \"-\", (4, 1.5), (1, 1), (3, 1.25, 1.5, 1.25), (5, 1, 1, 1),', '        ]', '', '        # Now programmatically build as many as we need', '        p = 3', '        while len(dashes) < n:', '', '            # Take combinations of long and short dashes', '            a = itertools.combinations_with_replacement([3, 1.25], p)', '            b = itertools.combinations_with_replacement([4, 1], p)', '', '            # Interleave the combinations, reversing one of the streams', '            segment_list = itertools.chain(*zip(list(a)[1:-1][::-1], list(b)[1:-1]))', '', '            # Now insert the gaps', '            for segments in segment_list:', '                gap = min(segments)', '                spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))', '                dashes.append(spec)', '', '            p += 1', '', '        return [self._get_dash_pattern(x) for x in dashes]']}, {'name': '_get_dash_pattern', 'start_line': 470, 'end_line': 513, 'text': ['    def _get_dash_pattern(style: str | DashPattern) -> DashPatternWithOffset:', '        \"\"\"Convert linestyle arguments to dash pattern with offset.\"\"\"', '        # Copied and modified from Matplotlib 3.4', '        # go from short hand -> full strings', '        ls_mapper = {\"-\": \"solid\", \"--\": \"dashed\", \"-.\": \"dashdot\", \":\": \"dotted\"}', '        if isinstance(style, str):', '            style = ls_mapper.get(style, style)', '            # un-dashed styles', '            if style in [\"solid\", \"none\", \"None\"]:', '                offset = 0', '                dashes = None', '            # dashed styles', '            elif style in [\"dashed\", \"dashdot\", \"dotted\"]:', '                offset = 0', '                dashes = tuple(mpl.rcParams[f\"lines.{style}_pattern\"])', '            else:', '                options = [*ls_mapper.values(), *ls_mapper.keys()]', '                msg = f\"Linestyle string must be one of {options}, not {repr(style)}.\"', '                raise ValueError(msg)', '', '        elif isinstance(style, tuple):', '            if len(style) > 1 and isinstance(style[1], tuple):', '                offset, dashes = style', '            elif len(style) > 1 and style[1] is None:', '                offset, dashes = style', '            else:', '                offset = 0', '                dashes = style', '        else:', '            val_type = type(style).__name__', '            msg = f\"Linestyle must be str or tuple, not {val_type}.\"', '            raise TypeError(msg)', '', '        # Normalize offset to be positive and shorter than the dash cycle', '        if dashes is not None:', '            try:', '                dsum = sum(dashes)', '            except TypeError as err:', '                msg = f\"Invalid dash pattern: {dashes}\"', '                raise TypeError(msg) from err', '            if dsum:', '                offset %= dsum', '', '        return offset, dashes']}]}, {'name': 'TextAlignment', 'start_line': 516, 'end_line': 517, 'text': ['class TextAlignment(ObjectProperty):', '    legend = False'], 'methods': []}, {'name': 'HorizontalAlignment', 'start_line': 520, 'end_line': 524, 'text': ['class HorizontalAlignment(TextAlignment):', '', '    def _default_values(self, n: int) -> list:', '        vals = itertools.cycle([\"left\", \"right\"])', '        return [next(vals) for _ in range(n)]'], 'methods': [{'name': '_default_values', 'start_line': 522, 'end_line': 524, 'text': ['    def _default_values(self, n: int) -> list:', '        vals = itertools.cycle([\"left\", \"right\"])', '        return [next(vals) for _ in range(n)]']}]}, {'name': 'VerticalAlignment', 'start_line': 527, 'end_line': 531, 'text': ['class VerticalAlignment(TextAlignment):', '', '    def _default_values(self, n: int) -> list:', '        vals = itertools.cycle([\"top\", \"bottom\"])', '        return [next(vals) for _ in range(n)]'], 'methods': [{'name': '_default_values', 'start_line': 529, 'end_line': 531, 'text': ['    def _default_values(self, n: int) -> list:', '        vals = itertools.cycle([\"top\", \"bottom\"])', '        return [next(vals) for _ in range(n)]']}]}, {'name': 'Color', 'start_line': 539, 'end_line': 690, 'text': ['class Color(Property):', '    \"\"\"Color, as RGB(A), scalable with nominal palettes or continuous gradients.\"\"\"', '    legend = True', '    normed = True', '', '    def standardize(self, val: ColorSpec) -> RGBTuple | RGBATuple:', '        # Return color with alpha channel only if the input spec has it', '        # This is so that RGBA colors can override the Alpha property', '        if to_rgba(val) != to_rgba(val, 1):', '            return to_rgba(val)', '        else:', '            return to_rgb(val)', '', '    def _standardize_color_sequence(self, colors: ArrayLike) -> ArrayLike:', '        \"\"\"Convert color sequence to RGB(A) array, preserving but not adding alpha.\"\"\"', '        def has_alpha(x):', '            return to_rgba(x) != to_rgba(x, 1)', '', '        if isinstance(colors, np.ndarray):', '            needs_alpha = colors.shape[1] == 4', '        else:', '            needs_alpha = any(has_alpha(x) for x in colors)', '', '        if needs_alpha:', '            return to_rgba_array(colors)', '        else:', '            return to_rgba_array(colors)[:, :3]', '', '    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        # TODO when inferring Continuous without data, verify type', '', '        # TODO need to rethink the variable type system', '        # (e.g. boolean, ordered categories as Ordinal, etc)..', '        var_type = variable_type(data, boolean_type=\"categorical\")', '', '        if isinstance(arg, (dict, list)):', '            return Nominal(arg)', '', '        if isinstance(arg, tuple):', '            if var_type == \"categorical\":', '                # TODO It seems reasonable to allow a gradient mapping for nominal', '                # scale but it also feels \"technically\" wrong. Should this infer', '                # Ordinal with categorical data and, if so, verify orderedness?', '                return Nominal(arg)', '            return Continuous(arg)', '', '        if callable(arg):', '            return Continuous(arg)', '', '        # TODO Do we accept str like \"log\", \"pow\", etc. for semantics?', '', '        # TODO what about', '        # - Temporal? (i.e. datetime)', '        # - Boolean?', '', '        if not isinstance(arg, str):', '            msg = \" \".join([', '                f\"A single scale argument for {self.variable} variables must be\",', '                f\"a string, dict, tuple, list, or callable, not {type(arg)}.\"', '            ])', '            raise TypeError(msg)', '', '        if arg in QUAL_PALETTES:', '            return Nominal(arg)', '        elif var_type == \"numeric\":', '            return Continuous(arg)', '        # TODO implement scales for date variables and any others.', '        else:', '            return Nominal(arg)', '', '    def _get_categorical_mapping(self, scale, data):', '        \"\"\"Define mapping as lookup in list of discrete color values.\"\"\"', '        levels = categorical_order(data, scale.order)', '        n = len(levels)', '        values = scale.values', '', '        if isinstance(values, dict):', '            self._check_dict_entries(levels, values)', '            # TODO where to ensure that dict values have consistent representation?', '            colors = [values[x] for x in levels]', '        elif isinstance(values, list):', '            colors = self._check_list_length(levels, scale.values)', '        elif isinstance(values, tuple):', '            colors = blend_palette(values, n)', '        elif isinstance(values, str):', '            colors = color_palette(values, n)', '        elif values is None:', '            if n <= len(get_color_cycle()):', '                # Use current (global) default palette', '                colors = color_palette(n_colors=n)', '            else:', '                colors = color_palette(\"husl\", n)', '        else:', '            scale_class = scale.__class__.__name__', '            msg = \" \".join([', '                f\"Scale values for {self.variable} with a {scale_class} mapping\",', '                f\"must be string, list, tuple, or dict; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        # If color specified here has alpha channel, it will override alpha property', '        colors = self._standardize_color_sequence(colors)', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            use = np.isfinite(x)', '            out = np.full((len(ixs), colors.shape[1]), np.nan)', '            out[use] = np.take(colors, ixs[use], axis=0)', '            return out', '', '        return mapping', '', '    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to color values.\"\"\"', '        # TODO what is best way to do this conditional?', '        # Should it be class-based or should classes have behavioral attributes?', '        if isinstance(scale, Nominal):', '            return self._get_categorical_mapping(scale, data)', '', '        if scale.values is None:', '            # TODO Rethink best default continuous color gradient', '            mapping = color_palette(\"ch:\", as_cmap=True)', '        elif isinstance(scale.values, tuple):', '            # TODO blend_palette will strip alpha, but we should support', '            # interpolation on all four channels', '            mapping = blend_palette(scale.values, as_cmap=True)', '        elif isinstance(scale.values, str):', '            # TODO for matplotlib colormaps this will clip extremes, which is', '            # different from what using the named colormap directly would do', '            # This may or may not be desireable.', '            mapping = color_palette(scale.values, as_cmap=True)', '        elif callable(scale.values):', '            mapping = scale.values', '        else:', '            scale_class = scale.__class__.__name__', '            msg = \" \".join([', '                f\"Scale values for {self.variable} with a {scale_class} mapping\",', '                f\"must be string, tuple, or callable; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        def _mapping(x):', '            # Remove alpha channel so it does not override alpha property downstream', '            # TODO this will need to be more flexible to support RGBA tuples (see above)', '            invalid = ~np.isfinite(x)', '            out = mapping(x)[:, :3]', '            out[invalid] = np.nan', '            return out', '', '        return _mapping'], 'methods': [{'name': 'standardize', 'start_line': 544, 'end_line': 550, 'text': ['    def standardize(self, val: ColorSpec) -> RGBTuple | RGBATuple:', '        # Return color with alpha channel only if the input spec has it', '        # This is so that RGBA colors can override the Alpha property', '        if to_rgba(val) != to_rgba(val, 1):', '            return to_rgba(val)', '        else:', '            return to_rgb(val)']}, {'name': '_standardize_color_sequence', 'start_line': 552, 'end_line': 565, 'text': ['    def _standardize_color_sequence(self, colors: ArrayLike) -> ArrayLike:', '        \"\"\"Convert color sequence to RGB(A) array, preserving but not adding alpha.\"\"\"', '        def has_alpha(x):', '            return to_rgba(x) != to_rgba(x, 1)', '', '        if isinstance(colors, np.ndarray):', '            needs_alpha = colors.shape[1] == 4', '        else:', '            needs_alpha = any(has_alpha(x) for x in colors)', '', '        if needs_alpha:', '            return to_rgba_array(colors)', '        else:', '            return to_rgba_array(colors)[:, :3]']}, {'name': 'infer_scale', 'start_line': 567, 'end_line': 607, 'text': ['    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        # TODO when inferring Continuous without data, verify type', '', '        # TODO need to rethink the variable type system', '        # (e.g. boolean, ordered categories as Ordinal, etc)..', '        var_type = variable_type(data, boolean_type=\"categorical\")', '', '        if isinstance(arg, (dict, list)):', '            return Nominal(arg)', '', '        if isinstance(arg, tuple):', '            if var_type == \"categorical\":', '                # TODO It seems reasonable to allow a gradient mapping for nominal', '                # scale but it also feels \"technically\" wrong. Should this infer', '                # Ordinal with categorical data and, if so, verify orderedness?', '                return Nominal(arg)', '            return Continuous(arg)', '', '        if callable(arg):', '            return Continuous(arg)', '', '        # TODO Do we accept str like \"log\", \"pow\", etc. for semantics?', '', '        # TODO what about', '        # - Temporal? (i.e. datetime)', '        # - Boolean?', '', '        if not isinstance(arg, str):', '            msg = \" \".join([', '                f\"A single scale argument for {self.variable} variables must be\",', '                f\"a string, dict, tuple, list, or callable, not {type(arg)}.\"', '            ])', '            raise TypeError(msg)', '', '        if arg in QUAL_PALETTES:', '            return Nominal(arg)', '        elif var_type == \"numeric\":', '            return Continuous(arg)', '        # TODO implement scales for date variables and any others.', '        else:', '            return Nominal(arg)']}, {'name': '_get_categorical_mapping', 'start_line': 609, 'end_line': 649, 'text': ['    def _get_categorical_mapping(self, scale, data):', '        \"\"\"Define mapping as lookup in list of discrete color values.\"\"\"', '        levels = categorical_order(data, scale.order)', '        n = len(levels)', '        values = scale.values', '', '        if isinstance(values, dict):', '            self._check_dict_entries(levels, values)', '            # TODO where to ensure that dict values have consistent representation?', '            colors = [values[x] for x in levels]', '        elif isinstance(values, list):', '            colors = self._check_list_length(levels, scale.values)', '        elif isinstance(values, tuple):', '            colors = blend_palette(values, n)', '        elif isinstance(values, str):', '            colors = color_palette(values, n)', '        elif values is None:', '            if n <= len(get_color_cycle()):', '                # Use current (global) default palette', '                colors = color_palette(n_colors=n)', '            else:', '                colors = color_palette(\"husl\", n)', '        else:', '            scale_class = scale.__class__.__name__', '            msg = \" \".join([', '                f\"Scale values for {self.variable} with a {scale_class} mapping\",', '                f\"must be string, list, tuple, or dict; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        # If color specified here has alpha channel, it will override alpha property', '        colors = self._standardize_color_sequence(colors)', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            use = np.isfinite(x)', '            out = np.full((len(ixs), colors.shape[1]), np.nan)', '            out[use] = np.take(colors, ixs[use], axis=0)', '            return out', '', '        return mapping']}, {'name': 'get_mapping', 'start_line': 651, 'end_line': 690, 'text': ['    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to color values.\"\"\"', '        # TODO what is best way to do this conditional?', '        # Should it be class-based or should classes have behavioral attributes?', '        if isinstance(scale, Nominal):', '            return self._get_categorical_mapping(scale, data)', '', '        if scale.values is None:', '            # TODO Rethink best default continuous color gradient', '            mapping = color_palette(\"ch:\", as_cmap=True)', '        elif isinstance(scale.values, tuple):', '            # TODO blend_palette will strip alpha, but we should support', '            # interpolation on all four channels', '            mapping = blend_palette(scale.values, as_cmap=True)', '        elif isinstance(scale.values, str):', '            # TODO for matplotlib colormaps this will clip extremes, which is', '            # different from what using the named colormap directly would do', '            # This may or may not be desireable.', '            mapping = color_palette(scale.values, as_cmap=True)', '        elif callable(scale.values):', '            mapping = scale.values', '        else:', '            scale_class = scale.__class__.__name__', '            msg = \" \".join([', '                f\"Scale values for {self.variable} with a {scale_class} mapping\",', '                f\"must be string, tuple, or callable; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        def _mapping(x):', '            # Remove alpha channel so it does not override alpha property downstream', '            # TODO this will need to be more flexible to support RGBA tuples (see above)', '            invalid = ~np.isfinite(x)', '            out = mapping(x)[:, :3]', '            out[invalid] = np.nan', '            return out', '', '        return _mapping']}]}, {'name': 'Fill', 'start_line': 698, 'end_line': 762, 'text': ['class Fill(Property):', '    \"\"\"Boolean property of points/bars/patches that can be solid or outlined.\"\"\"', '    legend = True', '    normed = False', '', '    # TODO default to Nominal scale always?', '    # Actually this will just not work with Continuous (except 0/1), suggesting we need', '    # an abstraction for failing gracefully on bad Property <> Scale interactions', '', '    def standardize(self, val: Any) -> bool:', '        return bool(val)', '', '    def _default_values(self, n: int) -> list:', '        \"\"\"Return a list of n values, alternating True and False.\"\"\"', '        if n > 2:', '            msg = \" \".join([', '                f\"The variable assigned to {self.variable} has more than two levels,\",', '                f\"so {self.variable} values will cycle and may be uninterpretable\",', '            ])', '            # TODO fire in a \"nice\" way (see above)', '            warnings.warn(msg, UserWarning)', '        return [x for x, _ in zip(itertools.cycle([True, False]), range(n))]', '', '    def default_scale(self, data: Series) -> Nominal:', '        \"\"\"Given data, initialize appropriate scale class.\"\"\"', '        return Nominal()', '', '    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '        # TODO infer Boolean where possible?', '        return Nominal(arg)', '', '    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps each data value to True or False.\"\"\"', '        # TODO categorical_order is going to return [False, True] for booleans,', '        # and [0, 1] for binary, but the default values order is [True, False].', '        # We should special case this to handle it properly, or change', '        # categorical_order to not \"sort\" booleans. Note that we need to sync with', \"        # what's going to happen upstream in the scale, so we can't just do it here.\", '        order = getattr(scale, \"order\", None)', '        levels = categorical_order(data, order)', '', '        if isinstance(scale.values, list):', '            values = [bool(x) for x in scale.values]', '        elif isinstance(scale.values, dict):', '            values = [bool(scale.values[x]) for x in levels]', '        elif scale.values is None:', '            values = self._default_values(len(levels))', '        else:', '            msg = \" \".join([', '                f\"Scale values for {self.variable} must be passed in\",', '                f\"a list or dict; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            return [', '                values[ix] if np.isfinite(x_i) else False', '                for x_i, ix in zip(x, ixs)', '            ]', '', '        return mapping'], 'methods': [{'name': 'standardize', 'start_line': 707, 'end_line': 708, 'text': ['    def standardize(self, val: Any) -> bool:', '        return bool(val)']}, {'name': '_default_values', 'start_line': 710, 'end_line': 719, 'text': ['    def _default_values(self, n: int) -> list:', '        \"\"\"Return a list of n values, alternating True and False.\"\"\"', '        if n > 2:', '            msg = \" \".join([', '                f\"The variable assigned to {self.variable} has more than two levels,\",', '                f\"so {self.variable} values will cycle and may be uninterpretable\",', '            ])', '            # TODO fire in a \"nice\" way (see above)', '            warnings.warn(msg, UserWarning)', '        return [x for x, _ in zip(itertools.cycle([True, False]), range(n))]']}, {'name': 'default_scale', 'start_line': 721, 'end_line': 723, 'text': ['    def default_scale(self, data: Series) -> Nominal:', '        \"\"\"Given data, initialize appropriate scale class.\"\"\"', '        return Nominal()']}, {'name': 'infer_scale', 'start_line': 725, 'end_line': 728, 'text': ['    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '        # TODO infer Boolean where possible?', '        return Nominal(arg)']}, {'name': 'get_mapping', 'start_line': 730, 'end_line': 762, 'text': ['    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps each data value to True or False.\"\"\"', '        # TODO categorical_order is going to return [False, True] for booleans,', '        # and [0, 1] for binary, but the default values order is [True, False].', '        # We should special case this to handle it properly, or change', '        # categorical_order to not \"sort\" booleans. Note that we need to sync with', \"        # what's going to happen upstream in the scale, so we can't just do it here.\", '        order = getattr(scale, \"order\", None)', '        levels = categorical_order(data, order)', '', '        if isinstance(scale.values, list):', '            values = [bool(x) for x in scale.values]', '        elif isinstance(scale.values, dict):', '            values = [bool(scale.values[x]) for x in levels]', '        elif scale.values is None:', '            values = self._default_values(len(levels))', '        else:', '            msg = \" \".join([', '                f\"Scale values for {self.variable} must be passed in\",', '                f\"a list or dict; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            return [', '                values[ix] if np.isfinite(x_i) else False', '                for x_i, ix in zip(x, ixs)', '            ]', '', '        return mapping']}]}], 'functions': [{'name': 'identity', 'start_line': 102, 'end_line': 103, 'text': ['        def identity(x):', '            return x']}, {'name': 'mapping', 'start_line': 217, 'end_line': 218, 'text': ['        def mapping(x):', '            return self._inverse(np.multiply(x, vmax - vmin) + vmin)']}, {'name': 'mapping', 'start_line': 249, 'end_line': 254, 'text': ['        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            out = np.full(len(x), np.nan)', '            use = np.isfinite(x)', '            out[use] = np.take(values, ixs[use])', '            return out']}, {'name': 'mapping', 'start_line': 365, 'end_line': 370, 'text': ['        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            return [', '                values[ix] if np.isfinite(x_i) else self.null_value', '                for x_i, ix in zip(x, ixs)', '            ]']}, {'name': 'has_alpha', 'start_line': 554, 'end_line': 555, 'text': ['        def has_alpha(x):', '            return to_rgba(x) != to_rgba(x, 1)']}, {'name': 'mapping', 'start_line': 642, 'end_line': 647, 'text': ['        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            use = np.isfinite(x)', '            out = np.full((len(ixs), colors.shape[1]), np.nan)', '            out[use] = np.take(colors, ixs[use], axis=0)', '            return out']}, {'name': '_mapping', 'start_line': 682, 'end_line': 688, 'text': ['        def _mapping(x):', '            # Remove alpha channel so it does not override alpha property downstream', '            # TODO this will need to be more flexible to support RGBA tuples (see above)', '            invalid = ~np.isfinite(x)', '            out = mapping(x)[:, :3]', '            out[invalid] = np.nan', '            return out']}, {'name': 'mapping', 'start_line': 755, 'end_line': 760, 'text': ['        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            return [', '                values[ix] if np.isfinite(x_i) else False', '                for x_i, ix in zip(x, ixs)', '            ]']}], 'text': ['from __future__ import annotations', 'import itertools', 'import warnings', '', 'import numpy as np', 'from pandas import Series', 'import matplotlib as mpl', 'from matplotlib.colors import to_rgb, to_rgba, to_rgba_array', 'from matplotlib.path import Path', '', 'from seaborn._core.scales import Scale, Nominal, Continuous, Temporal', 'from seaborn._core.rules import categorical_order, variable_type', 'from seaborn._compat import MarkerStyle', 'from seaborn.palettes import QUAL_PALETTES, color_palette, blend_palette', 'from seaborn.utils import get_color_cycle', '', 'from typing import Any, Callable, Tuple, List, Union, Optional', '', 'try:', '    from numpy.typing import ArrayLike', 'except ImportError:', '    # numpy<1.20.0 (Jan 2021)', '    ArrayLike = Any', '', 'RGBTuple = Tuple[float, float, float]', 'RGBATuple = Tuple[float, float, float, float]', 'ColorSpec = Union[RGBTuple, RGBATuple, str]', '', 'DashPattern = Tuple[float, ...]', 'DashPatternWithOffset = Tuple[float, Optional[DashPattern]]', '', 'MarkerPattern = Union[', '    float,', '    str,', '    Tuple[int, int, float],', '    List[Tuple[float, float]],', '    Path,', '    MarkerStyle,', ']', '', '', '# =================================================================================== #', '# Base classes', '# =================================================================================== #', '', '', 'class Property:', '    \"\"\"Base class for visual properties that can be set directly or be data scaling.\"\"\"', '', '    # When True, scales for this property will populate the legend by default', '    legend = False', '', '    # When True, scales for this property normalize data to [0, 1] before mapping', '    normed = False', '', '    def __init__(self, variable: str | None = None):', '        \"\"\"Initialize the property with the name of the corresponding plot variable.\"\"\"', '        if not variable:', '            variable = self.__class__.__name__.lower()', '        self.variable = variable', '', '    def default_scale(self, data: Series) -> Scale:', '        \"\"\"Given data, initialize appropriate scale class.\"\"\"', '        # TODO allow variable_type to be \"boolean\" if that\\'s a scale?', '        # TODO how will this handle data with units that can be treated as numeric', '        # if passed through a registered matplotlib converter?', '        var_type = variable_type(data, boolean_type=\"numeric\")', '        if var_type == \"numeric\":', '            return Continuous()', '        elif var_type == \"datetime\":', '            return Temporal()', '        # TODO others', '        # time-based (TimeStamp, TimeDelta, Period)', '        # boolean scale?', '        else:', '            return Nominal()', '', '    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '        # TODO put these somewhere external for validation', \"        # TODO putting this here won't pick it up if subclasses define infer_scale\", '        # (e.g. color). How best to handle that? One option is to call super after', '        # handling property-specific possibilities (e.g. for color check that the', '        # arg is not a valid palette name) but that could get tricky.', '        trans_args = [\"log\", \"symlog\", \"logit\", \"pow\", \"sqrt\"]', '        if isinstance(arg, str):', '            if any(arg.startswith(k) for k in trans_args):', '                # TODO validate numeric type? That should happen centrally somewhere', '                return Continuous(trans=arg)', '            else:', '                msg = f\"Unknown magic arg for {self.variable} scale: \\'{arg}\\'.\"', '                raise ValueError(msg)', '        else:', '            arg_type = type(arg).__name__', '            msg = f\"Magic arg for {self.variable} scale must be str, not {arg_type}.\"', '            raise TypeError(msg)', '', '    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to property range.\"\"\"', '        def identity(x):', '            return x', '        return identity', '', '    def standardize(self, val: Any) -> Any:', '        \"\"\"Coerce flexible property value to standardized representation.\"\"\"', '        return val', '', '    def _check_dict_entries(self, levels: list, values: dict) -> None:', '        \"\"\"Input check when values are provided as a dictionary.\"\"\"', '        missing = set(levels) - set(values)', '        if missing:', '            formatted = \", \".join(map(repr, sorted(missing, key=str)))', '            err = f\"No entry in {self.variable} dictionary for {formatted}\"', '            raise ValueError(err)', '', '    def _check_list_length(self, levels: list, values: list) -> list:', '        \"\"\"Input check when values are provided as a list.\"\"\"', '        message = \"\"', '        if len(levels) > len(values):', '            message = \" \".join([', '                f\"\\\\nThe {self.variable} list has fewer values ({len(values)})\",', '                f\"than needed ({len(levels)}) and will cycle, which may\",', '                \"produce an uninterpretable plot.\"', '            ])', '            values = [x for _, x in zip(levels, itertools.cycle(values))]', '', '        elif len(values) > len(levels):', '            message = \" \".join([', '                f\"The {self.variable} list has more values ({len(values)})\",', '                f\"than needed ({len(levels)}), which may not be intended.\",', '            ])', '            values = values[:len(levels)]', '', '        # TODO look into custom PlotSpecWarning with better formatting', '        if message:', '            warnings.warn(message, UserWarning)', '', '        return values', '', '', '# =================================================================================== #', '# Properties relating to spatial position of marks on the plotting axes', '# =================================================================================== #', '', '', 'class Coordinate(Property):', '    \"\"\"The position of visual marks with respect to the axes of the plot.\"\"\"', '    legend = False', '    normed = False', '', '', '# =================================================================================== #', '# Properties with numeric values where scale range can be defined as an interval', '# =================================================================================== #', '', '', 'class IntervalProperty(Property):', '    \"\"\"A numeric property where scale range can be defined as an interval.\"\"\"', '    legend = True', '    normed = True', '', '    _default_range: tuple[float, float] = (0, 1)', '', '    @property', '    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        return self._default_range', '', '    def _forward(self, values: ArrayLike) -> ArrayLike:', '        \"\"\"Transform applied to native values before linear mapping into interval.\"\"\"', '        return values', '', '    def _inverse(self, values: ArrayLike) -> ArrayLike:', '        \"\"\"Transform applied to results of mapping that returns to native values.\"\"\"', '        return values', '', '    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '', '        # TODO infer continuous based on log/sqrt etc?', '', '        if isinstance(arg, (list, dict)):', '            return Nominal(arg)', '        elif variable_type(data) == \"categorical\":', '            return Nominal(arg)', '        elif variable_type(data) == \"datetime\":', '            return Temporal(arg)', '        # TODO other variable types', '        else:', '            return Continuous(arg)', '', '    def get_mapping(', '        self, scale: Scale, data: ArrayLike', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to property range.\"\"\"', '        if isinstance(scale, Nominal):', '            return self._get_categorical_mapping(scale, data)', '', '        if scale.values is None:', '            vmin, vmax = self._forward(self.default_range)', '        elif isinstance(scale.values, tuple) and len(scale.values) == 2:', '            vmin, vmax = self._forward(scale.values)', '        else:', '            if isinstance(scale.values, tuple):', '                actual = f\"{len(scale.values)}-tuple\"', '            else:', '                actual = str(type(scale.values))', '            scale_class = scale.__class__.__name__', '            err = \" \".join([', '                f\"Values for {self.variable} variables with {scale_class} scale\",', '                f\"must be 2-tuple; not {actual}.\",', '            ])', '            raise TypeError(err)', '', '        def mapping(x):', '            return self._inverse(np.multiply(x, vmax - vmin) + vmin)', '', '        return mapping', '', '    def _get_categorical_mapping(', '        self, scale: Nominal, data: ArrayLike', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Identify evenly-spaced values using interval or explicit mapping.\"\"\"', '        levels = categorical_order(data, scale.order)', '', '        if isinstance(scale.values, dict):', '            self._check_dict_entries(levels, scale.values)', '            values = [scale.values[x] for x in levels]', '        elif isinstance(scale.values, list):', '            values = self._check_list_length(levels, scale.values)', '        else:', '            if scale.values is None:', '                vmin, vmax = self.default_range', '            elif isinstance(scale.values, tuple):', '                vmin, vmax = scale.values', '            else:', '                scale_class = scale.__class__.__name__', '                err = \" \".join([', '                    f\"Values for {self.variable} variables with {scale_class} scale\",', '                    f\"must be a dict, list or tuple; not {type(scale.values)}\",', '                ])', '                raise TypeError(err)', '', '            vmin, vmax = self._forward([vmin, vmax])', '            values = self._inverse(np.linspace(vmax, vmin, len(levels)))', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            out = np.full(len(x), np.nan)', '            use = np.isfinite(x)', '            out[use] = np.take(values, ixs[use])', '            return out', '', '        return mapping', '', '', 'class PointSize(IntervalProperty):', '    \"\"\"Size (diameter) of a point mark, in points, with scaling by area.\"\"\"', '    _default_range = 2, 8  # TODO use rcparams?', '', '    def _forward(self, values):', '        \"\"\"Square native values to implement linear scaling of point area.\"\"\"', '        return np.square(values)', '', '    def _inverse(self, values):', '        \"\"\"Invert areal values back to point diameter.\"\"\"', '        return np.sqrt(values)', '', '', 'class LineWidth(IntervalProperty):', '    \"\"\"Thickness of a line mark, in points.\"\"\"', '    @property', '    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"lines.linewidth\"]', '        return base * .5, base * 2', '', '', 'class EdgeWidth(IntervalProperty):', '    \"\"\"Thickness of the edges on a patch mark, in points.\"\"\"', '    @property', '    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"patch.linewidth\"]', '        return base * .5, base * 2', '', '', 'class Stroke(IntervalProperty):', '    \"\"\"Thickness of lines that define point glyphs.\"\"\"', '    _default_range = .25, 2.5', '', '', 'class Alpha(IntervalProperty):', '    \"\"\"Opacity of the color values for an arbitrary mark.\"\"\"', '    _default_range = .3, .95', '    # TODO validate / enforce that output is in [0, 1]', '', '', 'class Offset(IntervalProperty):', '    \"\"\"Offset for edge-aligned text, in point units.\"\"\"', '    _default_range = 0, 5', '    _legend = False', '', '', 'class FontSize(IntervalProperty):', '    \"\"\"Font size for textual marks, in points.\"\"\"', '    _legend = False', '', '    @property', '    def default_range(self) -> tuple[float, float]:', '        \"\"\"Min and max values used by default for semantic mapping.\"\"\"', '        base = mpl.rcParams[\"font.size\"]', '        return base * .5, base * 2', '', '', '# =================================================================================== #', '# Properties defined by arbitrary objects with inherently nominal scaling', '# =================================================================================== #', '', '', 'class ObjectProperty(Property):', '    \"\"\"A property defined by arbitrary an object, with inherently nominal scaling.\"\"\"', '    legend = True', '    normed = False', '', '    # Object representing null data, should appear invisible when drawn by matplotlib', '    # Note that we now drop nulls in Plot._plot_layer and thus may not need this', '    null_value: Any = None', '', '    def _default_values(self, n: int) -> list:', '        raise NotImplementedError()', '', '    def default_scale(self, data: Series) -> Nominal:', '        return Nominal()', '', '    def infer_scale(self, arg: Any, data: Series) -> Nominal:', '        return Nominal(arg)', '', '    def get_mapping(', '        self, scale: Scale, data: Series,', '    ) -> Callable[[ArrayLike], list]:', '        \"\"\"Define mapping as lookup into list of object values.\"\"\"', '        order = getattr(scale, \"order\", None)', '        levels = categorical_order(data, order)', '        n = len(levels)', '', '        if isinstance(scale.values, dict):', '            self._check_dict_entries(levels, scale.values)', '            values = [scale.values[x] for x in levels]', '        elif isinstance(scale.values, list):', '            values = self._check_list_length(levels, scale.values)', '        elif scale.values is None:', '            values = self._default_values(n)', '        else:', '            msg = \" \".join([', '                f\"Scale values for a {self.variable} variable must be provided\",', '                f\"in a dict or list; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        values = [self.standardize(x) for x in values]', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            return [', '                values[ix] if np.isfinite(x_i) else self.null_value', '                for x_i, ix in zip(x, ixs)', '            ]', '', '        return mapping', '', '', 'class Marker(ObjectProperty):', '    \"\"\"Shape of points in scatter-type marks or lines with data points marked.\"\"\"', '    null_value = MarkerStyle(\"\")', '', '    # TODO should we have named marker \"palettes\"? (e.g. see d3 options)', '', '    # TODO need some sort of \"require_scale\" functionality', '    # to raise when we get the wrong kind explicitly specified', '', '    def standardize(self, val: MarkerPattern) -> MarkerStyle:', '        return MarkerStyle(val)', '', '    def _default_values(self, n: int) -> list[MarkerStyle]:', '        \"\"\"Build an arbitrarily long list of unique marker styles.', '', '        Parameters', '        ----------', '        n : int', '            Number of unique marker specs to generate.', '', '        Returns', '        -------', '        markers : list of string or tuples', '            Values for defining :class:`matplotlib.markers.MarkerStyle` objects.', '            All markers will be filled.', '', '        \"\"\"', '        # Start with marker specs that are well distinguishable', '        markers = [', '            \"o\", \"X\", (4, 0, 45), \"P\", (4, 0, 0), (4, 1, 0), \"^\", (4, 1, 45), \"v\",', '        ]', '', '        # Now generate more from regular polygons of increasing order', '        s = 5', '        while len(markers) < n:', '            a = 360 / (s + 1) / 2', '            markers.extend([(s + 1, 1, a), (s + 1, 0, a), (s, 1, 0), (s, 0, 0)])', '            s += 1', '', '        markers = [MarkerStyle(m) for m in markers[:n]]', '', '        return markers', '', '', 'class LineStyle(ObjectProperty):', '    \"\"\"Dash pattern for line-type marks.\"\"\"', '    null_value = \"\"', '', '    def standardize(self, val: str | DashPattern) -> DashPatternWithOffset:', '        return self._get_dash_pattern(val)', '', '    def _default_values(self, n: int) -> list[DashPatternWithOffset]:', '        \"\"\"Build an arbitrarily long list of unique dash styles for lines.', '', '        Parameters', '        ----------', '        n : int', '            Number of unique dash specs to generate.', '', '        Returns', '        -------', '        dashes : list of strings or tuples', '            Valid arguments for the ``dashes`` parameter on', '            :class:`matplotlib.lines.Line2D`. The first spec is a solid', '            line (``\"\"``), the remainder are sequences of long and short', '            dashes.', '', '        \"\"\"', '        # Start with dash specs that are well distinguishable', '        dashes: list[str | DashPattern] = [', '            \"-\", (4, 1.5), (1, 1), (3, 1.25, 1.5, 1.25), (5, 1, 1, 1),', '        ]', '', '        # Now programmatically build as many as we need', '        p = 3', '        while len(dashes) < n:', '', '            # Take combinations of long and short dashes', '            a = itertools.combinations_with_replacement([3, 1.25], p)', '            b = itertools.combinations_with_replacement([4, 1], p)', '', '            # Interleave the combinations, reversing one of the streams', '            segment_list = itertools.chain(*zip(list(a)[1:-1][::-1], list(b)[1:-1]))', '', '            # Now insert the gaps', '            for segments in segment_list:', '                gap = min(segments)', '                spec = tuple(itertools.chain(*((seg, gap) for seg in segments)))', '                dashes.append(spec)', '', '            p += 1', '', '        return [self._get_dash_pattern(x) for x in dashes]', '', '    @staticmethod', '    def _get_dash_pattern(style: str | DashPattern) -> DashPatternWithOffset:', '        \"\"\"Convert linestyle arguments to dash pattern with offset.\"\"\"', '        # Copied and modified from Matplotlib 3.4', '        # go from short hand -> full strings', '        ls_mapper = {\"-\": \"solid\", \"--\": \"dashed\", \"-.\": \"dashdot\", \":\": \"dotted\"}', '        if isinstance(style, str):', '            style = ls_mapper.get(style, style)', '            # un-dashed styles', '            if style in [\"solid\", \"none\", \"None\"]:', '                offset = 0', '                dashes = None', '            # dashed styles', '            elif style in [\"dashed\", \"dashdot\", \"dotted\"]:', '                offset = 0', '                dashes = tuple(mpl.rcParams[f\"lines.{style}_pattern\"])', '            else:', '                options = [*ls_mapper.values(), *ls_mapper.keys()]', '                msg = f\"Linestyle string must be one of {options}, not {repr(style)}.\"', '                raise ValueError(msg)', '', '        elif isinstance(style, tuple):', '            if len(style) > 1 and isinstance(style[1], tuple):', '                offset, dashes = style', '            elif len(style) > 1 and style[1] is None:', '                offset, dashes = style', '            else:', '                offset = 0', '                dashes = style', '        else:', '            val_type = type(style).__name__', '            msg = f\"Linestyle must be str or tuple, not {val_type}.\"', '            raise TypeError(msg)', '', '        # Normalize offset to be positive and shorter than the dash cycle', '        if dashes is not None:', '            try:', '                dsum = sum(dashes)', '            except TypeError as err:', '                msg = f\"Invalid dash pattern: {dashes}\"', '                raise TypeError(msg) from err', '            if dsum:', '                offset %= dsum', '', '        return offset, dashes', '', '', 'class TextAlignment(ObjectProperty):', '    legend = False', '', '', 'class HorizontalAlignment(TextAlignment):', '', '    def _default_values(self, n: int) -> list:', '        vals = itertools.cycle([\"left\", \"right\"])', '        return [next(vals) for _ in range(n)]', '', '', 'class VerticalAlignment(TextAlignment):', '', '    def _default_values(self, n: int) -> list:', '        vals = itertools.cycle([\"top\", \"bottom\"])', '        return [next(vals) for _ in range(n)]', '', '', '# =================================================================================== #', '# Properties with  RGB(A) color values', '# =================================================================================== #', '', '', 'class Color(Property):', '    \"\"\"Color, as RGB(A), scalable with nominal palettes or continuous gradients.\"\"\"', '    legend = True', '    normed = True', '', '    def standardize(self, val: ColorSpec) -> RGBTuple | RGBATuple:', '        # Return color with alpha channel only if the input spec has it', '        # This is so that RGBA colors can override the Alpha property', '        if to_rgba(val) != to_rgba(val, 1):', '            return to_rgba(val)', '        else:', '            return to_rgb(val)', '', '    def _standardize_color_sequence(self, colors: ArrayLike) -> ArrayLike:', '        \"\"\"Convert color sequence to RGB(A) array, preserving but not adding alpha.\"\"\"', '        def has_alpha(x):', '            return to_rgba(x) != to_rgba(x, 1)', '', '        if isinstance(colors, np.ndarray):', '            needs_alpha = colors.shape[1] == 4', '        else:', '            needs_alpha = any(has_alpha(x) for x in colors)', '', '        if needs_alpha:', '            return to_rgba_array(colors)', '        else:', '            return to_rgba_array(colors)[:, :3]', '', '    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        # TODO when inferring Continuous without data, verify type', '', '        # TODO need to rethink the variable type system', '        # (e.g. boolean, ordered categories as Ordinal, etc)..', '        var_type = variable_type(data, boolean_type=\"categorical\")', '', '        if isinstance(arg, (dict, list)):', '            return Nominal(arg)', '', '        if isinstance(arg, tuple):', '            if var_type == \"categorical\":', '                # TODO It seems reasonable to allow a gradient mapping for nominal', '                # scale but it also feels \"technically\" wrong. Should this infer', '                # Ordinal with categorical data and, if so, verify orderedness?', '                return Nominal(arg)', '            return Continuous(arg)', '', '        if callable(arg):', '            return Continuous(arg)', '', '        # TODO Do we accept str like \"log\", \"pow\", etc. for semantics?', '', '        # TODO what about', '        # - Temporal? (i.e. datetime)', '        # - Boolean?', '', '        if not isinstance(arg, str):', '            msg = \" \".join([', '                f\"A single scale argument for {self.variable} variables must be\",', '                f\"a string, dict, tuple, list, or callable, not {type(arg)}.\"', '            ])', '            raise TypeError(msg)', '', '        if arg in QUAL_PALETTES:', '            return Nominal(arg)', '        elif var_type == \"numeric\":', '            return Continuous(arg)', '        # TODO implement scales for date variables and any others.', '        else:', '            return Nominal(arg)', '', '    def _get_categorical_mapping(self, scale, data):', '        \"\"\"Define mapping as lookup in list of discrete color values.\"\"\"', '        levels = categorical_order(data, scale.order)', '        n = len(levels)', '        values = scale.values', '', '        if isinstance(values, dict):', '            self._check_dict_entries(levels, values)', '            # TODO where to ensure that dict values have consistent representation?', '            colors = [values[x] for x in levels]', '        elif isinstance(values, list):', '            colors = self._check_list_length(levels, scale.values)', '        elif isinstance(values, tuple):', '            colors = blend_palette(values, n)', '        elif isinstance(values, str):', '            colors = color_palette(values, n)', '        elif values is None:', '            if n <= len(get_color_cycle()):', '                # Use current (global) default palette', '                colors = color_palette(n_colors=n)', '            else:', '                colors = color_palette(\"husl\", n)', '        else:', '            scale_class = scale.__class__.__name__', '            msg = \" \".join([', '                f\"Scale values for {self.variable} with a {scale_class} mapping\",', '                f\"must be string, list, tuple, or dict; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        # If color specified here has alpha channel, it will override alpha property', '        colors = self._standardize_color_sequence(colors)', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            use = np.isfinite(x)', '            out = np.full((len(ixs), colors.shape[1]), np.nan)', '            out[use] = np.take(colors, ixs[use], axis=0)', '            return out', '', '        return mapping', '', '    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps from data domain to color values.\"\"\"', '        # TODO what is best way to do this conditional?', '        # Should it be class-based or should classes have behavioral attributes?', '        if isinstance(scale, Nominal):', '            return self._get_categorical_mapping(scale, data)', '', '        if scale.values is None:', '            # TODO Rethink best default continuous color gradient', '            mapping = color_palette(\"ch:\", as_cmap=True)', '        elif isinstance(scale.values, tuple):', '            # TODO blend_palette will strip alpha, but we should support', '            # interpolation on all four channels', '            mapping = blend_palette(scale.values, as_cmap=True)', '        elif isinstance(scale.values, str):', '            # TODO for matplotlib colormaps this will clip extremes, which is', '            # different from what using the named colormap directly would do', '            # This may or may not be desireable.', '            mapping = color_palette(scale.values, as_cmap=True)', '        elif callable(scale.values):', '            mapping = scale.values', '        else:', '            scale_class = scale.__class__.__name__', '            msg = \" \".join([', '                f\"Scale values for {self.variable} with a {scale_class} mapping\",', '                f\"must be string, tuple, or callable; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        def _mapping(x):', '            # Remove alpha channel so it does not override alpha property downstream', '            # TODO this will need to be more flexible to support RGBA tuples (see above)', '            invalid = ~np.isfinite(x)', '            out = mapping(x)[:, :3]', '            out[invalid] = np.nan', '            return out', '', '        return _mapping', '', '', '# =================================================================================== #', '# Properties that can take only two states', '# =================================================================================== #', '', '', 'class Fill(Property):', '    \"\"\"Boolean property of points/bars/patches that can be solid or outlined.\"\"\"', '    legend = True', '    normed = False', '', '    # TODO default to Nominal scale always?', '    # Actually this will just not work with Continuous (except 0/1), suggesting we need', '    # an abstraction for failing gracefully on bad Property <> Scale interactions', '', '    def standardize(self, val: Any) -> bool:', '        return bool(val)', '', '    def _default_values(self, n: int) -> list:', '        \"\"\"Return a list of n values, alternating True and False.\"\"\"', '        if n > 2:', '            msg = \" \".join([', '                f\"The variable assigned to {self.variable} has more than two levels,\",', '                f\"so {self.variable} values will cycle and may be uninterpretable\",', '            ])', '            # TODO fire in a \"nice\" way (see above)', '            warnings.warn(msg, UserWarning)', '        return [x for x, _ in zip(itertools.cycle([True, False]), range(n))]', '', '    def default_scale(self, data: Series) -> Nominal:', '        \"\"\"Given data, initialize appropriate scale class.\"\"\"', '        return Nominal()', '', '    def infer_scale(self, arg: Any, data: Series) -> Scale:', '        \"\"\"Given data and a scaling argument, initialize appropriate scale class.\"\"\"', '        # TODO infer Boolean where possible?', '        return Nominal(arg)', '', '    def get_mapping(', '        self, scale: Scale, data: Series', '    ) -> Callable[[ArrayLike], ArrayLike]:', '        \"\"\"Return a function that maps each data value to True or False.\"\"\"', '        # TODO categorical_order is going to return [False, True] for booleans,', '        # and [0, 1] for binary, but the default values order is [True, False].', '        # We should special case this to handle it properly, or change', '        # categorical_order to not \"sort\" booleans. Note that we need to sync with', \"        # what's going to happen upstream in the scale, so we can't just do it here.\", '        order = getattr(scale, \"order\", None)', '        levels = categorical_order(data, order)', '', '        if isinstance(scale.values, list):', '            values = [bool(x) for x in scale.values]', '        elif isinstance(scale.values, dict):', '            values = [bool(scale.values[x]) for x in levels]', '        elif scale.values is None:', '            values = self._default_values(len(levels))', '        else:', '            msg = \" \".join([', '                f\"Scale values for {self.variable} must be passed in\",', '                f\"a list or dict; not {type(scale.values)}.\"', '            ])', '            raise TypeError(msg)', '', '        def mapping(x):', '            ixs = np.asarray(x, np.intp)', '            return [', '                values[ix] if np.isfinite(x_i) else False', '                for x_i, ix in zip(x, ixs)', '            ]', '', '        return mapping', '', '', '# =================================================================================== #', '# Enumeration of properties for use by Plot and Mark classes', '# =================================================================================== #', '# TODO turn this into a property registry with hooks, etc.', '# TODO Users do not interact directly with properties, so how to document them?', '', '', 'PROPERTY_CLASSES = {', '    \"x\": Coordinate,', '    \"y\": Coordinate,', '    \"color\": Color,', '    \"alpha\": Alpha,', '    \"fill\": Fill,', '    \"marker\": Marker,', '    \"pointsize\": PointSize,', '    \"stroke\": Stroke,', '    \"linewidth\": LineWidth,', '    \"linestyle\": LineStyle,', '    \"fillcolor\": Color,', '    \"fillalpha\": Alpha,', '    \"edgewidth\": EdgeWidth,', '    \"edgestyle\": LineStyle,', '    \"edgecolor\": Color,', '    \"edgealpha\": Alpha,', '    \"text\": Property,', '    \"halign\": HorizontalAlignment,', '    \"valign\": VerticalAlignment,', '    \"offset\": Offset,', '    \"fontsize\": FontSize,', '    \"xmin\": Coordinate,', '    \"xmax\": Coordinate,', '    \"ymin\": Coordinate,', '    \"ymax\": Coordinate,', '    \"group\": Property,', '    # TODO pattern?', '    # TODO gradient?', '}', '', 'PROPERTIES = {var: cls(var) for var, cls in PROPERTY_CLASSES.items()}']}, 'moves.py': {'classes': [{'name': 'Move', 'start_line': 16, 'end_line': 24, 'text': ['class Move:', '    \"\"\"Base class for objects that apply simple positional transforms.\"\"\"', '', '    group_by_orient: ClassVar[bool] = True', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '        raise NotImplementedError'], 'methods': [{'name': '__call__', 'start_line': 21, 'end_line': 24, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '        raise NotImplementedError']}]}, {'name': 'Jitter', 'start_line': 28, 'end_line': 77, 'text': ['class Jitter(Move):', '    \"\"\"', '    Random displacement along one or both axes to reduce overplotting.', '', '    Parameters', '    ----------', '    width : float', '        Magnitude of jitter, relative to mark width, along the orientation axis.', '        If not provided, the default value will be 0 when `x` or `y` are set, otherwise', '        there will be a small amount of jitter applied by default.', '    x : float', '        Magnitude of jitter, in data units, along the x axis.', '    y : float', '        Magnitude of jitter, in data units, along the y axis.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Jitter.rst', '', '    \"\"\"', '    width: float | Default = default', '    x: float = 0', '    y: float = 0', '    seed: int | None = None', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        data = data.copy()', '        rng = np.random.default_rng(self.seed)', '', '        def jitter(data, col, scale):', '            noise = rng.uniform(-.5, +.5, len(data))', '            offsets = noise * scale', '            return data[col] + offsets', '', '        if self.width is default:', '            width = 0.0 if self.x or self.y else 0.2', '        else:', '            width = cast(float, self.width)', '', '        if self.width:', '            data[orient] = jitter(data, orient, width * data[\"width\"])', '        if self.x:', '            data[\"x\"] = jitter(data, \"x\", self.x)', '        if self.y:', '            data[\"y\"] = jitter(data, \"y\", self.y)', '', '        return data'], 'methods': [{'name': '__call__', 'start_line': 53, 'end_line': 77, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        data = data.copy()', '        rng = np.random.default_rng(self.seed)', '', '        def jitter(data, col, scale):', '            noise = rng.uniform(-.5, +.5, len(data))', '            offsets = noise * scale', '            return data[col] + offsets', '', '        if self.width is default:', '            width = 0.0 if self.x or self.y else 0.2', '        else:', '            width = cast(float, self.width)', '', '        if self.width:', '            data[orient] = jitter(data, orient, width * data[\"width\"])', '        if self.x:', '            data[\"x\"] = jitter(data, \"x\", self.x)', '        if self.y:', '            data[\"y\"] = jitter(data, \"y\", self.y)', '', '        return data']}]}, {'name': 'Dodge', 'start_line': 81, 'end_line': 137, 'text': ['class Dodge(Move):', '    \"\"\"', '    Displacement and narrowing of overlapping marks along orientation axis.', '    \"\"\"', '    empty: str = \"keep\"  # Options: keep, drop, fill', '    gap: float = 0', '', '    # TODO accept just a str here?', '    # TODO should this always be present?', '    # TODO should the default be an \"all\" singleton?', '    by: Optional[list[str]] = None', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        grouping_vars = [v for v in groupby.order if v in data]', '        groups = groupby.agg(data, {\"width\": \"max\"})', '        if self.empty == \"fill\":', '            groups = groups.dropna()', '', '        def groupby_pos(s):', '            grouper = [groups[v] for v in [orient, \"col\", \"row\"] if v in data]', '            return s.groupby(grouper, sort=False, observed=True)', '', '        def scale_widths(w):', '            # TODO what value to fill missing widths??? Hard problem...', '            # TODO short circuit this if outer widths has no variance?', '            empty = 0 if self.empty == \"fill\" else w.mean()', '            filled = w.fillna(empty)', '            scale = filled.max()', '            norm = filled.sum()', '            if self.empty == \"keep\":', '                w = filled', '            return w / norm * scale', '', '        def widths_to_offsets(w):', '            return w.shift(1).fillna(0).cumsum() + (w - w.sum()) / 2', '', '        new_widths = groupby_pos(groups[\"width\"]).transform(scale_widths)', '        offsets = groupby_pos(new_widths).transform(widths_to_offsets)', '', '        if self.gap:', '            new_widths *= 1 - self.gap', '', '        groups[\"_dodged\"] = groups[orient] + offsets', '        groups[\"width\"] = new_widths', '', '        out = (', '            data', '            .drop(\"width\", axis=1)', '            .merge(groups, on=grouping_vars, how=\"left\")', '            .drop(orient, axis=1)', '            .rename(columns={\"_dodged\": orient})', '        )', '', '        return out'], 'methods': [{'name': '__call__', 'start_line': 93, 'end_line': 137, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        grouping_vars = [v for v in groupby.order if v in data]', '        groups = groupby.agg(data, {\"width\": \"max\"})', '        if self.empty == \"fill\":', '            groups = groups.dropna()', '', '        def groupby_pos(s):', '            grouper = [groups[v] for v in [orient, \"col\", \"row\"] if v in data]', '            return s.groupby(grouper, sort=False, observed=True)', '', '        def scale_widths(w):', '            # TODO what value to fill missing widths??? Hard problem...', '            # TODO short circuit this if outer widths has no variance?', '            empty = 0 if self.empty == \"fill\" else w.mean()', '            filled = w.fillna(empty)', '            scale = filled.max()', '            norm = filled.sum()', '            if self.empty == \"keep\":', '                w = filled', '            return w / norm * scale', '', '        def widths_to_offsets(w):', '            return w.shift(1).fillna(0).cumsum() + (w - w.sum()) / 2', '', '        new_widths = groupby_pos(groups[\"width\"]).transform(scale_widths)', '        offsets = groupby_pos(new_widths).transform(widths_to_offsets)', '', '        if self.gap:', '            new_widths *= 1 - self.gap', '', '        groups[\"_dodged\"] = groups[orient] + offsets', '        groups[\"width\"] = new_widths', '', '        out = (', '            data', '            .drop(\"width\", axis=1)', '            .merge(groups, on=grouping_vars, how=\"left\")', '            .drop(orient, axis=1)', '            .rename(columns={\"_dodged\": orient})', '        )', '', '        return out']}]}, {'name': 'Stack', 'start_line': 141, 'end_line': 172, 'text': ['class Stack(Move):', '    \"\"\"', '    Displacement of overlapping bar or area marks along the value axis.', '    \"\"\"', '    # TODO center? (or should this be a different move, eg. Stream())', '', '    def _stack(self, df, orient):', '', '        # TODO should stack do something with ymin/ymax style marks?', '        # Should there be an upstream conversion to baseline/height parameterization?', '', '        if df[\"baseline\"].nunique() > 1:', '            err = \"Stack move cannot be used when baselines are already heterogeneous\"', '            raise RuntimeError(err)', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        stacked_lengths = (df[other] - df[\"baseline\"]).dropna().cumsum()', '        offsets = stacked_lengths.shift(1).fillna(0)', '', '        df[other] = stacked_lengths', '        df[\"baseline\"] = df[\"baseline\"] + offsets', '', '        return df', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        # TODO where to ensure that other semantic variables are sorted properly?', '        # TODO why are we not using the passed in groupby here?', '        groupers = [\"col\", \"row\", orient]', '        return GroupBy(groupers).apply(data, self._stack, orient)'], 'methods': [{'name': '_stack', 'start_line': 147, 'end_line': 163, 'text': ['    def _stack(self, df, orient):', '', '        # TODO should stack do something with ymin/ymax style marks?', '        # Should there be an upstream conversion to baseline/height parameterization?', '', '        if df[\"baseline\"].nunique() > 1:', '            err = \"Stack move cannot be used when baselines are already heterogeneous\"', '            raise RuntimeError(err)', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        stacked_lengths = (df[other] - df[\"baseline\"]).dropna().cumsum()', '        offsets = stacked_lengths.shift(1).fillna(0)', '', '        df[other] = stacked_lengths', '        df[\"baseline\"] = df[\"baseline\"] + offsets', '', '        return df']}, {'name': '__call__', 'start_line': 165, 'end_line': 172, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        # TODO where to ensure that other semantic variables are sorted properly?', '        # TODO why are we not using the passed in groupby here?', '        groupers = [\"col\", \"row\", orient]', '        return GroupBy(groupers).apply(data, self._stack, orient)']}]}, {'name': 'Shift', 'start_line': 176, 'end_line': 190, 'text': ['class Shift(Move):', '    \"\"\"', '    Displacement of all marks with the same magnitude / direction.', '    \"\"\"', '    x: float = 0', '    y: float = 0', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        data = data.copy(deep=False)', '        data[\"x\"] = data[\"x\"] + self.x', '        data[\"y\"] = data[\"y\"] + self.y', '        return data'], 'methods': [{'name': '__call__', 'start_line': 183, 'end_line': 190, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        data = data.copy(deep=False)', '        data[\"x\"] = data[\"x\"] + self.x', '        data[\"y\"] = data[\"y\"] + self.y', '        return data']}]}, {'name': 'Norm', 'start_line': 194, 'end_line': 224, 'text': ['class Norm(Move):', '    \"\"\"', '    Divisive scaling on the value axis after aggregating within groups.', '    \"\"\"', '', '    func: Union[Callable, str] = \"max\"', '    where: Optional[str] = None', '    by: Optional[list[str]] = None', '    percent: bool = False', '', '    group_by_orient: ClassVar[bool] = False', '', '    def _norm(self, df, var):', '', '        if self.where is None:', '            denom_data = df[var]', '        else:', '            denom_data = df.query(self.where)[var]', '        df[var] = df[var] / denom_data.agg(self.func)', '', '        if self.percent:', '            df[var] = df[var] * 100', '', '        return df', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return groupby.apply(data, self._norm, other)'], 'methods': [{'name': '_norm', 'start_line': 206, 'end_line': 217, 'text': ['    def _norm(self, df, var):', '', '        if self.where is None:', '            denom_data = df[var]', '        else:', '            denom_data = df.query(self.where)[var]', '        df[var] = df[var] / denom_data.agg(self.func)', '', '        if self.percent:', '            df[var] = df[var] * 100', '', '        return df']}, {'name': '__call__', 'start_line': 219, 'end_line': 224, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return groupby.apply(data, self._norm, other)']}]}], 'functions': [{'name': 'jitter', 'start_line': 60, 'end_line': 63, 'text': ['        def jitter(data, col, scale):', '            noise = rng.uniform(-.5, +.5, len(data))', '            offsets = noise * scale', '            return data[col] + offsets']}, {'name': 'groupby_pos', 'start_line': 102, 'end_line': 104, 'text': ['        def groupby_pos(s):', '            grouper = [groups[v] for v in [orient, \"col\", \"row\"] if v in data]', '            return s.groupby(grouper, sort=False, observed=True)']}, {'name': 'scale_widths', 'start_line': 106, 'end_line': 115, 'text': ['        def scale_widths(w):', '            # TODO what value to fill missing widths??? Hard problem...', '            # TODO short circuit this if outer widths has no variance?', '            empty = 0 if self.empty == \"fill\" else w.mean()', '            filled = w.fillna(empty)', '            scale = filled.max()', '            norm = filled.sum()', '            if self.empty == \"keep\":', '                w = filled', '            return w / norm * scale']}, {'name': 'widths_to_offsets', 'start_line': 117, 'end_line': 118, 'text': ['        def widths_to_offsets(w):', '            return w.shift(1).fillna(0).cumsum() + (w - w.sum()) / 2']}], 'text': ['from __future__ import annotations', 'from dataclasses import dataclass', 'from typing import ClassVar, Callable, Optional, Union, cast', '', 'import numpy as np', 'from pandas import DataFrame', '', 'from seaborn._core.groupby import GroupBy', 'from seaborn._core.scales import Scale', 'from seaborn._core.typing import Default', '', 'default = Default()', '', '', '@dataclass', 'class Move:', '    \"\"\"Base class for objects that apply simple positional transforms.\"\"\"', '', '    group_by_orient: ClassVar[bool] = True', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '        raise NotImplementedError', '', '', '@dataclass', 'class Jitter(Move):', '    \"\"\"', '    Random displacement along one or both axes to reduce overplotting.', '', '    Parameters', '    ----------', '    width : float', '        Magnitude of jitter, relative to mark width, along the orientation axis.', '        If not provided, the default value will be 0 when `x` or `y` are set, otherwise', '        there will be a small amount of jitter applied by default.', '    x : float', '        Magnitude of jitter, in data units, along the x axis.', '    y : float', '        Magnitude of jitter, in data units, along the y axis.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Jitter.rst', '', '    \"\"\"', '    width: float | Default = default', '    x: float = 0', '    y: float = 0', '    seed: int | None = None', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        data = data.copy()', '        rng = np.random.default_rng(self.seed)', '', '        def jitter(data, col, scale):', '            noise = rng.uniform(-.5, +.5, len(data))', '            offsets = noise * scale', '            return data[col] + offsets', '', '        if self.width is default:', '            width = 0.0 if self.x or self.y else 0.2', '        else:', '            width = cast(float, self.width)', '', '        if self.width:', '            data[orient] = jitter(data, orient, width * data[\"width\"])', '        if self.x:', '            data[\"x\"] = jitter(data, \"x\", self.x)', '        if self.y:', '            data[\"y\"] = jitter(data, \"y\", self.y)', '', '        return data', '', '', '@dataclass', 'class Dodge(Move):', '    \"\"\"', '    Displacement and narrowing of overlapping marks along orientation axis.', '    \"\"\"', '    empty: str = \"keep\"  # Options: keep, drop, fill', '    gap: float = 0', '', '    # TODO accept just a str here?', '    # TODO should this always be present?', '    # TODO should the default be an \"all\" singleton?', '    by: Optional[list[str]] = None', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        grouping_vars = [v for v in groupby.order if v in data]', '        groups = groupby.agg(data, {\"width\": \"max\"})', '        if self.empty == \"fill\":', '            groups = groups.dropna()', '', '        def groupby_pos(s):', '            grouper = [groups[v] for v in [orient, \"col\", \"row\"] if v in data]', '            return s.groupby(grouper, sort=False, observed=True)', '', '        def scale_widths(w):', '            # TODO what value to fill missing widths??? Hard problem...', '            # TODO short circuit this if outer widths has no variance?', '            empty = 0 if self.empty == \"fill\" else w.mean()', '            filled = w.fillna(empty)', '            scale = filled.max()', '            norm = filled.sum()', '            if self.empty == \"keep\":', '                w = filled', '            return w / norm * scale', '', '        def widths_to_offsets(w):', '            return w.shift(1).fillna(0).cumsum() + (w - w.sum()) / 2', '', '        new_widths = groupby_pos(groups[\"width\"]).transform(scale_widths)', '        offsets = groupby_pos(new_widths).transform(widths_to_offsets)', '', '        if self.gap:', '            new_widths *= 1 - self.gap', '', '        groups[\"_dodged\"] = groups[orient] + offsets', '        groups[\"width\"] = new_widths', '', '        out = (', '            data', '            .drop(\"width\", axis=1)', '            .merge(groups, on=grouping_vars, how=\"left\")', '            .drop(orient, axis=1)', '            .rename(columns={\"_dodged\": orient})', '        )', '', '        return out', '', '', '@dataclass', 'class Stack(Move):', '    \"\"\"', '    Displacement of overlapping bar or area marks along the value axis.', '    \"\"\"', '    # TODO center? (or should this be a different move, eg. Stream())', '', '    def _stack(self, df, orient):', '', '        # TODO should stack do something with ymin/ymax style marks?', '        # Should there be an upstream conversion to baseline/height parameterization?', '', '        if df[\"baseline\"].nunique() > 1:', '            err = \"Stack move cannot be used when baselines are already heterogeneous\"', '            raise RuntimeError(err)', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        stacked_lengths = (df[other] - df[\"baseline\"]).dropna().cumsum()', '        offsets = stacked_lengths.shift(1).fillna(0)', '', '        df[other] = stacked_lengths', '        df[\"baseline\"] = df[\"baseline\"] + offsets', '', '        return df', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        # TODO where to ensure that other semantic variables are sorted properly?', '        # TODO why are we not using the passed in groupby here?', '        groupers = [\"col\", \"row\", orient]', '        return GroupBy(groupers).apply(data, self._stack, orient)', '', '', '@dataclass', 'class Shift(Move):', '    \"\"\"', '    Displacement of all marks with the same magnitude / direction.', '    \"\"\"', '    x: float = 0', '    y: float = 0', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        data = data.copy(deep=False)', '        data[\"x\"] = data[\"x\"] + self.x', '        data[\"y\"] = data[\"y\"] + self.y', '        return data', '', '', '@dataclass', 'class Norm(Move):', '    \"\"\"', '    Divisive scaling on the value axis after aggregating within groups.', '    \"\"\"', '', '    func: Union[Callable, str] = \"max\"', '    where: Optional[str] = None', '    by: Optional[list[str]] = None', '    percent: bool = False', '', '    group_by_orient: ClassVar[bool] = False', '', '    def _norm(self, df, var):', '', '        if self.where is None:', '            denom_data = df[var]', '        else:', '            denom_data = df.query(self.where)[var]', '        df[var] = df[var] / denom_data.agg(self.func)', '', '        if self.percent:', '            df[var] = df[var] * 100', '', '        return df', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return groupby.apply(data, self._norm, other)', '', '', '# TODO', '# @dataclass', '# class Ridge(Move):', '#     ...']}, 'subplots.py': {'classes': [{'name': 'Subplots', 'start_line': 16, 'end_line': 269, 'text': ['class Subplots:', '    \"\"\"', '    Interface for creating and using matplotlib subplots based on seaborn parameters.', '', '    Parameters', '    ----------', '    subplot_spec : dict', '        Keyword args for :meth:`matplotlib.figure.Figure.subplots`.', '    facet_spec : dict', '        Parameters that control subplot faceting.', '    pair_spec : dict', '        Parameters that control subplot pairing.', '    data : PlotData', '        Data used to define figure setup.', '', '    \"\"\"', '    def __init__(', '        self,', '        subplot_spec: dict,  # TODO define as TypedDict', '        facet_spec: FacetSpec,', '        pair_spec: PairSpec,', '    ):', '', '        self.subplot_spec = subplot_spec', '', '        self._check_dimension_uniqueness(facet_spec, pair_spec)', '        self._determine_grid_dimensions(facet_spec, pair_spec)', '        self._handle_wrapping(facet_spec, pair_spec)', '        self._determine_axis_sharing(pair_spec)', '', '    def _check_dimension_uniqueness(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Reject specs that pair and facet on (or wrap to) same figure dimension.\"\"\"', '        err = None', '', '        facet_vars = facet_spec.get(\"variables\", {})', '', '        if facet_spec.get(\"wrap\") and {\"col\", \"row\"} <= set(facet_vars):', '            err = \"Cannot wrap facets when specifying both `col` and `row`.\"', '        elif (', '            pair_spec.get(\"wrap\")', '            and pair_spec.get(\"cross\", True)', '            and len(pair_spec.get(\"structure\", {}).get(\"x\", [])) > 1', '            and len(pair_spec.get(\"structure\", {}).get(\"y\", [])) > 1', '        ):', '            err = \"Cannot wrap subplots when pairing on both `x` and `y`.\"', '', '        collisions = {\"x\": [\"columns\", \"rows\"], \"y\": [\"rows\", \"columns\"]}', '        for pair_axis, (multi_dim, wrap_dim) in collisions.items():', '            if pair_axis not in pair_spec.get(\"structure\", {}):', '                continue', '            elif multi_dim[:3] in facet_vars:', '                err = f\"Cannot facet the {multi_dim} while pairing on `{pair_axis}``.\"', '            elif wrap_dim[:3] in facet_vars and facet_spec.get(\"wrap\"):', '                err = f\"Cannot wrap the {wrap_dim} while pairing on `{pair_axis}``.\"', '            elif wrap_dim[:3] in facet_vars and pair_spec.get(\"wrap\"):', '                err = f\"Cannot wrap the {multi_dim} while faceting the {wrap_dim}.\"', '', '        if err is not None:', '            raise RuntimeError(err)  # TODO what err class? Define PlotSpecError?', '', '    def _determine_grid_dimensions(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Parse faceting and pairing information to define figure structure.\"\"\"', '        self.grid_dimensions: dict[str, list] = {}', '        for dim, axis in zip([\"col\", \"row\"], [\"x\", \"y\"]):', '', '            facet_vars = facet_spec.get(\"variables\", {})', '            if dim in facet_vars:', '                self.grid_dimensions[dim] = facet_spec[\"structure\"][dim]', '            elif axis in pair_spec.get(\"structure\", {}):', '                self.grid_dimensions[dim] = [', '                    None for _ in pair_spec.get(\"structure\", {})[axis]', '                ]', '            else:', '                self.grid_dimensions[dim] = [None]', '', '            self.subplot_spec[f\"n{dim}s\"] = len(self.grid_dimensions[dim])', '', '        if not pair_spec.get(\"cross\", True):', '            self.subplot_spec[\"nrows\"] = 1', '', '        self.n_subplots = self.subplot_spec[\"ncols\"] * self.subplot_spec[\"nrows\"]', '', '    def _handle_wrapping(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Update figure structure parameters based on facet/pair wrapping.\"\"\"', '        self.wrap = wrap = facet_spec.get(\"wrap\") or pair_spec.get(\"wrap\")', '        if not wrap:', '            return', '', '        wrap_dim = \"row\" if self.subplot_spec[\"nrows\"] > 1 else \"col\"', '        flow_dim = {\"row\": \"col\", \"col\": \"row\"}[wrap_dim]', '        n_subplots = self.subplot_spec[f\"n{wrap_dim}s\"]', '        flow = int(np.ceil(n_subplots / wrap))', '', '        if wrap < self.subplot_spec[f\"n{wrap_dim}s\"]:', '            self.subplot_spec[f\"n{wrap_dim}s\"] = wrap', '        self.subplot_spec[f\"n{flow_dim}s\"] = flow', '        self.n_subplots = n_subplots', '        self.wrap_dim = wrap_dim', '', '    def _determine_axis_sharing(self, pair_spec: PairSpec) -> None:', '        \"\"\"Update subplot spec with default or specified axis sharing parameters.\"\"\"', '        axis_to_dim = {\"x\": \"col\", \"y\": \"row\"}', '        key: str', '        val: str | bool', '        for axis in \"xy\":', '            key = f\"share{axis}\"', '            # Always use user-specified value, if present', '            if key not in self.subplot_spec:', '                if axis in pair_spec.get(\"structure\", {}):', '                    # Paired axes are shared along one dimension by default', '                    if self.wrap is None and pair_spec.get(\"cross\", True):', '                        val = axis_to_dim[axis]', '                    else:', '                        val = False', '                else:', '                    # This will pick up faceted plots, as well as single subplot', \"                    # figures, where the value doesn't really matter\", '                    val = True', '                self.subplot_spec[key] = val', '', '    def init_figure(', '        self,', '        pair_spec: PairSpec,', '        pyplot: bool = False,', '        figure_kws: dict | None = None,', '        target: Axes | Figure | SubFigure = None,', '    ) -> Figure:', '        \"\"\"Initialize matplotlib objects and add seaborn-relevant metadata.\"\"\"', '        # TODO reduce need to pass pair_spec here?', '', '        if figure_kws is None:', '            figure_kws = {}', '', '        if isinstance(target, mpl.axes.Axes):', '', '            if max(self.subplot_spec[\"nrows\"], self.subplot_spec[\"ncols\"]) > 1:', '                err = \" \".join([', '                    \"Cannot create multiple subplots after calling `Plot.on` with\",', '                    f\"a {mpl.axes.Axes} object.\",', '                ])', '                try:', '                    err += f\" You may want to use a {mpl.figure.SubFigure} instead.\"', '                except AttributeError:  # SubFigure added in mpl 3.4', '                    pass', '                raise RuntimeError(err)', '', '            self._subplot_list = [{', '                \"ax\": target,', '                \"left\": True,', '                \"right\": True,', '                \"top\": True,', '                \"bottom\": True,', '                \"col\": None,', '                \"row\": None,', '                \"x\": \"x\",', '                \"y\": \"y\",', '            }]', '            self._figure = target.figure', '            return self._figure', '', '        elif (', '            hasattr(mpl.figure, \"SubFigure\")  # Added in mpl 3.4', '            and isinstance(target, mpl.figure.SubFigure)', '        ):', '            figure = target.figure', '        elif isinstance(target, mpl.figure.Figure):', '            figure = target', '        else:', '            if pyplot:', '                figure = plt.figure(**figure_kws)', '            else:', '                figure = mpl.figure.Figure(**figure_kws)', '            target = figure', '        self._figure = figure', '', '        axs = target.subplots(**self.subplot_spec, squeeze=False)', '', '        if self.wrap:', '            # Remove unused Axes and flatten the rest into a (2D) vector', '            axs_flat = axs.ravel({\"col\": \"C\", \"row\": \"F\"}[self.wrap_dim])', '            axs, extra = np.split(axs_flat, [self.n_subplots])', '            for ax in extra:', '                ax.remove()', '            if self.wrap_dim == \"col\":', '                axs = axs[np.newaxis, :]', '            else:', '                axs = axs[:, np.newaxis]', '', '        # Get i, j coordinates for each Axes object', '        # Note that i, j are with respect to faceting/pairing,', '        # not the subplot grid itself, (which only matters in the case of wrapping).', '        iter_axs: np.ndenumerate | zip', '        if not pair_spec.get(\"cross\", True):', '            indices = np.arange(self.n_subplots)', '            iter_axs = zip(zip(indices, indices), axs.flat)', '        else:', '            iter_axs = np.ndenumerate(axs)', '', '        self._subplot_list = []', '        for (i, j), ax in iter_axs:', '', '            info = {\"ax\": ax}', '', '            nrows, ncols = self.subplot_spec[\"nrows\"], self.subplot_spec[\"ncols\"]', '            if not self.wrap:', '                info[\"left\"] = j % ncols == 0', '                info[\"right\"] = (j + 1) % ncols == 0', '                info[\"top\"] = i == 0', '                info[\"bottom\"] = i == nrows - 1', '            elif self.wrap_dim == \"col\":', '                info[\"left\"] = j % ncols == 0', '                info[\"right\"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)', '                info[\"top\"] = j < ncols', '                info[\"bottom\"] = j >= (self.n_subplots - ncols)', '            elif self.wrap_dim == \"row\":', '                info[\"left\"] = i < nrows', '                info[\"right\"] = i >= self.n_subplots - nrows', '                info[\"top\"] = i % nrows == 0', '                info[\"bottom\"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)', '', '            if not pair_spec.get(\"cross\", True):', '                info[\"top\"] = j < ncols', '                info[\"bottom\"] = j >= self.n_subplots - ncols', '', '            for dim in [\"row\", \"col\"]:', '                idx = {\"row\": i, \"col\": j}[dim]', '                info[dim] = self.grid_dimensions[dim][idx]', '', '            for axis in \"xy\":', '', '                idx = {\"x\": j, \"y\": i}[axis]', '                if axis in pair_spec.get(\"structure\", {}):', '                    key = f\"{axis}{idx}\"', '                else:', '                    key = axis', '                info[axis] = key', '', '            self._subplot_list.append(info)', '', '        return figure', '', '    def __iter__(self) -> Generator[dict, None, None]:  # TODO TypedDict?', '        \"\"\"Yield each subplot dictionary with Axes object and metadata.\"\"\"', '        yield from self._subplot_list', '', '    def __len__(self) -> int:', '        \"\"\"Return the number of subplots in this figure.\"\"\"', '        return len(self._subplot_list)'], 'methods': [{'name': '__init__', 'start_line': 32, 'end_line': 44, 'text': ['    def __init__(', '        self,', '        subplot_spec: dict,  # TODO define as TypedDict', '        facet_spec: FacetSpec,', '        pair_spec: PairSpec,', '    ):', '', '        self.subplot_spec = subplot_spec', '', '        self._check_dimension_uniqueness(facet_spec, pair_spec)', '        self._determine_grid_dimensions(facet_spec, pair_spec)', '        self._handle_wrapping(facet_spec, pair_spec)', '        self._determine_axis_sharing(pair_spec)']}, {'name': '_check_dimension_uniqueness', 'start_line': 46, 'end_line': 76, 'text': ['    def _check_dimension_uniqueness(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Reject specs that pair and facet on (or wrap to) same figure dimension.\"\"\"', '        err = None', '', '        facet_vars = facet_spec.get(\"variables\", {})', '', '        if facet_spec.get(\"wrap\") and {\"col\", \"row\"} <= set(facet_vars):', '            err = \"Cannot wrap facets when specifying both `col` and `row`.\"', '        elif (', '            pair_spec.get(\"wrap\")', '            and pair_spec.get(\"cross\", True)', '            and len(pair_spec.get(\"structure\", {}).get(\"x\", [])) > 1', '            and len(pair_spec.get(\"structure\", {}).get(\"y\", [])) > 1', '        ):', '            err = \"Cannot wrap subplots when pairing on both `x` and `y`.\"', '', '        collisions = {\"x\": [\"columns\", \"rows\"], \"y\": [\"rows\", \"columns\"]}', '        for pair_axis, (multi_dim, wrap_dim) in collisions.items():', '            if pair_axis not in pair_spec.get(\"structure\", {}):', '                continue', '            elif multi_dim[:3] in facet_vars:', '                err = f\"Cannot facet the {multi_dim} while pairing on `{pair_axis}``.\"', '            elif wrap_dim[:3] in facet_vars and facet_spec.get(\"wrap\"):', '                err = f\"Cannot wrap the {wrap_dim} while pairing on `{pair_axis}``.\"', '            elif wrap_dim[:3] in facet_vars and pair_spec.get(\"wrap\"):', '                err = f\"Cannot wrap the {multi_dim} while faceting the {wrap_dim}.\"', '', '        if err is not None:', '            raise RuntimeError(err)  # TODO what err class? Define PlotSpecError?']}, {'name': '_determine_grid_dimensions', 'start_line': 78, 'end_line': 100, 'text': ['    def _determine_grid_dimensions(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Parse faceting and pairing information to define figure structure.\"\"\"', '        self.grid_dimensions: dict[str, list] = {}', '        for dim, axis in zip([\"col\", \"row\"], [\"x\", \"y\"]):', '', '            facet_vars = facet_spec.get(\"variables\", {})', '            if dim in facet_vars:', '                self.grid_dimensions[dim] = facet_spec[\"structure\"][dim]', '            elif axis in pair_spec.get(\"structure\", {}):', '                self.grid_dimensions[dim] = [', '                    None for _ in pair_spec.get(\"structure\", {})[axis]', '                ]', '            else:', '                self.grid_dimensions[dim] = [None]', '', '            self.subplot_spec[f\"n{dim}s\"] = len(self.grid_dimensions[dim])', '', '        if not pair_spec.get(\"cross\", True):', '            self.subplot_spec[\"nrows\"] = 1', '', '        self.n_subplots = self.subplot_spec[\"ncols\"] * self.subplot_spec[\"nrows\"]']}, {'name': '_handle_wrapping', 'start_line': 102, 'end_line': 119, 'text': ['    def _handle_wrapping(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Update figure structure parameters based on facet/pair wrapping.\"\"\"', '        self.wrap = wrap = facet_spec.get(\"wrap\") or pair_spec.get(\"wrap\")', '        if not wrap:', '            return', '', '        wrap_dim = \"row\" if self.subplot_spec[\"nrows\"] > 1 else \"col\"', '        flow_dim = {\"row\": \"col\", \"col\": \"row\"}[wrap_dim]', '        n_subplots = self.subplot_spec[f\"n{wrap_dim}s\"]', '        flow = int(np.ceil(n_subplots / wrap))', '', '        if wrap < self.subplot_spec[f\"n{wrap_dim}s\"]:', '            self.subplot_spec[f\"n{wrap_dim}s\"] = wrap', '        self.subplot_spec[f\"n{flow_dim}s\"] = flow', '        self.n_subplots = n_subplots', '        self.wrap_dim = wrap_dim']}, {'name': '_determine_axis_sharing', 'start_line': 121, 'end_line': 140, 'text': ['    def _determine_axis_sharing(self, pair_spec: PairSpec) -> None:', '        \"\"\"Update subplot spec with default or specified axis sharing parameters.\"\"\"', '        axis_to_dim = {\"x\": \"col\", \"y\": \"row\"}', '        key: str', '        val: str | bool', '        for axis in \"xy\":', '            key = f\"share{axis}\"', '            # Always use user-specified value, if present', '            if key not in self.subplot_spec:', '                if axis in pair_spec.get(\"structure\", {}):', '                    # Paired axes are shared along one dimension by default', '                    if self.wrap is None and pair_spec.get(\"cross\", True):', '                        val = axis_to_dim[axis]', '                    else:', '                        val = False', '                else:', '                    # This will pick up faceted plots, as well as single subplot', \"                    # figures, where the value doesn't really matter\", '                    val = True', '                self.subplot_spec[key] = val']}, {'name': 'init_figure', 'start_line': 142, 'end_line': 261, 'text': ['    def init_figure(', '        self,', '        pair_spec: PairSpec,', '        pyplot: bool = False,', '        figure_kws: dict | None = None,', '        target: Axes | Figure | SubFigure = None,', '    ) -> Figure:', '        \"\"\"Initialize matplotlib objects and add seaborn-relevant metadata.\"\"\"', '        # TODO reduce need to pass pair_spec here?', '', '        if figure_kws is None:', '            figure_kws = {}', '', '        if isinstance(target, mpl.axes.Axes):', '', '            if max(self.subplot_spec[\"nrows\"], self.subplot_spec[\"ncols\"]) > 1:', '                err = \" \".join([', '                    \"Cannot create multiple subplots after calling `Plot.on` with\",', '                    f\"a {mpl.axes.Axes} object.\",', '                ])', '                try:', '                    err += f\" You may want to use a {mpl.figure.SubFigure} instead.\"', '                except AttributeError:  # SubFigure added in mpl 3.4', '                    pass', '                raise RuntimeError(err)', '', '            self._subplot_list = [{', '                \"ax\": target,', '                \"left\": True,', '                \"right\": True,', '                \"top\": True,', '                \"bottom\": True,', '                \"col\": None,', '                \"row\": None,', '                \"x\": \"x\",', '                \"y\": \"y\",', '            }]', '            self._figure = target.figure', '            return self._figure', '', '        elif (', '            hasattr(mpl.figure, \"SubFigure\")  # Added in mpl 3.4', '            and isinstance(target, mpl.figure.SubFigure)', '        ):', '            figure = target.figure', '        elif isinstance(target, mpl.figure.Figure):', '            figure = target', '        else:', '            if pyplot:', '                figure = plt.figure(**figure_kws)', '            else:', '                figure = mpl.figure.Figure(**figure_kws)', '            target = figure', '        self._figure = figure', '', '        axs = target.subplots(**self.subplot_spec, squeeze=False)', '', '        if self.wrap:', '            # Remove unused Axes and flatten the rest into a (2D) vector', '            axs_flat = axs.ravel({\"col\": \"C\", \"row\": \"F\"}[self.wrap_dim])', '            axs, extra = np.split(axs_flat, [self.n_subplots])', '            for ax in extra:', '                ax.remove()', '            if self.wrap_dim == \"col\":', '                axs = axs[np.newaxis, :]', '            else:', '                axs = axs[:, np.newaxis]', '', '        # Get i, j coordinates for each Axes object', '        # Note that i, j are with respect to faceting/pairing,', '        # not the subplot grid itself, (which only matters in the case of wrapping).', '        iter_axs: np.ndenumerate | zip', '        if not pair_spec.get(\"cross\", True):', '            indices = np.arange(self.n_subplots)', '            iter_axs = zip(zip(indices, indices), axs.flat)', '        else:', '            iter_axs = np.ndenumerate(axs)', '', '        self._subplot_list = []', '        for (i, j), ax in iter_axs:', '', '            info = {\"ax\": ax}', '', '            nrows, ncols = self.subplot_spec[\"nrows\"], self.subplot_spec[\"ncols\"]', '            if not self.wrap:', '                info[\"left\"] = j % ncols == 0', '                info[\"right\"] = (j + 1) % ncols == 0', '                info[\"top\"] = i == 0', '                info[\"bottom\"] = i == nrows - 1', '            elif self.wrap_dim == \"col\":', '                info[\"left\"] = j % ncols == 0', '                info[\"right\"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)', '                info[\"top\"] = j < ncols', '                info[\"bottom\"] = j >= (self.n_subplots - ncols)', '            elif self.wrap_dim == \"row\":', '                info[\"left\"] = i < nrows', '                info[\"right\"] = i >= self.n_subplots - nrows', '                info[\"top\"] = i % nrows == 0', '                info[\"bottom\"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)', '', '            if not pair_spec.get(\"cross\", True):', '                info[\"top\"] = j < ncols', '                info[\"bottom\"] = j >= self.n_subplots - ncols', '', '            for dim in [\"row\", \"col\"]:', '                idx = {\"row\": i, \"col\": j}[dim]', '                info[dim] = self.grid_dimensions[dim][idx]', '', '            for axis in \"xy\":', '', '                idx = {\"x\": j, \"y\": i}[axis]', '                if axis in pair_spec.get(\"structure\", {}):', '                    key = f\"{axis}{idx}\"', '                else:', '                    key = axis', '                info[axis] = key', '', '            self._subplot_list.append(info)', '', '        return figure']}, {'name': '__iter__', 'start_line': 263, 'end_line': 265, 'text': ['    def __iter__(self) -> Generator[dict, None, None]:  # TODO TypedDict?', '        \"\"\"Yield each subplot dictionary with Axes object and metadata.\"\"\"', '        yield from self._subplot_list']}, {'name': '__len__', 'start_line': 267, 'end_line': 269, 'text': ['    def __len__(self) -> int:', '        \"\"\"Return the number of subplots in this figure.\"\"\"', '        return len(self._subplot_list)']}]}], 'functions': [], 'text': ['from __future__ import annotations', 'from collections.abc import Generator', '', 'import numpy as np', 'import matplotlib as mpl', 'import matplotlib.pyplot as plt', '', 'from matplotlib.axes import Axes', 'from matplotlib.figure import Figure', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:  # TODO move to seaborn._core.typing?', '    from seaborn._core.plot import FacetSpec, PairSpec', '    from matplotlib.figure import SubFigure', '', '', 'class Subplots:', '    \"\"\"', '    Interface for creating and using matplotlib subplots based on seaborn parameters.', '', '    Parameters', '    ----------', '    subplot_spec : dict', '        Keyword args for :meth:`matplotlib.figure.Figure.subplots`.', '    facet_spec : dict', '        Parameters that control subplot faceting.', '    pair_spec : dict', '        Parameters that control subplot pairing.', '    data : PlotData', '        Data used to define figure setup.', '', '    \"\"\"', '    def __init__(', '        self,', '        subplot_spec: dict,  # TODO define as TypedDict', '        facet_spec: FacetSpec,', '        pair_spec: PairSpec,', '    ):', '', '        self.subplot_spec = subplot_spec', '', '        self._check_dimension_uniqueness(facet_spec, pair_spec)', '        self._determine_grid_dimensions(facet_spec, pair_spec)', '        self._handle_wrapping(facet_spec, pair_spec)', '        self._determine_axis_sharing(pair_spec)', '', '    def _check_dimension_uniqueness(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Reject specs that pair and facet on (or wrap to) same figure dimension.\"\"\"', '        err = None', '', '        facet_vars = facet_spec.get(\"variables\", {})', '', '        if facet_spec.get(\"wrap\") and {\"col\", \"row\"} <= set(facet_vars):', '            err = \"Cannot wrap facets when specifying both `col` and `row`.\"', '        elif (', '            pair_spec.get(\"wrap\")', '            and pair_spec.get(\"cross\", True)', '            and len(pair_spec.get(\"structure\", {}).get(\"x\", [])) > 1', '            and len(pair_spec.get(\"structure\", {}).get(\"y\", [])) > 1', '        ):', '            err = \"Cannot wrap subplots when pairing on both `x` and `y`.\"', '', '        collisions = {\"x\": [\"columns\", \"rows\"], \"y\": [\"rows\", \"columns\"]}', '        for pair_axis, (multi_dim, wrap_dim) in collisions.items():', '            if pair_axis not in pair_spec.get(\"structure\", {}):', '                continue', '            elif multi_dim[:3] in facet_vars:', '                err = f\"Cannot facet the {multi_dim} while pairing on `{pair_axis}``.\"', '            elif wrap_dim[:3] in facet_vars and facet_spec.get(\"wrap\"):', '                err = f\"Cannot wrap the {wrap_dim} while pairing on `{pair_axis}``.\"', '            elif wrap_dim[:3] in facet_vars and pair_spec.get(\"wrap\"):', '                err = f\"Cannot wrap the {multi_dim} while faceting the {wrap_dim}.\"', '', '        if err is not None:', '            raise RuntimeError(err)  # TODO what err class? Define PlotSpecError?', '', '    def _determine_grid_dimensions(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Parse faceting and pairing information to define figure structure.\"\"\"', '        self.grid_dimensions: dict[str, list] = {}', '        for dim, axis in zip([\"col\", \"row\"], [\"x\", \"y\"]):', '', '            facet_vars = facet_spec.get(\"variables\", {})', '            if dim in facet_vars:', '                self.grid_dimensions[dim] = facet_spec[\"structure\"][dim]', '            elif axis in pair_spec.get(\"structure\", {}):', '                self.grid_dimensions[dim] = [', '                    None for _ in pair_spec.get(\"structure\", {})[axis]', '                ]', '            else:', '                self.grid_dimensions[dim] = [None]', '', '            self.subplot_spec[f\"n{dim}s\"] = len(self.grid_dimensions[dim])', '', '        if not pair_spec.get(\"cross\", True):', '            self.subplot_spec[\"nrows\"] = 1', '', '        self.n_subplots = self.subplot_spec[\"ncols\"] * self.subplot_spec[\"nrows\"]', '', '    def _handle_wrapping(', '        self, facet_spec: FacetSpec, pair_spec: PairSpec', '    ) -> None:', '        \"\"\"Update figure structure parameters based on facet/pair wrapping.\"\"\"', '        self.wrap = wrap = facet_spec.get(\"wrap\") or pair_spec.get(\"wrap\")', '        if not wrap:', '            return', '', '        wrap_dim = \"row\" if self.subplot_spec[\"nrows\"] > 1 else \"col\"', '        flow_dim = {\"row\": \"col\", \"col\": \"row\"}[wrap_dim]', '        n_subplots = self.subplot_spec[f\"n{wrap_dim}s\"]', '        flow = int(np.ceil(n_subplots / wrap))', '', '        if wrap < self.subplot_spec[f\"n{wrap_dim}s\"]:', '            self.subplot_spec[f\"n{wrap_dim}s\"] = wrap', '        self.subplot_spec[f\"n{flow_dim}s\"] = flow', '        self.n_subplots = n_subplots', '        self.wrap_dim = wrap_dim', '', '    def _determine_axis_sharing(self, pair_spec: PairSpec) -> None:', '        \"\"\"Update subplot spec with default or specified axis sharing parameters.\"\"\"', '        axis_to_dim = {\"x\": \"col\", \"y\": \"row\"}', '        key: str', '        val: str | bool', '        for axis in \"xy\":', '            key = f\"share{axis}\"', '            # Always use user-specified value, if present', '            if key not in self.subplot_spec:', '                if axis in pair_spec.get(\"structure\", {}):', '                    # Paired axes are shared along one dimension by default', '                    if self.wrap is None and pair_spec.get(\"cross\", True):', '                        val = axis_to_dim[axis]', '                    else:', '                        val = False', '                else:', '                    # This will pick up faceted plots, as well as single subplot', \"                    # figures, where the value doesn't really matter\", '                    val = True', '                self.subplot_spec[key] = val', '', '    def init_figure(', '        self,', '        pair_spec: PairSpec,', '        pyplot: bool = False,', '        figure_kws: dict | None = None,', '        target: Axes | Figure | SubFigure = None,', '    ) -> Figure:', '        \"\"\"Initialize matplotlib objects and add seaborn-relevant metadata.\"\"\"', '        # TODO reduce need to pass pair_spec here?', '', '        if figure_kws is None:', '            figure_kws = {}', '', '        if isinstance(target, mpl.axes.Axes):', '', '            if max(self.subplot_spec[\"nrows\"], self.subplot_spec[\"ncols\"]) > 1:', '                err = \" \".join([', '                    \"Cannot create multiple subplots after calling `Plot.on` with\",', '                    f\"a {mpl.axes.Axes} object.\",', '                ])', '                try:', '                    err += f\" You may want to use a {mpl.figure.SubFigure} instead.\"', '                except AttributeError:  # SubFigure added in mpl 3.4', '                    pass', '                raise RuntimeError(err)', '', '            self._subplot_list = [{', '                \"ax\": target,', '                \"left\": True,', '                \"right\": True,', '                \"top\": True,', '                \"bottom\": True,', '                \"col\": None,', '                \"row\": None,', '                \"x\": \"x\",', '                \"y\": \"y\",', '            }]', '            self._figure = target.figure', '            return self._figure', '', '        elif (', '            hasattr(mpl.figure, \"SubFigure\")  # Added in mpl 3.4', '            and isinstance(target, mpl.figure.SubFigure)', '        ):', '            figure = target.figure', '        elif isinstance(target, mpl.figure.Figure):', '            figure = target', '        else:', '            if pyplot:', '                figure = plt.figure(**figure_kws)', '            else:', '                figure = mpl.figure.Figure(**figure_kws)', '            target = figure', '        self._figure = figure', '', '        axs = target.subplots(**self.subplot_spec, squeeze=False)', '', '        if self.wrap:', '            # Remove unused Axes and flatten the rest into a (2D) vector', '            axs_flat = axs.ravel({\"col\": \"C\", \"row\": \"F\"}[self.wrap_dim])', '            axs, extra = np.split(axs_flat, [self.n_subplots])', '            for ax in extra:', '                ax.remove()', '            if self.wrap_dim == \"col\":', '                axs = axs[np.newaxis, :]', '            else:', '                axs = axs[:, np.newaxis]', '', '        # Get i, j coordinates for each Axes object', '        # Note that i, j are with respect to faceting/pairing,', '        # not the subplot grid itself, (which only matters in the case of wrapping).', '        iter_axs: np.ndenumerate | zip', '        if not pair_spec.get(\"cross\", True):', '            indices = np.arange(self.n_subplots)', '            iter_axs = zip(zip(indices, indices), axs.flat)', '        else:', '            iter_axs = np.ndenumerate(axs)', '', '        self._subplot_list = []', '        for (i, j), ax in iter_axs:', '', '            info = {\"ax\": ax}', '', '            nrows, ncols = self.subplot_spec[\"nrows\"], self.subplot_spec[\"ncols\"]', '            if not self.wrap:', '                info[\"left\"] = j % ncols == 0', '                info[\"right\"] = (j + 1) % ncols == 0', '                info[\"top\"] = i == 0', '                info[\"bottom\"] = i == nrows - 1', '            elif self.wrap_dim == \"col\":', '                info[\"left\"] = j % ncols == 0', '                info[\"right\"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)', '                info[\"top\"] = j < ncols', '                info[\"bottom\"] = j >= (self.n_subplots - ncols)', '            elif self.wrap_dim == \"row\":', '                info[\"left\"] = i < nrows', '                info[\"right\"] = i >= self.n_subplots - nrows', '                info[\"top\"] = i % nrows == 0', '                info[\"bottom\"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)', '', '            if not pair_spec.get(\"cross\", True):', '                info[\"top\"] = j < ncols', '                info[\"bottom\"] = j >= self.n_subplots - ncols', '', '            for dim in [\"row\", \"col\"]:', '                idx = {\"row\": i, \"col\": j}[dim]', '                info[dim] = self.grid_dimensions[dim][idx]', '', '            for axis in \"xy\":', '', '                idx = {\"x\": j, \"y\": i}[axis]', '                if axis in pair_spec.get(\"structure\", {}):', '                    key = f\"{axis}{idx}\"', '                else:', '                    key = axis', '                info[axis] = key', '', '            self._subplot_list.append(info)', '', '        return figure', '', '    def __iter__(self) -> Generator[dict, None, None]:  # TODO TypedDict?', '        \"\"\"Yield each subplot dictionary with Axes object and metadata.\"\"\"', '        yield from self._subplot_list', '', '    def __len__(self) -> int:', '        \"\"\"Return the number of subplots in this figure.\"\"\"', '        return len(self._subplot_list)']}, 'scales.py': {'classes': [{'name': 'Scale', 'start_line': 53, 'end_line': 134, 'text': ['class Scale:', '    \"\"\"Base class for objects that map data values to visual properties.\"\"\"', '', '    values: tuple | str | list | dict | None', '', '    _priority: ClassVar[int]', '    _pipeline: Pipeline', '    _matplotlib_scale: ScaleBase', '    _spacer: staticmethod', '    _legend: tuple[list[str], list[Any]] | None', '', '    def __post_init__(self):', '', '        self._tick_params = None', '        self._label_params = None', '        self._legend = None', '', '    def tick(self):', '        raise NotImplementedError()', '', '    def label(self):', '        raise NotImplementedError()', '', '    def _get_locators(self):', '        raise NotImplementedError()', '', '    def _get_formatter(self, locator: Locator | None = None):', '        raise NotImplementedError()', '', '    def _get_scale(self, name: str, forward: Callable, inverse: Callable):', '', '        major_locator, minor_locator = self._get_locators(**self._tick_params)', '        major_formatter = self._get_formatter(major_locator, **self._label_params)', '', '        class InternalScale(mpl.scale.FuncScale):', '            def set_default_locators_and_formatters(self, axis):', '                axis.set_major_locator(major_locator)', '                if minor_locator is not None:', '                    axis.set_minor_locator(minor_locator)', '                axis.set_major_formatter(major_formatter)', '', '        return InternalScale(name, (forward, inverse))', '', '    def _spacing(self, x: Series) -> float:', '        return self._spacer(x)', '', '    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '        raise NotImplementedError()', '', '    def __call__(self, data: Series) -> ArrayLike:', '', '        trans_data: Series | NDArray | list', '', '        # TODO sometimes we need to handle scalars (e.g. for Line)', '        # but what is the best way to do that?', '        scalar_data = np.isscalar(data)', '        if scalar_data:', '            trans_data = np.array([data])', '        else:', '            trans_data = data', '', '        for func in self._pipeline:', '            if func is not None:', '                trans_data = func(trans_data)', '', '        if scalar_data:', '            return trans_data[0]', '        else:', '            return trans_data', '', '    @staticmethod', '    def _identity():', '', '        class Identity(Scale):', '            _pipeline = []', '            _spacer = None', '            _legend = None', '            _matplotlib_scale = None', '', '        return Identity()'], 'methods': [{'name': '__post_init__', 'start_line': 64, 'end_line': 68, 'text': ['    def __post_init__(self):', '', '        self._tick_params = None', '        self._label_params = None', '        self._legend = None']}, {'name': 'tick', 'start_line': 70, 'end_line': 71, 'text': ['    def tick(self):', '        raise NotImplementedError()']}, {'name': 'label', 'start_line': 73, 'end_line': 74, 'text': ['    def label(self):', '        raise NotImplementedError()']}, {'name': '_get_locators', 'start_line': 76, 'end_line': 77, 'text': ['    def _get_locators(self):', '        raise NotImplementedError()']}, {'name': '_get_formatter', 'start_line': 79, 'end_line': 80, 'text': ['    def _get_formatter(self, locator: Locator | None = None):', '        raise NotImplementedError()']}, {'name': '_get_scale', 'start_line': 82, 'end_line': 94, 'text': ['    def _get_scale(self, name: str, forward: Callable, inverse: Callable):', '', '        major_locator, minor_locator = self._get_locators(**self._tick_params)', '        major_formatter = self._get_formatter(major_locator, **self._label_params)', '', '        class InternalScale(mpl.scale.FuncScale):', '            def set_default_locators_and_formatters(self, axis):', '                axis.set_major_locator(major_locator)', '                if minor_locator is not None:', '                    axis.set_minor_locator(minor_locator)', '                axis.set_major_formatter(major_formatter)', '', '        return InternalScale(name, (forward, inverse))']}, {'name': '_spacing', 'start_line': 96, 'end_line': 97, 'text': ['    def _spacing(self, x: Series) -> float:', '        return self._spacer(x)']}, {'name': '_setup', 'start_line': 99, 'end_line': 102, 'text': ['    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '        raise NotImplementedError()']}, {'name': '__call__', 'start_line': 104, 'end_line': 123, 'text': ['    def __call__(self, data: Series) -> ArrayLike:', '', '        trans_data: Series | NDArray | list', '', '        # TODO sometimes we need to handle scalars (e.g. for Line)', '        # but what is the best way to do that?', '        scalar_data = np.isscalar(data)', '        if scalar_data:', '            trans_data = np.array([data])', '        else:', '            trans_data = data', '', '        for func in self._pipeline:', '            if func is not None:', '                trans_data = func(trans_data)', '', '        if scalar_data:', '            return trans_data[0]', '        else:', '            return trans_data']}, {'name': '_identity', 'start_line': 126, 'end_line': 134, 'text': ['    def _identity():', '', '        class Identity(Scale):', '            _pipeline = []', '            _spacer = None', '            _legend = None', '            _matplotlib_scale = None', '', '        return Identity()']}]}, {'name': 'Nominal', 'start_line': 138, 'end_line': 295, 'text': ['class Nominal(Scale):', '    \"\"\"', '    A categorical scale without relative importance / magnitude.', '    \"\"\"', '    # Categorical (convert to strings), un-sortable', '', '    values: tuple | str | list | dict | None = None', '    order: list | None = None', '', '    _priority: ClassVar[int] = 3', '', '    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '', '        new = copy(self)', '        if new._tick_params is None:', '            new = new.tick()', '        if new._label_params is None:', '            new = new.label()', '', \"        # TODO flexibility over format() which isn't great for numbers / dates\", '        stringify = np.vectorize(format)', '', '        units_seed = categorical_order(data, new.order)', '', '        # TODO move to Nominal._get_scale?', '        # TODO this needs some more complicated rethinking about how to pass', '        # a unit dictionary down to these methods, along with how much we want', '        # to invest in their API. What is it useful for tick() to do here?', '        # (Ordinal may be different if we draw that contrast).', '        # Any customization we do to allow, e.g., label wrapping will probably', '        # require defining our own Formatter subclass.', '        # We could also potentially implement auto-wrapping in an Axis subclass', '        # (see Axis.draw ... it already is computing the bboxes).', '        # major_locator, minor_locator = new._get_locators(**new._tick_params)', '        # major_formatter = new._get_formatter(major_locator, **new._label_params)', '', '        class CatScale(mpl.scale.LinearScale):', '            name = None  # To work around mpl<3.4 compat issues', '', '            def set_default_locators_and_formatters(self, axis):', '                ...', '                # axis.set_major_locator(major_locator)', '                # if minor_locator is not None:', '                #     axis.set_minor_locator(minor_locator)', '                # axis.set_major_formatter(major_formatter)', '', '        mpl_scale = CatScale(data.name)', '        if axis is None:', '            axis = PseudoAxis(mpl_scale)', '', '            # TODO Currently just used in non-Coordinate contexts, but should', '            # we use this to (A) set the padding we want for categorial plots', '            # and (B) allow the values parameter for a Coordinate to set xlim/ylim', '            axis.set_view_interval(0, len(units_seed) - 1)', '', '        new._matplotlib_scale = mpl_scale', '', '        # TODO array cast necessary to handle float/int mixture, which we need', '        # to solve in a more systematic way probably', '        # (i.e. if we have [1, 2.5], do we want [1.0, 2.5]? Unclear)', '        axis.update_units(stringify(np.array(units_seed)))', '', '        # TODO define this more centrally', '        def convert_units(x):', '            # TODO only do this with explicit order?', '            # (But also category dtype?)', '            # TODO isin fails when units_seed mixes numbers and strings (numpy error?)', '            # but np.isin also does not seem any faster? (Maybe not broadcasting in C)', '            # keep = x.isin(units_seed)', '            keep = np.array([x_ in units_seed for x_ in x], bool)', '            out = np.full(len(x), np.nan)', '            out[keep] = axis.convert_units(stringify(x[keep]))', '            return out', '', '        new._pipeline = [', '            convert_units,', '            prop.get_mapping(new, data),', '            # TODO how to handle color representation consistency?', '        ]', '', '        def spacer(x):', '            return 1', '', '        new._spacer = spacer', '', '        if prop.legend:', '            new._legend = units_seed, list(stringify(units_seed))', '', '        return new', '', '    def tick(self, locator: Locator | None = None):', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '            At the moment, it is probably not very useful.', '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '', '        Returns', '        -------', '        Copy of self with new tick configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._tick_params = {', '            \"locator\": locator,', '        }', '        return new', '', '    def label(self, formatter: Formatter | None = None):', '        \"\"\"', \"        Configure the selection of labels for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '            At the moment, it is probably not very useful.', '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured matplotlib formatter; other parameters will not be used.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._label_params = {', '            \"formatter\": formatter,', '        }', '        return new', '', '    def _get_locators(self, locator):', '', '        if locator is not None:', '            return locator, None', '', '        locator = mpl.category.StrCategoryLocator({})', '', '        return locator, None', '', '    def _get_formatter(self, locator, formatter):', '', '        if formatter is not None:', '            return formatter', '', '        formatter = mpl.category.StrCategoryFormatter({})', '', '        return formatter'], 'methods': [{'name': '_setup', 'start_line': 149, 'end_line': 228, 'text': ['    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '', '        new = copy(self)', '        if new._tick_params is None:', '            new = new.tick()', '        if new._label_params is None:', '            new = new.label()', '', \"        # TODO flexibility over format() which isn't great for numbers / dates\", '        stringify = np.vectorize(format)', '', '        units_seed = categorical_order(data, new.order)', '', '        # TODO move to Nominal._get_scale?', '        # TODO this needs some more complicated rethinking about how to pass', '        # a unit dictionary down to these methods, along with how much we want', '        # to invest in their API. What is it useful for tick() to do here?', '        # (Ordinal may be different if we draw that contrast).', '        # Any customization we do to allow, e.g., label wrapping will probably', '        # require defining our own Formatter subclass.', '        # We could also potentially implement auto-wrapping in an Axis subclass', '        # (see Axis.draw ... it already is computing the bboxes).', '        # major_locator, minor_locator = new._get_locators(**new._tick_params)', '        # major_formatter = new._get_formatter(major_locator, **new._label_params)', '', '        class CatScale(mpl.scale.LinearScale):', '            name = None  # To work around mpl<3.4 compat issues', '', '            def set_default_locators_and_formatters(self, axis):', '                ...', '                # axis.set_major_locator(major_locator)', '                # if minor_locator is not None:', '                #     axis.set_minor_locator(minor_locator)', '                # axis.set_major_formatter(major_formatter)', '', '        mpl_scale = CatScale(data.name)', '        if axis is None:', '            axis = PseudoAxis(mpl_scale)', '', '            # TODO Currently just used in non-Coordinate contexts, but should', '            # we use this to (A) set the padding we want for categorial plots', '            # and (B) allow the values parameter for a Coordinate to set xlim/ylim', '            axis.set_view_interval(0, len(units_seed) - 1)', '', '        new._matplotlib_scale = mpl_scale', '', '        # TODO array cast necessary to handle float/int mixture, which we need', '        # to solve in a more systematic way probably', '        # (i.e. if we have [1, 2.5], do we want [1.0, 2.5]? Unclear)', '        axis.update_units(stringify(np.array(units_seed)))', '', '        # TODO define this more centrally', '        def convert_units(x):', '            # TODO only do this with explicit order?', '            # (But also category dtype?)', '            # TODO isin fails when units_seed mixes numbers and strings (numpy error?)', '            # but np.isin also does not seem any faster? (Maybe not broadcasting in C)', '            # keep = x.isin(units_seed)', '            keep = np.array([x_ in units_seed for x_ in x], bool)', '            out = np.full(len(x), np.nan)', '            out[keep] = axis.convert_units(stringify(x[keep]))', '            return out', '', '        new._pipeline = [', '            convert_units,', '            prop.get_mapping(new, data),', '            # TODO how to handle color representation consistency?', '        ]', '', '        def spacer(x):', '            return 1', '', '        new._spacer = spacer', '', '        if prop.legend:', '            new._legend = units_seed, list(stringify(units_seed))', '', '        return new']}, {'name': 'tick', 'start_line': 230, 'end_line': 252, 'text': ['    def tick(self, locator: Locator | None = None):', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '            At the moment, it is probably not very useful.', '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '', '        Returns', '        -------', '        Copy of self with new tick configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._tick_params = {', '            \"locator\": locator,', '        }', '        return new']}, {'name': 'label', 'start_line': 254, 'end_line': 277, 'text': ['    def label(self, formatter: Formatter | None = None):', '        \"\"\"', \"        Configure the selection of labels for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '            At the moment, it is probably not very useful.', '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured matplotlib formatter; other parameters will not be used.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._label_params = {', '            \"formatter\": formatter,', '        }', '        return new']}, {'name': '_get_locators', 'start_line': 279, 'end_line': 286, 'text': ['    def _get_locators(self, locator):', '', '        if locator is not None:', '            return locator, None', '', '        locator = mpl.category.StrCategoryLocator({})', '', '        return locator, None']}, {'name': '_get_formatter', 'start_line': 288, 'end_line': 295, 'text': ['    def _get_formatter(self, locator, formatter):', '', '        if formatter is not None:', '            return formatter', '', '        formatter = mpl.category.StrCategoryFormatter({})', '', '        return formatter']}]}, {'name': 'Ordinal', 'start_line': 299, 'end_line': 301, 'text': ['class Ordinal(Scale):', '    # Categorical (convert to strings), sortable, can skip ticklabels', '    ...'], 'methods': []}, {'name': 'Discrete', 'start_line': 305, 'end_line': 307, 'text': ['class Discrete(Scale):', '    # Numeric, integral, can skip ticks/ticklabels', '    ...'], 'methods': []}, {'name': 'ContinuousBase', 'start_line': 311, 'end_line': 411, 'text': ['class ContinuousBase(Scale):', '', '    values: tuple | str | None = None', '    norm: tuple | None = None', '', '    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '', '        new = copy(self)', '        if new._tick_params is None:', '            new = new.tick()', '        if new._label_params is None:', '            new = new.label()', '', '        forward, inverse = new._get_transform()', '', '        mpl_scale = new._get_scale(str(data.name), forward, inverse)', '', '        if axis is None:', '            axis = PseudoAxis(mpl_scale)', '            axis.update_units(data)', '', '        mpl_scale.set_default_locators_and_formatters(axis)', '        new._matplotlib_scale = mpl_scale', '', '        normalize: Optional[Callable[[ArrayLike], ArrayLike]]', '        if prop.normed:', '            if new.norm is None:', '                vmin, vmax = data.min(), data.max()', '            else:', '                vmin, vmax = new.norm', '            vmin, vmax = axis.convert_units((vmin, vmax))', '            a = forward(vmin)', '            b = forward(vmax) - forward(vmin)', '', '            def normalize(x):', '                return (x - a) / b', '', '        else:', '            normalize = vmin = vmax = None', '', '        new._pipeline = [', '            axis.convert_units,', '            forward,', '            normalize,', '            prop.get_mapping(new, data)', '        ]', '', '        def spacer(x):', '            x = x.dropna().unique()', '            if len(x) < 2:', '                return np.nan', '            return np.min(np.diff(np.sort(x)))', '        new._spacer = spacer', '', '        # TODO How to allow disabling of legend for all uses of property?', '        # Could add a Scale parameter, or perhaps Scale.suppress()?', '        # Are there other useful parameters that would be in Scale.legend()', '        # besides allowing Scale.legend(False)?', '        if prop.legend:', '            axis.set_view_interval(vmin, vmax)', '            locs = axis.major.locator()', '            locs = locs[(vmin <= locs) & (locs <= vmax)]', '            labels = axis.major.formatter.format_ticks(locs)', '            new._legend = list(locs), list(labels)', '', '        return new', '', '    def _get_transform(self):', '', '        arg = self.trans', '', '        def get_param(method, default):', '            if arg == method:', '                return default', '            return float(arg[len(method):])', '', '        if arg is None:', '            return _make_identity_transforms()', '        elif isinstance(arg, tuple):', '            return arg', '        elif isinstance(arg, str):', '            if arg == \"ln\":', '                return _make_log_transforms()', '            elif arg == \"logit\":', '                base = get_param(\"logit\", 10)', '                return _make_logit_transforms(base)', '            elif arg.startswith(\"log\"):', '                base = get_param(\"log\", 10)', '                return _make_log_transforms(base)', '            elif arg.startswith(\"symlog\"):', '                c = get_param(\"symlog\", 1)', '                return _make_symlog_transforms(c)', '            elif arg.startswith(\"pow\"):', '                exp = get_param(\"pow\", 2)', '                return _make_power_transforms(exp)', '            elif arg == \"sqrt\":', '                return _make_sqrt_transforms()', '            else:', '                raise ValueError(f\"Unknown value provided for trans: {arg!r}\")'], 'methods': [{'name': '_setup', 'start_line': 316, 'end_line': 378, 'text': ['    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '', '        new = copy(self)', '        if new._tick_params is None:', '            new = new.tick()', '        if new._label_params is None:', '            new = new.label()', '', '        forward, inverse = new._get_transform()', '', '        mpl_scale = new._get_scale(str(data.name), forward, inverse)', '', '        if axis is None:', '            axis = PseudoAxis(mpl_scale)', '            axis.update_units(data)', '', '        mpl_scale.set_default_locators_and_formatters(axis)', '        new._matplotlib_scale = mpl_scale', '', '        normalize: Optional[Callable[[ArrayLike], ArrayLike]]', '        if prop.normed:', '            if new.norm is None:', '                vmin, vmax = data.min(), data.max()', '            else:', '                vmin, vmax = new.norm', '            vmin, vmax = axis.convert_units((vmin, vmax))', '            a = forward(vmin)', '            b = forward(vmax) - forward(vmin)', '', '            def normalize(x):', '                return (x - a) / b', '', '        else:', '            normalize = vmin = vmax = None', '', '        new._pipeline = [', '            axis.convert_units,', '            forward,', '            normalize,', '            prop.get_mapping(new, data)', '        ]', '', '        def spacer(x):', '            x = x.dropna().unique()', '            if len(x) < 2:', '                return np.nan', '            return np.min(np.diff(np.sort(x)))', '        new._spacer = spacer', '', '        # TODO How to allow disabling of legend for all uses of property?', '        # Could add a Scale parameter, or perhaps Scale.suppress()?', '        # Are there other useful parameters that would be in Scale.legend()', '        # besides allowing Scale.legend(False)?', '        if prop.legend:', '            axis.set_view_interval(vmin, vmax)', '            locs = axis.major.locator()', '            locs = locs[(vmin <= locs) & (locs <= vmax)]', '            labels = axis.major.formatter.format_ticks(locs)', '            new._legend = list(locs), list(labels)', '', '        return new']}, {'name': '_get_transform', 'start_line': 380, 'end_line': 411, 'text': ['    def _get_transform(self):', '', '        arg = self.trans', '', '        def get_param(method, default):', '            if arg == method:', '                return default', '            return float(arg[len(method):])', '', '        if arg is None:', '            return _make_identity_transforms()', '        elif isinstance(arg, tuple):', '            return arg', '        elif isinstance(arg, str):', '            if arg == \"ln\":', '                return _make_log_transforms()', '            elif arg == \"logit\":', '                base = get_param(\"logit\", 10)', '                return _make_logit_transforms(base)', '            elif arg.startswith(\"log\"):', '                base = get_param(\"log\", 10)', '                return _make_log_transforms(base)', '            elif arg.startswith(\"symlog\"):', '                c = get_param(\"symlog\", 1)', '                return _make_symlog_transforms(c)', '            elif arg.startswith(\"pow\"):', '                exp = get_param(\"pow\", 2)', '                return _make_power_transforms(exp)', '            elif arg == \"sqrt\":', '                return _make_sqrt_transforms()', '            else:', '                raise ValueError(f\"Unknown value provided for trans: {arg!r}\")']}]}, {'name': 'Continuous', 'start_line': 415, 'end_line': 645, 'text': ['class Continuous(ContinuousBase):', '    \"\"\"', '    A numeric scale supporting norms and functional transforms.', '    \"\"\"', '    values: tuple | str | None = None', '    trans: str | TransFuncs | None = None', '', '    # TODO Add this to deal with outliers?', '    # outside: Literal[\"keep\", \"drop\", \"clip\"] = \"keep\"', '', '    _priority: ClassVar[int] = 1', '', '    def tick(', '        self,', '        locator: Locator | None = None, *,', '        at: Sequence[float] = None,', '        upto: int | None = None,', '        count: int | None = None,', '        every: float | None = None,', '        between: tuple[float, float] | None = None,', '        minor: int | None = None,', '    ) -> Continuous:', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '        at : sequence of floats', '            Place ticks at these specific locations (in data units).', '        upto : int', '            Choose \"nice\" locations for ticks, but do not exceed this number.', '        count : int', '            Choose exactly this number of ticks, bounded by `between` or axis limits.', '        every : float', '            Choose locations at this interval of separation (in data units).', '        between : pair of floats', '            Bound upper / lower ticks when using `every` or `count`.', '        minor : int', '            Number of unlabeled ticks to draw between labeled \"major\" ticks.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        # Input checks', '        if locator is not None and not isinstance(locator, Locator):', '            raise TypeError(', '                f\"Tick locator must be an instance of {Locator!r}, \"', '                f\"not {type(locator)!r}.\"', '            )', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '        if log_base or symlog_thresh:', '            if count is not None and between is None:', '                raise RuntimeError(\"`count` requires `between` with log transform.\")', '            if every is not None:', '                raise RuntimeError(\"`every` not supported with log transform.\")', '', '        new = copy(self)', '        new._tick_params = {', '            \"locator\": locator,', '            \"at\": at,', '            \"upto\": upto,', '            \"count\": count,', '            \"every\": every,', '            \"between\": between,', '            \"minor\": minor,', '        }', '        return new', '', '    def label(', '        self,', '        formatter: Formatter | None = None, *,', '        like: str | Callable | None = None,', '        base: int | None = None,', '        unit: str | None = None,', '    ) -> Continuous:', '        \"\"\"', \"        Configure the appearance of tick labels for the scale's axis or legend.\", '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured formatter to use; other parameters will be ignored.', '        like : str or callable', '            Either a format pattern (e.g., `\".2f\"`), a format string with fields named', '            `x` and/or `pos` (e.g., `\"${x:.2f}\"`), or a callable that consumes a number', '            and returns a string.', '        base : number', '            Use log formatter (with scientific notation) having this value as the base.', '        unit : str or (str, str) tuple', '            Use  SI prefixes with these units (e.g., with `unit=\"g\"`, a tick value', '            of 5000 will appear as `5 kg`). When a tuple, the first element gives the', '            separator between the number and unit.', '', '        Returns', '        -------', '        scale', '            Copy of self with new label configuration.', '', '        \"\"\"', '        # Input checks', '        if formatter is not None and not isinstance(formatter, Formatter):', '            raise TypeError(', '                f\"Label formatter must be an instance of {Formatter!r}, \"', '                f\"not {type(formatter)!r}\"', '            )', '        if like is not None and not (isinstance(like, str) or callable(like)):', '            msg = f\"`like` must be a string or callable, not {type(like).__name__}.\"', '            raise TypeError(msg)', '', '        new = copy(self)', '        new._label_params = {', '            \"formatter\": formatter,', '            \"like\": like,', '            \"base\": base,', '            \"unit\": unit,', '        }', '        return new', '', '    def _parse_for_log_params(', '        self, trans: str | TransFuncs | None', '    ) -> tuple[float | None, float | None]:', '', '        log_base = symlog_thresh = None', '        if isinstance(trans, str):', '            m = re.match(r\"^log(\\\\d*)\", trans)', '            if m is not None:', '                log_base = float(m[1] or 10)', '            m = re.match(r\"symlog(\\\\d*)\", trans)', '            if m is not None:', '                symlog_thresh = float(m[1] or 1)', '        return log_base, symlog_thresh', '', '    def _get_locators(self, locator, at, upto, count, every, between, minor):', '', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '', '        if locator is not None:', '            major_locator = locator', '', '        elif upto is not None:', '            if log_base:', '                major_locator = LogLocator(base=log_base, numticks=upto)', '            else:', '                major_locator = MaxNLocator(upto, steps=[1, 1.5, 2, 2.5, 3, 5, 10])', '', '        elif count is not None:', '            if between is None:', '                # This is rarely useful (unless you are setting limits)', '                major_locator = LinearLocator(count)', '            else:', '                if log_base or symlog_thresh:', '                    forward, inverse = self._get_transform()', '                    lo, hi = forward(between)', '                    ticks = inverse(np.linspace(lo, hi, num=count))', '                else:', '                    ticks = np.linspace(*between, num=count)', '                major_locator = FixedLocator(ticks)', '', '        elif every is not None:', '            if between is None:', '                major_locator = MultipleLocator(every)', '            else:', '                lo, hi = between', '                ticks = np.arange(lo, hi + every, every)', '                major_locator = FixedLocator(ticks)', '', '        elif at is not None:', '            major_locator = FixedLocator(at)', '', '        else:', '            if log_base:', '                major_locator = LogLocator(log_base)', '            elif symlog_thresh:', '                major_locator = SymmetricalLogLocator(linthresh=symlog_thresh, base=10)', '            else:', '                major_locator = AutoLocator()', '', '        if minor is None:', '            minor_locator = LogLocator(log_base, subs=None) if log_base else None', '        else:', '            if log_base:', '                subs = np.linspace(0, log_base, minor + 2)[1:-1]', '                minor_locator = LogLocator(log_base, subs=subs)', '            else:', '                minor_locator = AutoMinorLocator(minor + 1)', '', '        return major_locator, minor_locator', '', '    def _get_formatter(self, locator, formatter, like, base, unit):', '', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '        if base is None:', '            if symlog_thresh:', '                log_base = 10', '            base = log_base', '', '        if formatter is not None:', '            return formatter', '', '        if like is not None:', '            if isinstance(like, str):', '                if \"{x\" in like or \"{pos\" in like:', '                    fmt = like', '                else:', '                    fmt = f\"{{x:{like}}}\"', '                formatter = StrMethodFormatter(fmt)', '            else:', '                formatter = FuncFormatter(like)', '', '        elif base is not None:', '            # We could add other log options if necessary', '            formatter = LogFormatterSciNotation(base)', '', '        elif unit is not None:', '            if isinstance(unit, tuple):', '                sep, unit = unit', '            elif not unit:', '                sep = \"\"', '            else:', '                sep = \" \"', '            formatter = EngFormatter(unit, sep=sep)', '', '        else:', '            formatter = ScalarFormatter()', '', '        return formatter'], 'methods': [{'name': 'tick', 'start_line': 427, 'end_line': 486, 'text': ['    def tick(', '        self,', '        locator: Locator | None = None, *,', '        at: Sequence[float] = None,', '        upto: int | None = None,', '        count: int | None = None,', '        every: float | None = None,', '        between: tuple[float, float] | None = None,', '        minor: int | None = None,', '    ) -> Continuous:', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '        at : sequence of floats', '            Place ticks at these specific locations (in data units).', '        upto : int', '            Choose \"nice\" locations for ticks, but do not exceed this number.', '        count : int', '            Choose exactly this number of ticks, bounded by `between` or axis limits.', '        every : float', '            Choose locations at this interval of separation (in data units).', '        between : pair of floats', '            Bound upper / lower ticks when using `every` or `count`.', '        minor : int', '            Number of unlabeled ticks to draw between labeled \"major\" ticks.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        # Input checks', '        if locator is not None and not isinstance(locator, Locator):', '            raise TypeError(', '                f\"Tick locator must be an instance of {Locator!r}, \"', '                f\"not {type(locator)!r}.\"', '            )', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '        if log_base or symlog_thresh:', '            if count is not None and between is None:', '                raise RuntimeError(\"`count` requires `between` with log transform.\")', '            if every is not None:', '                raise RuntimeError(\"`every` not supported with log transform.\")', '', '        new = copy(self)', '        new._tick_params = {', '            \"locator\": locator,', '            \"at\": at,', '            \"upto\": upto,', '            \"count\": count,', '            \"every\": every,', '            \"between\": between,', '            \"minor\": minor,', '        }', '        return new']}, {'name': 'label', 'start_line': 488, 'end_line': 536, 'text': ['    def label(', '        self,', '        formatter: Formatter | None = None, *,', '        like: str | Callable | None = None,', '        base: int | None = None,', '        unit: str | None = None,', '    ) -> Continuous:', '        \"\"\"', \"        Configure the appearance of tick labels for the scale's axis or legend.\", '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured formatter to use; other parameters will be ignored.', '        like : str or callable', '            Either a format pattern (e.g., `\".2f\"`), a format string with fields named', '            `x` and/or `pos` (e.g., `\"${x:.2f}\"`), or a callable that consumes a number', '            and returns a string.', '        base : number', '            Use log formatter (with scientific notation) having this value as the base.', '        unit : str or (str, str) tuple', '            Use  SI prefixes with these units (e.g., with `unit=\"g\"`, a tick value', '            of 5000 will appear as `5 kg`). When a tuple, the first element gives the', '            separator between the number and unit.', '', '        Returns', '        -------', '        scale', '            Copy of self with new label configuration.', '', '        \"\"\"', '        # Input checks', '        if formatter is not None and not isinstance(formatter, Formatter):', '            raise TypeError(', '                f\"Label formatter must be an instance of {Formatter!r}, \"', '                f\"not {type(formatter)!r}\"', '            )', '        if like is not None and not (isinstance(like, str) or callable(like)):', '            msg = f\"`like` must be a string or callable, not {type(like).__name__}.\"', '            raise TypeError(msg)', '', '        new = copy(self)', '        new._label_params = {', '            \"formatter\": formatter,', '            \"like\": like,', '            \"base\": base,', '            \"unit\": unit,', '        }', '        return new']}, {'name': '_parse_for_log_params', 'start_line': 538, 'end_line': 550, 'text': ['    def _parse_for_log_params(', '        self, trans: str | TransFuncs | None', '    ) -> tuple[float | None, float | None]:', '', '        log_base = symlog_thresh = None', '        if isinstance(trans, str):', '            m = re.match(r\"^log(\\\\d*)\", trans)', '            if m is not None:', '                log_base = float(m[1] or 10)', '            m = re.match(r\"symlog(\\\\d*)\", trans)', '            if m is not None:', '                symlog_thresh = float(m[1] or 1)', '        return log_base, symlog_thresh']}, {'name': '_get_locators', 'start_line': 552, 'end_line': 606, 'text': ['    def _get_locators(self, locator, at, upto, count, every, between, minor):', '', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '', '        if locator is not None:', '            major_locator = locator', '', '        elif upto is not None:', '            if log_base:', '                major_locator = LogLocator(base=log_base, numticks=upto)', '            else:', '                major_locator = MaxNLocator(upto, steps=[1, 1.5, 2, 2.5, 3, 5, 10])', '', '        elif count is not None:', '            if between is None:', '                # This is rarely useful (unless you are setting limits)', '                major_locator = LinearLocator(count)', '            else:', '                if log_base or symlog_thresh:', '                    forward, inverse = self._get_transform()', '                    lo, hi = forward(between)', '                    ticks = inverse(np.linspace(lo, hi, num=count))', '                else:', '                    ticks = np.linspace(*between, num=count)', '                major_locator = FixedLocator(ticks)', '', '        elif every is not None:', '            if between is None:', '                major_locator = MultipleLocator(every)', '            else:', '                lo, hi = between', '                ticks = np.arange(lo, hi + every, every)', '                major_locator = FixedLocator(ticks)', '', '        elif at is not None:', '            major_locator = FixedLocator(at)', '', '        else:', '            if log_base:', '                major_locator = LogLocator(log_base)', '            elif symlog_thresh:', '                major_locator = SymmetricalLogLocator(linthresh=symlog_thresh, base=10)', '            else:', '                major_locator = AutoLocator()', '', '        if minor is None:', '            minor_locator = LogLocator(log_base, subs=None) if log_base else None', '        else:', '            if log_base:', '                subs = np.linspace(0, log_base, minor + 2)[1:-1]', '                minor_locator = LogLocator(log_base, subs=subs)', '            else:', '                minor_locator = AutoMinorLocator(minor + 1)', '', '        return major_locator, minor_locator']}, {'name': '_get_formatter', 'start_line': 608, 'end_line': 645, 'text': ['    def _get_formatter(self, locator, formatter, like, base, unit):', '', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '        if base is None:', '            if symlog_thresh:', '                log_base = 10', '            base = log_base', '', '        if formatter is not None:', '            return formatter', '', '        if like is not None:', '            if isinstance(like, str):', '                if \"{x\" in like or \"{pos\" in like:', '                    fmt = like', '                else:', '                    fmt = f\"{{x:{like}}}\"', '                formatter = StrMethodFormatter(fmt)', '            else:', '                formatter = FuncFormatter(like)', '', '        elif base is not None:', '            # We could add other log options if necessary', '            formatter = LogFormatterSciNotation(base)', '', '        elif unit is not None:', '            if isinstance(unit, tuple):', '                sep, unit = unit', '            elif not unit:', '                sep = \"\"', '            else:', '                sep = \" \"', '            formatter = EngFormatter(unit, sep=sep)', '', '        else:', '            formatter = ScalarFormatter()', '', '        return formatter']}]}, {'name': 'Temporal', 'start_line': 649, 'end_line': 755, 'text': ['class Temporal(ContinuousBase):', '    \"\"\"', '    A scale for date/time data.', '    \"\"\"', '    # TODO date: bool?', '    # For when we only care about the time component, would affect', '    # default formatter and norm conversion. Should also happen in', '    # Property.default_scale. The alternative was having distinct', '    # Calendric / Temporal scales, but that feels a bit fussy, and it', '    # would get in the way of using first-letter shorthands because', \"    # Calendric and Continuous would collide. Still, we haven't implemented\", '    # those yet, and having a clear distinction betewen date(time) / time', '    # may be more useful.', '', '    trans = None', '', '    _priority: ClassVar[int] = 2', '', '    def tick(', '        self, locator: Locator | None = None, *,', '        upto: int | None = None,', '    ) -> Temporal:', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '        upto : int', '            Choose \"nice\" locations for ticks, but do not exceed this number.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        if locator is not None and not isinstance(locator, Locator):', '            err = (', '                f\"Tick locator must be an instance of {Locator!r}, \"', '                f\"not {type(locator)!r}.\"', '            )', '            raise TypeError(err)', '', '        new = copy(self)', '        new._tick_params = {\"locator\": locator, \"upto\": upto}', '        return new', '', '    def label(', '        self,', '        formatter: Formatter | None = None, *,', '        concise: bool = False,', '    ) -> Temporal:', '        \"\"\"', \"        Configure the appearance of tick labels for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured formatter to use; other parameters will be ignored.', '        concise : bool', '            If True, use :class:`matplotlib.dates.ConciseDateFormatter` to make', '            the tick labels as compact as possible.', '', '        Returns', '        -------', '        scale', '            Copy of self with new label configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._label_params = {\"formatter\": formatter, \"concise\": concise}', '        return new', '', '    def _get_locators(self, locator, upto):', '', '        if locator is not None:', '            major_locator = locator', '        elif upto is not None:', '            major_locator = AutoDateLocator(minticks=2, maxticks=upto)', '', '        else:', '            major_locator = AutoDateLocator(minticks=2, maxticks=6)', '        minor_locator = None', '', '        return major_locator, minor_locator', '', '    def _get_formatter(self, locator, formatter, concise):', '', '        if formatter is not None:', '            return formatter', '', '        if concise:', '            # TODO ideally we would have concise coordinate ticks,', '            # but full semantic ticks. Is that possible?', '            formatter = ConciseDateFormatter(locator)', '        else:', '            formatter = AutoDateFormatter(locator)', '', '        return formatter'], 'methods': [{'name': 'tick', 'start_line': 667, 'end_line': 699, 'text': ['    def tick(', '        self, locator: Locator | None = None, *,', '        upto: int | None = None,', '    ) -> Temporal:', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '        upto : int', '            Choose \"nice\" locations for ticks, but do not exceed this number.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        if locator is not None and not isinstance(locator, Locator):', '            err = (', '                f\"Tick locator must be an instance of {Locator!r}, \"', '                f\"not {type(locator)!r}.\"', '            )', '            raise TypeError(err)', '', '        new = copy(self)', '        new._tick_params = {\"locator\": locator, \"upto\": upto}', '        return new']}, {'name': 'label', 'start_line': 701, 'end_line': 728, 'text': ['    def label(', '        self,', '        formatter: Formatter | None = None, *,', '        concise: bool = False,', '    ) -> Temporal:', '        \"\"\"', \"        Configure the appearance of tick labels for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured formatter to use; other parameters will be ignored.', '        concise : bool', '            If True, use :class:`matplotlib.dates.ConciseDateFormatter` to make', '            the tick labels as compact as possible.', '', '        Returns', '        -------', '        scale', '            Copy of self with new label configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._label_params = {\"formatter\": formatter, \"concise\": concise}', '        return new']}, {'name': '_get_locators', 'start_line': 730, 'end_line': 741, 'text': ['    def _get_locators(self, locator, upto):', '', '        if locator is not None:', '            major_locator = locator', '        elif upto is not None:', '            major_locator = AutoDateLocator(minticks=2, maxticks=upto)', '', '        else:', '            major_locator = AutoDateLocator(minticks=2, maxticks=6)', '        minor_locator = None', '', '        return major_locator, minor_locator']}, {'name': '_get_formatter', 'start_line': 743, 'end_line': 755, 'text': ['    def _get_formatter(self, locator, formatter, concise):', '', '        if formatter is not None:', '            return formatter', '', '        if concise:', '            # TODO ideally we would have concise coordinate ticks,', '            # but full semantic ticks. Is that possible?', '            formatter = ConciseDateFormatter(locator)', '        else:', '            formatter = AutoDateFormatter(locator)', '', '        return formatter']}]}, {'name': 'PseudoAxis', 'start_line': 776, 'end_line': 879, 'text': ['class PseudoAxis:', '    \"\"\"', '    Internal class implementing minimal interface equivalent to matplotlib Axis.', '', '    Coordinate variables are typically scaled by attaching the Axis object from', '    the figure where the plot will end up. Matplotlib has no similar concept of', '    and axis for the other mappable variables (color, etc.), but to simplify the', '    code, this object acts like an Axis and can be used to scale other variables.', '', '    \"\"\"', '    axis_name = \"\"  # Matplotlib requirement but not actually used', '', '    def __init__(self, scale):', '', '        self.converter = None', '        self.units = None', '        self.scale = scale', '        self.major = mpl.axis.Ticker()', '        self.minor = mpl.axis.Ticker()', '', '        # It appears that this needs to be initialized this way on matplotlib 3.1,', '        # but not later versions. It is unclear whether there are any issues with it.', '        self._data_interval = None, None', '', '        scale.set_default_locators_and_formatters(self)', '        # self.set_default_intervals()  Is this ever needed?', '', '    def set_view_interval(self, vmin, vmax):', '        self._view_interval = vmin, vmax', '', '    def get_view_interval(self):', '        return self._view_interval', '', '    # TODO do we want to distinguish view/data intervals? e.g. for a legend', '    # we probably want to represent the full range of the data values, but', \"    # still norm the colormap. If so, we'll need to track data range separately\", \"    # from the norm, which we currently don't do.\", '', '    def set_data_interval(self, vmin, vmax):', '        self._data_interval = vmin, vmax', '', '    def get_data_interval(self):', '        return self._data_interval', '', '    def get_tick_space(self):', '        # TODO how to do this in a configurable / auto way?', '        # Would be cool to have legend density adapt to figure size, etc.', '        return 5', '', '    def set_major_locator(self, locator):', '        self.major.locator = locator', '        locator.set_axis(self)', '', '    def set_major_formatter(self, formatter):', '        self.major.formatter = formatter', '        formatter.set_axis(self)', '', '    def set_minor_locator(self, locator):', '        self.minor.locator = locator', '        locator.set_axis(self)', '', '    def set_minor_formatter(self, formatter):', '        self.minor.formatter = formatter', '        formatter.set_axis(self)', '', '    def set_units(self, units):', '        self.units = units', '', '    def update_units(self, x):', '        \"\"\"Pass units to the internal converter, potentially updating its mapping.\"\"\"', '        self.converter = mpl.units.registry.get_converter(x)', '        if self.converter is not None:', '            self.converter.default_units(x, self)', '', '            info = self.converter.axisinfo(self.units, self)', '', '            if info is None:', '                return', '            if info.majloc is not None:', '                self.set_major_locator(info.majloc)', '            if info.majfmt is not None:', '                self.set_major_formatter(info.majfmt)', '', '            # This is in matplotlib method; do we need this?', '            # self.set_default_intervals()', '', '    def convert_units(self, x):', '        \"\"\"Return a numeric representation of the input data.\"\"\"', '        if np.issubdtype(np.asarray(x).dtype, np.number):', '            return x', '        elif self.converter is None:', '            return x', '        return self.converter.convert(x, self.units, self)', '', '    def get_scale(self):', '        # Note that matplotlib actually returns a string here!', '        # (e.g., with a log scale, axis.get_scale() returns \"log\")', '        # Currently we just hit it with minor ticks where it checks for', '        # scale == \"log\". I\\'m not sure how you\\'d actually use log-scale', '        # minor \"ticks\" in a legend context, so this is fine....', '        return self.scale', '', '    def get_majorticklocs(self):', '        return self.major.locator()'], 'methods': [{'name': '__init__', 'start_line': 788, 'end_line': 800, 'text': ['    def __init__(self, scale):', '', '        self.converter = None', '        self.units = None', '        self.scale = scale', '        self.major = mpl.axis.Ticker()', '        self.minor = mpl.axis.Ticker()', '', '        # It appears that this needs to be initialized this way on matplotlib 3.1,', '        # but not later versions. It is unclear whether there are any issues with it.', '        self._data_interval = None, None', '', '        scale.set_default_locators_and_formatters(self)']}, {'name': 'set_view_interval', 'start_line': 803, 'end_line': 804, 'text': ['    def set_view_interval(self, vmin, vmax):', '        self._view_interval = vmin, vmax']}, {'name': 'get_view_interval', 'start_line': 806, 'end_line': 807, 'text': ['    def get_view_interval(self):', '        return self._view_interval']}, {'name': 'set_data_interval', 'start_line': 814, 'end_line': 815, 'text': ['    def set_data_interval(self, vmin, vmax):', '        self._data_interval = vmin, vmax']}, {'name': 'get_data_interval', 'start_line': 817, 'end_line': 818, 'text': ['    def get_data_interval(self):', '        return self._data_interval']}, {'name': 'get_tick_space', 'start_line': 820, 'end_line': 823, 'text': ['    def get_tick_space(self):', '        # TODO how to do this in a configurable / auto way?', '        # Would be cool to have legend density adapt to figure size, etc.', '        return 5']}, {'name': 'set_major_locator', 'start_line': 825, 'end_line': 827, 'text': ['    def set_major_locator(self, locator):', '        self.major.locator = locator', '        locator.set_axis(self)']}, {'name': 'set_major_formatter', 'start_line': 829, 'end_line': 831, 'text': ['    def set_major_formatter(self, formatter):', '        self.major.formatter = formatter', '        formatter.set_axis(self)']}, {'name': 'set_minor_locator', 'start_line': 833, 'end_line': 835, 'text': ['    def set_minor_locator(self, locator):', '        self.minor.locator = locator', '        locator.set_axis(self)']}, {'name': 'set_minor_formatter', 'start_line': 837, 'end_line': 839, 'text': ['    def set_minor_formatter(self, formatter):', '        self.minor.formatter = formatter', '        formatter.set_axis(self)']}, {'name': 'set_units', 'start_line': 841, 'end_line': 842, 'text': ['    def set_units(self, units):', '        self.units = units']}, {'name': 'update_units', 'start_line': 844, 'end_line': 857, 'text': ['    def update_units(self, x):', '        \"\"\"Pass units to the internal converter, potentially updating its mapping.\"\"\"', '        self.converter = mpl.units.registry.get_converter(x)', '        if self.converter is not None:', '            self.converter.default_units(x, self)', '', '            info = self.converter.axisinfo(self.units, self)', '', '            if info is None:', '                return', '            if info.majloc is not None:', '                self.set_major_locator(info.majloc)', '            if info.majfmt is not None:', '                self.set_major_formatter(info.majfmt)']}, {'name': 'convert_units', 'start_line': 862, 'end_line': 868, 'text': ['    def convert_units(self, x):', '        \"\"\"Return a numeric representation of the input data.\"\"\"', '        if np.issubdtype(np.asarray(x).dtype, np.number):', '            return x', '        elif self.converter is None:', '            return x', '        return self.converter.convert(x, self.units, self)']}, {'name': 'get_scale', 'start_line': 870, 'end_line': 876, 'text': ['    def get_scale(self):', '        # Note that matplotlib actually returns a string here!', '        # (e.g., with a log scale, axis.get_scale() returns \"log\")', '        # Currently we just hit it with minor ticks where it checks for', '        # scale == \"log\". I\\'m not sure how you\\'d actually use log-scale', '        # minor \"ticks\" in a legend context, so this is fine....', '        return self.scale']}, {'name': 'get_majorticklocs', 'start_line': 878, 'end_line': 879, 'text': ['    def get_majorticklocs(self):', '        return self.major.locator()']}]}, {'name': 'InternalScale', 'start_line': 87, 'end_line': 92, 'text': ['        class InternalScale(mpl.scale.FuncScale):', '            def set_default_locators_and_formatters(self, axis):', '                axis.set_major_locator(major_locator)', '                if minor_locator is not None:', '                    axis.set_minor_locator(minor_locator)', '                axis.set_major_formatter(major_formatter)'], 'methods': [{'name': 'set_default_locators_and_formatters', 'start_line': 88, 'end_line': 92, 'text': ['            def set_default_locators_and_formatters(self, axis):', '                axis.set_major_locator(major_locator)', '                if minor_locator is not None:', '                    axis.set_minor_locator(minor_locator)', '                axis.set_major_formatter(major_formatter)']}]}, {'name': 'Identity', 'start_line': 128, 'end_line': 132, 'text': ['        class Identity(Scale):', '            _pipeline = []', '            _spacer = None', '            _legend = None', '            _matplotlib_scale = None'], 'methods': []}, {'name': 'CatScale', 'start_line': 176, 'end_line': 180, 'text': ['        class CatScale(mpl.scale.LinearScale):', '            name = None  # To work around mpl<3.4 compat issues', '', '            def set_default_locators_and_formatters(self, axis):', '                ...'], 'methods': [{'name': 'set_default_locators_and_formatters', 'start_line': 179, 'end_line': 180, 'text': ['            def set_default_locators_and_formatters(self, axis):', '                ...']}]}], 'functions': [{'name': '_make_identity_transforms', 'start_line': 886, 'end_line': 891, 'text': ['def _make_identity_transforms() -> TransFuncs:', '', '    def identity(x):', '        return x', '', '    return identity, identity']}, {'name': '_make_logit_transforms', 'start_line': 894, 'end_line': 906, 'text': ['def _make_logit_transforms(base: float = None) -> TransFuncs:', '', '    log, exp = _make_log_transforms(base)', '', '    def logit(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return log(x) - log(1 - x)', '', '    def expit(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return exp(x) / (1 + exp(x))', '', '    return logit, expit']}, {'name': '_make_log_transforms', 'start_line': 909, 'end_line': 931, 'text': ['def _make_log_transforms(base: float | None = None) -> TransFuncs:', '', '    fs: TransFuncs', '    if base is None:', '        fs = np.log, np.exp', '    elif base == 2:', '        fs = np.log2, partial(np.power, 2)', '    elif base == 10:', '        fs = np.log10, partial(np.power, 10)', '    else:', '        def forward(x):', '            return np.log(x) / np.log(base)', '        fs = forward, partial(np.power, base)', '', '    def log(x: ArrayLike) -> ArrayLike:', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return fs[0](x)', '', '    def exp(x: ArrayLike) -> ArrayLike:', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return fs[1](x)', '', '    return log, exp']}, {'name': '_make_symlog_transforms', 'start_line': 934, 'end_line': 951, 'text': ['def _make_symlog_transforms(c: float = 1, base: float = 10) -> TransFuncs:', '', '    # From https://iopscience.iop.org/article/10.1088/0957-0233/24/2/027001', '', '    # Note: currently not using base because we only get', '    # one parameter from the string, and are using c (this is consistent with d3)', '', '    log, exp = _make_log_transforms(base)', '', '    def symlog(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return np.sign(x) * log(1 + np.abs(np.divide(x, c)))', '', '    def symexp(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return np.sign(x) * c * (exp(np.abs(x)) - 1)', '', '    return symlog, symexp']}, {'name': '_make_sqrt_transforms', 'start_line': 954, 'end_line': 962, 'text': ['def _make_sqrt_transforms() -> TransFuncs:', '', '    def sqrt(x):', '        return np.sign(x) * np.sqrt(np.abs(x))', '', '    def square(x):', '        return np.sign(x) * np.square(x)', '', '    return sqrt, square']}, {'name': '_make_power_transforms', 'start_line': 965, 'end_line': 973, 'text': ['def _make_power_transforms(exp: float) -> TransFuncs:', '', '    def forward(x):', '        return np.sign(x) * np.power(np.abs(x), exp)', '', '    def inverse(x):', '        return np.sign(x) * np.power(np.abs(x), 1 / exp)', '', '    return forward, inverse']}, {'name': 'identity', 'start_line': 888, 'end_line': 889, 'text': ['    def identity(x):', '        return x']}, {'name': 'logit', 'start_line': 898, 'end_line': 900, 'text': ['    def logit(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return log(x) - log(1 - x)']}, {'name': 'expit', 'start_line': 902, 'end_line': 904, 'text': ['    def expit(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return exp(x) / (1 + exp(x))']}, {'name': 'log', 'start_line': 923, 'end_line': 925, 'text': ['    def log(x: ArrayLike) -> ArrayLike:', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return fs[0](x)']}, {'name': 'exp', 'start_line': 927, 'end_line': 929, 'text': ['    def exp(x: ArrayLike) -> ArrayLike:', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return fs[1](x)']}, {'name': 'symlog', 'start_line': 943, 'end_line': 945, 'text': ['    def symlog(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return np.sign(x) * log(1 + np.abs(np.divide(x, c)))']}, {'name': 'symexp', 'start_line': 947, 'end_line': 949, 'text': ['    def symexp(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return np.sign(x) * c * (exp(np.abs(x)) - 1)']}, {'name': 'sqrt', 'start_line': 956, 'end_line': 957, 'text': ['    def sqrt(x):', '        return np.sign(x) * np.sqrt(np.abs(x))']}, {'name': 'square', 'start_line': 959, 'end_line': 960, 'text': ['    def square(x):', '        return np.sign(x) * np.square(x)']}, {'name': 'forward', 'start_line': 967, 'end_line': 968, 'text': ['    def forward(x):', '        return np.sign(x) * np.power(np.abs(x), exp)']}, {'name': 'inverse', 'start_line': 970, 'end_line': 971, 'text': ['    def inverse(x):', '        return np.sign(x) * np.power(np.abs(x), 1 / exp)']}, {'name': 'spacer', 'start_line': 220, 'end_line': 221, 'text': ['        def spacer(x):', '            return 1']}, {'name': 'spacer', 'start_line': 360, 'end_line': 364, 'text': ['        def spacer(x):', '            x = x.dropna().unique()', '            if len(x) < 2:', '                return np.nan', '            return np.min(np.diff(np.sort(x)))']}, {'name': 'get_param', 'start_line': 384, 'end_line': 387, 'text': ['        def get_param(method, default):', '            if arg == method:', '                return default', '            return float(arg[len(method):])']}, {'name': 'normalize', 'start_line': 347, 'end_line': 348, 'text': ['            def normalize(x):', '                return (x - a) / b']}, {'name': 'forward', 'start_line': 919, 'end_line': 920, 'text': ['        def forward(x):', '            return np.log(x) / np.log(base)']}], 'text': ['from __future__ import annotations', 'import re', 'from copy import copy', 'from collections.abc import Sequence', 'from dataclasses import dataclass', 'from functools import partial', 'from typing import Any, Callable, Tuple, Optional, ClassVar', '', 'import numpy as np', 'import matplotlib as mpl', 'from matplotlib.ticker import (', '    Locator,', '    Formatter,', '    AutoLocator,', '    AutoMinorLocator,', '    FixedLocator,', '    LinearLocator,', '    LogLocator,', '    SymmetricalLogLocator,', '    MaxNLocator,', '    MultipleLocator,', '    EngFormatter,', '    FuncFormatter,', '    LogFormatterSciNotation,', '    ScalarFormatter,', '    StrMethodFormatter,', ')', 'from matplotlib.dates import (', '    AutoDateLocator,', '    AutoDateFormatter,', '    ConciseDateFormatter,', ')', 'from matplotlib.axis import Axis', 'from matplotlib.scale import ScaleBase', 'from pandas import Series', '', 'from seaborn._core.rules import categorical_order', '', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:', '    from seaborn._core.properties import Property', '    from numpy.typing import ArrayLike, NDArray', '', '    TransFuncs = Tuple[', '        Callable[[ArrayLike], ArrayLike], Callable[[ArrayLike], ArrayLike]', '    ]', '', '    # TODO Reverting typing to Any as it was proving too complicated to', '    # work out the right way to communicate the types to mypy. Revisit!', '    Pipeline = Sequence[Optional[Callable[[Any], Any]]]', '', '', 'class Scale:', '    \"\"\"Base class for objects that map data values to visual properties.\"\"\"', '', '    values: tuple | str | list | dict | None', '', '    _priority: ClassVar[int]', '    _pipeline: Pipeline', '    _matplotlib_scale: ScaleBase', '    _spacer: staticmethod', '    _legend: tuple[list[str], list[Any]] | None', '', '    def __post_init__(self):', '', '        self._tick_params = None', '        self._label_params = None', '        self._legend = None', '', '    def tick(self):', '        raise NotImplementedError()', '', '    def label(self):', '        raise NotImplementedError()', '', '    def _get_locators(self):', '        raise NotImplementedError()', '', '    def _get_formatter(self, locator: Locator | None = None):', '        raise NotImplementedError()', '', '    def _get_scale(self, name: str, forward: Callable, inverse: Callable):', '', '        major_locator, minor_locator = self._get_locators(**self._tick_params)', '        major_formatter = self._get_formatter(major_locator, **self._label_params)', '', '        class InternalScale(mpl.scale.FuncScale):', '            def set_default_locators_and_formatters(self, axis):', '                axis.set_major_locator(major_locator)', '                if minor_locator is not None:', '                    axis.set_minor_locator(minor_locator)', '                axis.set_major_formatter(major_formatter)', '', '        return InternalScale(name, (forward, inverse))', '', '    def _spacing(self, x: Series) -> float:', '        return self._spacer(x)', '', '    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '        raise NotImplementedError()', '', '    def __call__(self, data: Series) -> ArrayLike:', '', '        trans_data: Series | NDArray | list', '', '        # TODO sometimes we need to handle scalars (e.g. for Line)', '        # but what is the best way to do that?', '        scalar_data = np.isscalar(data)', '        if scalar_data:', '            trans_data = np.array([data])', '        else:', '            trans_data = data', '', '        for func in self._pipeline:', '            if func is not None:', '                trans_data = func(trans_data)', '', '        if scalar_data:', '            return trans_data[0]', '        else:', '            return trans_data', '', '    @staticmethod', '    def _identity():', '', '        class Identity(Scale):', '            _pipeline = []', '            _spacer = None', '            _legend = None', '            _matplotlib_scale = None', '', '        return Identity()', '', '', '@dataclass', 'class Nominal(Scale):', '    \"\"\"', '    A categorical scale without relative importance / magnitude.', '    \"\"\"', '    # Categorical (convert to strings), un-sortable', '', '    values: tuple | str | list | dict | None = None', '    order: list | None = None', '', '    _priority: ClassVar[int] = 3', '', '    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '', '        new = copy(self)', '        if new._tick_params is None:', '            new = new.tick()', '        if new._label_params is None:', '            new = new.label()', '', \"        # TODO flexibility over format() which isn't great for numbers / dates\", '        stringify = np.vectorize(format)', '', '        units_seed = categorical_order(data, new.order)', '', '        # TODO move to Nominal._get_scale?', '        # TODO this needs some more complicated rethinking about how to pass', '        # a unit dictionary down to these methods, along with how much we want', '        # to invest in their API. What is it useful for tick() to do here?', '        # (Ordinal may be different if we draw that contrast).', '        # Any customization we do to allow, e.g., label wrapping will probably', '        # require defining our own Formatter subclass.', '        # We could also potentially implement auto-wrapping in an Axis subclass', '        # (see Axis.draw ... it already is computing the bboxes).', '        # major_locator, minor_locator = new._get_locators(**new._tick_params)', '        # major_formatter = new._get_formatter(major_locator, **new._label_params)', '', '        class CatScale(mpl.scale.LinearScale):', '            name = None  # To work around mpl<3.4 compat issues', '', '            def set_default_locators_and_formatters(self, axis):', '                ...', '                # axis.set_major_locator(major_locator)', '                # if minor_locator is not None:', '                #     axis.set_minor_locator(minor_locator)', '                # axis.set_major_formatter(major_formatter)', '', '        mpl_scale = CatScale(data.name)', '        if axis is None:', '            axis = PseudoAxis(mpl_scale)', '', '            # TODO Currently just used in non-Coordinate contexts, but should', '            # we use this to (A) set the padding we want for categorial plots', '            # and (B) allow the values parameter for a Coordinate to set xlim/ylim', '            axis.set_view_interval(0, len(units_seed) - 1)', '', '        new._matplotlib_scale = mpl_scale', '', '        # TODO array cast necessary to handle float/int mixture, which we need', '        # to solve in a more systematic way probably', '        # (i.e. if we have [1, 2.5], do we want [1.0, 2.5]? Unclear)', '        axis.update_units(stringify(np.array(units_seed)))', '', '        # TODO define this more centrally', '        def convert_units(x):', '            # TODO only do this with explicit order?', '            # (But also category dtype?)', '            # TODO isin fails when units_seed mixes numbers and strings (numpy error?)', '            # but np.isin also does not seem any faster? (Maybe not broadcasting in C)', '            # keep = x.isin(units_seed)', '            keep = np.array([x_ in units_seed for x_ in x], bool)', '            out = np.full(len(x), np.nan)', '            out[keep] = axis.convert_units(stringify(x[keep]))', '            return out', '', '        new._pipeline = [', '            convert_units,', '            prop.get_mapping(new, data),', '            # TODO how to handle color representation consistency?', '        ]', '', '        def spacer(x):', '            return 1', '', '        new._spacer = spacer', '', '        if prop.legend:', '            new._legend = units_seed, list(stringify(units_seed))', '', '        return new', '', '    def tick(self, locator: Locator | None = None):', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '            At the moment, it is probably not very useful.', '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '', '        Returns', '        -------', '        Copy of self with new tick configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._tick_params = {', '            \"locator\": locator,', '        }', '        return new', '', '    def label(self, formatter: Formatter | None = None):', '        \"\"\"', \"        Configure the selection of labels for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '            At the moment, it is probably not very useful.', '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured matplotlib formatter; other parameters will not be used.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._label_params = {', '            \"formatter\": formatter,', '        }', '        return new', '', '    def _get_locators(self, locator):', '', '        if locator is not None:', '            return locator, None', '', '        locator = mpl.category.StrCategoryLocator({})', '', '        return locator, None', '', '    def _get_formatter(self, locator, formatter):', '', '        if formatter is not None:', '            return formatter', '', '        formatter = mpl.category.StrCategoryFormatter({})', '', '        return formatter', '', '', '@dataclass', 'class Ordinal(Scale):', '    # Categorical (convert to strings), sortable, can skip ticklabels', '    ...', '', '', '@dataclass', 'class Discrete(Scale):', '    # Numeric, integral, can skip ticks/ticklabels', '    ...', '', '', '@dataclass', 'class ContinuousBase(Scale):', '', '    values: tuple | str | None = None', '    norm: tuple | None = None', '', '    def _setup(', '        self, data: Series, prop: Property, axis: Axis | None = None,', '    ) -> Scale:', '', '        new = copy(self)', '        if new._tick_params is None:', '            new = new.tick()', '        if new._label_params is None:', '            new = new.label()', '', '        forward, inverse = new._get_transform()', '', '        mpl_scale = new._get_scale(str(data.name), forward, inverse)', '', '        if axis is None:', '            axis = PseudoAxis(mpl_scale)', '            axis.update_units(data)', '', '        mpl_scale.set_default_locators_and_formatters(axis)', '        new._matplotlib_scale = mpl_scale', '', '        normalize: Optional[Callable[[ArrayLike], ArrayLike]]', '        if prop.normed:', '            if new.norm is None:', '                vmin, vmax = data.min(), data.max()', '            else:', '                vmin, vmax = new.norm', '            vmin, vmax = axis.convert_units((vmin, vmax))', '            a = forward(vmin)', '            b = forward(vmax) - forward(vmin)', '', '            def normalize(x):', '                return (x - a) / b', '', '        else:', '            normalize = vmin = vmax = None', '', '        new._pipeline = [', '            axis.convert_units,', '            forward,', '            normalize,', '            prop.get_mapping(new, data)', '        ]', '', '        def spacer(x):', '            x = x.dropna().unique()', '            if len(x) < 2:', '                return np.nan', '            return np.min(np.diff(np.sort(x)))', '        new._spacer = spacer', '', '        # TODO How to allow disabling of legend for all uses of property?', '        # Could add a Scale parameter, or perhaps Scale.suppress()?', '        # Are there other useful parameters that would be in Scale.legend()', '        # besides allowing Scale.legend(False)?', '        if prop.legend:', '            axis.set_view_interval(vmin, vmax)', '            locs = axis.major.locator()', '            locs = locs[(vmin <= locs) & (locs <= vmax)]', '            labels = axis.major.formatter.format_ticks(locs)', '            new._legend = list(locs), list(labels)', '', '        return new', '', '    def _get_transform(self):', '', '        arg = self.trans', '', '        def get_param(method, default):', '            if arg == method:', '                return default', '            return float(arg[len(method):])', '', '        if arg is None:', '            return _make_identity_transforms()', '        elif isinstance(arg, tuple):', '            return arg', '        elif isinstance(arg, str):', '            if arg == \"ln\":', '                return _make_log_transforms()', '            elif arg == \"logit\":', '                base = get_param(\"logit\", 10)', '                return _make_logit_transforms(base)', '            elif arg.startswith(\"log\"):', '                base = get_param(\"log\", 10)', '                return _make_log_transforms(base)', '            elif arg.startswith(\"symlog\"):', '                c = get_param(\"symlog\", 1)', '                return _make_symlog_transforms(c)', '            elif arg.startswith(\"pow\"):', '                exp = get_param(\"pow\", 2)', '                return _make_power_transforms(exp)', '            elif arg == \"sqrt\":', '                return _make_sqrt_transforms()', '            else:', '                raise ValueError(f\"Unknown value provided for trans: {arg!r}\")', '', '', '@dataclass', 'class Continuous(ContinuousBase):', '    \"\"\"', '    A numeric scale supporting norms and functional transforms.', '    \"\"\"', '    values: tuple | str | None = None', '    trans: str | TransFuncs | None = None', '', '    # TODO Add this to deal with outliers?', '    # outside: Literal[\"keep\", \"drop\", \"clip\"] = \"keep\"', '', '    _priority: ClassVar[int] = 1', '', '    def tick(', '        self,', '        locator: Locator | None = None, *,', '        at: Sequence[float] = None,', '        upto: int | None = None,', '        count: int | None = None,', '        every: float | None = None,', '        between: tuple[float, float] | None = None,', '        minor: int | None = None,', '    ) -> Continuous:', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '        at : sequence of floats', '            Place ticks at these specific locations (in data units).', '        upto : int', '            Choose \"nice\" locations for ticks, but do not exceed this number.', '        count : int', '            Choose exactly this number of ticks, bounded by `between` or axis limits.', '        every : float', '            Choose locations at this interval of separation (in data units).', '        between : pair of floats', '            Bound upper / lower ticks when using `every` or `count`.', '        minor : int', '            Number of unlabeled ticks to draw between labeled \"major\" ticks.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        # Input checks', '        if locator is not None and not isinstance(locator, Locator):', '            raise TypeError(', '                f\"Tick locator must be an instance of {Locator!r}, \"', '                f\"not {type(locator)!r}.\"', '            )', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '        if log_base or symlog_thresh:', '            if count is not None and between is None:', '                raise RuntimeError(\"`count` requires `between` with log transform.\")', '            if every is not None:', '                raise RuntimeError(\"`every` not supported with log transform.\")', '', '        new = copy(self)', '        new._tick_params = {', '            \"locator\": locator,', '            \"at\": at,', '            \"upto\": upto,', '            \"count\": count,', '            \"every\": every,', '            \"between\": between,', '            \"minor\": minor,', '        }', '        return new', '', '    def label(', '        self,', '        formatter: Formatter | None = None, *,', '        like: str | Callable | None = None,', '        base: int | None = None,', '        unit: str | None = None,', '    ) -> Continuous:', '        \"\"\"', \"        Configure the appearance of tick labels for the scale's axis or legend.\", '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured formatter to use; other parameters will be ignored.', '        like : str or callable', '            Either a format pattern (e.g., `\".2f\"`), a format string with fields named', '            `x` and/or `pos` (e.g., `\"${x:.2f}\"`), or a callable that consumes a number', '            and returns a string.', '        base : number', '            Use log formatter (with scientific notation) having this value as the base.', '        unit : str or (str, str) tuple', '            Use  SI prefixes with these units (e.g., with `unit=\"g\"`, a tick value', '            of 5000 will appear as `5 kg`). When a tuple, the first element gives the', '            separator between the number and unit.', '', '        Returns', '        -------', '        scale', '            Copy of self with new label configuration.', '', '        \"\"\"', '        # Input checks', '        if formatter is not None and not isinstance(formatter, Formatter):', '            raise TypeError(', '                f\"Label formatter must be an instance of {Formatter!r}, \"', '                f\"not {type(formatter)!r}\"', '            )', '        if like is not None and not (isinstance(like, str) or callable(like)):', '            msg = f\"`like` must be a string or callable, not {type(like).__name__}.\"', '            raise TypeError(msg)', '', '        new = copy(self)', '        new._label_params = {', '            \"formatter\": formatter,', '            \"like\": like,', '            \"base\": base,', '            \"unit\": unit,', '        }', '        return new', '', '    def _parse_for_log_params(', '        self, trans: str | TransFuncs | None', '    ) -> tuple[float | None, float | None]:', '', '        log_base = symlog_thresh = None', '        if isinstance(trans, str):', '            m = re.match(r\"^log(\\\\d*)\", trans)', '            if m is not None:', '                log_base = float(m[1] or 10)', '            m = re.match(r\"symlog(\\\\d*)\", trans)', '            if m is not None:', '                symlog_thresh = float(m[1] or 1)', '        return log_base, symlog_thresh', '', '    def _get_locators(self, locator, at, upto, count, every, between, minor):', '', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '', '        if locator is not None:', '            major_locator = locator', '', '        elif upto is not None:', '            if log_base:', '                major_locator = LogLocator(base=log_base, numticks=upto)', '            else:', '                major_locator = MaxNLocator(upto, steps=[1, 1.5, 2, 2.5, 3, 5, 10])', '', '        elif count is not None:', '            if between is None:', '                # This is rarely useful (unless you are setting limits)', '                major_locator = LinearLocator(count)', '            else:', '                if log_base or symlog_thresh:', '                    forward, inverse = self._get_transform()', '                    lo, hi = forward(between)', '                    ticks = inverse(np.linspace(lo, hi, num=count))', '                else:', '                    ticks = np.linspace(*between, num=count)', '                major_locator = FixedLocator(ticks)', '', '        elif every is not None:', '            if between is None:', '                major_locator = MultipleLocator(every)', '            else:', '                lo, hi = between', '                ticks = np.arange(lo, hi + every, every)', '                major_locator = FixedLocator(ticks)', '', '        elif at is not None:', '            major_locator = FixedLocator(at)', '', '        else:', '            if log_base:', '                major_locator = LogLocator(log_base)', '            elif symlog_thresh:', '                major_locator = SymmetricalLogLocator(linthresh=symlog_thresh, base=10)', '            else:', '                major_locator = AutoLocator()', '', '        if minor is None:', '            minor_locator = LogLocator(log_base, subs=None) if log_base else None', '        else:', '            if log_base:', '                subs = np.linspace(0, log_base, minor + 2)[1:-1]', '                minor_locator = LogLocator(log_base, subs=subs)', '            else:', '                minor_locator = AutoMinorLocator(minor + 1)', '', '        return major_locator, minor_locator', '', '    def _get_formatter(self, locator, formatter, like, base, unit):', '', '        log_base, symlog_thresh = self._parse_for_log_params(self.trans)', '        if base is None:', '            if symlog_thresh:', '                log_base = 10', '            base = log_base', '', '        if formatter is not None:', '            return formatter', '', '        if like is not None:', '            if isinstance(like, str):', '                if \"{x\" in like or \"{pos\" in like:', '                    fmt = like', '                else:', '                    fmt = f\"{{x:{like}}}\"', '                formatter = StrMethodFormatter(fmt)', '            else:', '                formatter = FuncFormatter(like)', '', '        elif base is not None:', '            # We could add other log options if necessary', '            formatter = LogFormatterSciNotation(base)', '', '        elif unit is not None:', '            if isinstance(unit, tuple):', '                sep, unit = unit', '            elif not unit:', '                sep = \"\"', '            else:', '                sep = \" \"', '            formatter = EngFormatter(unit, sep=sep)', '', '        else:', '            formatter = ScalarFormatter()', '', '        return formatter', '', '', '@dataclass', 'class Temporal(ContinuousBase):', '    \"\"\"', '    A scale for date/time data.', '    \"\"\"', '    # TODO date: bool?', '    # For when we only care about the time component, would affect', '    # default formatter and norm conversion. Should also happen in', '    # Property.default_scale. The alternative was having distinct', '    # Calendric / Temporal scales, but that feels a bit fussy, and it', '    # would get in the way of using first-letter shorthands because', \"    # Calendric and Continuous would collide. Still, we haven't implemented\", '    # those yet, and having a clear distinction betewen date(time) / time', '    # may be more useful.', '', '    trans = None', '', '    _priority: ClassVar[int] = 2', '', '    def tick(', '        self, locator: Locator | None = None, *,', '        upto: int | None = None,', '    ) -> Temporal:', '        \"\"\"', \"        Configure the selection of ticks for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '', '        Parameters', '        ----------', '        locator : :class:`matplotlib.ticker.Locator` subclass', '            Pre-configured matplotlib locator; other parameters will not be used.', '        upto : int', '            Choose \"nice\" locations for ticks, but do not exceed this number.', '', '        Returns', '        -------', '        scale', '            Copy of self with new tick configuration.', '', '        \"\"\"', '        if locator is not None and not isinstance(locator, Locator):', '            err = (', '                f\"Tick locator must be an instance of {Locator!r}, \"', '                f\"not {type(locator)!r}.\"', '            )', '            raise TypeError(err)', '', '        new = copy(self)', '        new._tick_params = {\"locator\": locator, \"upto\": upto}', '        return new', '', '    def label(', '        self,', '        formatter: Formatter | None = None, *,', '        concise: bool = False,', '    ) -> Temporal:', '        \"\"\"', \"        Configure the appearance of tick labels for the scale's axis or legend.\", '', '        .. note::', '            This API is under construction and will be enhanced over time.', '', '        Parameters', '        ----------', '        formatter : :class:`matplotlib.ticker.Formatter` subclass', '            Pre-configured formatter to use; other parameters will be ignored.', '        concise : bool', '            If True, use :class:`matplotlib.dates.ConciseDateFormatter` to make', '            the tick labels as compact as possible.', '', '        Returns', '        -------', '        scale', '            Copy of self with new label configuration.', '', '        \"\"\"', '        new = copy(self)', '        new._label_params = {\"formatter\": formatter, \"concise\": concise}', '        return new', '', '    def _get_locators(self, locator, upto):', '', '        if locator is not None:', '            major_locator = locator', '        elif upto is not None:', '            major_locator = AutoDateLocator(minticks=2, maxticks=upto)', '', '        else:', '            major_locator = AutoDateLocator(minticks=2, maxticks=6)', '        minor_locator = None', '', '        return major_locator, minor_locator', '', '    def _get_formatter(self, locator, formatter, concise):', '', '        if formatter is not None:', '            return formatter', '', '        if concise:', '            # TODO ideally we would have concise coordinate ticks,', '            # but full semantic ticks. Is that possible?', '            formatter = ConciseDateFormatter(locator)', '        else:', '            formatter = AutoDateFormatter(locator)', '', '        return formatter', '', '', '# ----------------------------------------------------------------------------------- #', '', '', '# TODO Have this separate from Temporal or have Temporal(date=True) or similar?', '# class Calendric(Scale):', '', '# TODO Needed? Or handle this at layer (in stat or as param, eg binning=)', '# class Binned(Scale):', '', '# TODO any need for color-specific scales?', '# class Sequential(Continuous):', '# class Diverging(Continuous):', '# class Qualitative(Nominal):', '', '', '# ----------------------------------------------------------------------------------- #', '', '', 'class PseudoAxis:', '    \"\"\"', '    Internal class implementing minimal interface equivalent to matplotlib Axis.', '', '    Coordinate variables are typically scaled by attaching the Axis object from', '    the figure where the plot will end up. Matplotlib has no similar concept of', '    and axis for the other mappable variables (color, etc.), but to simplify the', '    code, this object acts like an Axis and can be used to scale other variables.', '', '    \"\"\"', '    axis_name = \"\"  # Matplotlib requirement but not actually used', '', '    def __init__(self, scale):', '', '        self.converter = None', '        self.units = None', '        self.scale = scale', '        self.major = mpl.axis.Ticker()', '        self.minor = mpl.axis.Ticker()', '', '        # It appears that this needs to be initialized this way on matplotlib 3.1,', '        # but not later versions. It is unclear whether there are any issues with it.', '        self._data_interval = None, None', '', '        scale.set_default_locators_and_formatters(self)', '        # self.set_default_intervals()  Is this ever needed?', '', '    def set_view_interval(self, vmin, vmax):', '        self._view_interval = vmin, vmax', '', '    def get_view_interval(self):', '        return self._view_interval', '', '    # TODO do we want to distinguish view/data intervals? e.g. for a legend', '    # we probably want to represent the full range of the data values, but', \"    # still norm the colormap. If so, we'll need to track data range separately\", \"    # from the norm, which we currently don't do.\", '', '    def set_data_interval(self, vmin, vmax):', '        self._data_interval = vmin, vmax', '', '    def get_data_interval(self):', '        return self._data_interval', '', '    def get_tick_space(self):', '        # TODO how to do this in a configurable / auto way?', '        # Would be cool to have legend density adapt to figure size, etc.', '        return 5', '', '    def set_major_locator(self, locator):', '        self.major.locator = locator', '        locator.set_axis(self)', '', '    def set_major_formatter(self, formatter):', '        self.major.formatter = formatter', '        formatter.set_axis(self)', '', '    def set_minor_locator(self, locator):', '        self.minor.locator = locator', '        locator.set_axis(self)', '', '    def set_minor_formatter(self, formatter):', '        self.minor.formatter = formatter', '        formatter.set_axis(self)', '', '    def set_units(self, units):', '        self.units = units', '', '    def update_units(self, x):', '        \"\"\"Pass units to the internal converter, potentially updating its mapping.\"\"\"', '        self.converter = mpl.units.registry.get_converter(x)', '        if self.converter is not None:', '            self.converter.default_units(x, self)', '', '            info = self.converter.axisinfo(self.units, self)', '', '            if info is None:', '                return', '            if info.majloc is not None:', '                self.set_major_locator(info.majloc)', '            if info.majfmt is not None:', '                self.set_major_formatter(info.majfmt)', '', '            # This is in matplotlib method; do we need this?', '            # self.set_default_intervals()', '', '    def convert_units(self, x):', '        \"\"\"Return a numeric representation of the input data.\"\"\"', '        if np.issubdtype(np.asarray(x).dtype, np.number):', '            return x', '        elif self.converter is None:', '            return x', '        return self.converter.convert(x, self.units, self)', '', '    def get_scale(self):', '        # Note that matplotlib actually returns a string here!', '        # (e.g., with a log scale, axis.get_scale() returns \"log\")', '        # Currently we just hit it with minor ticks where it checks for', '        # scale == \"log\". I\\'m not sure how you\\'d actually use log-scale', '        # minor \"ticks\" in a legend context, so this is fine....', '        return self.scale', '', '    def get_majorticklocs(self):', '        return self.major.locator()', '', '', '# ------------------------------------------------------------------------------------ #', '# Transform function creation', '', '', 'def _make_identity_transforms() -> TransFuncs:', '', '    def identity(x):', '        return x', '', '    return identity, identity', '', '', 'def _make_logit_transforms(base: float = None) -> TransFuncs:', '', '    log, exp = _make_log_transforms(base)', '', '    def logit(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return log(x) - log(1 - x)', '', '    def expit(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return exp(x) / (1 + exp(x))', '', '    return logit, expit', '', '', 'def _make_log_transforms(base: float | None = None) -> TransFuncs:', '', '    fs: TransFuncs', '    if base is None:', '        fs = np.log, np.exp', '    elif base == 2:', '        fs = np.log2, partial(np.power, 2)', '    elif base == 10:', '        fs = np.log10, partial(np.power, 10)', '    else:', '        def forward(x):', '            return np.log(x) / np.log(base)', '        fs = forward, partial(np.power, base)', '', '    def log(x: ArrayLike) -> ArrayLike:', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return fs[0](x)', '', '    def exp(x: ArrayLike) -> ArrayLike:', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return fs[1](x)', '', '    return log, exp', '', '', 'def _make_symlog_transforms(c: float = 1, base: float = 10) -> TransFuncs:', '', '    # From https://iopscience.iop.org/article/10.1088/0957-0233/24/2/027001', '', '    # Note: currently not using base because we only get', '    # one parameter from the string, and are using c (this is consistent with d3)', '', '    log, exp = _make_log_transforms(base)', '', '    def symlog(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return np.sign(x) * log(1 + np.abs(np.divide(x, c)))', '', '    def symexp(x):', '        with np.errstate(invalid=\"ignore\", divide=\"ignore\"):', '            return np.sign(x) * c * (exp(np.abs(x)) - 1)', '', '    return symlog, symexp', '', '', 'def _make_sqrt_transforms() -> TransFuncs:', '', '    def sqrt(x):', '        return np.sign(x) * np.sqrt(np.abs(x))', '', '    def square(x):', '        return np.sign(x) * np.square(x)', '', '    return sqrt, square', '', '', 'def _make_power_transforms(exp: float) -> TransFuncs:', '', '    def forward(x):', '        return np.sign(x) * np.power(np.abs(x), exp)', '', '    def inverse(x):', '        return np.sign(x) * np.power(np.abs(x), 1 / exp)', '', '    return forward, inverse']}, 'rules.py': {'classes': [{'name': 'VarType', 'start_line': 17, 'end_line': 35, 'text': ['class VarType(UserString):', '    \"\"\"', '    Prevent comparisons elsewhere in the library from using the wrong name.', '', '    Errors are simple assertions because users should not be able to trigger', '    them. If that changes, they should be more verbose.', '', '    \"\"\"', '    # TODO VarType is an awfully overloaded name, but so is DataType ...', '    # TODO adding unknown because we are using this in for scales, is that right?', '    allowed = \"numeric\", \"datetime\", \"categorical\", \"unknown\"', '', '    def __init__(self, data):', '        assert data in self.allowed, data', '        super().__init__(data)', '', '    def __eq__(self, other):', '        assert other in self.allowed, other', '        return self.data == other'], 'methods': [{'name': '__init__', 'start_line': 29, 'end_line': 31, 'text': ['    def __init__(self, data):', '        assert data in self.allowed, data', '        super().__init__(data)']}, {'name': '__eq__', 'start_line': 33, 'end_line': 35, 'text': ['    def __eq__(self, other):', '        assert other in self.allowed, other', '        return self.data == other']}]}], 'functions': [{'name': 'variable_type', 'start_line': 38, 'end_line': 122, 'text': ['def variable_type(', '    vector: Series,', '    boolean_type: Literal[\"numeric\", \"categorical\"] = \"numeric\",', ') -> VarType:', '    \"\"\"', '    Determine whether a vector contains numeric, categorical, or datetime data.', '', '    This function differs from the pandas typing API in two ways:', '', '    - Python sequences or object-typed PyData objects are considered numeric if', '      all of their entries are numeric.', '    - String or mixed-type data are considered categorical even if not', '      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.', '', '    Parameters', '    ----------', '    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence', '        Input data to test.', \"    boolean_type : 'numeric' or 'categorical'\", '        Type to use for vectors containing only 0s and 1s (and NAs).', '', '    Returns', '    -------', \"    var_type : 'numeric', 'categorical', or 'datetime'\", '        Name identifying the type of data in the vector.', '    \"\"\"', '', '    # If a categorical dtype is set, infer categorical', '    if pd.api.types.is_categorical_dtype(vector):', '        return VarType(\"categorical\")', '', '    # Special-case all-na data, which is always \"numeric\"', '    if pd.isna(vector).all():', '        return VarType(\"numeric\")', '', '    # Special-case binary/boolean data, allow caller to determine', '    # This triggers a numpy warning when vector has strings/objects', '    # https://github.com/numpy/numpy/issues/6784', '    # Because we reduce with .all(), we are agnostic about whether the', '    # comparison returns a scalar or vector, so we will ignore the warning.', '    # It triggers a separate DeprecationWarning when the vector has datetimes:', '    # https://github.com/numpy/numpy/issues/13548', '    # This is considered a bug by numpy and will likely go away.', '    with warnings.catch_warnings():', '        warnings.simplefilter(', \"            action='ignore',\", '            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?', '        )', '        if np.isin(vector, [0, 1, np.nan]).all():', '            return VarType(boolean_type)', '', '    # Defer to positive pandas tests', '    if pd.api.types.is_numeric_dtype(vector):', '        return VarType(\"numeric\")', '', '    if pd.api.types.is_datetime64_dtype(vector):', '        return VarType(\"datetime\")', '', '    # --- If we get to here, we need to check the entries', '', '    # Check for a collection where everything is a number', '', '    def all_numeric(x):', '        for x_i in x:', '            if not isinstance(x_i, Number):', '                return False', '        return True', '', '    if all_numeric(vector):', '        return VarType(\"numeric\")', '', '    # Check for a collection where everything is a datetime', '', '    def all_datetime(x):', '        for x_i in x:', '            if not isinstance(x_i, (datetime, np.datetime64)):', '                return False', '        return True', '', '    if all_datetime(vector):', '        return VarType(\"datetime\")', '', '    # Otherwise, our final fallback is to consider things categorical', '', '    return VarType(\"categorical\")']}, {'name': 'categorical_order', 'start_line': 125, 'end_line': 153, 'text': ['def categorical_order(vector: Series, order: list | None = None) -> list:', '    \"\"\"', \"    Return a list of unique data values using seaborn's ordering rules.\", '', '    Parameters', '    ----------', '    vector : Series', '        Vector of \"categorical\" values', '    order : list', '        Desired order of category levels to override the order determined', '        from the `data` object.', '', '    Returns', '    -------', '    order : list', '        Ordered list of category levels not including null values.', '', '    \"\"\"', '    if order is not None:', '        return order', '', '    if vector.dtype.name == \"category\":', '        order = list(vector.cat.categories)', '    else:', '        order = list(filter(pd.notnull, vector.unique()))', '        if variable_type(pd.Series(order)) == \"numeric\":', '            order.sort()', '', '    return order']}, {'name': 'all_numeric', 'start_line': 100, 'end_line': 104, 'text': ['    def all_numeric(x):', '        for x_i in x:', '            if not isinstance(x_i, Number):', '                return False', '        return True']}, {'name': 'all_datetime', 'start_line': 111, 'end_line': 115, 'text': ['    def all_datetime(x):', '        for x_i in x:', '            if not isinstance(x_i, (datetime, np.datetime64)):', '                return False', '        return True']}], 'text': ['from __future__ import annotations', '', 'import warnings', 'from collections import UserString', 'from numbers import Number', 'from datetime import datetime', '', 'import numpy as np', 'import pandas as pd', '', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:', '    from typing import Literal', '    from pandas import Series', '', '', 'class VarType(UserString):', '    \"\"\"', '    Prevent comparisons elsewhere in the library from using the wrong name.', '', '    Errors are simple assertions because users should not be able to trigger', '    them. If that changes, they should be more verbose.', '', '    \"\"\"', '    # TODO VarType is an awfully overloaded name, but so is DataType ...', '    # TODO adding unknown because we are using this in for scales, is that right?', '    allowed = \"numeric\", \"datetime\", \"categorical\", \"unknown\"', '', '    def __init__(self, data):', '        assert data in self.allowed, data', '        super().__init__(data)', '', '    def __eq__(self, other):', '        assert other in self.allowed, other', '        return self.data == other', '', '', 'def variable_type(', '    vector: Series,', '    boolean_type: Literal[\"numeric\", \"categorical\"] = \"numeric\",', ') -> VarType:', '    \"\"\"', '    Determine whether a vector contains numeric, categorical, or datetime data.', '', '    This function differs from the pandas typing API in two ways:', '', '    - Python sequences or object-typed PyData objects are considered numeric if', '      all of their entries are numeric.', '    - String or mixed-type data are considered categorical even if not', '      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`.', '', '    Parameters', '    ----------', '    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence', '        Input data to test.', \"    boolean_type : 'numeric' or 'categorical'\", '        Type to use for vectors containing only 0s and 1s (and NAs).', '', '    Returns', '    -------', \"    var_type : 'numeric', 'categorical', or 'datetime'\", '        Name identifying the type of data in the vector.', '    \"\"\"', '', '    # If a categorical dtype is set, infer categorical', '    if pd.api.types.is_categorical_dtype(vector):', '        return VarType(\"categorical\")', '', '    # Special-case all-na data, which is always \"numeric\"', '    if pd.isna(vector).all():', '        return VarType(\"numeric\")', '', '    # Special-case binary/boolean data, allow caller to determine', '    # This triggers a numpy warning when vector has strings/objects', '    # https://github.com/numpy/numpy/issues/6784', '    # Because we reduce with .all(), we are agnostic about whether the', '    # comparison returns a scalar or vector, so we will ignore the warning.', '    # It triggers a separate DeprecationWarning when the vector has datetimes:', '    # https://github.com/numpy/numpy/issues/13548', '    # This is considered a bug by numpy and will likely go away.', '    with warnings.catch_warnings():', '        warnings.simplefilter(', \"            action='ignore',\", '            category=(FutureWarning, DeprecationWarning)  # type: ignore  # mypy bug?', '        )', '        if np.isin(vector, [0, 1, np.nan]).all():', '            return VarType(boolean_type)', '', '    # Defer to positive pandas tests', '    if pd.api.types.is_numeric_dtype(vector):', '        return VarType(\"numeric\")', '', '    if pd.api.types.is_datetime64_dtype(vector):', '        return VarType(\"datetime\")', '', '    # --- If we get to here, we need to check the entries', '', '    # Check for a collection where everything is a number', '', '    def all_numeric(x):', '        for x_i in x:', '            if not isinstance(x_i, Number):', '                return False', '        return True', '', '    if all_numeric(vector):', '        return VarType(\"numeric\")', '', '    # Check for a collection where everything is a datetime', '', '    def all_datetime(x):', '        for x_i in x:', '            if not isinstance(x_i, (datetime, np.datetime64)):', '                return False', '        return True', '', '    if all_datetime(vector):', '        return VarType(\"datetime\")', '', '    # Otherwise, our final fallback is to consider things categorical', '', '    return VarType(\"categorical\")', '', '', 'def categorical_order(vector: Series, order: list | None = None) -> list:', '    \"\"\"', \"    Return a list of unique data values using seaborn's ordering rules.\", '', '    Parameters', '    ----------', '    vector : Series', '        Vector of \"categorical\" values', '    order : list', '        Desired order of category levels to override the order determined', '        from the `data` object.', '', '    Returns', '    -------', '    order : list', '        Ordered list of category levels not including null values.', '', '    \"\"\"', '    if order is not None:', '        return order', '', '    if vector.dtype.name == \"category\":', '        order = list(vector.cat.categories)', '    else:', '        order = list(filter(pd.notnull, vector.unique()))', '        if variable_type(pd.Series(order)) == \"numeric\":', '            order.sort()', '', '    return order']}, 'typing.py': {'classes': [{'name': 'Default', 'start_line': 34, 'end_line': 36, 'text': ['class Default:', '    def __repr__(self):', '        return \"<default>\"'], 'methods': [{'name': '__repr__', 'start_line': 35, 'end_line': 36, 'text': ['    def __repr__(self):', '        return \"<default>\"']}]}], 'functions': [], 'text': ['from __future__ import annotations', '', 'from datetime import date, datetime, timedelta', 'from typing import Any, Optional, Union, Mapping, Tuple, List, Dict', 'from collections.abc import Hashable, Iterable', '', 'from numpy import ndarray  # TODO use ArrayLike?', 'from pandas import DataFrame, Series, Index, Timestamp, Timedelta', 'from matplotlib.colors import Colormap, Normalize', '', '', 'ColumnName = Union[', '    str, bytes, date, datetime, timedelta, bool, complex, Timestamp, Timedelta', ']', 'Vector = Union[Series, Index, ndarray]', '', 'VariableSpec = Union[ColumnName, Vector, None]', 'VariableSpecList = Union[List[VariableSpec], Index, None]', '', 'DataSource = Union[DataFrame, Mapping[Hashable, Vector], None]', '', 'OrderSpec = Union[Iterable, None]  # TODO technically str is iterable', 'NormSpec = Union[Tuple[Optional[float], Optional[float]], Normalize, None]', '', '# TODO for discrete mappings, it would be ideal to use a parameterized type', '# as the dict values / list entries should be of specific type(s) for each method', 'PaletteSpec = Union[str, list, dict, Colormap, None]', 'DiscreteValueSpec = Union[dict, list, None]', 'ContinuousValueSpec = Union[', '    Tuple[float, float], List[float], Dict[Any, float], None,', ']', '', '', 'class Default:', '    def __repr__(self):', '        return \"<default>\"', '', '', 'default = Default()']}}, '_marks': {'base.py': {'classes': [{'name': 'Mappable', 'start_line': 25, 'end_line': 90, 'text': ['class Mappable:', '    def __init__(', '        self,', '        val: Any = None,', '        depend: str | None = None,', '        rc: str | None = None,', '        auto: bool = False,', '        grouping: bool = True,', '    ):', '        \"\"\"', '        Property that can be mapped from data or set directly, with flexible defaults.', '', '        Parameters', '        ----------', '        val : Any', '            Use this value as the default.', '        depend : str', '            Use the value of this feature as the default.', '        rc : str', '            Use the value of this rcParam as the default.', '        auto : bool', '            The default value will depend on other parameters at compile time.', '        grouping : bool', '            If True, use the mapped variable to define groups.', '', '        \"\"\"', '        if depend is not None:', '            assert depend in PROPERTIES', '        if rc is not None:', '            assert rc in mpl.rcParams', '', '        self._val = val', '        self._rc = rc', '        self._depend = depend', '        self._auto = auto', '        self._grouping = grouping', '', '    def __repr__(self):', '        \"\"\"Nice formatting for when object appears in Mark init signature.\"\"\"', '        if self._val is not None:', '            s = f\"<{repr(self._val)}>\"', '        elif self._depend is not None:', '            s = f\"<depend:{self._depend}>\"', '        elif self._rc is not None:', '            s = f\"<rc:{self._rc}>\"', '        elif self._auto:', '            s = \"<auto>\"', '        else:', '            s = \"<undefined>\"', '        return s', '', '    @property', '    def depend(self) -> Any:', '        \"\"\"Return the name of the feature to source a default value from.\"\"\"', '        return self._depend', '', '    @property', '    def grouping(self) -> bool:', '        return self._grouping', '', '    @property', '    def default(self) -> Any:', '        \"\"\"Get the default value for this feature, or access the relevant rcParam.\"\"\"', '        if self._val is not None:', '            return self._val', '        return mpl.rcParams.get(self._rc)'], 'methods': [{'name': '__init__', 'start_line': 26, 'end_line': 60, 'text': ['    def __init__(', '        self,', '        val: Any = None,', '        depend: str | None = None,', '        rc: str | None = None,', '        auto: bool = False,', '        grouping: bool = True,', '    ):', '        \"\"\"', '        Property that can be mapped from data or set directly, with flexible defaults.', '', '        Parameters', '        ----------', '        val : Any', '            Use this value as the default.', '        depend : str', '            Use the value of this feature as the default.', '        rc : str', '            Use the value of this rcParam as the default.', '        auto : bool', '            The default value will depend on other parameters at compile time.', '        grouping : bool', '            If True, use the mapped variable to define groups.', '', '        \"\"\"', '        if depend is not None:', '            assert depend in PROPERTIES', '        if rc is not None:', '            assert rc in mpl.rcParams', '', '        self._val = val', '        self._rc = rc', '        self._depend = depend', '        self._auto = auto', '        self._grouping = grouping']}, {'name': '__repr__', 'start_line': 62, 'end_line': 74, 'text': ['    def __repr__(self):', '        \"\"\"Nice formatting for when object appears in Mark init signature.\"\"\"', '        if self._val is not None:', '            s = f\"<{repr(self._val)}>\"', '        elif self._depend is not None:', '            s = f\"<depend:{self._depend}>\"', '        elif self._rc is not None:', '            s = f\"<rc:{self._rc}>\"', '        elif self._auto:', '            s = \"<auto>\"', '        else:', '            s = \"<undefined>\"', '        return s']}, {'name': 'depend', 'start_line': 77, 'end_line': 79, 'text': ['    def depend(self) -> Any:', '        \"\"\"Return the name of the feature to source a default value from.\"\"\"', '        return self._depend']}, {'name': 'grouping', 'start_line': 82, 'end_line': 83, 'text': ['    def grouping(self) -> bool:', '        return self._grouping']}, {'name': 'default', 'start_line': 86, 'end_line': 90, 'text': ['    def default(self) -> Any:', '        \"\"\"Get the default value for this feature, or access the relevant rcParam.\"\"\"', '        if self._val is not None:', '            return self._val', '        return mpl.rcParams.get(self._rc)']}]}, {'name': 'Mark', 'start_line': 103, 'end_line': 221, 'text': ['class Mark:', '    \"\"\"Base class for objects that visually represent data.\"\"\"', '', '    artist_kws: dict = field(default_factory=dict)', '', '    @property', '    def _mappable_props(self):', '        return {', '            f.name: getattr(self, f.name) for f in fields(self)', '            if isinstance(f.default, Mappable)', '        }', '', '    @property', '    def _grouping_props(self):', \"        # TODO does it make sense to have variation within a Mark's\", '        # properties about whether they are grouping?', '        return [', '            f.name for f in fields(self)', '            if isinstance(f.default, Mappable) and f.default.grouping', '        ]', '', '    # TODO make this method private? Would extender every need to call directly?', '    def _resolve(', '        self,', '        data: DataFrame | dict[str, Any],', '        name: str,', '        scales: dict[str, Scale] | None = None,', '    ) -> Any:', '        \"\"\"Obtain default, specified, or mapped value for a named feature.', '', '        Parameters', '        ----------', '        data : DataFrame or dict with scalar values', '            Container with data values for features that will be semantically mapped.', '        name : string', '            Identity of the feature / semantic.', '        scales: dict', '            Mapping from variable to corresponding scale object.', '', '        Returns', '        -------', '        value or array of values', '            Outer return type depends on whether `data` is a dict (implying that', '            we want a single value) or DataFrame (implying that we want an array', '            of values with matching length).', '', '        \"\"\"', '        feature = self._mappable_props[name]', '        prop = PROPERTIES.get(name, Property(name))', '        directly_specified = not isinstance(feature, Mappable)', '        return_multiple = isinstance(data, pd.DataFrame)', '        return_array = return_multiple and not name.endswith(\"style\")', '', '        # Special case width because it needs to be resolved and added to the dataframe', '        # during layer prep (so the Move operations use it properly).', '        # TODO how does width *scaling* work, e.g. for violin width by count?', '        if name == \"width\":', '            directly_specified = directly_specified and name not in data', '', '        if directly_specified:', '            feature = prop.standardize(feature)', '            if return_multiple:', '                feature = [feature] * len(data)', '            if return_array:', '                feature = np.array(feature)', '            return feature', '', '        if name in data:', '            if scales is None or name not in scales:', \"                # TODO Might this obviate the identity scale? Just don't add a scale?\", '                feature = data[name]', '            else:', '                feature = scales[name](data[name])', '            if return_array:', '                feature = np.asarray(feature)', '            return feature', '', '        if feature.depend is not None:', '            # TODO add source_func or similar to transform the source value?', '            # e.g. set linewidth as a proportion of pointsize?', '            return self._resolve(data, feature.depend, scales)', '', '        default = prop.standardize(feature.default)', '        if return_multiple:', '            default = [default] * len(data)', '        if return_array:', '            default = np.array(default)', '        return default', '', '    def _infer_orient(self, scales: dict) -> str:  # TODO type scales', '', '        # TODO The original version of this (in seaborn._oldcore) did more checking.', '        # Paring that down here for the prototype to see what restrictions make sense.', '', '        # TODO rethink this to map from scale type to \"DV priority\" and use that?', '        # e.g. Nominal > Discrete > Continuous', '', '        x = 0 if \"x\" not in scales else scales[\"x\"]._priority', '        y = 0 if \"y\" not in scales else scales[\"y\"]._priority', '', '        if y > x:', '            return \"y\"', '        else:', '            return \"x\"', '', '    def _plot(', '        self,', '        split_generator: Callable[[], Generator],', '        scales: dict[str, Scale],', '        orient: str,', '    ) -> None:', '        \"\"\"Main interface for creating a plot.\"\"\"', '        raise NotImplementedError()', '', '    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '', '        return None'], 'methods': [{'name': '_mappable_props', 'start_line': 109, 'end_line': 113, 'text': ['    def _mappable_props(self):', '        return {', '            f.name: getattr(self, f.name) for f in fields(self)', '            if isinstance(f.default, Mappable)', '        }']}, {'name': '_grouping_props', 'start_line': 116, 'end_line': 122, 'text': ['    def _grouping_props(self):', \"        # TODO does it make sense to have variation within a Mark's\", '        # properties about whether they are grouping?', '        return [', '            f.name for f in fields(self)', '            if isinstance(f.default, Mappable) and f.default.grouping', '        ]']}, {'name': '_resolve', 'start_line': 125, 'end_line': 190, 'text': ['    def _resolve(', '        self,', '        data: DataFrame | dict[str, Any],', '        name: str,', '        scales: dict[str, Scale] | None = None,', '    ) -> Any:', '        \"\"\"Obtain default, specified, or mapped value for a named feature.', '', '        Parameters', '        ----------', '        data : DataFrame or dict with scalar values', '            Container with data values for features that will be semantically mapped.', '        name : string', '            Identity of the feature / semantic.', '        scales: dict', '            Mapping from variable to corresponding scale object.', '', '        Returns', '        -------', '        value or array of values', '            Outer return type depends on whether `data` is a dict (implying that', '            we want a single value) or DataFrame (implying that we want an array', '            of values with matching length).', '', '        \"\"\"', '        feature = self._mappable_props[name]', '        prop = PROPERTIES.get(name, Property(name))', '        directly_specified = not isinstance(feature, Mappable)', '        return_multiple = isinstance(data, pd.DataFrame)', '        return_array = return_multiple and not name.endswith(\"style\")', '', '        # Special case width because it needs to be resolved and added to the dataframe', '        # during layer prep (so the Move operations use it properly).', '        # TODO how does width *scaling* work, e.g. for violin width by count?', '        if name == \"width\":', '            directly_specified = directly_specified and name not in data', '', '        if directly_specified:', '            feature = prop.standardize(feature)', '            if return_multiple:', '                feature = [feature] * len(data)', '            if return_array:', '                feature = np.array(feature)', '            return feature', '', '        if name in data:', '            if scales is None or name not in scales:', \"                # TODO Might this obviate the identity scale? Just don't add a scale?\", '                feature = data[name]', '            else:', '                feature = scales[name](data[name])', '            if return_array:', '                feature = np.asarray(feature)', '            return feature', '', '        if feature.depend is not None:', '            # TODO add source_func or similar to transform the source value?', '            # e.g. set linewidth as a proportion of pointsize?', '            return self._resolve(data, feature.depend, scales)', '', '        default = prop.standardize(feature.default)', '        if return_multiple:', '            default = [default] * len(data)', '        if return_array:', '            default = np.array(default)', '        return default']}, {'name': '_infer_orient', 'start_line': 192, 'end_line': 206, 'text': ['    def _infer_orient(self, scales: dict) -> str:  # TODO type scales', '', '        # TODO The original version of this (in seaborn._oldcore) did more checking.', '        # Paring that down here for the prototype to see what restrictions make sense.', '', '        # TODO rethink this to map from scale type to \"DV priority\" and use that?', '        # e.g. Nominal > Discrete > Continuous', '', '        x = 0 if \"x\" not in scales else scales[\"x\"]._priority', '        y = 0 if \"y\" not in scales else scales[\"y\"]._priority', '', '        if y > x:', '            return \"y\"', '        else:', '            return \"x\"']}, {'name': '_plot', 'start_line': 208, 'end_line': 215, 'text': ['    def _plot(', '        self,', '        split_generator: Callable[[], Generator],', '        scales: dict[str, Scale],', '        orient: str,', '    ) -> None:', '        \"\"\"Main interface for creating a plot.\"\"\"', '        raise NotImplementedError()']}, {'name': '_legend_artist', 'start_line': 217, 'end_line': 221, 'text': ['    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '', '        return None']}]}], 'functions': [{'name': 'resolve_properties', 'start_line': 224, 'end_line': 231, 'text': ['def resolve_properties(', '    mark: Mark, data: DataFrame, scales: dict[str, Scale]', ') -> dict[str, Any]:', '', '    props = {', '        name: mark._resolve(data, name, scales) for name in mark._mappable_props', '    }', '    return props']}, {'name': 'resolve_color', 'start_line': 234, 'end_line': 284, 'text': ['def resolve_color(', '    mark: Mark,', '    data: DataFrame | dict,', '    prefix: str = \"\",', '    scales: dict[str, Scale] | None = None,', ') -> RGBATuple | ndarray:', '    \"\"\"', '    Obtain a default, specified, or mapped value for a color feature.', '', '    This method exists separately to support the relationship between a', '    color and its corresponding alpha. We want to respect alpha values that', '    are passed in specified (or mapped) color values but also make use of a', '    separate `alpha` variable, which can be mapped. This approach may also', '    be extended to support mapping of specific color channels (i.e.', '    luminance, chroma) in the future.', '', '    Parameters', '    ----------', '    mark :', '        Mark with the color property.', '    data :', '        Container with data values for features that will be semantically mapped.', '    prefix :', '        Support \"color\", \"fillcolor\", etc.', '', '    \"\"\"', '    color = mark._resolve(data, f\"{prefix}color\", scales)', '', '    if f\"{prefix}alpha\" in mark._mappable_props:', '        alpha = mark._resolve(data, f\"{prefix}alpha\", scales)', '    else:', '        alpha = mark._resolve(data, \"alpha\", scales)', '', '    def visible(x, axis=None):', '        \"\"\"Detect \"invisible\" colors to set alpha appropriately.\"\"\"', '        # TODO First clause only needed to handle non-rgba arrays,', '        # which we are trying to handle upstream', '        return np.array(x).dtype.kind != \"f\" or np.isfinite(x).all(axis)', '', '    # Second check here catches vectors of strings with identity scale', '    # It could probably be handled better upstream. This is a tricky problem', '    if np.ndim(color) < 2 and all(isinstance(x, float) for x in color):', '        if len(color) == 4:', '            return mpl.colors.to_rgba(color)', '        alpha = alpha if visible(color) else np.nan', '        return mpl.colors.to_rgba(color, alpha)', '    else:', '        if np.ndim(color) == 2 and color.shape[1] == 4:', '            return mpl.colors.to_rgba_array(color)', '        alpha = np.where(visible(color, axis=1), alpha, np.nan)', '        return mpl.colors.to_rgba_array(color, alpha)']}, {'name': 'document_properties', 'start_line': 290, 'end_line': 309, 'text': ['def document_properties(mark):', '', '    properties = [f.name for f in fields(mark) if isinstance(f.default, Mappable)]', '    text = [', '        \"\",', '        \"    This mark defines the following properties:\",', '        textwrap.fill(', '            \", \".join([f\"|{p}|\" for p in properties]),', '            width=78, initial_indent=\" \" * 8, subsequent_indent=\" \" * 8,', '        ),', '    ]', '', '    docstring_lines = mark.__doc__.split(\"\\\\n\")', '    new_docstring = \"\\\\n\".join([', '        *docstring_lines[:2],', '        *text,', '        *docstring_lines[2:],', '    ])', '    mark.__doc__ = new_docstring', '    return mark']}, {'name': 'visible', 'start_line': 267, 'end_line': 271, 'text': ['    def visible(x, axis=None):', '        \"\"\"Detect \"invisible\" colors to set alpha appropriately.\"\"\"', '        # TODO First clause only needed to handle non-rgba arrays,', '        # which we are trying to handle upstream', '        return np.array(x).dtype.kind != \"f\" or np.isfinite(x).all(axis)']}], 'text': ['from __future__ import annotations', 'from dataclasses import dataclass, fields, field', 'import textwrap', 'from typing import Any, Callable, Union', 'from collections.abc import Generator', '', 'import numpy as np', 'import pandas as pd', 'import matplotlib as mpl', '', 'from numpy import ndarray', 'from pandas import DataFrame', 'from matplotlib.artist import Artist', '', 'from seaborn._core.scales import Scale', 'from seaborn._core.properties import (', '    PROPERTIES,', '    Property,', '    RGBATuple,', '    DashPattern,', '    DashPatternWithOffset,', ')', '', '', 'class Mappable:', '    def __init__(', '        self,', '        val: Any = None,', '        depend: str | None = None,', '        rc: str | None = None,', '        auto: bool = False,', '        grouping: bool = True,', '    ):', '        \"\"\"', '        Property that can be mapped from data or set directly, with flexible defaults.', '', '        Parameters', '        ----------', '        val : Any', '            Use this value as the default.', '        depend : str', '            Use the value of this feature as the default.', '        rc : str', '            Use the value of this rcParam as the default.', '        auto : bool', '            The default value will depend on other parameters at compile time.', '        grouping : bool', '            If True, use the mapped variable to define groups.', '', '        \"\"\"', '        if depend is not None:', '            assert depend in PROPERTIES', '        if rc is not None:', '            assert rc in mpl.rcParams', '', '        self._val = val', '        self._rc = rc', '        self._depend = depend', '        self._auto = auto', '        self._grouping = grouping', '', '    def __repr__(self):', '        \"\"\"Nice formatting for when object appears in Mark init signature.\"\"\"', '        if self._val is not None:', '            s = f\"<{repr(self._val)}>\"', '        elif self._depend is not None:', '            s = f\"<depend:{self._depend}>\"', '        elif self._rc is not None:', '            s = f\"<rc:{self._rc}>\"', '        elif self._auto:', '            s = \"<auto>\"', '        else:', '            s = \"<undefined>\"', '        return s', '', '    @property', '    def depend(self) -> Any:', '        \"\"\"Return the name of the feature to source a default value from.\"\"\"', '        return self._depend', '', '    @property', '    def grouping(self) -> bool:', '        return self._grouping', '', '    @property', '    def default(self) -> Any:', '        \"\"\"Get the default value for this feature, or access the relevant rcParam.\"\"\"', '        if self._val is not None:', '            return self._val', '        return mpl.rcParams.get(self._rc)', '', '', '# TODO where is the right place to put this kind of type aliasing?', '', 'MappableBool = Union[bool, Mappable]', 'MappableString = Union[str, Mappable]', 'MappableFloat = Union[float, Mappable]', 'MappableColor = Union[str, tuple, Mappable]', 'MappableStyle = Union[str, DashPattern, DashPatternWithOffset, Mappable]', '', '', '@dataclass', 'class Mark:', '    \"\"\"Base class for objects that visually represent data.\"\"\"', '', '    artist_kws: dict = field(default_factory=dict)', '', '    @property', '    def _mappable_props(self):', '        return {', '            f.name: getattr(self, f.name) for f in fields(self)', '            if isinstance(f.default, Mappable)', '        }', '', '    @property', '    def _grouping_props(self):', \"        # TODO does it make sense to have variation within a Mark's\", '        # properties about whether they are grouping?', '        return [', '            f.name for f in fields(self)', '            if isinstance(f.default, Mappable) and f.default.grouping', '        ]', '', '    # TODO make this method private? Would extender every need to call directly?', '    def _resolve(', '        self,', '        data: DataFrame | dict[str, Any],', '        name: str,', '        scales: dict[str, Scale] | None = None,', '    ) -> Any:', '        \"\"\"Obtain default, specified, or mapped value for a named feature.', '', '        Parameters', '        ----------', '        data : DataFrame or dict with scalar values', '            Container with data values for features that will be semantically mapped.', '        name : string', '            Identity of the feature / semantic.', '        scales: dict', '            Mapping from variable to corresponding scale object.', '', '        Returns', '        -------', '        value or array of values', '            Outer return type depends on whether `data` is a dict (implying that', '            we want a single value) or DataFrame (implying that we want an array', '            of values with matching length).', '', '        \"\"\"', '        feature = self._mappable_props[name]', '        prop = PROPERTIES.get(name, Property(name))', '        directly_specified = not isinstance(feature, Mappable)', '        return_multiple = isinstance(data, pd.DataFrame)', '        return_array = return_multiple and not name.endswith(\"style\")', '', '        # Special case width because it needs to be resolved and added to the dataframe', '        # during layer prep (so the Move operations use it properly).', '        # TODO how does width *scaling* work, e.g. for violin width by count?', '        if name == \"width\":', '            directly_specified = directly_specified and name not in data', '', '        if directly_specified:', '            feature = prop.standardize(feature)', '            if return_multiple:', '                feature = [feature] * len(data)', '            if return_array:', '                feature = np.array(feature)', '            return feature', '', '        if name in data:', '            if scales is None or name not in scales:', \"                # TODO Might this obviate the identity scale? Just don't add a scale?\", '                feature = data[name]', '            else:', '                feature = scales[name](data[name])', '            if return_array:', '                feature = np.asarray(feature)', '            return feature', '', '        if feature.depend is not None:', '            # TODO add source_func or similar to transform the source value?', '            # e.g. set linewidth as a proportion of pointsize?', '            return self._resolve(data, feature.depend, scales)', '', '        default = prop.standardize(feature.default)', '        if return_multiple:', '            default = [default] * len(data)', '        if return_array:', '            default = np.array(default)', '        return default', '', '    def _infer_orient(self, scales: dict) -> str:  # TODO type scales', '', '        # TODO The original version of this (in seaborn._oldcore) did more checking.', '        # Paring that down here for the prototype to see what restrictions make sense.', '', '        # TODO rethink this to map from scale type to \"DV priority\" and use that?', '        # e.g. Nominal > Discrete > Continuous', '', '        x = 0 if \"x\" not in scales else scales[\"x\"]._priority', '        y = 0 if \"y\" not in scales else scales[\"y\"]._priority', '', '        if y > x:', '            return \"y\"', '        else:', '            return \"x\"', '', '    def _plot(', '        self,', '        split_generator: Callable[[], Generator],', '        scales: dict[str, Scale],', '        orient: str,', '    ) -> None:', '        \"\"\"Main interface for creating a plot.\"\"\"', '        raise NotImplementedError()', '', '    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '', '        return None', '', '', 'def resolve_properties(', '    mark: Mark, data: DataFrame, scales: dict[str, Scale]', ') -> dict[str, Any]:', '', '    props = {', '        name: mark._resolve(data, name, scales) for name in mark._mappable_props', '    }', '    return props', '', '', 'def resolve_color(', '    mark: Mark,', '    data: DataFrame | dict,', '    prefix: str = \"\",', '    scales: dict[str, Scale] | None = None,', ') -> RGBATuple | ndarray:', '    \"\"\"', '    Obtain a default, specified, or mapped value for a color feature.', '', '    This method exists separately to support the relationship between a', '    color and its corresponding alpha. We want to respect alpha values that', '    are passed in specified (or mapped) color values but also make use of a', '    separate `alpha` variable, which can be mapped. This approach may also', '    be extended to support mapping of specific color channels (i.e.', '    luminance, chroma) in the future.', '', '    Parameters', '    ----------', '    mark :', '        Mark with the color property.', '    data :', '        Container with data values for features that will be semantically mapped.', '    prefix :', '        Support \"color\", \"fillcolor\", etc.', '', '    \"\"\"', '    color = mark._resolve(data, f\"{prefix}color\", scales)', '', '    if f\"{prefix}alpha\" in mark._mappable_props:', '        alpha = mark._resolve(data, f\"{prefix}alpha\", scales)', '    else:', '        alpha = mark._resolve(data, \"alpha\", scales)', '', '    def visible(x, axis=None):', '        \"\"\"Detect \"invisible\" colors to set alpha appropriately.\"\"\"', '        # TODO First clause only needed to handle non-rgba arrays,', '        # which we are trying to handle upstream', '        return np.array(x).dtype.kind != \"f\" or np.isfinite(x).all(axis)', '', '    # Second check here catches vectors of strings with identity scale', '    # It could probably be handled better upstream. This is a tricky problem', '    if np.ndim(color) < 2 and all(isinstance(x, float) for x in color):', '        if len(color) == 4:', '            return mpl.colors.to_rgba(color)', '        alpha = alpha if visible(color) else np.nan', '        return mpl.colors.to_rgba(color, alpha)', '    else:', '        if np.ndim(color) == 2 and color.shape[1] == 4:', '            return mpl.colors.to_rgba_array(color)', '        alpha = np.where(visible(color, axis=1), alpha, np.nan)', '        return mpl.colors.to_rgba_array(color, alpha)', '', '    # TODO should we be implementing fill here too?', '    # (i.e. set fillalpha to 0 when fill=False)', '', '', 'def document_properties(mark):', '', '    properties = [f.name for f in fields(mark) if isinstance(f.default, Mappable)]', '    text = [', '        \"\",', '        \"    This mark defines the following properties:\",', '        textwrap.fill(', '            \", \".join([f\"|{p}|\" for p in properties]),', '            width=78, initial_indent=\" \" * 8, subsequent_indent=\" \" * 8,', '        ),', '    ]', '', '    docstring_lines = mark.__doc__.split(\"\\\\n\")', '    new_docstring = \"\\\\n\".join([', '        *docstring_lines[:2],', '        *text,', '        *docstring_lines[2:],', '    ])', '    mark.__doc__ = new_docstring', '    return mark']}, 'line.py': {'classes': [{'name': 'Path', 'start_line': 23, 'end_line': 117, 'text': ['class Path(Mark):', '    \"\"\"', '    A mark connecting data points in the order they appear.', '', '    See also', '    --------', '    Line : A mark connecting data points with sorting along the orientation axis.', '    Paths : A faster but less-flexible mark for drawing many paths.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Path.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\")', '    alpha: MappableFloat = Mappable(1)', '    linewidth: MappableFloat = Mappable(rc=\"lines.linewidth\")', '    linestyle: MappableString = Mappable(rc=\"lines.linestyle\")', '    marker: MappableString = Mappable(rc=\"lines.marker\")', '    pointsize: MappableFloat = Mappable(rc=\"lines.markersize\")', '    fillcolor: MappableColor = Mappable(depend=\"color\")', '    edgecolor: MappableColor = Mappable(depend=\"color\")', '    edgewidth: MappableFloat = Mappable(rc=\"lines.markeredgewidth\")', '', '    _sort: ClassVar[bool] = False', '', '    def _plot(self, split_gen, scales, orient):', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '            vals[\"fillcolor\"] = resolve_color(self, keys, prefix=\"fill\", scales=scales)', '            vals[\"edgecolor\"] = resolve_color(self, keys, prefix=\"edge\", scales=scales)', '', '            # https://github.com/matplotlib/matplotlib/pull/16692', '            if Version(mpl.__version__) < Version(\"3.3.0\"):', '                vals[\"marker\"] = vals[\"marker\"]._marker', '', '            if self._sort:', '                data = data.sort_values(orient, kind=\"mergesort\")', '', '            artist_kws = self.artist_kws.copy()', '            self._handle_capstyle(artist_kws, vals)', '', '            line = mpl.lines.Line2D(', '                data[\"x\"].to_numpy(),', '                data[\"y\"].to_numpy(),', '                color=vals[\"color\"],', '                linewidth=vals[\"linewidth\"],', '                linestyle=vals[\"linestyle\"],', '                marker=vals[\"marker\"],', '                markersize=vals[\"pointsize\"],', '                markerfacecolor=vals[\"fillcolor\"],', '                markeredgecolor=vals[\"edgecolor\"],', '                markeredgewidth=vals[\"edgewidth\"],', '                **artist_kws,', '            )', '            ax.add_line(line)', '', '    def _legend_artist(self, variables, value, scales):', '', '        keys = {v: value for v in variables}', '        vals = resolve_properties(self, keys, scales)', '        vals[\"color\"] = resolve_color(self, keys, scales=scales)', '        vals[\"fillcolor\"] = resolve_color(self, keys, prefix=\"fill\", scales=scales)', '        vals[\"edgecolor\"] = resolve_color(self, keys, prefix=\"edge\", scales=scales)', '', '        # https://github.com/matplotlib/matplotlib/pull/16692', '        if Version(mpl.__version__) < Version(\"3.3.0\"):', '            vals[\"marker\"] = vals[\"marker\"]._marker', '', '        artist_kws = self.artist_kws.copy()', '        self._handle_capstyle(artist_kws, vals)', '', '        return mpl.lines.Line2D(', '            [], [],', '            color=vals[\"color\"],', '            linewidth=vals[\"linewidth\"],', '            linestyle=vals[\"linestyle\"],', '            marker=vals[\"marker\"],', '            markersize=vals[\"pointsize\"],', '            markerfacecolor=vals[\"fillcolor\"],', '            markeredgecolor=vals[\"edgecolor\"],', '            markeredgewidth=vals[\"edgewidth\"],', '            **artist_kws,', '        )', '', '    def _handle_capstyle(self, kws, vals):', '', '        # Work around for this matplotlib issue:', '        # https://github.com/matplotlib/matplotlib/issues/23437', '        if vals[\"linestyle\"][1] is None:', '            capstyle = kws.get(\"solid_capstyle\", mpl.rcParams[\"lines.solid_capstyle\"])', '            kws[\"dash_capstyle\"] = capstyle'], 'methods': [{'name': '_plot', 'start_line': 49, 'end_line': 81, 'text': ['    def _plot(self, split_gen, scales, orient):', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '            vals[\"fillcolor\"] = resolve_color(self, keys, prefix=\"fill\", scales=scales)', '            vals[\"edgecolor\"] = resolve_color(self, keys, prefix=\"edge\", scales=scales)', '', '            # https://github.com/matplotlib/matplotlib/pull/16692', '            if Version(mpl.__version__) < Version(\"3.3.0\"):', '                vals[\"marker\"] = vals[\"marker\"]._marker', '', '            if self._sort:', '                data = data.sort_values(orient, kind=\"mergesort\")', '', '            artist_kws = self.artist_kws.copy()', '            self._handle_capstyle(artist_kws, vals)', '', '            line = mpl.lines.Line2D(', '                data[\"x\"].to_numpy(),', '                data[\"y\"].to_numpy(),', '                color=vals[\"color\"],', '                linewidth=vals[\"linewidth\"],', '                linestyle=vals[\"linestyle\"],', '                marker=vals[\"marker\"],', '                markersize=vals[\"pointsize\"],', '                markerfacecolor=vals[\"fillcolor\"],', '                markeredgecolor=vals[\"edgecolor\"],', '                markeredgewidth=vals[\"edgewidth\"],', '                **artist_kws,', '            )', '            ax.add_line(line)']}, {'name': '_legend_artist', 'start_line': 83, 'end_line': 109, 'text': ['    def _legend_artist(self, variables, value, scales):', '', '        keys = {v: value for v in variables}', '        vals = resolve_properties(self, keys, scales)', '        vals[\"color\"] = resolve_color(self, keys, scales=scales)', '        vals[\"fillcolor\"] = resolve_color(self, keys, prefix=\"fill\", scales=scales)', '        vals[\"edgecolor\"] = resolve_color(self, keys, prefix=\"edge\", scales=scales)', '', '        # https://github.com/matplotlib/matplotlib/pull/16692', '        if Version(mpl.__version__) < Version(\"3.3.0\"):', '            vals[\"marker\"] = vals[\"marker\"]._marker', '', '        artist_kws = self.artist_kws.copy()', '        self._handle_capstyle(artist_kws, vals)', '', '        return mpl.lines.Line2D(', '            [], [],', '            color=vals[\"color\"],', '            linewidth=vals[\"linewidth\"],', '            linestyle=vals[\"linestyle\"],', '            marker=vals[\"marker\"],', '            markersize=vals[\"pointsize\"],', '            markerfacecolor=vals[\"fillcolor\"],', '            markeredgecolor=vals[\"edgecolor\"],', '            markeredgewidth=vals[\"edgewidth\"],', '            **artist_kws,', '        )']}, {'name': '_handle_capstyle', 'start_line': 111, 'end_line': 117, 'text': ['    def _handle_capstyle(self, kws, vals):', '', '        # Work around for this matplotlib issue:', '        # https://github.com/matplotlib/matplotlib/issues/23437', '        if vals[\"linestyle\"][1] is None:', '            capstyle = kws.get(\"solid_capstyle\", mpl.rcParams[\"lines.solid_capstyle\"])', '            kws[\"dash_capstyle\"] = capstyle']}]}, {'name': 'Line', 'start_line': 122, 'end_line': 136, 'text': ['class Line(Path):', '    \"\"\"', '    A mark connecting data points with sorting along the orientation axis.', '', '    See also', '    --------', '    Path : A mark connecting data points in the order they appear.', '    Lines : A faster but less-flexible mark for drawing many lines.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Line.rst', '', '    \"\"\"', '    _sort: ClassVar[bool] = True'], 'methods': []}, {'name': 'Paths', 'start_line': 141, 'end_line': 226, 'text': ['class Paths(Mark):', '    \"\"\"', '    A faster but less-flexible mark for drawing many paths.', '', '    See also', '    --------', '    Path : A mark connecting data points in the order they appear.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Paths.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\")', '    alpha: MappableFloat = Mappable(1)', '    linewidth: MappableFloat = Mappable(rc=\"lines.linewidth\")', '    linestyle: MappableString = Mappable(rc=\"lines.linestyle\")', '', '    _sort: ClassVar[bool] = False', '', '    def __post_init__(self):', '', \"        # LineCollection artists have a capstyle property but don't source its value\", '        # from the rc, so we do that manually here. Unfortunately, because we add', '        # only one LineCollection, we have the use the same capstyle for all lines', \"        # even when they are dashed. It's a slight inconsistency, but looks fine IMO.\", '        self.artist_kws.setdefault(\"capstyle\", mpl.rcParams[\"lines.solid_capstyle\"])', '', '    def _setup_lines(self, split_gen, scales, orient):', '', '        line_data = {}', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            if ax not in line_data:', '                line_data[ax] = {', '                    \"segments\": [],', '                    \"colors\": [],', '                    \"linewidths\": [],', '                    \"linestyles\": [],', '                }', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '', '            if self._sort:', '                data = data.sort_values(orient, kind=\"mergesort\")', '', '            # Column stack to avoid block consolidation', '            xy = np.column_stack([data[\"x\"], data[\"y\"]])', '            line_data[ax][\"segments\"].append(xy)', '            line_data[ax][\"colors\"].append(vals[\"color\"])', '            line_data[ax][\"linewidths\"].append(vals[\"linewidth\"])', '            line_data[ax][\"linestyles\"].append(vals[\"linestyle\"])', '', '        return line_data', '', '    def _plot(self, split_gen, scales, orient):', '', '        line_data = self._setup_lines(split_gen, scales, orient)', '', '        for ax, ax_data in line_data.items():', '            lines = mpl.collections.LineCollection(**ax_data, **self.artist_kws)', '            # Handle datalim update manually', '            # https://github.com/matplotlib/matplotlib/issues/23129', '            ax.add_collection(lines, autolim=False)', '            if ax_data[\"segments\"]:', '                xy = np.concatenate(ax_data[\"segments\"])', '                ax.update_datalim(xy)', '', '    def _legend_artist(self, variables, value, scales):', '', '        key = resolve_properties(self, {v: value for v in variables}, scales)', '', '        artist_kws = self.artist_kws.copy()', '        capstyle = artist_kws.pop(\"capstyle\")', '        artist_kws[\"solid_capstyle\"] = capstyle', '        artist_kws[\"dash_capstyle\"] = capstyle', '', '        return mpl.lines.Line2D(', '            [], [],', '            color=key[\"color\"],', '            linewidth=key[\"linewidth\"],', '            linestyle=key[\"linestyle\"],', '            **artist_kws,', '        )'], 'methods': [{'name': '__post_init__', 'start_line': 161, 'end_line': 167, 'text': ['    def __post_init__(self):', '', \"        # LineCollection artists have a capstyle property but don't source its value\", '        # from the rc, so we do that manually here. Unfortunately, because we add', '        # only one LineCollection, we have the use the same capstyle for all lines', \"        # even when they are dashed. It's a slight inconsistency, but looks fine IMO.\", '        self.artist_kws.setdefault(\"capstyle\", mpl.rcParams[\"lines.solid_capstyle\"])']}, {'name': '_setup_lines', 'start_line': 169, 'end_line': 196, 'text': ['    def _setup_lines(self, split_gen, scales, orient):', '', '        line_data = {}', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            if ax not in line_data:', '                line_data[ax] = {', '                    \"segments\": [],', '                    \"colors\": [],', '                    \"linewidths\": [],', '                    \"linestyles\": [],', '                }', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '', '            if self._sort:', '                data = data.sort_values(orient, kind=\"mergesort\")', '', '            # Column stack to avoid block consolidation', '            xy = np.column_stack([data[\"x\"], data[\"y\"]])', '            line_data[ax][\"segments\"].append(xy)', '            line_data[ax][\"colors\"].append(vals[\"color\"])', '            line_data[ax][\"linewidths\"].append(vals[\"linewidth\"])', '            line_data[ax][\"linestyles\"].append(vals[\"linestyle\"])', '', '        return line_data']}, {'name': '_plot', 'start_line': 198, 'end_line': 209, 'text': ['    def _plot(self, split_gen, scales, orient):', '', '        line_data = self._setup_lines(split_gen, scales, orient)', '', '        for ax, ax_data in line_data.items():', '            lines = mpl.collections.LineCollection(**ax_data, **self.artist_kws)', '            # Handle datalim update manually', '            # https://github.com/matplotlib/matplotlib/issues/23129', '            ax.add_collection(lines, autolim=False)', '            if ax_data[\"segments\"]:', '                xy = np.concatenate(ax_data[\"segments\"])', '                ax.update_datalim(xy)']}, {'name': '_legend_artist', 'start_line': 211, 'end_line': 226, 'text': ['    def _legend_artist(self, variables, value, scales):', '', '        key = resolve_properties(self, {v: value for v in variables}, scales)', '', '        artist_kws = self.artist_kws.copy()', '        capstyle = artist_kws.pop(\"capstyle\")', '        artist_kws[\"solid_capstyle\"] = capstyle', '        artist_kws[\"dash_capstyle\"] = capstyle', '', '        return mpl.lines.Line2D(', '            [], [],', '            color=key[\"color\"],', '            linewidth=key[\"linewidth\"],', '            linestyle=key[\"linestyle\"],', '            **artist_kws,', '        )']}]}, {'name': 'Lines', 'start_line': 231, 'end_line': 244, 'text': ['class Lines(Paths):', '    \"\"\"', '    A faster but less-flexible mark for drawing many lines.', '', '    See also', '    --------', '    Line : A mark connecting data points with sorting along the orientation axis.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Lines.rst', '', '    \"\"\"', '    _sort: ClassVar[bool] = True'], 'methods': []}, {'name': 'Range', 'start_line': 249, 'end_line': 295, 'text': ['class Range(Paths):', '    \"\"\"', '    An oriented line mark drawn between min/max values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Range.rst', '', '    \"\"\"', '    def _setup_lines(self, split_gen, scales, orient):', '', '        line_data = {}', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            if ax not in line_data:', '                line_data[ax] = {', '                    \"segments\": [],', '                    \"colors\": [],', '                    \"linewidths\": [],', '                    \"linestyles\": [],', '                }', '', '            # TODO better checks on what variables we have', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '', '            # TODO what if only one exist?', '            if not set(data.columns) & {f\"{other}min\", f\"{other}max\"}:', '                agg = {f\"{other}min\": (other, \"min\"), f\"{other}max\": (other, \"max\")}', '                data = data.groupby(orient).agg(**agg).reset_index()', '', '            cols = [orient, f\"{other}min\", f\"{other}max\"]', '            data = data[cols].melt(orient, value_name=other)[[\"x\", \"y\"]]', '            segments = [d.to_numpy() for _, d in data.groupby(orient)]', '', '            line_data[ax][\"segments\"].extend(segments)', '', '            n = len(segments)', '            line_data[ax][\"colors\"].extend([vals[\"color\"]] * n)', '            line_data[ax][\"linewidths\"].extend([vals[\"linewidth\"]] * n)', '            line_data[ax][\"linestyles\"].extend([vals[\"linestyle\"]] * n)', '', '        return line_data'], 'methods': [{'name': '_setup_lines', 'start_line': 258, 'end_line': 295, 'text': ['    def _setup_lines(self, split_gen, scales, orient):', '', '        line_data = {}', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            if ax not in line_data:', '                line_data[ax] = {', '                    \"segments\": [],', '                    \"colors\": [],', '                    \"linewidths\": [],', '                    \"linestyles\": [],', '                }', '', '            # TODO better checks on what variables we have', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '', '            # TODO what if only one exist?', '            if not set(data.columns) & {f\"{other}min\", f\"{other}max\"}:', '                agg = {f\"{other}min\": (other, \"min\"), f\"{other}max\": (other, \"max\")}', '                data = data.groupby(orient).agg(**agg).reset_index()', '', '            cols = [orient, f\"{other}min\", f\"{other}max\"]', '            data = data[cols].melt(orient, value_name=other)[[\"x\", \"y\"]]', '            segments = [d.to_numpy() for _, d in data.groupby(orient)]', '', '            line_data[ax][\"segments\"].extend(segments)', '', '            n = len(segments)', '            line_data[ax][\"colors\"].extend([vals[\"color\"]] * n)', '            line_data[ax][\"linewidths\"].extend([vals[\"linewidth\"]] * n)', '            line_data[ax][\"linestyles\"].extend([vals[\"linestyle\"]] * n)', '', '        return line_data']}]}], 'functions': [], 'text': ['from __future__ import annotations', 'from dataclasses import dataclass', 'from typing import ClassVar', '', 'import numpy as np', 'import matplotlib as mpl', '', 'from seaborn._marks.base import (', '    Mark,', '    Mappable,', '    MappableFloat,', '    MappableString,', '    MappableColor,', '    resolve_properties,', '    resolve_color,', '    document_properties,', ')', 'from seaborn.external.version import Version', '', '', '@document_properties', '@dataclass', 'class Path(Mark):', '    \"\"\"', '    A mark connecting data points in the order they appear.', '', '    See also', '    --------', '    Line : A mark connecting data points with sorting along the orientation axis.', '    Paths : A faster but less-flexible mark for drawing many paths.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Path.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\")', '    alpha: MappableFloat = Mappable(1)', '    linewidth: MappableFloat = Mappable(rc=\"lines.linewidth\")', '    linestyle: MappableString = Mappable(rc=\"lines.linestyle\")', '    marker: MappableString = Mappable(rc=\"lines.marker\")', '    pointsize: MappableFloat = Mappable(rc=\"lines.markersize\")', '    fillcolor: MappableColor = Mappable(depend=\"color\")', '    edgecolor: MappableColor = Mappable(depend=\"color\")', '    edgewidth: MappableFloat = Mappable(rc=\"lines.markeredgewidth\")', '', '    _sort: ClassVar[bool] = False', '', '    def _plot(self, split_gen, scales, orient):', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '            vals[\"fillcolor\"] = resolve_color(self, keys, prefix=\"fill\", scales=scales)', '            vals[\"edgecolor\"] = resolve_color(self, keys, prefix=\"edge\", scales=scales)', '', '            # https://github.com/matplotlib/matplotlib/pull/16692', '            if Version(mpl.__version__) < Version(\"3.3.0\"):', '                vals[\"marker\"] = vals[\"marker\"]._marker', '', '            if self._sort:', '                data = data.sort_values(orient, kind=\"mergesort\")', '', '            artist_kws = self.artist_kws.copy()', '            self._handle_capstyle(artist_kws, vals)', '', '            line = mpl.lines.Line2D(', '                data[\"x\"].to_numpy(),', '                data[\"y\"].to_numpy(),', '                color=vals[\"color\"],', '                linewidth=vals[\"linewidth\"],', '                linestyle=vals[\"linestyle\"],', '                marker=vals[\"marker\"],', '                markersize=vals[\"pointsize\"],', '                markerfacecolor=vals[\"fillcolor\"],', '                markeredgecolor=vals[\"edgecolor\"],', '                markeredgewidth=vals[\"edgewidth\"],', '                **artist_kws,', '            )', '            ax.add_line(line)', '', '    def _legend_artist(self, variables, value, scales):', '', '        keys = {v: value for v in variables}', '        vals = resolve_properties(self, keys, scales)', '        vals[\"color\"] = resolve_color(self, keys, scales=scales)', '        vals[\"fillcolor\"] = resolve_color(self, keys, prefix=\"fill\", scales=scales)', '        vals[\"edgecolor\"] = resolve_color(self, keys, prefix=\"edge\", scales=scales)', '', '        # https://github.com/matplotlib/matplotlib/pull/16692', '        if Version(mpl.__version__) < Version(\"3.3.0\"):', '            vals[\"marker\"] = vals[\"marker\"]._marker', '', '        artist_kws = self.artist_kws.copy()', '        self._handle_capstyle(artist_kws, vals)', '', '        return mpl.lines.Line2D(', '            [], [],', '            color=vals[\"color\"],', '            linewidth=vals[\"linewidth\"],', '            linestyle=vals[\"linestyle\"],', '            marker=vals[\"marker\"],', '            markersize=vals[\"pointsize\"],', '            markerfacecolor=vals[\"fillcolor\"],', '            markeredgecolor=vals[\"edgecolor\"],', '            markeredgewidth=vals[\"edgewidth\"],', '            **artist_kws,', '        )', '', '    def _handle_capstyle(self, kws, vals):', '', '        # Work around for this matplotlib issue:', '        # https://github.com/matplotlib/matplotlib/issues/23437', '        if vals[\"linestyle\"][1] is None:', '            capstyle = kws.get(\"solid_capstyle\", mpl.rcParams[\"lines.solid_capstyle\"])', '            kws[\"dash_capstyle\"] = capstyle', '', '', '@document_properties', '@dataclass', 'class Line(Path):', '    \"\"\"', '    A mark connecting data points with sorting along the orientation axis.', '', '    See also', '    --------', '    Path : A mark connecting data points in the order they appear.', '    Lines : A faster but less-flexible mark for drawing many lines.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Line.rst', '', '    \"\"\"', '    _sort: ClassVar[bool] = True', '', '', '@document_properties', '@dataclass', 'class Paths(Mark):', '    \"\"\"', '    A faster but less-flexible mark for drawing many paths.', '', '    See also', '    --------', '    Path : A mark connecting data points in the order they appear.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Paths.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\")', '    alpha: MappableFloat = Mappable(1)', '    linewidth: MappableFloat = Mappable(rc=\"lines.linewidth\")', '    linestyle: MappableString = Mappable(rc=\"lines.linestyle\")', '', '    _sort: ClassVar[bool] = False', '', '    def __post_init__(self):', '', \"        # LineCollection artists have a capstyle property but don't source its value\", '        # from the rc, so we do that manually here. Unfortunately, because we add', '        # only one LineCollection, we have the use the same capstyle for all lines', \"        # even when they are dashed. It's a slight inconsistency, but looks fine IMO.\", '        self.artist_kws.setdefault(\"capstyle\", mpl.rcParams[\"lines.solid_capstyle\"])', '', '    def _setup_lines(self, split_gen, scales, orient):', '', '        line_data = {}', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            if ax not in line_data:', '                line_data[ax] = {', '                    \"segments\": [],', '                    \"colors\": [],', '                    \"linewidths\": [],', '                    \"linestyles\": [],', '                }', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '', '            if self._sort:', '                data = data.sort_values(orient, kind=\"mergesort\")', '', '            # Column stack to avoid block consolidation', '            xy = np.column_stack([data[\"x\"], data[\"y\"]])', '            line_data[ax][\"segments\"].append(xy)', '            line_data[ax][\"colors\"].append(vals[\"color\"])', '            line_data[ax][\"linewidths\"].append(vals[\"linewidth\"])', '            line_data[ax][\"linestyles\"].append(vals[\"linestyle\"])', '', '        return line_data', '', '    def _plot(self, split_gen, scales, orient):', '', '        line_data = self._setup_lines(split_gen, scales, orient)', '', '        for ax, ax_data in line_data.items():', '            lines = mpl.collections.LineCollection(**ax_data, **self.artist_kws)', '            # Handle datalim update manually', '            # https://github.com/matplotlib/matplotlib/issues/23129', '            ax.add_collection(lines, autolim=False)', '            if ax_data[\"segments\"]:', '                xy = np.concatenate(ax_data[\"segments\"])', '                ax.update_datalim(xy)', '', '    def _legend_artist(self, variables, value, scales):', '', '        key = resolve_properties(self, {v: value for v in variables}, scales)', '', '        artist_kws = self.artist_kws.copy()', '        capstyle = artist_kws.pop(\"capstyle\")', '        artist_kws[\"solid_capstyle\"] = capstyle', '        artist_kws[\"dash_capstyle\"] = capstyle', '', '        return mpl.lines.Line2D(', '            [], [],', '            color=key[\"color\"],', '            linewidth=key[\"linewidth\"],', '            linestyle=key[\"linestyle\"],', '            **artist_kws,', '        )', '', '', '@document_properties', '@dataclass', 'class Lines(Paths):', '    \"\"\"', '    A faster but less-flexible mark for drawing many lines.', '', '    See also', '    --------', '    Line : A mark connecting data points with sorting along the orientation axis.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Lines.rst', '', '    \"\"\"', '    _sort: ClassVar[bool] = True', '', '', '@document_properties', '@dataclass', 'class Range(Paths):', '    \"\"\"', '    An oriented line mark drawn between min/max values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Range.rst', '', '    \"\"\"', '    def _setup_lines(self, split_gen, scales, orient):', '', '        line_data = {}', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '', '        for keys, data, ax in split_gen(keep_na=not self._sort):', '', '            if ax not in line_data:', '                line_data[ax] = {', '                    \"segments\": [],', '                    \"colors\": [],', '                    \"linewidths\": [],', '                    \"linestyles\": [],', '                }', '', '            # TODO better checks on what variables we have', '', '            vals = resolve_properties(self, keys, scales)', '            vals[\"color\"] = resolve_color(self, keys, scales=scales)', '', '            # TODO what if only one exist?', '            if not set(data.columns) & {f\"{other}min\", f\"{other}max\"}:', '                agg = {f\"{other}min\": (other, \"min\"), f\"{other}max\": (other, \"max\")}', '                data = data.groupby(orient).agg(**agg).reset_index()', '', '            cols = [orient, f\"{other}min\", f\"{other}max\"]', '            data = data[cols].melt(orient, value_name=other)[[\"x\", \"y\"]]', '            segments = [d.to_numpy() for _, d in data.groupby(orient)]', '', '            line_data[ax][\"segments\"].extend(segments)', '', '            n = len(segments)', '            line_data[ax][\"colors\"].extend([vals[\"color\"]] * n)', '            line_data[ax][\"linewidths\"].extend([vals[\"linewidth\"]] * n)', '            line_data[ax][\"linestyles\"].extend([vals[\"linestyle\"]] * n)', '', '        return line_data']}, '__init__.py': {'classes': [], 'functions': [], 'text': []}, 'text.py': {'classes': [{'name': 'Text', 'start_line': 23, 'end_line': 76, 'text': ['class Text(Mark):', '    \"\"\"', '    A textual mark to annotate or represent data values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Text.rst', '', '    \"\"\"', '    text: MappableString = Mappable(\"\")', '    color: MappableColor = Mappable(\"k\")', '    alpha: MappableFloat = Mappable(1)', '    fontsize: MappableFloat = Mappable(rc=\"font.size\")', '    halign: MappableString = Mappable(\"center\")', '    valign: MappableString = Mappable(\"center_baseline\")', '    offset: MappableFloat = Mappable(4)', '', '    def _plot(self, split_gen, scales, orient):', '', '        ax_data = defaultdict(list)', '', '        for keys, data, ax in split_gen():', '', '            vals = resolve_properties(self, keys, scales)', '            color = resolve_color(self, keys, \"\", scales)', '', '            halign = vals[\"halign\"]', '            valign = vals[\"valign\"]', '            fontsize = vals[\"fontsize\"]', '            offset = vals[\"offset\"] / 72', '', '            offset_trans = ScaledTranslation(', '                {\"right\": -offset, \"left\": +offset}.get(halign, 0),', '                {\"top\": -offset, \"bottom\": +offset, \"baseline\": +offset}.get(valign, 0),', '                ax.figure.dpi_scale_trans,', '            )', '', '            for row in data.to_dict(\"records\"):', '                artist = mpl.text.Text(', '                    x=row[\"x\"],', '                    y=row[\"y\"],', '                    text=str(row.get(\"text\", vals[\"text\"])),', '                    color=color,', '                    fontsize=fontsize,', '                    horizontalalignment=halign,', '                    verticalalignment=valign,', '                    transform=ax.transData + offset_trans,', '                    **self.artist_kws,', '                )', '                ax.add_artist(artist)', '                ax_data[ax].append([row[\"x\"], row[\"y\"]])', '', '        for ax, ax_vals in ax_data.items():', '            ax.update_datalim(np.array(ax_vals))'], 'methods': [{'name': '_plot', 'start_line': 40, 'end_line': 76, 'text': ['    def _plot(self, split_gen, scales, orient):', '', '        ax_data = defaultdict(list)', '', '        for keys, data, ax in split_gen():', '', '            vals = resolve_properties(self, keys, scales)', '            color = resolve_color(self, keys, \"\", scales)', '', '            halign = vals[\"halign\"]', '            valign = vals[\"valign\"]', '            fontsize = vals[\"fontsize\"]', '            offset = vals[\"offset\"] / 72', '', '            offset_trans = ScaledTranslation(', '                {\"right\": -offset, \"left\": +offset}.get(halign, 0),', '                {\"top\": -offset, \"bottom\": +offset, \"baseline\": +offset}.get(valign, 0),', '                ax.figure.dpi_scale_trans,', '            )', '', '            for row in data.to_dict(\"records\"):', '                artist = mpl.text.Text(', '                    x=row[\"x\"],', '                    y=row[\"y\"],', '                    text=str(row.get(\"text\", vals[\"text\"])),', '                    color=color,', '                    fontsize=fontsize,', '                    horizontalalignment=halign,', '                    verticalalignment=valign,', '                    transform=ax.transData + offset_trans,', '                    **self.artist_kws,', '                )', '                ax.add_artist(artist)', '                ax_data[ax].append([row[\"x\"], row[\"y\"]])', '', '        for ax, ax_vals in ax_data.items():', '            ax.update_datalim(np.array(ax_vals))']}]}], 'functions': [], 'text': ['from __future__ import annotations', 'from collections import defaultdict', 'from dataclasses import dataclass', '', 'import numpy as np', 'import matplotlib as mpl', 'from matplotlib.transforms import ScaledTranslation', '', 'from seaborn._marks.base import (', '    Mark,', '    Mappable,', '    MappableFloat,', '    MappableString,', '    MappableColor,', '    resolve_properties,', '    resolve_color,', '    document_properties,', ')', '', '', '@document_properties', '@dataclass', 'class Text(Mark):', '    \"\"\"', '    A textual mark to annotate or represent data values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Text.rst', '', '    \"\"\"', '    text: MappableString = Mappable(\"\")', '    color: MappableColor = Mappable(\"k\")', '    alpha: MappableFloat = Mappable(1)', '    fontsize: MappableFloat = Mappable(rc=\"font.size\")', '    halign: MappableString = Mappable(\"center\")', '    valign: MappableString = Mappable(\"center_baseline\")', '    offset: MappableFloat = Mappable(4)', '', '    def _plot(self, split_gen, scales, orient):', '', '        ax_data = defaultdict(list)', '', '        for keys, data, ax in split_gen():', '', '            vals = resolve_properties(self, keys, scales)', '            color = resolve_color(self, keys, \"\", scales)', '', '            halign = vals[\"halign\"]', '            valign = vals[\"valign\"]', '            fontsize = vals[\"fontsize\"]', '            offset = vals[\"offset\"] / 72', '', '            offset_trans = ScaledTranslation(', '                {\"right\": -offset, \"left\": +offset}.get(halign, 0),', '                {\"top\": -offset, \"bottom\": +offset, \"baseline\": +offset}.get(valign, 0),', '                ax.figure.dpi_scale_trans,', '            )', '', '            for row in data.to_dict(\"records\"):', '                artist = mpl.text.Text(', '                    x=row[\"x\"],', '                    y=row[\"y\"],', '                    text=str(row.get(\"text\", vals[\"text\"])),', '                    color=color,', '                    fontsize=fontsize,', '                    horizontalalignment=halign,', '                    verticalalignment=valign,', '                    transform=ax.transData + offset_trans,', '                    **self.artist_kws,', '                )', '                ax.add_artist(artist)', '                ax_data[ax].append([row[\"x\"], row[\"y\"]])', '', '        for ax, ax_vals in ax_data.items():', '            ax.update_datalim(np.array(ax_vals))']}, 'area.py': {'classes': [{'name': 'AreaBase', 'start_line': 21, 'end_line': 86, 'text': ['class AreaBase:', '', '    def _plot(self, split_gen, scales, orient):', '', '        patches = defaultdict(list)', '', '        for keys, data, ax in split_gen():', '', '            kws = {}', '            data = self._standardize_coordinate_parameters(data, orient)', '            resolved = resolve_properties(self, keys, scales)', '            verts = self._get_verts(data, orient)', '            ax.update_datalim(verts)', '', '            # TODO should really move this logic into resolve_color', '            fc = resolve_color(self, keys, \"\", scales)', '            if not resolved[\"fill\"]:', '                fc = mpl.colors.to_rgba(fc, 0)', '', '            kws[\"facecolor\"] = fc', '            kws[\"edgecolor\"] = resolve_color(self, keys, \"edge\", scales)', '            kws[\"linewidth\"] = resolved[\"edgewidth\"]', '            kws[\"linestyle\"] = resolved[\"edgestyle\"]', '', '            patches[ax].append(mpl.patches.Polygon(verts, **kws))', '', '        for ax, ax_patches in patches.items():', '', '            for patch in ax_patches:', '                self._postprocess_artist(patch, ax, orient)', '                ax.add_patch(patch)', '', '    def _standardize_coordinate_parameters(self, data, orient):', '        return data', '', '    def _postprocess_artist(self, artist, ax, orient):', '        pass', '', '    def _get_verts(self, data, orient):', '', '        dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        data = data.sort_values(orient, kind=\"mergesort\")', '        verts = np.concatenate([', '            data[[orient, f\"{dv}min\"]].to_numpy(),', '            data[[orient, f\"{dv}max\"]].to_numpy()[::-1],', '        ])', '        if orient == \"y\":', '            verts = verts[:, ::-1]', '        return verts', '', '    def _legend_artist(self, variables, value, scales):', '', '        keys = {v: value for v in variables}', '        resolved = resolve_properties(self, keys, scales)', '', '        fc = resolve_color(self, keys, \"\", scales)', '        if not resolved[\"fill\"]:', '            fc = mpl.colors.to_rgba(fc, 0)', '', '        return mpl.patches.Patch(', '            facecolor=fc,', '            edgecolor=resolve_color(self, keys, \"edge\", scales),', '            linewidth=resolved[\"edgewidth\"],', '            linestyle=resolved[\"edgestyle\"],', '            **self.artist_kws,', '        )'], 'methods': [{'name': '_plot', 'start_line': 23, 'end_line': 51, 'text': ['    def _plot(self, split_gen, scales, orient):', '', '        patches = defaultdict(list)', '', '        for keys, data, ax in split_gen():', '', '            kws = {}', '            data = self._standardize_coordinate_parameters(data, orient)', '            resolved = resolve_properties(self, keys, scales)', '            verts = self._get_verts(data, orient)', '            ax.update_datalim(verts)', '', '            # TODO should really move this logic into resolve_color', '            fc = resolve_color(self, keys, \"\", scales)', '            if not resolved[\"fill\"]:', '                fc = mpl.colors.to_rgba(fc, 0)', '', '            kws[\"facecolor\"] = fc', '            kws[\"edgecolor\"] = resolve_color(self, keys, \"edge\", scales)', '            kws[\"linewidth\"] = resolved[\"edgewidth\"]', '            kws[\"linestyle\"] = resolved[\"edgestyle\"]', '', '            patches[ax].append(mpl.patches.Polygon(verts, **kws))', '', '        for ax, ax_patches in patches.items():', '', '            for patch in ax_patches:', '                self._postprocess_artist(patch, ax, orient)', '                ax.add_patch(patch)']}, {'name': '_standardize_coordinate_parameters', 'start_line': 53, 'end_line': 54, 'text': ['    def _standardize_coordinate_parameters(self, data, orient):', '        return data']}, {'name': '_postprocess_artist', 'start_line': 56, 'end_line': 57, 'text': ['    def _postprocess_artist(self, artist, ax, orient):', '        pass']}, {'name': '_get_verts', 'start_line': 59, 'end_line': 69, 'text': ['    def _get_verts(self, data, orient):', '', '        dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        data = data.sort_values(orient, kind=\"mergesort\")', '        verts = np.concatenate([', '            data[[orient, f\"{dv}min\"]].to_numpy(),', '            data[[orient, f\"{dv}max\"]].to_numpy()[::-1],', '        ])', '        if orient == \"y\":', '            verts = verts[:, ::-1]', '        return verts']}, {'name': '_legend_artist', 'start_line': 71, 'end_line': 86, 'text': ['    def _legend_artist(self, variables, value, scales):', '', '        keys = {v: value for v in variables}', '        resolved = resolve_properties(self, keys, scales)', '', '        fc = resolve_color(self, keys, \"\", scales)', '        if not resolved[\"fill\"]:', '            fc = mpl.colors.to_rgba(fc, 0)', '', '        return mpl.patches.Patch(', '            facecolor=fc,', '            edgecolor=resolve_color(self, keys, \"edge\", scales),', '            linewidth=resolved[\"edgewidth\"],', '            linestyle=resolved[\"edgestyle\"],', '            **self.artist_kws,', '        )']}]}, {'name': 'Area', 'start_line': 91, 'end_line': 136, 'text': ['class Area(AreaBase, Mark):', '    \"\"\"', '    A fill mark drawn from a baseline to data values.', '', '    See also', '    --------', '    Band : A fill mark representing an interval between values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Area.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\", )', '    alpha: MappableFloat = Mappable(.2, )', '    fill: MappableBool = Mappable(True, )', '    edgecolor: MappableColor = Mappable(depend=\"color\")', '    edgealpha: MappableFloat = Mappable(1, )', '    edgewidth: MappableFloat = Mappable(rc=\"patch.linewidth\", )', '    edgestyle: MappableStyle = Mappable(\"-\", )', '', '    # TODO should this be settable / mappable?', '    baseline: MappableFloat = Mappable(0, grouping=False)', '', '    def _standardize_coordinate_parameters(self, data, orient):', '        dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return data.rename(columns={\"baseline\": f\"{dv}min\", dv: f\"{dv}max\"})', '', '    def _postprocess_artist(self, artist, ax, orient):', '', \"        # TODO copying a lot of code from Bar, let's abstract this\", '        # See comments there, I am not going to repeat them too', '', '        artist.set_linewidth(artist.get_linewidth() * 2)', '', '        linestyle = artist.get_linestyle()', '        if linestyle[1]:', '            linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))', '        artist.set_linestyle(linestyle)', '', '        artist.set_clip_path(artist.get_path(), artist.get_transform() + ax.transData)', '        if self.artist_kws.get(\"clip_on\", True):', '            artist.set_clip_box(ax.bbox)', '', '        val_idx = [\"y\", \"x\"].index(orient)', '        artist.sticky_edges[val_idx][:] = (0, np.inf)'], 'methods': [{'name': '_standardize_coordinate_parameters', 'start_line': 115, 'end_line': 117, 'text': ['    def _standardize_coordinate_parameters(self, data, orient):', '        dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return data.rename(columns={\"baseline\": f\"{dv}min\", dv: f\"{dv}max\"})']}, {'name': '_postprocess_artist', 'start_line': 119, 'end_line': 136, 'text': ['    def _postprocess_artist(self, artist, ax, orient):', '', \"        # TODO copying a lot of code from Bar, let's abstract this\", '        # See comments there, I am not going to repeat them too', '', '        artist.set_linewidth(artist.get_linewidth() * 2)', '', '        linestyle = artist.get_linestyle()', '        if linestyle[1]:', '            linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))', '        artist.set_linestyle(linestyle)', '', '        artist.set_clip_path(artist.get_path(), artist.get_transform() + ax.transData)', '        if self.artist_kws.get(\"clip_on\", True):', '            artist.set_clip_box(ax.bbox)', '', '        val_idx = [\"y\", \"x\"].index(orient)', '        artist.sticky_edges[val_idx][:] = (0, np.inf)']}]}, {'name': 'Band', 'start_line': 141, 'end_line': 170, 'text': ['class Band(AreaBase, Mark):', '    \"\"\"', '    A fill mark representing an interval between values.', '', '    See also', '    --------', '    Area : A fill mark drawn from a baseline to data values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Band.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\", )', '    alpha: MappableFloat = Mappable(.2, )', '    fill: MappableBool = Mappable(True, )', '    edgecolor: MappableColor = Mappable(depend=\"color\", )', '    edgealpha: MappableFloat = Mappable(1, )', '    edgewidth: MappableFloat = Mappable(0, )', '    edgestyle: MappableFloat = Mappable(\"-\", )', '', '    def _standardize_coordinate_parameters(self, data, orient):', '        # dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        # TODO assert that all(ymax >= ymin)?', '        # TODO what if only one exist?', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        if not set(data.columns) & {f\"{other}min\", f\"{other}max\"}:', '            agg = {f\"{other}min\": (other, \"min\"), f\"{other}max\": (other, \"max\")}', '            data = data.groupby(orient).agg(**agg).reset_index()', '        return data'], 'methods': [{'name': '_standardize_coordinate_parameters', 'start_line': 162, 'end_line': 170, 'text': ['    def _standardize_coordinate_parameters(self, data, orient):', '        # dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        # TODO assert that all(ymax >= ymin)?', '        # TODO what if only one exist?', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        if not set(data.columns) & {f\"{other}min\", f\"{other}max\"}:', '            agg = {f\"{other}min\": (other, \"min\"), f\"{other}max\": (other, \"max\")}', '            data = data.groupby(orient).agg(**agg).reset_index()', '        return data']}]}], 'functions': [], 'text': ['from __future__ import annotations', 'from collections import defaultdict', 'from dataclasses import dataclass', '', 'import numpy as np', 'import matplotlib as mpl', '', 'from seaborn._marks.base import (', '    Mark,', '    Mappable,', '    MappableBool,', '    MappableFloat,', '    MappableColor,', '    MappableStyle,', '    resolve_properties,', '    resolve_color,', '    document_properties,', ')', '', '', 'class AreaBase:', '', '    def _plot(self, split_gen, scales, orient):', '', '        patches = defaultdict(list)', '', '        for keys, data, ax in split_gen():', '', '            kws = {}', '            data = self._standardize_coordinate_parameters(data, orient)', '            resolved = resolve_properties(self, keys, scales)', '            verts = self._get_verts(data, orient)', '            ax.update_datalim(verts)', '', '            # TODO should really move this logic into resolve_color', '            fc = resolve_color(self, keys, \"\", scales)', '            if not resolved[\"fill\"]:', '                fc = mpl.colors.to_rgba(fc, 0)', '', '            kws[\"facecolor\"] = fc', '            kws[\"edgecolor\"] = resolve_color(self, keys, \"edge\", scales)', '            kws[\"linewidth\"] = resolved[\"edgewidth\"]', '            kws[\"linestyle\"] = resolved[\"edgestyle\"]', '', '            patches[ax].append(mpl.patches.Polygon(verts, **kws))', '', '        for ax, ax_patches in patches.items():', '', '            for patch in ax_patches:', '                self._postprocess_artist(patch, ax, orient)', '                ax.add_patch(patch)', '', '    def _standardize_coordinate_parameters(self, data, orient):', '        return data', '', '    def _postprocess_artist(self, artist, ax, orient):', '        pass', '', '    def _get_verts(self, data, orient):', '', '        dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        data = data.sort_values(orient, kind=\"mergesort\")', '        verts = np.concatenate([', '            data[[orient, f\"{dv}min\"]].to_numpy(),', '            data[[orient, f\"{dv}max\"]].to_numpy()[::-1],', '        ])', '        if orient == \"y\":', '            verts = verts[:, ::-1]', '        return verts', '', '    def _legend_artist(self, variables, value, scales):', '', '        keys = {v: value for v in variables}', '        resolved = resolve_properties(self, keys, scales)', '', '        fc = resolve_color(self, keys, \"\", scales)', '        if not resolved[\"fill\"]:', '            fc = mpl.colors.to_rgba(fc, 0)', '', '        return mpl.patches.Patch(', '            facecolor=fc,', '            edgecolor=resolve_color(self, keys, \"edge\", scales),', '            linewidth=resolved[\"edgewidth\"],', '            linestyle=resolved[\"edgestyle\"],', '            **self.artist_kws,', '        )', '', '', '@document_properties', '@dataclass', 'class Area(AreaBase, Mark):', '    \"\"\"', '    A fill mark drawn from a baseline to data values.', '', '    See also', '    --------', '    Band : A fill mark representing an interval between values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Area.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\", )', '    alpha: MappableFloat = Mappable(.2, )', '    fill: MappableBool = Mappable(True, )', '    edgecolor: MappableColor = Mappable(depend=\"color\")', '    edgealpha: MappableFloat = Mappable(1, )', '    edgewidth: MappableFloat = Mappable(rc=\"patch.linewidth\", )', '    edgestyle: MappableStyle = Mappable(\"-\", )', '', '    # TODO should this be settable / mappable?', '    baseline: MappableFloat = Mappable(0, grouping=False)', '', '    def _standardize_coordinate_parameters(self, data, orient):', '        dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return data.rename(columns={\"baseline\": f\"{dv}min\", dv: f\"{dv}max\"})', '', '    def _postprocess_artist(self, artist, ax, orient):', '', \"        # TODO copying a lot of code from Bar, let's abstract this\", '        # See comments there, I am not going to repeat them too', '', '        artist.set_linewidth(artist.get_linewidth() * 2)', '', '        linestyle = artist.get_linestyle()', '        if linestyle[1]:', '            linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))', '        artist.set_linestyle(linestyle)', '', '        artist.set_clip_path(artist.get_path(), artist.get_transform() + ax.transData)', '        if self.artist_kws.get(\"clip_on\", True):', '            artist.set_clip_box(ax.bbox)', '', '        val_idx = [\"y\", \"x\"].index(orient)', '        artist.sticky_edges[val_idx][:] = (0, np.inf)', '', '', '@document_properties', '@dataclass', 'class Band(AreaBase, Mark):', '    \"\"\"', '    A fill mark representing an interval between values.', '', '    See also', '    --------', '    Area : A fill mark drawn from a baseline to data values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Band.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\", )', '    alpha: MappableFloat = Mappable(.2, )', '    fill: MappableBool = Mappable(True, )', '    edgecolor: MappableColor = Mappable(depend=\"color\", )', '    edgealpha: MappableFloat = Mappable(1, )', '    edgewidth: MappableFloat = Mappable(0, )', '    edgestyle: MappableFloat = Mappable(\"-\", )', '', '    def _standardize_coordinate_parameters(self, data, orient):', '        # dv = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        # TODO assert that all(ymax >= ymin)?', '        # TODO what if only one exist?', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        if not set(data.columns) & {f\"{other}min\", f\"{other}max\"}:', '            agg = {f\"{other}min\": (other, \"min\"), f\"{other}max\": (other, \"max\")}', '            data = data.groupby(orient).agg(**agg).reset_index()', '        return data']}, 'bar.py': {'classes': [{'name': 'BarBase', 'start_line': 28, 'end_line': 103, 'text': ['class BarBase(Mark):', '', '    def _make_patches(self, data, scales, orient):', '', '        kws = self._resolve_properties(data, scales)', '        if orient == \"x\":', '            kws[\"x\"] = (data[\"x\"] - data[\"width\"] / 2).to_numpy()', '            kws[\"y\"] = data[\"baseline\"].to_numpy()', '            kws[\"w\"] = data[\"width\"].to_numpy()', '            kws[\"h\"] = (data[\"y\"] - data[\"baseline\"]).to_numpy()', '        else:', '            kws[\"x\"] = data[\"baseline\"].to_numpy()', '            kws[\"y\"] = (data[\"y\"] - data[\"width\"] / 2).to_numpy()', '            kws[\"w\"] = (data[\"x\"] - data[\"baseline\"]).to_numpy()', '            kws[\"h\"] = data[\"width\"].to_numpy()', '', '        kws.pop(\"width\", None)', '        kws.pop(\"baseline\", None)', '', '        val_dim = {\"x\": \"h\", \"y\": \"w\"}[orient]', '        bars, vals = [], []', '', '        for i in range(len(data)):', '', '            row = {k: v[i] for k, v in kws.items()}', '', \"            # Skip bars with no value. It's possible we'll want to make this\", '            # an option (i.e so you have an artist for animating or annotating),', \"            # but let's keep things simple for now.\", '            if not np.nan_to_num(row[val_dim]):', '                continue', '', '            bar = mpl.patches.Rectangle(', '                xy=(row[\"x\"], row[\"y\"]),', '                width=row[\"w\"],', '                height=row[\"h\"],', '                facecolor=row[\"facecolor\"],', '                edgecolor=row[\"edgecolor\"],', '                linestyle=row[\"edgestyle\"],', '                linewidth=row[\"edgewidth\"],', '                **self.artist_kws,', '            )', '            bars.append(bar)', '            vals.append(row[val_dim])', '', '        return bars, vals', '', '    def _resolve_properties(self, data, scales):', '', '        resolved = resolve_properties(self, data, scales)', '', '        resolved[\"facecolor\"] = resolve_color(self, data, \"\", scales)', '        resolved[\"edgecolor\"] = resolve_color(self, data, \"edge\", scales)', '', '        fc = resolved[\"facecolor\"]', '        if isinstance(fc, tuple):', '            resolved[\"facecolor\"] = fc[0], fc[1], fc[2], fc[3] * resolved[\"fill\"]', '        else:', '            fc[:, 3] = fc[:, 3] * resolved[\"fill\"]  # TODO Is inplace mod a problem?', '            resolved[\"facecolor\"] = fc', '', '        return resolved', '', '    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '        # TODO return some sensible default?', '        key = {v: value for v in variables}', '        key = self._resolve_properties(key, scales)', '        artist = mpl.patches.Patch(', '            facecolor=key[\"facecolor\"],', '            edgecolor=key[\"edgecolor\"],', '            linewidth=key[\"edgewidth\"],', '            linestyle=key[\"edgestyle\"],', '        )', '        return artist'], 'methods': [{'name': '_make_patches', 'start_line': 30, 'end_line': 73, 'text': ['    def _make_patches(self, data, scales, orient):', '', '        kws = self._resolve_properties(data, scales)', '        if orient == \"x\":', '            kws[\"x\"] = (data[\"x\"] - data[\"width\"] / 2).to_numpy()', '            kws[\"y\"] = data[\"baseline\"].to_numpy()', '            kws[\"w\"] = data[\"width\"].to_numpy()', '            kws[\"h\"] = (data[\"y\"] - data[\"baseline\"]).to_numpy()', '        else:', '            kws[\"x\"] = data[\"baseline\"].to_numpy()', '            kws[\"y\"] = (data[\"y\"] - data[\"width\"] / 2).to_numpy()', '            kws[\"w\"] = (data[\"x\"] - data[\"baseline\"]).to_numpy()', '            kws[\"h\"] = data[\"width\"].to_numpy()', '', '        kws.pop(\"width\", None)', '        kws.pop(\"baseline\", None)', '', '        val_dim = {\"x\": \"h\", \"y\": \"w\"}[orient]', '        bars, vals = [], []', '', '        for i in range(len(data)):', '', '            row = {k: v[i] for k, v in kws.items()}', '', \"            # Skip bars with no value. It's possible we'll want to make this\", '            # an option (i.e so you have an artist for animating or annotating),', \"            # but let's keep things simple for now.\", '            if not np.nan_to_num(row[val_dim]):', '                continue', '', '            bar = mpl.patches.Rectangle(', '                xy=(row[\"x\"], row[\"y\"]),', '                width=row[\"w\"],', '                height=row[\"h\"],', '                facecolor=row[\"facecolor\"],', '                edgecolor=row[\"edgecolor\"],', '                linestyle=row[\"edgestyle\"],', '                linewidth=row[\"edgewidth\"],', '                **self.artist_kws,', '            )', '            bars.append(bar)', '            vals.append(row[val_dim])', '', '        return bars, vals']}, {'name': '_resolve_properties', 'start_line': 75, 'end_line': 89, 'text': ['    def _resolve_properties(self, data, scales):', '', '        resolved = resolve_properties(self, data, scales)', '', '        resolved[\"facecolor\"] = resolve_color(self, data, \"\", scales)', '        resolved[\"edgecolor\"] = resolve_color(self, data, \"edge\", scales)', '', '        fc = resolved[\"facecolor\"]', '        if isinstance(fc, tuple):', '            resolved[\"facecolor\"] = fc[0], fc[1], fc[2], fc[3] * resolved[\"fill\"]', '        else:', '            fc[:, 3] = fc[:, 3] * resolved[\"fill\"]  # TODO Is inplace mod a problem?', '            resolved[\"facecolor\"] = fc', '', '        return resolved']}, {'name': '_legend_artist', 'start_line': 91, 'end_line': 103, 'text': ['    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '        # TODO return some sensible default?', '        key = {v: value for v in variables}', '        key = self._resolve_properties(key, scales)', '        artist = mpl.patches.Patch(', '            facecolor=key[\"facecolor\"],', '            edgecolor=key[\"edgecolor\"],', '            linewidth=key[\"edgewidth\"],', '            linestyle=key[\"edgestyle\"],', '        )', '        return artist']}]}, {'name': 'Bar', 'start_line': 108, 'end_line': 173, 'text': ['class Bar(BarBase):', '    \"\"\"', '    A bar mark drawn between baseline and data values.', '', '    See also', '    --------', '    Bars : A faster bar mark with defaults more suitable for histograms.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Bar.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\", grouping=False)', '    alpha: MappableFloat = Mappable(.7, grouping=False)', '    fill: MappableBool = Mappable(True, grouping=False)', '    edgecolor: MappableColor = Mappable(depend=\"color\", grouping=False)', '    edgealpha: MappableFloat = Mappable(1, grouping=False)', '    edgewidth: MappableFloat = Mappable(rc=\"patch.linewidth\", grouping=False)', '    edgestyle: MappableStyle = Mappable(\"-\", grouping=False)', '    # pattern: MappableString = Mappable(None)  # TODO no Property yet', '', '    width: MappableFloat = Mappable(.8, grouping=False)', '    baseline: MappableFloat = Mappable(0, grouping=False)  # TODO *is* this mappable?', '', '    def _plot(self, split_gen, scales, orient):', '', '        val_idx = [\"y\", \"x\"].index(orient)', '', '        for _, data, ax in split_gen():', '', '            bars, vals = self._make_patches(data, scales, orient)', '', '            for bar in bars:', '', '                # Because we are clipping the artist (see below), the edges end up', \"                # looking half as wide as they actually are. I don't love this clumsy\", '                # workaround, which is going to cause surprises if you work with the', '                # artists directly. We may need to revisit after feedback.', '                bar.set_linewidth(bar.get_linewidth() * 2)', '                linestyle = bar.get_linestyle()', '                if linestyle[1]:', '                    linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))', '                bar.set_linestyle(linestyle)', '', '                # This is a bit of a hack to handle the fact that the edge lines are', '                # centered on the actual extents of the bar, and overlap when bars are', '                # stacked or dodged. We may discover that this causes problems and needs', '                # to be revisited at some point. Also it should be faster to clip with', \"                # a bbox than a path, but I cant't work out how to get the intersection\", '                # with the axes bbox.', '                bar.set_clip_path(bar.get_path(), bar.get_transform() + ax.transData)', '                if self.artist_kws.get(\"clip_on\", True):', '                    # It seems the above hack undoes the default axes clipping', '                    bar.set_clip_box(ax.bbox)', '                bar.sticky_edges[val_idx][:] = (0, np.inf)', '                ax.add_patch(bar)', '', '            # Add a container which is useful for, e.g. Axes.bar_label', '            if Version(mpl.__version__) >= Version(\"3.4.0\"):', '                orientation = {\"x\": \"vertical\", \"y\": \"horizontal\"}[orient]', '                container_kws = dict(datavalues=vals, orientation=orientation)', '            else:', '                container_kws = {}', '            container = mpl.container.BarContainer(bars, **container_kws)', '            ax.add_container(container)'], 'methods': [{'name': '_plot', 'start_line': 133, 'end_line': 173, 'text': ['    def _plot(self, split_gen, scales, orient):', '', '        val_idx = [\"y\", \"x\"].index(orient)', '', '        for _, data, ax in split_gen():', '', '            bars, vals = self._make_patches(data, scales, orient)', '', '            for bar in bars:', '', '                # Because we are clipping the artist (see below), the edges end up', \"                # looking half as wide as they actually are. I don't love this clumsy\", '                # workaround, which is going to cause surprises if you work with the', '                # artists directly. We may need to revisit after feedback.', '                bar.set_linewidth(bar.get_linewidth() * 2)', '                linestyle = bar.get_linestyle()', '                if linestyle[1]:', '                    linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))', '                bar.set_linestyle(linestyle)', '', '                # This is a bit of a hack to handle the fact that the edge lines are', '                # centered on the actual extents of the bar, and overlap when bars are', '                # stacked or dodged. We may discover that this causes problems and needs', '                # to be revisited at some point. Also it should be faster to clip with', \"                # a bbox than a path, but I cant't work out how to get the intersection\", '                # with the axes bbox.', '                bar.set_clip_path(bar.get_path(), bar.get_transform() + ax.transData)', '                if self.artist_kws.get(\"clip_on\", True):', '                    # It seems the above hack undoes the default axes clipping', '                    bar.set_clip_box(ax.bbox)', '                bar.sticky_edges[val_idx][:] = (0, np.inf)', '                ax.add_patch(bar)', '', '            # Add a container which is useful for, e.g. Axes.bar_label', '            if Version(mpl.__version__) >= Version(\"3.4.0\"):', '                orientation = {\"x\": \"vertical\", \"y\": \"horizontal\"}[orient]', '                container_kws = dict(datavalues=vals, orientation=orientation)', '            else:', '                container_kws = {}', '            container = mpl.container.BarContainer(bars, **container_kws)', '            ax.add_container(container)']}]}, {'name': 'Bars', 'start_line': 178, 'end_line': 250, 'text': ['class Bars(BarBase):', '    \"\"\"', '    A faster bar mark with defaults more suitable histograms.', '', '    See also', '    --------', '    Bar : A bar mark drawn between baseline and data values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Bars.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\", grouping=False)', '    alpha: MappableFloat = Mappable(.7, grouping=False)', '    fill: MappableBool = Mappable(True, grouping=False)', '    edgecolor: MappableColor = Mappable(rc=\"patch.edgecolor\", grouping=False)', '    edgealpha: MappableFloat = Mappable(1, grouping=False)', '    edgewidth: MappableFloat = Mappable(auto=True, grouping=False)', '    edgestyle: MappableStyle = Mappable(\"-\", grouping=False)', '    # pattern: MappableString = Mappable(None)  # TODO no Property yet', '', '    width: MappableFloat = Mappable(1, grouping=False)', '    baseline: MappableFloat = Mappable(0, grouping=False)  # TODO *is* this mappable?', '', '    def _plot(self, split_gen, scales, orient):', '', '        ori_idx = [\"x\", \"y\"].index(orient)', '        val_idx = [\"y\", \"x\"].index(orient)', '', '        patches = defaultdict(list)', '        for _, data, ax in split_gen():', '            bars, _ = self._make_patches(data, scales, orient)', '            patches[ax].extend(bars)', '', '        collections = {}', '        for ax, ax_patches in patches.items():', '', '            col = mpl.collections.PatchCollection(ax_patches, match_original=True)', '            col.sticky_edges[val_idx][:] = (0, np.inf)', '            ax.add_collection(col, autolim=False)', '            collections[ax] = col', '', '            # Workaround for matplotlib autoscaling bug', '            # https://github.com/matplotlib/matplotlib/issues/11898', '            # https://github.com/matplotlib/matplotlib/issues/23129', '            xys = np.vstack([path.vertices for path in col.get_paths()])', '            ax.update_datalim(xys)', '', '        if \"edgewidth\" not in scales and isinstance(self.edgewidth, Mappable):', '', '            for ax in collections:', '                ax.autoscale_view()', '', '            def get_dimensions(collection):', '                edges, widths = [], []', '                for verts in (path.vertices for path in collection.get_paths()):', '                    edges.append(min(verts[:, ori_idx]))', '                    widths.append(np.ptp(verts[:, ori_idx]))', '                return np.array(edges), np.array(widths)', '', '            min_width = np.inf', '            for ax, col in collections.items():', '                edges, widths = get_dimensions(col)', '                points = 72 / ax.figure.dpi * abs(', '                    ax.transData.transform([edges + widths] * 2)', '                    - ax.transData.transform([edges] * 2)', '                )', '                min_width = min(min_width, min(points[:, ori_idx]))', '', '            linewidth = min(.1 * min_width, mpl.rcParams[\"patch.linewidth\"])', '            for _, col in collections.items():', '                col.set_linewidth(linewidth)'], 'methods': [{'name': '_plot', 'start_line': 203, 'end_line': 250, 'text': ['    def _plot(self, split_gen, scales, orient):', '', '        ori_idx = [\"x\", \"y\"].index(orient)', '        val_idx = [\"y\", \"x\"].index(orient)', '', '        patches = defaultdict(list)', '        for _, data, ax in split_gen():', '            bars, _ = self._make_patches(data, scales, orient)', '            patches[ax].extend(bars)', '', '        collections = {}', '        for ax, ax_patches in patches.items():', '', '            col = mpl.collections.PatchCollection(ax_patches, match_original=True)', '            col.sticky_edges[val_idx][:] = (0, np.inf)', '            ax.add_collection(col, autolim=False)', '            collections[ax] = col', '', '            # Workaround for matplotlib autoscaling bug', '            # https://github.com/matplotlib/matplotlib/issues/11898', '            # https://github.com/matplotlib/matplotlib/issues/23129', '            xys = np.vstack([path.vertices for path in col.get_paths()])', '            ax.update_datalim(xys)', '', '        if \"edgewidth\" not in scales and isinstance(self.edgewidth, Mappable):', '', '            for ax in collections:', '                ax.autoscale_view()', '', '            def get_dimensions(collection):', '                edges, widths = [], []', '                for verts in (path.vertices for path in collection.get_paths()):', '                    edges.append(min(verts[:, ori_idx]))', '                    widths.append(np.ptp(verts[:, ori_idx]))', '                return np.array(edges), np.array(widths)', '', '            min_width = np.inf', '            for ax, col in collections.items():', '                edges, widths = get_dimensions(col)', '                points = 72 / ax.figure.dpi * abs(', '                    ax.transData.transform([edges + widths] * 2)', '                    - ax.transData.transform([edges] * 2)', '                )', '                min_width = min(min_width, min(points[:, ori_idx]))', '', '            linewidth = min(.1 * min_width, mpl.rcParams[\"patch.linewidth\"])', '            for _, col in collections.items():', '                col.set_linewidth(linewidth)']}]}], 'functions': [{'name': 'get_dimensions', 'start_line': 232, 'end_line': 237, 'text': ['            def get_dimensions(collection):', '                edges, widths = [], []', '                for verts in (path.vertices for path in collection.get_paths()):', '                    edges.append(min(verts[:, ori_idx]))', '                    widths.append(np.ptp(verts[:, ori_idx]))', '                return np.array(edges), np.array(widths)']}], 'text': ['from __future__ import annotations', 'from collections import defaultdict', 'from dataclasses import dataclass', '', 'import numpy as np', 'import matplotlib as mpl', '', 'from seaborn._marks.base import (', '    Mark,', '    Mappable,', '    MappableBool,', '    MappableColor,', '    MappableFloat,', '    MappableStyle,', '    resolve_properties,', '    resolve_color,', '    document_properties', ')', 'from seaborn.external.version import Version', '', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:', '    from typing import Any', '    from matplotlib.artist import Artist', '    from seaborn._core.scales import Scale', '', '', 'class BarBase(Mark):', '', '    def _make_patches(self, data, scales, orient):', '', '        kws = self._resolve_properties(data, scales)', '        if orient == \"x\":', '            kws[\"x\"] = (data[\"x\"] - data[\"width\"] / 2).to_numpy()', '            kws[\"y\"] = data[\"baseline\"].to_numpy()', '            kws[\"w\"] = data[\"width\"].to_numpy()', '            kws[\"h\"] = (data[\"y\"] - data[\"baseline\"]).to_numpy()', '        else:', '            kws[\"x\"] = data[\"baseline\"].to_numpy()', '            kws[\"y\"] = (data[\"y\"] - data[\"width\"] / 2).to_numpy()', '            kws[\"w\"] = (data[\"x\"] - data[\"baseline\"]).to_numpy()', '            kws[\"h\"] = data[\"width\"].to_numpy()', '', '        kws.pop(\"width\", None)', '        kws.pop(\"baseline\", None)', '', '        val_dim = {\"x\": \"h\", \"y\": \"w\"}[orient]', '        bars, vals = [], []', '', '        for i in range(len(data)):', '', '            row = {k: v[i] for k, v in kws.items()}', '', \"            # Skip bars with no value. It's possible we'll want to make this\", '            # an option (i.e so you have an artist for animating or annotating),', \"            # but let's keep things simple for now.\", '            if not np.nan_to_num(row[val_dim]):', '                continue', '', '            bar = mpl.patches.Rectangle(', '                xy=(row[\"x\"], row[\"y\"]),', '                width=row[\"w\"],', '                height=row[\"h\"],', '                facecolor=row[\"facecolor\"],', '                edgecolor=row[\"edgecolor\"],', '                linestyle=row[\"edgestyle\"],', '                linewidth=row[\"edgewidth\"],', '                **self.artist_kws,', '            )', '            bars.append(bar)', '            vals.append(row[val_dim])', '', '        return bars, vals', '', '    def _resolve_properties(self, data, scales):', '', '        resolved = resolve_properties(self, data, scales)', '', '        resolved[\"facecolor\"] = resolve_color(self, data, \"\", scales)', '        resolved[\"edgecolor\"] = resolve_color(self, data, \"edge\", scales)', '', '        fc = resolved[\"facecolor\"]', '        if isinstance(fc, tuple):', '            resolved[\"facecolor\"] = fc[0], fc[1], fc[2], fc[3] * resolved[\"fill\"]', '        else:', '            fc[:, 3] = fc[:, 3] * resolved[\"fill\"]  # TODO Is inplace mod a problem?', '            resolved[\"facecolor\"] = fc', '', '        return resolved', '', '    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '        # TODO return some sensible default?', '        key = {v: value for v in variables}', '        key = self._resolve_properties(key, scales)', '        artist = mpl.patches.Patch(', '            facecolor=key[\"facecolor\"],', '            edgecolor=key[\"edgecolor\"],', '            linewidth=key[\"edgewidth\"],', '            linestyle=key[\"edgestyle\"],', '        )', '        return artist', '', '', '@document_properties', '@dataclass', 'class Bar(BarBase):', '    \"\"\"', '    A bar mark drawn between baseline and data values.', '', '    See also', '    --------', '    Bars : A faster bar mark with defaults more suitable for histograms.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Bar.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\", grouping=False)', '    alpha: MappableFloat = Mappable(.7, grouping=False)', '    fill: MappableBool = Mappable(True, grouping=False)', '    edgecolor: MappableColor = Mappable(depend=\"color\", grouping=False)', '    edgealpha: MappableFloat = Mappable(1, grouping=False)', '    edgewidth: MappableFloat = Mappable(rc=\"patch.linewidth\", grouping=False)', '    edgestyle: MappableStyle = Mappable(\"-\", grouping=False)', '    # pattern: MappableString = Mappable(None)  # TODO no Property yet', '', '    width: MappableFloat = Mappable(.8, grouping=False)', '    baseline: MappableFloat = Mappable(0, grouping=False)  # TODO *is* this mappable?', '', '    def _plot(self, split_gen, scales, orient):', '', '        val_idx = [\"y\", \"x\"].index(orient)', '', '        for _, data, ax in split_gen():', '', '            bars, vals = self._make_patches(data, scales, orient)', '', '            for bar in bars:', '', '                # Because we are clipping the artist (see below), the edges end up', \"                # looking half as wide as they actually are. I don't love this clumsy\", '                # workaround, which is going to cause surprises if you work with the', '                # artists directly. We may need to revisit after feedback.', '                bar.set_linewidth(bar.get_linewidth() * 2)', '                linestyle = bar.get_linestyle()', '                if linestyle[1]:', '                    linestyle = (linestyle[0], tuple(x / 2 for x in linestyle[1]))', '                bar.set_linestyle(linestyle)', '', '                # This is a bit of a hack to handle the fact that the edge lines are', '                # centered on the actual extents of the bar, and overlap when bars are', '                # stacked or dodged. We may discover that this causes problems and needs', '                # to be revisited at some point. Also it should be faster to clip with', \"                # a bbox than a path, but I cant't work out how to get the intersection\", '                # with the axes bbox.', '                bar.set_clip_path(bar.get_path(), bar.get_transform() + ax.transData)', '                if self.artist_kws.get(\"clip_on\", True):', '                    # It seems the above hack undoes the default axes clipping', '                    bar.set_clip_box(ax.bbox)', '                bar.sticky_edges[val_idx][:] = (0, np.inf)', '                ax.add_patch(bar)', '', '            # Add a container which is useful for, e.g. Axes.bar_label', '            if Version(mpl.__version__) >= Version(\"3.4.0\"):', '                orientation = {\"x\": \"vertical\", \"y\": \"horizontal\"}[orient]', '                container_kws = dict(datavalues=vals, orientation=orientation)', '            else:', '                container_kws = {}', '            container = mpl.container.BarContainer(bars, **container_kws)', '            ax.add_container(container)', '', '', '@document_properties', '@dataclass', 'class Bars(BarBase):', '    \"\"\"', '    A faster bar mark with defaults more suitable histograms.', '', '    See also', '    --------', '    Bar : A bar mark drawn between baseline and data values.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Bars.rst', '', '    \"\"\"', '    color: MappableColor = Mappable(\"C0\", grouping=False)', '    alpha: MappableFloat = Mappable(.7, grouping=False)', '    fill: MappableBool = Mappable(True, grouping=False)', '    edgecolor: MappableColor = Mappable(rc=\"patch.edgecolor\", grouping=False)', '    edgealpha: MappableFloat = Mappable(1, grouping=False)', '    edgewidth: MappableFloat = Mappable(auto=True, grouping=False)', '    edgestyle: MappableStyle = Mappable(\"-\", grouping=False)', '    # pattern: MappableString = Mappable(None)  # TODO no Property yet', '', '    width: MappableFloat = Mappable(1, grouping=False)', '    baseline: MappableFloat = Mappable(0, grouping=False)  # TODO *is* this mappable?', '', '    def _plot(self, split_gen, scales, orient):', '', '        ori_idx = [\"x\", \"y\"].index(orient)', '        val_idx = [\"y\", \"x\"].index(orient)', '', '        patches = defaultdict(list)', '        for _, data, ax in split_gen():', '            bars, _ = self._make_patches(data, scales, orient)', '            patches[ax].extend(bars)', '', '        collections = {}', '        for ax, ax_patches in patches.items():', '', '            col = mpl.collections.PatchCollection(ax_patches, match_original=True)', '            col.sticky_edges[val_idx][:] = (0, np.inf)', '            ax.add_collection(col, autolim=False)', '            collections[ax] = col', '', '            # Workaround for matplotlib autoscaling bug', '            # https://github.com/matplotlib/matplotlib/issues/11898', '            # https://github.com/matplotlib/matplotlib/issues/23129', '            xys = np.vstack([path.vertices for path in col.get_paths()])', '            ax.update_datalim(xys)', '', '        if \"edgewidth\" not in scales and isinstance(self.edgewidth, Mappable):', '', '            for ax in collections:', '                ax.autoscale_view()', '', '            def get_dimensions(collection):', '                edges, widths = [], []', '                for verts in (path.vertices for path in collection.get_paths()):', '                    edges.append(min(verts[:, ori_idx]))', '                    widths.append(np.ptp(verts[:, ori_idx]))', '                return np.array(edges), np.array(widths)', '', '            min_width = np.inf', '            for ax, col in collections.items():', '                edges, widths = get_dimensions(col)', '                points = 72 / ax.figure.dpi * abs(', '                    ax.transData.transform([edges + widths] * 2)', '                    - ax.transData.transform([edges] * 2)', '                )', '                min_width = min(min_width, min(points[:, ori_idx]))', '', '            linewidth = min(.1 * min_width, mpl.rcParams[\"patch.linewidth\"])', '            for _, col in collections.items():', '                col.set_linewidth(linewidth)']}, 'dot.py': {'classes': [{'name': 'DotBase', 'start_line': 27, 'end_line': 103, 'text': ['class DotBase(Mark):', '', '    def _resolve_paths(self, data):', '', '        paths = []', '        path_cache = {}', '        marker = data[\"marker\"]', '', '        def get_transformed_path(m):', '            return m.get_path().transformed(m.get_transform())', '', '        if isinstance(marker, mpl.markers.MarkerStyle):', '            return get_transformed_path(marker)', '', '        for m in marker:', '            if m not in path_cache:', '                path_cache[m] = get_transformed_path(m)', '            paths.append(path_cache[m])', '        return paths', '', '    def _resolve_properties(self, data, scales):', '', '        resolved = resolve_properties(self, data, scales)', '        resolved[\"path\"] = self._resolve_paths(resolved)', '        resolved[\"size\"] = resolved[\"pointsize\"] ** 2', '', '        if isinstance(data, dict):  # Properties for single dot', '            filled_marker = resolved[\"marker\"].is_filled()', '        else:', '            filled_marker = [m.is_filled() for m in resolved[\"marker\"]]', '', '        resolved[\"fill\"] = resolved[\"fill\"] * filled_marker', '', '        return resolved', '', '    def _plot(self, split_gen, scales, orient):', '', '        # TODO Not backcompat with allowed (but nonfunctional) univariate plots', '        # (That should be solved upstream by defaulting to \"\" for unset x/y?)', '        # (Be mindful of xmin/xmax, etc!)', '', '        for _, data, ax in split_gen():', '', '            offsets = np.column_stack([data[\"x\"], data[\"y\"]])', '            data = self._resolve_properties(data, scales)', '', '            points = mpl.collections.PathCollection(', '                offsets=offsets,', '                paths=data[\"path\"],', '                sizes=data[\"size\"],', '                facecolors=data[\"facecolor\"],', '                edgecolors=data[\"edgecolor\"],', '                linewidths=data[\"linewidth\"],', '                linestyles=data[\"edgestyle\"],', '                transOffset=ax.transData,', '                transform=mpl.transforms.IdentityTransform(),', '                **self.artist_kws,', '            )', '            ax.add_collection(points)', '', '    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '', '        key = {v: value for v in variables}', '        res = self._resolve_properties(key, scales)', '', '        return mpl.collections.PathCollection(', '            paths=[res[\"path\"]],', '            sizes=[res[\"size\"]],', '            facecolors=[res[\"facecolor\"]],', '            edgecolors=[res[\"edgecolor\"]],', '            linewidths=[res[\"linewidth\"]],', '            linestyles=[res[\"edgestyle\"]],', '            transform=mpl.transforms.IdentityTransform(),', '            **self.artist_kws,', '        )'], 'methods': [{'name': '_resolve_paths', 'start_line': 29, 'end_line': 45, 'text': ['    def _resolve_paths(self, data):', '', '        paths = []', '        path_cache = {}', '        marker = data[\"marker\"]', '', '        def get_transformed_path(m):', '            return m.get_path().transformed(m.get_transform())', '', '        if isinstance(marker, mpl.markers.MarkerStyle):', '            return get_transformed_path(marker)', '', '        for m in marker:', '            if m not in path_cache:', '                path_cache[m] = get_transformed_path(m)', '            paths.append(path_cache[m])', '        return paths']}, {'name': '_resolve_properties', 'start_line': 47, 'end_line': 60, 'text': ['    def _resolve_properties(self, data, scales):', '', '        resolved = resolve_properties(self, data, scales)', '        resolved[\"path\"] = self._resolve_paths(resolved)', '        resolved[\"size\"] = resolved[\"pointsize\"] ** 2', '', '        if isinstance(data, dict):  # Properties for single dot', '            filled_marker = resolved[\"marker\"].is_filled()', '        else:', '            filled_marker = [m.is_filled() for m in resolved[\"marker\"]]', '', '        resolved[\"fill\"] = resolved[\"fill\"] * filled_marker', '', '        return resolved']}, {'name': '_plot', 'start_line': 62, 'end_line': 85, 'text': ['    def _plot(self, split_gen, scales, orient):', '', '        # TODO Not backcompat with allowed (but nonfunctional) univariate plots', '        # (That should be solved upstream by defaulting to \"\" for unset x/y?)', '        # (Be mindful of xmin/xmax, etc!)', '', '        for _, data, ax in split_gen():', '', '            offsets = np.column_stack([data[\"x\"], data[\"y\"]])', '            data = self._resolve_properties(data, scales)', '', '            points = mpl.collections.PathCollection(', '                offsets=offsets,', '                paths=data[\"path\"],', '                sizes=data[\"size\"],', '                facecolors=data[\"facecolor\"],', '                edgecolors=data[\"edgecolor\"],', '                linewidths=data[\"linewidth\"],', '                linestyles=data[\"edgestyle\"],', '                transOffset=ax.transData,', '                transform=mpl.transforms.IdentityTransform(),', '                **self.artist_kws,', '            )', '            ax.add_collection(points)']}, {'name': '_legend_artist', 'start_line': 87, 'end_line': 103, 'text': ['    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '', '        key = {v: value for v in variables}', '        res = self._resolve_properties(key, scales)', '', '        return mpl.collections.PathCollection(', '            paths=[res[\"path\"]],', '            sizes=[res[\"size\"]],', '            facecolors=[res[\"facecolor\"]],', '            edgecolors=[res[\"edgecolor\"]],', '            linewidths=[res[\"linewidth\"]],', '            linestyles=[res[\"edgestyle\"]],', '            transform=mpl.transforms.IdentityTransform(),', '            **self.artist_kws,', '        )']}]}, {'name': 'Dot', 'start_line': 108, 'end_line': 157, 'text': ['class Dot(DotBase):', '    \"\"\"', '    A mark suitable for dot plots or less-dense scatterplots.', '', '    See also', '    --------', '    Dots : A dot mark defined by strokes to better handle overplotting.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Dot.rst', '', '    \"\"\"', '    marker: MappableString = Mappable(\"o\", grouping=False)', '    pointsize: MappableFloat = Mappable(6, grouping=False)  # TODO rcParam?', '    stroke: MappableFloat = Mappable(.75, grouping=False)  # TODO rcParam?', '    color: MappableColor = Mappable(\"C0\", grouping=False)', '    alpha: MappableFloat = Mappable(1, grouping=False)', '    fill: MappableBool = Mappable(True, grouping=False)', '    edgecolor: MappableColor = Mappable(depend=\"color\", grouping=False)', '    edgealpha: MappableFloat = Mappable(depend=\"alpha\", grouping=False)', '    edgewidth: MappableFloat = Mappable(.5, grouping=False)  # TODO rcParam?', '    edgestyle: MappableStyle = Mappable(\"-\", grouping=False)', '', '    def _resolve_properties(self, data, scales):', '', '        resolved = super()._resolve_properties(data, scales)', '        filled = resolved[\"fill\"]', '', '        main_stroke = resolved[\"stroke\"]', '        edge_stroke = resolved[\"edgewidth\"]', '        resolved[\"linewidth\"] = np.where(filled, edge_stroke, main_stroke)', '', '        main_color = resolve_color(self, data, \"\", scales)', '        edge_color = resolve_color(self, data, \"edge\", scales)', '', '        if not np.isscalar(filled):', '            # Expand dims to use in np.where with rgba arrays', '            filled = filled[:, None]', '        resolved[\"edgecolor\"] = np.where(filled, edge_color, main_color)', '', '        filled = np.squeeze(filled)', '        if isinstance(main_color, tuple):', '            # TODO handle this in resolve_color', '            main_color = tuple([*main_color[:3], main_color[3] * filled])', '        else:', '            main_color = np.c_[main_color[:, :3], main_color[:, 3] * filled]', '        resolved[\"facecolor\"] = main_color', '', '        return resolved'], 'methods': [{'name': '_resolve_properties', 'start_line': 132, 'end_line': 157, 'text': ['    def _resolve_properties(self, data, scales):', '', '        resolved = super()._resolve_properties(data, scales)', '        filled = resolved[\"fill\"]', '', '        main_stroke = resolved[\"stroke\"]', '        edge_stroke = resolved[\"edgewidth\"]', '        resolved[\"linewidth\"] = np.where(filled, edge_stroke, main_stroke)', '', '        main_color = resolve_color(self, data, \"\", scales)', '        edge_color = resolve_color(self, data, \"edge\", scales)', '', '        if not np.isscalar(filled):', '            # Expand dims to use in np.where with rgba arrays', '            filled = filled[:, None]', '        resolved[\"edgecolor\"] = np.where(filled, edge_color, main_color)', '', '        filled = np.squeeze(filled)', '        if isinstance(main_color, tuple):', '            # TODO handle this in resolve_color', '            main_color = tuple([*main_color[:3], main_color[3] * filled])', '        else:', '            main_color = np.c_[main_color[:, :3], main_color[:, 3] * filled]', '        resolved[\"facecolor\"] = main_color', '', '        return resolved']}]}, {'name': 'Dots', 'start_line': 162, 'end_line': 200, 'text': ['class Dots(DotBase):', '    \"\"\"', '    A dot mark defined by strokes to better handle overplotting.', '', '    See also', '    --------', '    Dot : A mark suitable for dot plots or less-dense scatterplots.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Dots.rst', '', '    \"\"\"', '    # TODO retype marker as MappableMarker', '    marker: MappableString = Mappable(rc=\"scatter.marker\", grouping=False)', '    pointsize: MappableFloat = Mappable(4, grouping=False)  # TODO rcParam?', '    stroke: MappableFloat = Mappable(.75, grouping=False)  # TODO rcParam?', '    color: MappableColor = Mappable(\"C0\", grouping=False)', '    alpha: MappableFloat = Mappable(1, grouping=False)  # TODO auto alpha?', '    fill: MappableBool = Mappable(True, grouping=False)', '    fillcolor: MappableColor = Mappable(depend=\"color\", grouping=False)', '    fillalpha: MappableFloat = Mappable(.2, grouping=False)', '', '    def _resolve_properties(self, data, scales):', '', '        resolved = super()._resolve_properties(data, scales)', '        resolved[\"linewidth\"] = resolved.pop(\"stroke\")', '        resolved[\"facecolor\"] = resolve_color(self, data, \"fill\", scales)', '        resolved[\"edgecolor\"] = resolve_color(self, data, \"\", scales)', '        resolved.setdefault(\"edgestyle\", (0, None))', '', '        fc = resolved[\"facecolor\"]', '        if isinstance(fc, tuple):', '            resolved[\"facecolor\"] = fc[0], fc[1], fc[2], fc[3] * resolved[\"fill\"]', '        else:', '            fc[:, 3] = fc[:, 3] * resolved[\"fill\"]  # TODO Is inplace mod a problem?', '            resolved[\"facecolor\"] = fc', '', '        return resolved'], 'methods': [{'name': '_resolve_properties', 'start_line': 185, 'end_line': 200, 'text': ['    def _resolve_properties(self, data, scales):', '', '        resolved = super()._resolve_properties(data, scales)', '        resolved[\"linewidth\"] = resolved.pop(\"stroke\")', '        resolved[\"facecolor\"] = resolve_color(self, data, \"fill\", scales)', '        resolved[\"edgecolor\"] = resolve_color(self, data, \"\", scales)', '        resolved.setdefault(\"edgestyle\", (0, None))', '', '        fc = resolved[\"facecolor\"]', '        if isinstance(fc, tuple):', '            resolved[\"facecolor\"] = fc[0], fc[1], fc[2], fc[3] * resolved[\"fill\"]', '        else:', '            fc[:, 3] = fc[:, 3] * resolved[\"fill\"]  # TODO Is inplace mod a problem?', '            resolved[\"facecolor\"] = fc', '', '        return resolved']}]}], 'functions': [{'name': 'get_transformed_path', 'start_line': 35, 'end_line': 36, 'text': ['        def get_transformed_path(m):', '            return m.get_path().transformed(m.get_transform())']}], 'text': ['from __future__ import annotations', 'from dataclasses import dataclass', '', 'import numpy as np', 'import matplotlib as mpl', '', 'from seaborn._marks.base import (', '    Mark,', '    Mappable,', '    MappableBool,', '    MappableFloat,', '    MappableString,', '    MappableColor,', '    MappableStyle,', '    resolve_properties,', '    resolve_color,', '    document_properties,', ')', '', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:', '    from typing import Any', '    from matplotlib.artist import Artist', '    from seaborn._core.scales import Scale', '', '', 'class DotBase(Mark):', '', '    def _resolve_paths(self, data):', '', '        paths = []', '        path_cache = {}', '        marker = data[\"marker\"]', '', '        def get_transformed_path(m):', '            return m.get_path().transformed(m.get_transform())', '', '        if isinstance(marker, mpl.markers.MarkerStyle):', '            return get_transformed_path(marker)', '', '        for m in marker:', '            if m not in path_cache:', '                path_cache[m] = get_transformed_path(m)', '            paths.append(path_cache[m])', '        return paths', '', '    def _resolve_properties(self, data, scales):', '', '        resolved = resolve_properties(self, data, scales)', '        resolved[\"path\"] = self._resolve_paths(resolved)', '        resolved[\"size\"] = resolved[\"pointsize\"] ** 2', '', '        if isinstance(data, dict):  # Properties for single dot', '            filled_marker = resolved[\"marker\"].is_filled()', '        else:', '            filled_marker = [m.is_filled() for m in resolved[\"marker\"]]', '', '        resolved[\"fill\"] = resolved[\"fill\"] * filled_marker', '', '        return resolved', '', '    def _plot(self, split_gen, scales, orient):', '', '        # TODO Not backcompat with allowed (but nonfunctional) univariate plots', '        # (That should be solved upstream by defaulting to \"\" for unset x/y?)', '        # (Be mindful of xmin/xmax, etc!)', '', '        for _, data, ax in split_gen():', '', '            offsets = np.column_stack([data[\"x\"], data[\"y\"]])', '            data = self._resolve_properties(data, scales)', '', '            points = mpl.collections.PathCollection(', '                offsets=offsets,', '                paths=data[\"path\"],', '                sizes=data[\"size\"],', '                facecolors=data[\"facecolor\"],', '                edgecolors=data[\"edgecolor\"],', '                linewidths=data[\"linewidth\"],', '                linestyles=data[\"edgestyle\"],', '                transOffset=ax.transData,', '                transform=mpl.transforms.IdentityTransform(),', '                **self.artist_kws,', '            )', '            ax.add_collection(points)', '', '    def _legend_artist(', '        self, variables: list[str], value: Any, scales: dict[str, Scale],', '    ) -> Artist:', '', '        key = {v: value for v in variables}', '        res = self._resolve_properties(key, scales)', '', '        return mpl.collections.PathCollection(', '            paths=[res[\"path\"]],', '            sizes=[res[\"size\"]],', '            facecolors=[res[\"facecolor\"]],', '            edgecolors=[res[\"edgecolor\"]],', '            linewidths=[res[\"linewidth\"]],', '            linestyles=[res[\"edgestyle\"]],', '            transform=mpl.transforms.IdentityTransform(),', '            **self.artist_kws,', '        )', '', '', '@document_properties', '@dataclass', 'class Dot(DotBase):', '    \"\"\"', '    A mark suitable for dot plots or less-dense scatterplots.', '', '    See also', '    --------', '    Dots : A dot mark defined by strokes to better handle overplotting.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Dot.rst', '', '    \"\"\"', '    marker: MappableString = Mappable(\"o\", grouping=False)', '    pointsize: MappableFloat = Mappable(6, grouping=False)  # TODO rcParam?', '    stroke: MappableFloat = Mappable(.75, grouping=False)  # TODO rcParam?', '    color: MappableColor = Mappable(\"C0\", grouping=False)', '    alpha: MappableFloat = Mappable(1, grouping=False)', '    fill: MappableBool = Mappable(True, grouping=False)', '    edgecolor: MappableColor = Mappable(depend=\"color\", grouping=False)', '    edgealpha: MappableFloat = Mappable(depend=\"alpha\", grouping=False)', '    edgewidth: MappableFloat = Mappable(.5, grouping=False)  # TODO rcParam?', '    edgestyle: MappableStyle = Mappable(\"-\", grouping=False)', '', '    def _resolve_properties(self, data, scales):', '', '        resolved = super()._resolve_properties(data, scales)', '        filled = resolved[\"fill\"]', '', '        main_stroke = resolved[\"stroke\"]', '        edge_stroke = resolved[\"edgewidth\"]', '        resolved[\"linewidth\"] = np.where(filled, edge_stroke, main_stroke)', '', '        main_color = resolve_color(self, data, \"\", scales)', '        edge_color = resolve_color(self, data, \"edge\", scales)', '', '        if not np.isscalar(filled):', '            # Expand dims to use in np.where with rgba arrays', '            filled = filled[:, None]', '        resolved[\"edgecolor\"] = np.where(filled, edge_color, main_color)', '', '        filled = np.squeeze(filled)', '        if isinstance(main_color, tuple):', '            # TODO handle this in resolve_color', '            main_color = tuple([*main_color[:3], main_color[3] * filled])', '        else:', '            main_color = np.c_[main_color[:, :3], main_color[:, 3] * filled]', '        resolved[\"facecolor\"] = main_color', '', '        return resolved', '', '', '@document_properties', '@dataclass', 'class Dots(DotBase):', '    \"\"\"', '    A dot mark defined by strokes to better handle overplotting.', '', '    See also', '    --------', '    Dot : A mark suitable for dot plots or less-dense scatterplots.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Dots.rst', '', '    \"\"\"', '    # TODO retype marker as MappableMarker', '    marker: MappableString = Mappable(rc=\"scatter.marker\", grouping=False)', '    pointsize: MappableFloat = Mappable(4, grouping=False)  # TODO rcParam?', '    stroke: MappableFloat = Mappable(.75, grouping=False)  # TODO rcParam?', '    color: MappableColor = Mappable(\"C0\", grouping=False)', '    alpha: MappableFloat = Mappable(1, grouping=False)  # TODO auto alpha?', '    fill: MappableBool = Mappable(True, grouping=False)', '    fillcolor: MappableColor = Mappable(depend=\"color\", grouping=False)', '    fillalpha: MappableFloat = Mappable(.2, grouping=False)', '', '    def _resolve_properties(self, data, scales):', '', '        resolved = super()._resolve_properties(data, scales)', '        resolved[\"linewidth\"] = resolved.pop(\"stroke\")', '        resolved[\"facecolor\"] = resolve_color(self, data, \"fill\", scales)', '        resolved[\"edgecolor\"] = resolve_color(self, data, \"\", scales)', '        resolved.setdefault(\"edgestyle\", (0, None))', '', '        fc = resolved[\"facecolor\"]', '        if isinstance(fc, tuple):', '            resolved[\"facecolor\"] = fc[0], fc[1], fc[2], fc[3] * resolved[\"fill\"]', '        else:', '            fc[:, 3] = fc[:, 3] * resolved[\"fill\"]  # TODO Is inplace mod a problem?', '            resolved[\"facecolor\"] = fc', '', '        return resolved']}}, 'external': {'docscrape.py': {'classes': [{'name': 'Reader', 'start_line': 49, 'end_line': 122, 'text': ['class Reader:', '    \"\"\"A line-based string reader.', '', '    \"\"\"', '    def __init__(self, data):', '        \"\"\"', '        Parameters', '        ----------', '        data : str', \"           String with lines separated by '\\\\n'.\", '', '        \"\"\"', '        if isinstance(data, list):', '            self._str = data', '        else:', \"            self._str = data.split('\\\\n')  # store string as list of lines\", '', '        self.reset()', '', '    def __getitem__(self, n):', '        return self._str[n]', '', '    def reset(self):', '        self._l = 0  # current line nr', '', '    def read(self):', '        if not self.eof():', '            out = self[self._l]', '            self._l += 1', '            return out', '        else:', \"            return ''\", '', '    def seek_next_non_empty_line(self):', '        for l in self[self._l:]:', '            if l.strip():', '                break', '            else:', '                self._l += 1', '', '    def eof(self):', '        return self._l >= len(self._str)', '', '    def read_to_condition(self, condition_func):', '        start = self._l', '        for line in self[start:]:', '            if condition_func(line):', '                return self[start:self._l]', '            self._l += 1', '            if self.eof():', '                return self[start:self._l+1]', '        return []', '', '    def read_to_next_empty_line(self):', '        self.seek_next_non_empty_line()', '', '        def is_empty(line):', '            return not line.strip()', '', '        return self.read_to_condition(is_empty)', '', '    def read_to_next_unindented_line(self):', '        def is_unindented(line):', '            return (line.strip() and (len(line.lstrip()) == len(line)))', '        return self.read_to_condition(is_unindented)', '', '    def peek(self, n=0):', '        if self._l + n < len(self._str):', '            return self[self._l + n]', '        else:', \"            return ''\", '', '    def is_empty(self):', \"        return not ''.join(self._str).strip()\"], 'methods': [{'name': '__init__', 'start_line': 53, 'end_line': 66, 'text': ['    def __init__(self, data):', '        \"\"\"', '        Parameters', '        ----------', '        data : str', \"           String with lines separated by '\\\\n'.\", '', '        \"\"\"', '        if isinstance(data, list):', '            self._str = data', '        else:', \"            self._str = data.split('\\\\n')  # store string as list of lines\", '', '        self.reset()']}, {'name': '__getitem__', 'start_line': 68, 'end_line': 69, 'text': ['    def __getitem__(self, n):', '        return self._str[n]']}, {'name': 'reset', 'start_line': 71, 'end_line': 72, 'text': ['    def reset(self):', '        self._l = 0  # current line nr']}, {'name': 'read', 'start_line': 74, 'end_line': 80, 'text': ['    def read(self):', '        if not self.eof():', '            out = self[self._l]', '            self._l += 1', '            return out', '        else:', \"            return ''\"]}, {'name': 'seek_next_non_empty_line', 'start_line': 82, 'end_line': 87, 'text': ['    def seek_next_non_empty_line(self):', '        for l in self[self._l:]:', '            if l.strip():', '                break', '            else:', '                self._l += 1']}, {'name': 'eof', 'start_line': 89, 'end_line': 90, 'text': ['    def eof(self):', '        return self._l >= len(self._str)']}, {'name': 'read_to_condition', 'start_line': 92, 'end_line': 100, 'text': ['    def read_to_condition(self, condition_func):', '        start = self._l', '        for line in self[start:]:', '            if condition_func(line):', '                return self[start:self._l]', '            self._l += 1', '            if self.eof():', '                return self[start:self._l+1]', '        return []']}, {'name': 'read_to_next_empty_line', 'start_line': 102, 'end_line': 108, 'text': ['    def read_to_next_empty_line(self):', '        self.seek_next_non_empty_line()', '', '        def is_empty(line):', '            return not line.strip()', '', '        return self.read_to_condition(is_empty)']}, {'name': 'read_to_next_unindented_line', 'start_line': 110, 'end_line': 113, 'text': ['    def read_to_next_unindented_line(self):', '        def is_unindented(line):', '            return (line.strip() and (len(line.lstrip()) == len(line)))', '        return self.read_to_condition(is_unindented)']}, {'name': 'peek', 'start_line': 115, 'end_line': 119, 'text': ['    def peek(self, n=0):', '        if self._l + n < len(self._str):', '            return self[self._l + n]', '        else:', \"            return ''\"]}, {'name': 'is_empty', 'start_line': 121, 'end_line': 122, 'text': ['    def is_empty(self):', \"        return not ''.join(self._str).strip()\"]}]}, {'name': 'ParseError', 'start_line': 125, 'end_line': 130, 'text': ['class ParseError(Exception):', '    def __str__(self):', '        message = self.args[0]', \"        if hasattr(self, 'docstring'):\", '            message = f\"{message} in {self.docstring!r}\"', '        return message'], 'methods': [{'name': '__str__', 'start_line': 126, 'end_line': 130, 'text': ['    def __str__(self):', '        message = self.args[0]', \"        if hasattr(self, 'docstring'):\", '            message = f\"{message} in {self.docstring!r}\"', '        return message']}]}, {'name': 'NumpyDocString', 'start_line': 136, 'end_line': 561, 'text': ['class NumpyDocString(Mapping):', '    \"\"\"Parses a numpydoc string to an abstract representation', '', '    Instances define a mapping from section title to structured data.', '', '    \"\"\"', '', '    sections = {', \"        'Signature': '',\", \"        'Summary': [''],\", \"        'Extended Summary': [],\", \"        'Parameters': [],\", \"        'Returns': [],\", \"        'Yields': [],\", \"        'Receives': [],\", \"        'Raises': [],\", \"        'Warns': [],\", \"        'Other Parameters': [],\", \"        'Attributes': [],\", \"        'Methods': [],\", \"        'See Also': [],\", \"        'Notes': [],\", \"        'Warnings': [],\", \"        'References': '',\", \"        'Examples': '',\", \"        'index': {}\", '    }', '', '    def __init__(self, docstring, config={}):', '        orig_docstring = docstring', \"        docstring = textwrap.dedent(docstring).split('\\\\n')\", '', '        self._doc = Reader(docstring)', '        self._parsed_data = copy.deepcopy(self.sections)', '', '        try:', '            self._parse()', '        except ParseError as e:', '            e.docstring = orig_docstring', '            raise', '', '    def __getitem__(self, key):', '        return self._parsed_data[key]', '', '    def __setitem__(self, key, val):', '        if key not in self._parsed_data:', '            self._error_location(f\"Unknown section {key}\", error=False)', '        else:', '            self._parsed_data[key] = val', '', '    def __iter__(self):', '        return iter(self._parsed_data)', '', '    def __len__(self):', '        return len(self._parsed_data)', '', '    def _is_at_section(self):', '        self._doc.seek_next_non_empty_line()', '', '        if self._doc.eof():', '            return False', '', '        l1 = self._doc.peek().strip()  # e.g. Parameters', '', \"        if l1.startswith('.. index::'):\", '            return True', '', '        l2 = self._doc.peek(1).strip()  # ---------- or ==========', \"        return l2.startswith('-'*len(l1)) or l2.startswith('='*len(l1))\", '', '    def _strip(self, doc):', '        i = 0', '        j = 0', '        for i, line in enumerate(doc):', '            if line.strip():', '                break', '', '        for j, line in enumerate(doc[::-1]):', '            if line.strip():', '                break', '', '        return doc[i:len(doc)-j]', '', '    def _read_to_next_section(self):', '        section = self._doc.read_to_next_empty_line()', '', '        while not self._is_at_section() and not self._doc.eof():', '            if not self._doc.peek(-1).strip():  # previous line was empty', \"                section += ['']\", '', '            section += self._doc.read_to_next_empty_line()', '', '        return section', '', '    def _read_sections(self):', '        while not self._doc.eof():', '            data = self._read_to_next_section()', '            name = data[0].strip()', '', \"            if name.startswith('..'):  # index section\", '                yield name, data[1:]', '            elif len(data) < 2:', '                yield StopIteration', '            else:', '                yield name, self._strip(data[2:])', '', '    def _parse_param_list(self, content, single_element_is_type=False):', '        r = Reader(content)', '        params = []', '        while not r.eof():', '            header = r.read().strip()', \"            if ' : ' in header:\", \"                arg_name, arg_type = header.split(' : ')[:2]\", '            else:', '                if single_element_is_type:', \"                    arg_name, arg_type = '', header\", '                else:', \"                    arg_name, arg_type = header, ''\", '', '            desc = r.read_to_next_unindented_line()', '            desc = dedent_lines(desc)', '            desc = strip_blank_lines(desc)', '', '            params.append(Parameter(arg_name, arg_type, desc))', '', '        return params', '', '    # See also supports the following formats.', '    #', '    # <FUNCNAME>', '    # <FUNCNAME> SPACE* COLON SPACE+ <DESC> SPACE*', '    # <FUNCNAME> ( COMMA SPACE+ <FUNCNAME>)+ (COMMA | PERIOD)? SPACE*', '    # <FUNCNAME> ( COMMA SPACE+ <FUNCNAME>)* SPACE* COLON SPACE+ <DESC> SPACE*', '', '    # <FUNCNAME> is one of', '    #   <PLAIN_FUNCNAME>', '    #   COLON <ROLE> COLON BACKTICK <PLAIN_FUNCNAME> BACKTICK', '    # where', '    #   <PLAIN_FUNCNAME> is a legal function name, and', '    #   <ROLE> is any nonempty sequence of word characters.', '    # Examples: func_f1  :meth:`func_h1` :obj:`~baz.obj_r` :class:`class_j`', '    # <DESC> is a string describing the function.', '', '    _role = r\":(?P<role>\\\\w+):\"', '    _funcbacktick = r\"`(?P<name>(?:~\\\\w+\\\\.)?[a-zA-Z0-9_\\\\.-]+)`\"', '    _funcplain = r\"(?P<name2>[a-zA-Z0-9_\\\\.-]+)\"', '    _funcname = r\"(\" + _role + _funcbacktick + r\"|\" + _funcplain + r\")\"', \"    _funcnamenext = _funcname.replace('role', 'rolenext')\", \"    _funcnamenext = _funcnamenext.replace('name', 'namenext')\", '    _description = r\"(?P<description>\\\\s*:(\\\\s+(?P<desc>\\\\S+.*))?)?\\\\s*$\"', '    _func_rgx = re.compile(r\"^\\\\s*\" + _funcname + r\"\\\\s*\")', '    _line_rgx = re.compile(', '        r\"^\\\\s*\" +', '        r\"(?P<allfuncs>\" +        # group for all function names', '        _funcname +', '        r\"(?P<morefuncs>([,]\\\\s+\" + _funcnamenext + r\")*)\" +', '        r\")\" +                     # end of \"allfuncs\"', '        r\"(?P<trailing>[,\\\\.])?\" +   # Some function lists have a trailing comma (or period)  \\'\\\\s*\\'', '        _description)', '', \"    # Empty <DESC> elements are replaced with '..'\", \"    empty_description = '..'\", '', '    def _parse_see_also(self, content):', '        \"\"\"', '        func_name : Descriptive text', '            continued text', '        another_func_name : Descriptive text', '        func_name1, func_name2, :meth:`func_name`, func_name3', '', '        \"\"\"', '', '        items = []', '', '        def parse_item_name(text):', '            \"\"\"Match \\':role:`name`\\' or \\'name\\'.\"\"\"', '            m = self._func_rgx.match(text)', '            if not m:', '                raise ParseError(f\"{text} is not a item name\")', \"            role = m.group('role')\", \"            name = m.group('name') if role else m.group('name2')\", '            return name, role, m.end()', '', '        rest = []', '        for line in content:', '            if not line.strip():', '                continue', '', '            line_match = self._line_rgx.match(line)', '            description = None', '            if line_match:', \"                description = line_match.group('desc')\", \"                if line_match.group('trailing') and description:\", '                    self._error_location(', \"                        'Unexpected comma or period after function list at index %d of '\", '                        \\'line \"%s\"\\' % (line_match.end(\\'trailing\\'), line),', '                        error=False)', \"            if not description and line.startswith(' '):\", '                rest.append(line.strip())', '            elif line_match:', '                funcs = []', \"                text = line_match.group('allfuncs')\", '                while True:', '                    if not text.strip():', '                        break', '                    name, role, match_end = parse_item_name(text)', '                    funcs.append((name, role))', '                    text = text[match_end:].strip()', \"                    if text and text[0] == ',':\", '                        text = text[1:].strip()', '                rest = list(filter(None, [description]))', '                items.append((funcs, rest))', '            else:', '                raise ParseError(f\"{line} is not a item name\")', '        return items', '', '    def _parse_index(self, section, content):', '        \"\"\"', '        .. index: default', '           :refguide: something, else, and more', '', '        \"\"\"', '        def strip_each_in(lst):', '            return [s.strip() for s in lst]', '', '        out = {}', \"        section = section.split('::')\", '        if len(section) > 1:', \"            out['default'] = strip_each_in(section[1].split(','))[0]\", '        for line in content:', \"            line = line.split(':')\", '            if len(line) > 2:', \"                out[line[1]] = strip_each_in(line[2].split(','))\", '        return out', '', '    def _parse_summary(self):', '        \"\"\"Grab signature (if given) and summary\"\"\"', '        if self._is_at_section():', '            return', '', '        # If several signatures present, take the last one', '        while True:', '            summary = self._doc.read_to_next_empty_line()', '            summary_str = \" \".join([s.strip() for s in summary]).strip()', \"            compiled = re.compile(r'^([\\\\w., ]+=)?\\\\s*[\\\\w\\\\.]+\\\\(.*\\\\)$')\", '            if compiled.match(summary_str):', \"                self['Signature'] = summary_str\", '                if not self._is_at_section():', '                    continue', '            break', '', '        if summary is not None:', \"            self['Summary'] = summary\", '', '        if not self._is_at_section():', \"            self['Extended Summary'] = self._read_to_next_section()\", '', '    def _parse(self):', '        self._doc.reset()', '        self._parse_summary()', '', '        sections = list(self._read_sections())', '        section_names = {section for section, content in sections}', '', \"        has_returns = 'Returns' in section_names\", \"        has_yields = 'Yields' in section_names\", '        # We could do more tests, but we are not. Arbitrarily.', '        if has_returns and has_yields:', \"            msg = 'Docstring contains both a Returns and Yields section.'\", '            raise ValueError(msg)', \"        if not has_yields and 'Receives' in section_names:\", \"            msg = 'Docstring contains a Receives section but not Yields.'\", '            raise ValueError(msg)', '', '        for (section, content) in sections:', \"            if not section.startswith('..'):\", \"                section = (s.capitalize() for s in section.split(' '))\", \"                section = ' '.join(section)\", '                if self.get(section):', '                    self._error_location(f\"The section {section} appears twice\")', '', \"            if section in ('Parameters', 'Other Parameters', 'Attributes',\", \"                           'Methods'):\", '                self[section] = self._parse_param_list(content)', \"            elif section in ('Returns', 'Yields', 'Raises', 'Warns', 'Receives'):\", '                self[section] = self._parse_param_list(', '                    content, single_element_is_type=True)', \"            elif section.startswith('.. index::'):\", \"                self['index'] = self._parse_index(section, content)\", \"            elif section == 'See Also':\", \"                self['See Also'] = self._parse_see_also(content)\", '            else:', '                self[section] = content', '', '    def _error_location(self, msg, error=True):', \"        if hasattr(self, '_obj'):\", '            # we know where the docs came from:', '            try:', '                filename = inspect.getsourcefile(self._obj)', '            except TypeError:', '                filename = None', '            msg = msg + f\" in the docstring of {self._obj} in {filename}.\"', '        if error:', '            raise ValueError(msg)', '        else:', '            warn(msg)', '', '    # string conversion routines', '', \"    def _str_header(self, name, symbol='-'):\", '        return [name, len(name)*symbol]', '', '    def _str_indent(self, doc, indent=4):', '        out = []', '        for line in doc:', \"            out += [' '*indent + line]\", '        return out', '', '    def _str_signature(self):', \"        if self['Signature']:\", \"            return [self['Signature'].replace('*', r'\\\\*')] + ['']\", '        else:', \"            return ['']\", '', '    def _str_summary(self):', \"        if self['Summary']:\", \"            return self['Summary'] + ['']\", '        else:', '            return []', '', '    def _str_extended_summary(self):', \"        if self['Extended Summary']:\", \"            return self['Extended Summary'] + ['']\", '        else:', '            return []', '', '    def _str_param_list(self, name):', '        out = []', '        if self[name]:', '            out += self._str_header(name)', '            for param in self[name]:', '                parts = []', '                if param.name:', '                    parts.append(param.name)', '                if param.type:', '                    parts.append(param.type)', \"                out += [' : '.join(parts)]\", \"                if param.desc and ''.join(param.desc).strip():\", '                    out += self._str_indent(param.desc)', \"            out += ['']\", '        return out', '', '    def _str_section(self, name):', '        out = []', '        if self[name]:', '            out += self._str_header(name)', '            out += self[name]', \"            out += ['']\", '        return out', '', '    def _str_see_also(self, func_role):', \"        if not self['See Also']:\", '            return []', '        out = []', '        out += self._str_header(\"See Also\")', \"        out += ['']\", '        last_had_desc = True', \"        for funcs, desc in self['See Also']:\", '            assert isinstance(funcs, list)', '            links = []', '            for func, role in funcs:', '                if role:', \"                    link = f':{role}:`{func}`'\", '                elif func_role:', \"                    link = f':{func_role}:`{func}`'\", '                else:', '                    link = f\"`{func}`_\"', '                links.append(link)', \"            link = ', '.join(links)\", '            out += [link]', '            if desc:', \"                out += self._str_indent([' '.join(desc)])\", '                last_had_desc = True', '            else:', '                last_had_desc = False', '                out += self._str_indent([self.empty_description])', '', '        if last_had_desc:', \"            out += ['']\", \"        out += ['']\", '        return out', '', '    def _str_index(self):', \"        idx = self['index']\", '        out = []', '        output_index = False', \"        default_index = idx.get('default', '')\", '        if default_index:', '            output_index = True', \"        out += [f'.. index:: {default_index}']\", '        for section, references in idx.items():', \"            if section == 'default':\", '                continue', '            output_index = True', '            out += [f\"   :{section}: {\\', \\'.join(references)}\"]', '        if output_index:', '            return out', '        else:', \"            return ''\", '', \"    def __str__(self, func_role=''):\", '        out = []', '        out += self._str_signature()', '        out += self._str_summary()', '        out += self._str_extended_summary()', \"        for param_list in ('Parameters', 'Returns', 'Yields', 'Receives',\", \"                           'Other Parameters', 'Raises', 'Warns'):\", '            out += self._str_param_list(param_list)', \"        out += self._str_section('Warnings')\", '        out += self._str_see_also(func_role)', \"        for s in ('Notes', 'References', 'Examples'):\", '            out += self._str_section(s)', \"        for param_list in ('Attributes', 'Methods'):\", '            out += self._str_param_list(param_list)', '        out += self._str_index()', \"        return '\\\\n'.join(out)\"], 'methods': [{'name': '__init__', 'start_line': 164, 'end_line': 175, 'text': ['    def __init__(self, docstring, config={}):', '        orig_docstring = docstring', \"        docstring = textwrap.dedent(docstring).split('\\\\n')\", '', '        self._doc = Reader(docstring)', '        self._parsed_data = copy.deepcopy(self.sections)', '', '        try:', '            self._parse()', '        except ParseError as e:', '            e.docstring = orig_docstring', '            raise']}, {'name': '__getitem__', 'start_line': 177, 'end_line': 178, 'text': ['    def __getitem__(self, key):', '        return self._parsed_data[key]']}, {'name': '__setitem__', 'start_line': 180, 'end_line': 184, 'text': ['    def __setitem__(self, key, val):', '        if key not in self._parsed_data:', '            self._error_location(f\"Unknown section {key}\", error=False)', '        else:', '            self._parsed_data[key] = val']}, {'name': '__iter__', 'start_line': 186, 'end_line': 187, 'text': ['    def __iter__(self):', '        return iter(self._parsed_data)']}, {'name': '__len__', 'start_line': 189, 'end_line': 190, 'text': ['    def __len__(self):', '        return len(self._parsed_data)']}, {'name': '_is_at_section', 'start_line': 192, 'end_line': 204, 'text': ['    def _is_at_section(self):', '        self._doc.seek_next_non_empty_line()', '', '        if self._doc.eof():', '            return False', '', '        l1 = self._doc.peek().strip()  # e.g. Parameters', '', \"        if l1.startswith('.. index::'):\", '            return True', '', '        l2 = self._doc.peek(1).strip()  # ---------- or ==========', \"        return l2.startswith('-'*len(l1)) or l2.startswith('='*len(l1))\"]}, {'name': '_strip', 'start_line': 206, 'end_line': 217, 'text': ['    def _strip(self, doc):', '        i = 0', '        j = 0', '        for i, line in enumerate(doc):', '            if line.strip():', '                break', '', '        for j, line in enumerate(doc[::-1]):', '            if line.strip():', '                break', '', '        return doc[i:len(doc)-j]']}, {'name': '_read_to_next_section', 'start_line': 219, 'end_line': 228, 'text': ['    def _read_to_next_section(self):', '        section = self._doc.read_to_next_empty_line()', '', '        while not self._is_at_section() and not self._doc.eof():', '            if not self._doc.peek(-1).strip():  # previous line was empty', \"                section += ['']\", '', '            section += self._doc.read_to_next_empty_line()', '', '        return section']}, {'name': '_read_sections', 'start_line': 230, 'end_line': 240, 'text': ['    def _read_sections(self):', '        while not self._doc.eof():', '            data = self._read_to_next_section()', '            name = data[0].strip()', '', \"            if name.startswith('..'):  # index section\", '                yield name, data[1:]', '            elif len(data) < 2:', '                yield StopIteration', '            else:', '                yield name, self._strip(data[2:])']}, {'name': '_parse_param_list', 'start_line': 242, 'end_line': 261, 'text': ['    def _parse_param_list(self, content, single_element_is_type=False):', '        r = Reader(content)', '        params = []', '        while not r.eof():', '            header = r.read().strip()', \"            if ' : ' in header:\", \"                arg_name, arg_type = header.split(' : ')[:2]\", '            else:', '                if single_element_is_type:', \"                    arg_name, arg_type = '', header\", '                else:', \"                    arg_name, arg_type = header, ''\", '', '            desc = r.read_to_next_unindented_line()', '            desc = dedent_lines(desc)', '            desc = strip_blank_lines(desc)', '', '            params.append(Parameter(arg_name, arg_type, desc))', '', '        return params']}, {'name': '_parse_see_also', 'start_line': 299, 'end_line': 350, 'text': ['    def _parse_see_also(self, content):', '        \"\"\"', '        func_name : Descriptive text', '            continued text', '        another_func_name : Descriptive text', '        func_name1, func_name2, :meth:`func_name`, func_name3', '', '        \"\"\"', '', '        items = []', '', '        def parse_item_name(text):', '            \"\"\"Match \\':role:`name`\\' or \\'name\\'.\"\"\"', '            m = self._func_rgx.match(text)', '            if not m:', '                raise ParseError(f\"{text} is not a item name\")', \"            role = m.group('role')\", \"            name = m.group('name') if role else m.group('name2')\", '            return name, role, m.end()', '', '        rest = []', '        for line in content:', '            if not line.strip():', '                continue', '', '            line_match = self._line_rgx.match(line)', '            description = None', '            if line_match:', \"                description = line_match.group('desc')\", \"                if line_match.group('trailing') and description:\", '                    self._error_location(', \"                        'Unexpected comma or period after function list at index %d of '\", '                        \\'line \"%s\"\\' % (line_match.end(\\'trailing\\'), line),', '                        error=False)', \"            if not description and line.startswith(' '):\", '                rest.append(line.strip())', '            elif line_match:', '                funcs = []', \"                text = line_match.group('allfuncs')\", '                while True:', '                    if not text.strip():', '                        break', '                    name, role, match_end = parse_item_name(text)', '                    funcs.append((name, role))', '                    text = text[match_end:].strip()', \"                    if text and text[0] == ',':\", '                        text = text[1:].strip()', '                rest = list(filter(None, [description]))', '                items.append((funcs, rest))', '            else:', '                raise ParseError(f\"{line} is not a item name\")', '        return items']}, {'name': '_parse_index', 'start_line': 352, 'end_line': 369, 'text': ['    def _parse_index(self, section, content):', '        \"\"\"', '        .. index: default', '           :refguide: something, else, and more', '', '        \"\"\"', '        def strip_each_in(lst):', '            return [s.strip() for s in lst]', '', '        out = {}', \"        section = section.split('::')\", '        if len(section) > 1:', \"            out['default'] = strip_each_in(section[1].split(','))[0]\", '        for line in content:', \"            line = line.split(':')\", '            if len(line) > 2:', \"                out[line[1]] = strip_each_in(line[2].split(','))\", '        return out']}, {'name': '_parse_summary', 'start_line': 371, 'end_line': 391, 'text': ['    def _parse_summary(self):', '        \"\"\"Grab signature (if given) and summary\"\"\"', '        if self._is_at_section():', '            return', '', '        # If several signatures present, take the last one', '        while True:', '            summary = self._doc.read_to_next_empty_line()', '            summary_str = \" \".join([s.strip() for s in summary]).strip()', \"            compiled = re.compile(r'^([\\\\w., ]+=)?\\\\s*[\\\\w\\\\.]+\\\\(.*\\\\)$')\", '            if compiled.match(summary_str):', \"                self['Signature'] = summary_str\", '                if not self._is_at_section():', '                    continue', '            break', '', '        if summary is not None:', \"            self['Summary'] = summary\", '', '        if not self._is_at_section():', \"            self['Extended Summary'] = self._read_to_next_section()\"]}, {'name': '_parse', 'start_line': 393, 'end_line': 428, 'text': ['    def _parse(self):', '        self._doc.reset()', '        self._parse_summary()', '', '        sections = list(self._read_sections())', '        section_names = {section for section, content in sections}', '', \"        has_returns = 'Returns' in section_names\", \"        has_yields = 'Yields' in section_names\", '        # We could do more tests, but we are not. Arbitrarily.', '        if has_returns and has_yields:', \"            msg = 'Docstring contains both a Returns and Yields section.'\", '            raise ValueError(msg)', \"        if not has_yields and 'Receives' in section_names:\", \"            msg = 'Docstring contains a Receives section but not Yields.'\", '            raise ValueError(msg)', '', '        for (section, content) in sections:', \"            if not section.startswith('..'):\", \"                section = (s.capitalize() for s in section.split(' '))\", \"                section = ' '.join(section)\", '                if self.get(section):', '                    self._error_location(f\"The section {section} appears twice\")', '', \"            if section in ('Parameters', 'Other Parameters', 'Attributes',\", \"                           'Methods'):\", '                self[section] = self._parse_param_list(content)', \"            elif section in ('Returns', 'Yields', 'Raises', 'Warns', 'Receives'):\", '                self[section] = self._parse_param_list(', '                    content, single_element_is_type=True)', \"            elif section.startswith('.. index::'):\", \"                self['index'] = self._parse_index(section, content)\", \"            elif section == 'See Also':\", \"                self['See Also'] = self._parse_see_also(content)\", '            else:', '                self[section] = content']}, {'name': '_error_location', 'start_line': 430, 'end_line': 441, 'text': ['    def _error_location(self, msg, error=True):', \"        if hasattr(self, '_obj'):\", '            # we know where the docs came from:', '            try:', '                filename = inspect.getsourcefile(self._obj)', '            except TypeError:', '                filename = None', '            msg = msg + f\" in the docstring of {self._obj} in {filename}.\"', '        if error:', '            raise ValueError(msg)', '        else:', '            warn(msg)']}, {'name': '_str_header', 'start_line': 445, 'end_line': 446, 'text': [\"    def _str_header(self, name, symbol='-'):\", '        return [name, len(name)*symbol]']}, {'name': '_str_indent', 'start_line': 448, 'end_line': 452, 'text': ['    def _str_indent(self, doc, indent=4):', '        out = []', '        for line in doc:', \"            out += [' '*indent + line]\", '        return out']}, {'name': '_str_signature', 'start_line': 454, 'end_line': 458, 'text': ['    def _str_signature(self):', \"        if self['Signature']:\", \"            return [self['Signature'].replace('*', r'\\\\*')] + ['']\", '        else:', \"            return ['']\"]}, {'name': '_str_summary', 'start_line': 460, 'end_line': 464, 'text': ['    def _str_summary(self):', \"        if self['Summary']:\", \"            return self['Summary'] + ['']\", '        else:', '            return []']}, {'name': '_str_extended_summary', 'start_line': 466, 'end_line': 470, 'text': ['    def _str_extended_summary(self):', \"        if self['Extended Summary']:\", \"            return self['Extended Summary'] + ['']\", '        else:', '            return []']}, {'name': '_str_param_list', 'start_line': 472, 'end_line': 486, 'text': ['    def _str_param_list(self, name):', '        out = []', '        if self[name]:', '            out += self._str_header(name)', '            for param in self[name]:', '                parts = []', '                if param.name:', '                    parts.append(param.name)', '                if param.type:', '                    parts.append(param.type)', \"                out += [' : '.join(parts)]\", \"                if param.desc and ''.join(param.desc).strip():\", '                    out += self._str_indent(param.desc)', \"            out += ['']\", '        return out']}, {'name': '_str_section', 'start_line': 488, 'end_line': 494, 'text': ['    def _str_section(self, name):', '        out = []', '        if self[name]:', '            out += self._str_header(name)', '            out += self[name]', \"            out += ['']\", '        return out']}, {'name': '_str_see_also', 'start_line': 496, 'end_line': 526, 'text': ['    def _str_see_also(self, func_role):', \"        if not self['See Also']:\", '            return []', '        out = []', '        out += self._str_header(\"See Also\")', \"        out += ['']\", '        last_had_desc = True', \"        for funcs, desc in self['See Also']:\", '            assert isinstance(funcs, list)', '            links = []', '            for func, role in funcs:', '                if role:', \"                    link = f':{role}:`{func}`'\", '                elif func_role:', \"                    link = f':{func_role}:`{func}`'\", '                else:', '                    link = f\"`{func}`_\"', '                links.append(link)', \"            link = ', '.join(links)\", '            out += [link]', '            if desc:', \"                out += self._str_indent([' '.join(desc)])\", '                last_had_desc = True', '            else:', '                last_had_desc = False', '                out += self._str_indent([self.empty_description])', '', '        if last_had_desc:', \"            out += ['']\", \"        out += ['']\", '        return out']}, {'name': '_str_index', 'start_line': 528, 'end_line': 544, 'text': ['    def _str_index(self):', \"        idx = self['index']\", '        out = []', '        output_index = False', \"        default_index = idx.get('default', '')\", '        if default_index:', '            output_index = True', \"        out += [f'.. index:: {default_index}']\", '        for section, references in idx.items():', \"            if section == 'default':\", '                continue', '            output_index = True', '            out += [f\"   :{section}: {\\', \\'.join(references)}\"]', '        if output_index:', '            return out', '        else:', \"            return ''\"]}, {'name': '__str__', 'start_line': 546, 'end_line': 561, 'text': [\"    def __str__(self, func_role=''):\", '        out = []', '        out += self._str_signature()', '        out += self._str_summary()', '        out += self._str_extended_summary()', \"        for param_list in ('Parameters', 'Returns', 'Yields', 'Receives',\", \"                           'Other Parameters', 'Raises', 'Warns'):\", '            out += self._str_param_list(param_list)', \"        out += self._str_section('Warnings')\", '        out += self._str_see_also(func_role)', \"        for s in ('Notes', 'References', 'Examples'):\", '            out += self._str_section(s)', \"        for param_list in ('Attributes', 'Methods'):\", '            out += self._str_param_list(param_list)', '        out += self._str_index()', \"        return '\\\\n'.join(out)\"]}]}, {'name': 'FunctionDoc', 'start_line': 581, 'end_line': 631, 'text': ['class FunctionDoc(NumpyDocString):', \"    def __init__(self, func, role='func', doc=None, config={}):\", '        self._f = func', '        self._role = role  # e.g. \"func\" or \"meth\"', '', '        if doc is None:', '            if func is None:', '                raise ValueError(\"No function or docstring given\")', \"            doc = inspect.getdoc(func) or ''\", '        NumpyDocString.__init__(self, doc, config)', '', \"        if not self['Signature'] and func is not None:\", '            func, func_name = self.get_func()', '            try:', '                try:', '                    signature = str(inspect.signature(func))', '                except (AttributeError, ValueError):', '                    # try to read signature, backward compat for older Python', '                    if sys.version_info[0] >= 3:', '                        argspec = inspect.getfullargspec(func)', '                    else:', '                        argspec = inspect.getargspec(func)', '                    signature = inspect.formatargspec(*argspec)', \"                signature = f'{func_name}{signature}'\", '            except TypeError:', \"                signature = f'{func_name}()'\", \"            self['Signature'] = signature\", '', '    def get_func(self):', \"        func_name = getattr(self._f, '__name__', self.__class__.__name__)\", '        if inspect.isclass(self._f):', \"            func = getattr(self._f, '__call__', self._f.__init__)\", '        else:', '            func = self._f', '        return func, func_name', '', '    def __str__(self):', \"        out = ''\", '', '        func, func_name = self.get_func()', '', \"        roles = {'func': 'function',\", \"                 'meth': 'method'}\", '', '        if self._role:', '            if self._role not in roles:', '                print(f\"Warning: invalid role {self._role}\")', '            out += f\".. {roles.get(self._role, \\'\\')}:: {func_name}\\\\n    \\\\n\\\\n\"', '', '        out += super().__str__(func_role=self._role)', '        return out'], 'methods': [{'name': '__init__', 'start_line': 582, 'end_line': 607, 'text': [\"    def __init__(self, func, role='func', doc=None, config={}):\", '        self._f = func', '        self._role = role  # e.g. \"func\" or \"meth\"', '', '        if doc is None:', '            if func is None:', '                raise ValueError(\"No function or docstring given\")', \"            doc = inspect.getdoc(func) or ''\", '        NumpyDocString.__init__(self, doc, config)', '', \"        if not self['Signature'] and func is not None:\", '            func, func_name = self.get_func()', '            try:', '                try:', '                    signature = str(inspect.signature(func))', '                except (AttributeError, ValueError):', '                    # try to read signature, backward compat for older Python', '                    if sys.version_info[0] >= 3:', '                        argspec = inspect.getfullargspec(func)', '                    else:', '                        argspec = inspect.getargspec(func)', '                    signature = inspect.formatargspec(*argspec)', \"                signature = f'{func_name}{signature}'\", '            except TypeError:', \"                signature = f'{func_name}()'\", \"            self['Signature'] = signature\"]}, {'name': 'get_func', 'start_line': 609, 'end_line': 615, 'text': ['    def get_func(self):', \"        func_name = getattr(self._f, '__name__', self.__class__.__name__)\", '        if inspect.isclass(self._f):', \"            func = getattr(self._f, '__call__', self._f.__init__)\", '        else:', '            func = self._f', '        return func, func_name']}, {'name': '__str__', 'start_line': 617, 'end_line': 631, 'text': ['    def __str__(self):', \"        out = ''\", '', '        func, func_name = self.get_func()', '', \"        roles = {'func': 'function',\", \"                 'meth': 'method'}\", '', '        if self._role:', '            if self._role not in roles:', '                print(f\"Warning: invalid role {self._role}\")', '            out += f\".. {roles.get(self._role, \\'\\')}:: {func_name}\\\\n    \\\\n\\\\n\"', '', '        out += super().__str__(func_role=self._role)', '        return out']}]}, {'name': 'ClassDoc', 'start_line': 634, 'end_line': 715, 'text': ['class ClassDoc(NumpyDocString):', '', \"    extra_public_methods = ['__call__']\", '', \"    def __init__(self, cls, doc=None, modulename='', func_doc=FunctionDoc,\", '                 config={}):', '        if not inspect.isclass(cls) and cls is not None:', '            raise ValueError(f\"Expected a class or None, but got {cls!r}\")', '        self._cls = cls', '', \"        if 'sphinx' in sys.modules:\", '            from sphinx.ext.autodoc import ALL', '        else:', '            ALL = object()', '', '        self.show_inherited_members = config.get(', \"                    'show_inherited_class_members', True)\", '', \"        if modulename and not modulename.endswith('.'):\", \"            modulename += '.'\", '        self._mod = modulename', '', '        if doc is None:', '            if cls is None:', '                raise ValueError(\"No class or documentation string given\")', '            doc = pydoc.getdoc(cls)', '', '        NumpyDocString.__init__(self, doc)', '', \"        _members = config.get('members', [])\", '        if _members is ALL:', '            _members = None', \"        _exclude = config.get('exclude-members', [])\", '', \"        if config.get('show_class_members', True) and _exclude is not ALL:\", '            def splitlines_x(s):', '                if not s:', '                    return []', '                else:', '                    return s.splitlines()', \"            for field, items in [('Methods', self.methods),\", \"                                 ('Attributes', self.properties)]:\", '                if not self[field]:', '                    doc_list = []', '                    for name in sorted(items):', '                        if (name in _exclude or', '                                (_members and name not in _members)):', '                            continue', '                        try:', '                            doc_item = pydoc.getdoc(getattr(self._cls, name))', '                            doc_list.append(', \"                                Parameter(name, '', splitlines_x(doc_item)))\", '                        except AttributeError:', \"                            pass  # method doesn't exist\", '                    self[field] = doc_list', '', '    @property', '    def methods(self):', '        if self._cls is None:', '            return []', '        return [name for name, func in inspect.getmembers(self._cls)', \"                if ((not name.startswith('_')\", '                     or name in self.extra_public_methods)', '                    and isinstance(func, Callable)', '                    and self._is_show_member(name))]', '', '    @property', '    def properties(self):', '        if self._cls is None:', '            return []', '        return [name for name, func in inspect.getmembers(self._cls)', \"                if (not name.startswith('_') and\", '                    (func is None or isinstance(func, property) or', '                     inspect.isdatadescriptor(func))', '                    and self._is_show_member(name))]', '', '    def _is_show_member(self, name):', '        if self.show_inherited_members:', '            return True  # show all class members', '        if name not in self._cls.__dict__:', '            return False  # class member is inherited, we do not show it', '        return True'], 'methods': [{'name': '__init__', 'start_line': 638, 'end_line': 688, 'text': [\"    def __init__(self, cls, doc=None, modulename='', func_doc=FunctionDoc,\", '                 config={}):', '        if not inspect.isclass(cls) and cls is not None:', '            raise ValueError(f\"Expected a class or None, but got {cls!r}\")', '        self._cls = cls', '', \"        if 'sphinx' in sys.modules:\", '            from sphinx.ext.autodoc import ALL', '        else:', '            ALL = object()', '', '        self.show_inherited_members = config.get(', \"                    'show_inherited_class_members', True)\", '', \"        if modulename and not modulename.endswith('.'):\", \"            modulename += '.'\", '        self._mod = modulename', '', '        if doc is None:', '            if cls is None:', '                raise ValueError(\"No class or documentation string given\")', '            doc = pydoc.getdoc(cls)', '', '        NumpyDocString.__init__(self, doc)', '', \"        _members = config.get('members', [])\", '        if _members is ALL:', '            _members = None', \"        _exclude = config.get('exclude-members', [])\", '', \"        if config.get('show_class_members', True) and _exclude is not ALL:\", '            def splitlines_x(s):', '                if not s:', '                    return []', '                else:', '                    return s.splitlines()', \"            for field, items in [('Methods', self.methods),\", \"                                 ('Attributes', self.properties)]:\", '                if not self[field]:', '                    doc_list = []', '                    for name in sorted(items):', '                        if (name in _exclude or', '                                (_members and name not in _members)):', '                            continue', '                        try:', '                            doc_item = pydoc.getdoc(getattr(self._cls, name))', '                            doc_list.append(', \"                                Parameter(name, '', splitlines_x(doc_item)))\", '                        except AttributeError:', \"                            pass  # method doesn't exist\", '                    self[field] = doc_list']}, {'name': 'methods', 'start_line': 691, 'end_line': 698, 'text': ['    def methods(self):', '        if self._cls is None:', '            return []', '        return [name for name, func in inspect.getmembers(self._cls)', \"                if ((not name.startswith('_')\", '                     or name in self.extra_public_methods)', '                    and isinstance(func, Callable)', '                    and self._is_show_member(name))]']}, {'name': 'properties', 'start_line': 701, 'end_line': 708, 'text': ['    def properties(self):', '        if self._cls is None:', '            return []', '        return [name for name, func in inspect.getmembers(self._cls)', \"                if (not name.startswith('_') and\", '                    (func is None or isinstance(func, property) or', '                     inspect.isdatadescriptor(func))', '                    and self._is_show_member(name))]']}, {'name': '_is_show_member', 'start_line': 710, 'end_line': 715, 'text': ['    def _is_show_member(self, name):', '        if self.show_inherited_members:', '            return True  # show all class members', '        if name not in self._cls.__dict__:', '            return False  # class member is inherited, we do not show it', '        return True']}]}], 'functions': [{'name': 'strip_blank_lines', 'start_line': 40, 'end_line': 46, 'text': ['def strip_blank_lines(l):', '    \"Remove leading and trailing blank lines from a list of lines\"', '    while l and not l[0].strip():', '        del l[0]', '    while l and not l[-1].strip():', '        del l[-1]', '    return l']}, {'name': 'indent', 'start_line': 564, 'end_line': 569, 'text': ['def indent(str, indent=4):', \"    indent_str = ' '*indent\", '    if str is None:', '        return indent_str', \"    lines = str.split('\\\\n')\", \"    return '\\\\n'.join(indent_str + l for l in lines)\"]}, {'name': 'dedent_lines', 'start_line': 572, 'end_line': 574, 'text': ['def dedent_lines(lines):', '    \"\"\"Deindent a list of lines maximally\"\"\"', '    return textwrap.dedent(\"\\\\n\".join(lines)).split(\"\\\\n\")']}, {'name': 'header', 'start_line': 577, 'end_line': 578, 'text': [\"def header(text, style='-'):\", \"    return text + '\\\\n' + style*len(text) + '\\\\n'\"]}, {'name': 'is_unindented', 'start_line': 111, 'end_line': 112, 'text': ['        def is_unindented(line):', '            return (line.strip() and (len(line.lstrip()) == len(line)))']}, {'name': 'parse_item_name', 'start_line': 310, 'end_line': 317, 'text': ['        def parse_item_name(text):', '            \"\"\"Match \\':role:`name`\\' or \\'name\\'.\"\"\"', '            m = self._func_rgx.match(text)', '            if not m:', '                raise ParseError(f\"{text} is not a item name\")', \"            role = m.group('role')\", \"            name = m.group('name') if role else m.group('name2')\", '            return name, role, m.end()']}, {'name': 'strip_each_in', 'start_line': 358, 'end_line': 359, 'text': ['        def strip_each_in(lst):', '            return [s.strip() for s in lst]']}, {'name': 'splitlines_x', 'start_line': 669, 'end_line': 673, 'text': ['            def splitlines_x(s):', '                if not s:', '                    return []', '                else:', '                    return s.splitlines()']}], 'text': ['\"\"\"Extract reference documentation from the NumPy source tree.', '', 'Copyright (C) 2008 Stefan van der Walt <stefan@mentat.za.net>, Pauli Virtanen <pav@iki.fi>', '', 'Redistribution and use in source and binary forms, with or without', 'modification, are permitted provided that the following conditions are', 'met:', '', ' 1. Redistributions of source code must retain the above copyright', '    notice, this list of conditions and the following disclaimer.', ' 2. Redistributions in binary form must reproduce the above copyright', '    notice, this list of conditions and the following disclaimer in', '    the documentation and/or other materials provided with the', '    distribution.', '', \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\", 'IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED', 'WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE', 'DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,', 'INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES', '(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR', 'SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)', 'HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,', 'STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING', 'IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE', 'POSSIBILITY OF SUCH DAMAGE.', '', '\"\"\"', 'import inspect', 'import textwrap', 'import re', 'import pydoc', 'from warnings import warn', 'from collections import namedtuple', 'from collections.abc import Callable, Mapping', 'import copy', 'import sys', '', '', 'def strip_blank_lines(l):', '    \"Remove leading and trailing blank lines from a list of lines\"', '    while l and not l[0].strip():', '        del l[0]', '    while l and not l[-1].strip():', '        del l[-1]', '    return l', '', '', 'class Reader:', '    \"\"\"A line-based string reader.', '', '    \"\"\"', '    def __init__(self, data):', '        \"\"\"', '        Parameters', '        ----------', '        data : str', \"           String with lines separated by '\\\\n'.\", '', '        \"\"\"', '        if isinstance(data, list):', '            self._str = data', '        else:', \"            self._str = data.split('\\\\n')  # store string as list of lines\", '', '        self.reset()', '', '    def __getitem__(self, n):', '        return self._str[n]', '', '    def reset(self):', '        self._l = 0  # current line nr', '', '    def read(self):', '        if not self.eof():', '            out = self[self._l]', '            self._l += 1', '            return out', '        else:', \"            return ''\", '', '    def seek_next_non_empty_line(self):', '        for l in self[self._l:]:', '            if l.strip():', '                break', '            else:', '                self._l += 1', '', '    def eof(self):', '        return self._l >= len(self._str)', '', '    def read_to_condition(self, condition_func):', '        start = self._l', '        for line in self[start:]:', '            if condition_func(line):', '                return self[start:self._l]', '            self._l += 1', '            if self.eof():', '                return self[start:self._l+1]', '        return []', '', '    def read_to_next_empty_line(self):', '        self.seek_next_non_empty_line()', '', '        def is_empty(line):', '            return not line.strip()', '', '        return self.read_to_condition(is_empty)', '', '    def read_to_next_unindented_line(self):', '        def is_unindented(line):', '            return (line.strip() and (len(line.lstrip()) == len(line)))', '        return self.read_to_condition(is_unindented)', '', '    def peek(self, n=0):', '        if self._l + n < len(self._str):', '            return self[self._l + n]', '        else:', \"            return ''\", '', '    def is_empty(self):', \"        return not ''.join(self._str).strip()\", '', '', 'class ParseError(Exception):', '    def __str__(self):', '        message = self.args[0]', \"        if hasattr(self, 'docstring'):\", '            message = f\"{message} in {self.docstring!r}\"', '        return message', '', '', \"Parameter = namedtuple('Parameter', ['name', 'type', 'desc'])\", '', '', 'class NumpyDocString(Mapping):', '    \"\"\"Parses a numpydoc string to an abstract representation', '', '    Instances define a mapping from section title to structured data.', '', '    \"\"\"', '', '    sections = {', \"        'Signature': '',\", \"        'Summary': [''],\", \"        'Extended Summary': [],\", \"        'Parameters': [],\", \"        'Returns': [],\", \"        'Yields': [],\", \"        'Receives': [],\", \"        'Raises': [],\", \"        'Warns': [],\", \"        'Other Parameters': [],\", \"        'Attributes': [],\", \"        'Methods': [],\", \"        'See Also': [],\", \"        'Notes': [],\", \"        'Warnings': [],\", \"        'References': '',\", \"        'Examples': '',\", \"        'index': {}\", '    }', '', '    def __init__(self, docstring, config={}):', '        orig_docstring = docstring', \"        docstring = textwrap.dedent(docstring).split('\\\\n')\", '', '        self._doc = Reader(docstring)', '        self._parsed_data = copy.deepcopy(self.sections)', '', '        try:', '            self._parse()', '        except ParseError as e:', '            e.docstring = orig_docstring', '            raise', '', '    def __getitem__(self, key):', '        return self._parsed_data[key]', '', '    def __setitem__(self, key, val):', '        if key not in self._parsed_data:', '            self._error_location(f\"Unknown section {key}\", error=False)', '        else:', '            self._parsed_data[key] = val', '', '    def __iter__(self):', '        return iter(self._parsed_data)', '', '    def __len__(self):', '        return len(self._parsed_data)', '', '    def _is_at_section(self):', '        self._doc.seek_next_non_empty_line()', '', '        if self._doc.eof():', '            return False', '', '        l1 = self._doc.peek().strip()  # e.g. Parameters', '', \"        if l1.startswith('.. index::'):\", '            return True', '', '        l2 = self._doc.peek(1).strip()  # ---------- or ==========', \"        return l2.startswith('-'*len(l1)) or l2.startswith('='*len(l1))\", '', '    def _strip(self, doc):', '        i = 0', '        j = 0', '        for i, line in enumerate(doc):', '            if line.strip():', '                break', '', '        for j, line in enumerate(doc[::-1]):', '            if line.strip():', '                break', '', '        return doc[i:len(doc)-j]', '', '    def _read_to_next_section(self):', '        section = self._doc.read_to_next_empty_line()', '', '        while not self._is_at_section() and not self._doc.eof():', '            if not self._doc.peek(-1).strip():  # previous line was empty', \"                section += ['']\", '', '            section += self._doc.read_to_next_empty_line()', '', '        return section', '', '    def _read_sections(self):', '        while not self._doc.eof():', '            data = self._read_to_next_section()', '            name = data[0].strip()', '', \"            if name.startswith('..'):  # index section\", '                yield name, data[1:]', '            elif len(data) < 2:', '                yield StopIteration', '            else:', '                yield name, self._strip(data[2:])', '', '    def _parse_param_list(self, content, single_element_is_type=False):', '        r = Reader(content)', '        params = []', '        while not r.eof():', '            header = r.read().strip()', \"            if ' : ' in header:\", \"                arg_name, arg_type = header.split(' : ')[:2]\", '            else:', '                if single_element_is_type:', \"                    arg_name, arg_type = '', header\", '                else:', \"                    arg_name, arg_type = header, ''\", '', '            desc = r.read_to_next_unindented_line()', '            desc = dedent_lines(desc)', '            desc = strip_blank_lines(desc)', '', '            params.append(Parameter(arg_name, arg_type, desc))', '', '        return params', '', '    # See also supports the following formats.', '    #', '    # <FUNCNAME>', '    # <FUNCNAME> SPACE* COLON SPACE+ <DESC> SPACE*', '    # <FUNCNAME> ( COMMA SPACE+ <FUNCNAME>)+ (COMMA | PERIOD)? SPACE*', '    # <FUNCNAME> ( COMMA SPACE+ <FUNCNAME>)* SPACE* COLON SPACE+ <DESC> SPACE*', '', '    # <FUNCNAME> is one of', '    #   <PLAIN_FUNCNAME>', '    #   COLON <ROLE> COLON BACKTICK <PLAIN_FUNCNAME> BACKTICK', '    # where', '    #   <PLAIN_FUNCNAME> is a legal function name, and', '    #   <ROLE> is any nonempty sequence of word characters.', '    # Examples: func_f1  :meth:`func_h1` :obj:`~baz.obj_r` :class:`class_j`', '    # <DESC> is a string describing the function.', '', '    _role = r\":(?P<role>\\\\w+):\"', '    _funcbacktick = r\"`(?P<name>(?:~\\\\w+\\\\.)?[a-zA-Z0-9_\\\\.-]+)`\"', '    _funcplain = r\"(?P<name2>[a-zA-Z0-9_\\\\.-]+)\"', '    _funcname = r\"(\" + _role + _funcbacktick + r\"|\" + _funcplain + r\")\"', \"    _funcnamenext = _funcname.replace('role', 'rolenext')\", \"    _funcnamenext = _funcnamenext.replace('name', 'namenext')\", '    _description = r\"(?P<description>\\\\s*:(\\\\s+(?P<desc>\\\\S+.*))?)?\\\\s*$\"', '    _func_rgx = re.compile(r\"^\\\\s*\" + _funcname + r\"\\\\s*\")', '    _line_rgx = re.compile(', '        r\"^\\\\s*\" +', '        r\"(?P<allfuncs>\" +        # group for all function names', '        _funcname +', '        r\"(?P<morefuncs>([,]\\\\s+\" + _funcnamenext + r\")*)\" +', '        r\")\" +                     # end of \"allfuncs\"', '        r\"(?P<trailing>[,\\\\.])?\" +   # Some function lists have a trailing comma (or period)  \\'\\\\s*\\'', '        _description)', '', \"    # Empty <DESC> elements are replaced with '..'\", \"    empty_description = '..'\", '', '    def _parse_see_also(self, content):', '        \"\"\"', '        func_name : Descriptive text', '            continued text', '        another_func_name : Descriptive text', '        func_name1, func_name2, :meth:`func_name`, func_name3', '', '        \"\"\"', '', '        items = []', '', '        def parse_item_name(text):', '            \"\"\"Match \\':role:`name`\\' or \\'name\\'.\"\"\"', '            m = self._func_rgx.match(text)', '            if not m:', '                raise ParseError(f\"{text} is not a item name\")', \"            role = m.group('role')\", \"            name = m.group('name') if role else m.group('name2')\", '            return name, role, m.end()', '', '        rest = []', '        for line in content:', '            if not line.strip():', '                continue', '', '            line_match = self._line_rgx.match(line)', '            description = None', '            if line_match:', \"                description = line_match.group('desc')\", \"                if line_match.group('trailing') and description:\", '                    self._error_location(', \"                        'Unexpected comma or period after function list at index %d of '\", '                        \\'line \"%s\"\\' % (line_match.end(\\'trailing\\'), line),', '                        error=False)', \"            if not description and line.startswith(' '):\", '                rest.append(line.strip())', '            elif line_match:', '                funcs = []', \"                text = line_match.group('allfuncs')\", '                while True:', '                    if not text.strip():', '                        break', '                    name, role, match_end = parse_item_name(text)', '                    funcs.append((name, role))', '                    text = text[match_end:].strip()', \"                    if text and text[0] == ',':\", '                        text = text[1:].strip()', '                rest = list(filter(None, [description]))', '                items.append((funcs, rest))', '            else:', '                raise ParseError(f\"{line} is not a item name\")', '        return items', '', '    def _parse_index(self, section, content):', '        \"\"\"', '        .. index: default', '           :refguide: something, else, and more', '', '        \"\"\"', '        def strip_each_in(lst):', '            return [s.strip() for s in lst]', '', '        out = {}', \"        section = section.split('::')\", '        if len(section) > 1:', \"            out['default'] = strip_each_in(section[1].split(','))[0]\", '        for line in content:', \"            line = line.split(':')\", '            if len(line) > 2:', \"                out[line[1]] = strip_each_in(line[2].split(','))\", '        return out', '', '    def _parse_summary(self):', '        \"\"\"Grab signature (if given) and summary\"\"\"', '        if self._is_at_section():', '            return', '', '        # If several signatures present, take the last one', '        while True:', '            summary = self._doc.read_to_next_empty_line()', '            summary_str = \" \".join([s.strip() for s in summary]).strip()', \"            compiled = re.compile(r'^([\\\\w., ]+=)?\\\\s*[\\\\w\\\\.]+\\\\(.*\\\\)$')\", '            if compiled.match(summary_str):', \"                self['Signature'] = summary_str\", '                if not self._is_at_section():', '                    continue', '            break', '', '        if summary is not None:', \"            self['Summary'] = summary\", '', '        if not self._is_at_section():', \"            self['Extended Summary'] = self._read_to_next_section()\", '', '    def _parse(self):', '        self._doc.reset()', '        self._parse_summary()', '', '        sections = list(self._read_sections())', '        section_names = {section for section, content in sections}', '', \"        has_returns = 'Returns' in section_names\", \"        has_yields = 'Yields' in section_names\", '        # We could do more tests, but we are not. Arbitrarily.', '        if has_returns and has_yields:', \"            msg = 'Docstring contains both a Returns and Yields section.'\", '            raise ValueError(msg)', \"        if not has_yields and 'Receives' in section_names:\", \"            msg = 'Docstring contains a Receives section but not Yields.'\", '            raise ValueError(msg)', '', '        for (section, content) in sections:', \"            if not section.startswith('..'):\", \"                section = (s.capitalize() for s in section.split(' '))\", \"                section = ' '.join(section)\", '                if self.get(section):', '                    self._error_location(f\"The section {section} appears twice\")', '', \"            if section in ('Parameters', 'Other Parameters', 'Attributes',\", \"                           'Methods'):\", '                self[section] = self._parse_param_list(content)', \"            elif section in ('Returns', 'Yields', 'Raises', 'Warns', 'Receives'):\", '                self[section] = self._parse_param_list(', '                    content, single_element_is_type=True)', \"            elif section.startswith('.. index::'):\", \"                self['index'] = self._parse_index(section, content)\", \"            elif section == 'See Also':\", \"                self['See Also'] = self._parse_see_also(content)\", '            else:', '                self[section] = content', '', '    def _error_location(self, msg, error=True):', \"        if hasattr(self, '_obj'):\", '            # we know where the docs came from:', '            try:', '                filename = inspect.getsourcefile(self._obj)', '            except TypeError:', '                filename = None', '            msg = msg + f\" in the docstring of {self._obj} in {filename}.\"', '        if error:', '            raise ValueError(msg)', '        else:', '            warn(msg)', '', '    # string conversion routines', '', \"    def _str_header(self, name, symbol='-'):\", '        return [name, len(name)*symbol]', '', '    def _str_indent(self, doc, indent=4):', '        out = []', '        for line in doc:', \"            out += [' '*indent + line]\", '        return out', '', '    def _str_signature(self):', \"        if self['Signature']:\", \"            return [self['Signature'].replace('*', r'\\\\*')] + ['']\", '        else:', \"            return ['']\", '', '    def _str_summary(self):', \"        if self['Summary']:\", \"            return self['Summary'] + ['']\", '        else:', '            return []', '', '    def _str_extended_summary(self):', \"        if self['Extended Summary']:\", \"            return self['Extended Summary'] + ['']\", '        else:', '            return []', '', '    def _str_param_list(self, name):', '        out = []', '        if self[name]:', '            out += self._str_header(name)', '            for param in self[name]:', '                parts = []', '                if param.name:', '                    parts.append(param.name)', '                if param.type:', '                    parts.append(param.type)', \"                out += [' : '.join(parts)]\", \"                if param.desc and ''.join(param.desc).strip():\", '                    out += self._str_indent(param.desc)', \"            out += ['']\", '        return out', '', '    def _str_section(self, name):', '        out = []', '        if self[name]:', '            out += self._str_header(name)', '            out += self[name]', \"            out += ['']\", '        return out', '', '    def _str_see_also(self, func_role):', \"        if not self['See Also']:\", '            return []', '        out = []', '        out += self._str_header(\"See Also\")', \"        out += ['']\", '        last_had_desc = True', \"        for funcs, desc in self['See Also']:\", '            assert isinstance(funcs, list)', '            links = []', '            for func, role in funcs:', '                if role:', \"                    link = f':{role}:`{func}`'\", '                elif func_role:', \"                    link = f':{func_role}:`{func}`'\", '                else:', '                    link = f\"`{func}`_\"', '                links.append(link)', \"            link = ', '.join(links)\", '            out += [link]', '            if desc:', \"                out += self._str_indent([' '.join(desc)])\", '                last_had_desc = True', '            else:', '                last_had_desc = False', '                out += self._str_indent([self.empty_description])', '', '        if last_had_desc:', \"            out += ['']\", \"        out += ['']\", '        return out', '', '    def _str_index(self):', \"        idx = self['index']\", '        out = []', '        output_index = False', \"        default_index = idx.get('default', '')\", '        if default_index:', '            output_index = True', \"        out += [f'.. index:: {default_index}']\", '        for section, references in idx.items():', \"            if section == 'default':\", '                continue', '            output_index = True', '            out += [f\"   :{section}: {\\', \\'.join(references)}\"]', '        if output_index:', '            return out', '        else:', \"            return ''\", '', \"    def __str__(self, func_role=''):\", '        out = []', '        out += self._str_signature()', '        out += self._str_summary()', '        out += self._str_extended_summary()', \"        for param_list in ('Parameters', 'Returns', 'Yields', 'Receives',\", \"                           'Other Parameters', 'Raises', 'Warns'):\", '            out += self._str_param_list(param_list)', \"        out += self._str_section('Warnings')\", '        out += self._str_see_also(func_role)', \"        for s in ('Notes', 'References', 'Examples'):\", '            out += self._str_section(s)', \"        for param_list in ('Attributes', 'Methods'):\", '            out += self._str_param_list(param_list)', '        out += self._str_index()', \"        return '\\\\n'.join(out)\", '', '', 'def indent(str, indent=4):', \"    indent_str = ' '*indent\", '    if str is None:', '        return indent_str', \"    lines = str.split('\\\\n')\", \"    return '\\\\n'.join(indent_str + l for l in lines)\", '', '', 'def dedent_lines(lines):', '    \"\"\"Deindent a list of lines maximally\"\"\"', '    return textwrap.dedent(\"\\\\n\".join(lines)).split(\"\\\\n\")', '', '', \"def header(text, style='-'):\", \"    return text + '\\\\n' + style*len(text) + '\\\\n'\", '', '', 'class FunctionDoc(NumpyDocString):', \"    def __init__(self, func, role='func', doc=None, config={}):\", '        self._f = func', '        self._role = role  # e.g. \"func\" or \"meth\"', '', '        if doc is None:', '            if func is None:', '                raise ValueError(\"No function or docstring given\")', \"            doc = inspect.getdoc(func) or ''\", '        NumpyDocString.__init__(self, doc, config)', '', \"        if not self['Signature'] and func is not None:\", '            func, func_name = self.get_func()', '            try:', '                try:', '                    signature = str(inspect.signature(func))', '                except (AttributeError, ValueError):', '                    # try to read signature, backward compat for older Python', '                    if sys.version_info[0] >= 3:', '                        argspec = inspect.getfullargspec(func)', '                    else:', '                        argspec = inspect.getargspec(func)', '                    signature = inspect.formatargspec(*argspec)', \"                signature = f'{func_name}{signature}'\", '            except TypeError:', \"                signature = f'{func_name}()'\", \"            self['Signature'] = signature\", '', '    def get_func(self):', \"        func_name = getattr(self._f, '__name__', self.__class__.__name__)\", '        if inspect.isclass(self._f):', \"            func = getattr(self._f, '__call__', self._f.__init__)\", '        else:', '            func = self._f', '        return func, func_name', '', '    def __str__(self):', \"        out = ''\", '', '        func, func_name = self.get_func()', '', \"        roles = {'func': 'function',\", \"                 'meth': 'method'}\", '', '        if self._role:', '            if self._role not in roles:', '                print(f\"Warning: invalid role {self._role}\")', '            out += f\".. {roles.get(self._role, \\'\\')}:: {func_name}\\\\n    \\\\n\\\\n\"', '', '        out += super().__str__(func_role=self._role)', '        return out', '', '', 'class ClassDoc(NumpyDocString):', '', \"    extra_public_methods = ['__call__']\", '', \"    def __init__(self, cls, doc=None, modulename='', func_doc=FunctionDoc,\", '                 config={}):', '        if not inspect.isclass(cls) and cls is not None:', '            raise ValueError(f\"Expected a class or None, but got {cls!r}\")', '        self._cls = cls', '', \"        if 'sphinx' in sys.modules:\", '            from sphinx.ext.autodoc import ALL', '        else:', '            ALL = object()', '', '        self.show_inherited_members = config.get(', \"                    'show_inherited_class_members', True)\", '', \"        if modulename and not modulename.endswith('.'):\", \"            modulename += '.'\", '        self._mod = modulename', '', '        if doc is None:', '            if cls is None:', '                raise ValueError(\"No class or documentation string given\")', '            doc = pydoc.getdoc(cls)', '', '        NumpyDocString.__init__(self, doc)', '', \"        _members = config.get('members', [])\", '        if _members is ALL:', '            _members = None', \"        _exclude = config.get('exclude-members', [])\", '', \"        if config.get('show_class_members', True) and _exclude is not ALL:\", '            def splitlines_x(s):', '                if not s:', '                    return []', '                else:', '                    return s.splitlines()', \"            for field, items in [('Methods', self.methods),\", \"                                 ('Attributes', self.properties)]:\", '                if not self[field]:', '                    doc_list = []', '                    for name in sorted(items):', '                        if (name in _exclude or', '                                (_members and name not in _members)):', '                            continue', '                        try:', '                            doc_item = pydoc.getdoc(getattr(self._cls, name))', '                            doc_list.append(', \"                                Parameter(name, '', splitlines_x(doc_item)))\", '                        except AttributeError:', \"                            pass  # method doesn't exist\", '                    self[field] = doc_list', '', '    @property', '    def methods(self):', '        if self._cls is None:', '            return []', '        return [name for name, func in inspect.getmembers(self._cls)', \"                if ((not name.startswith('_')\", '                     or name in self.extra_public_methods)', '                    and isinstance(func, Callable)', '                    and self._is_show_member(name))]', '', '    @property', '    def properties(self):', '        if self._cls is None:', '            return []', '        return [name for name, func in inspect.getmembers(self._cls)', \"                if (not name.startswith('_') and\", '                    (func is None or isinstance(func, property) or', '                     inspect.isdatadescriptor(func))', '                    and self._is_show_member(name))]', '', '    def _is_show_member(self, name):', '        if self.show_inherited_members:', '            return True  # show all class members', '        if name not in self._cls.__dict__:', '            return False  # class member is inherited, we do not show it', '        return True']}, 'version.py': {'classes': [{'name': 'InfinityType', 'start_line': 34, 'end_line': 60, 'text': ['class InfinityType:', '    def __repr__(self) -> str:', '        return \"Infinity\"', '', '    def __hash__(self) -> int:', '        return hash(repr(self))', '', '    def __lt__(self, other: object) -> bool:', '        return False', '', '    def __le__(self, other: object) -> bool:', '        return False', '', '    def __eq__(self, other: object) -> bool:', '        return isinstance(other, self.__class__)', '', '    def __ne__(self, other: object) -> bool:', '        return not isinstance(other, self.__class__)', '', '    def __gt__(self, other: object) -> bool:', '        return True', '', '    def __ge__(self, other: object) -> bool:', '        return True', '', '    def __neg__(self: object) -> \"NegativeInfinityType\":', '        return NegativeInfinity'], 'methods': [{'name': '__repr__', 'start_line': 35, 'end_line': 36, 'text': ['    def __repr__(self) -> str:', '        return \"Infinity\"']}, {'name': '__hash__', 'start_line': 38, 'end_line': 39, 'text': ['    def __hash__(self) -> int:', '        return hash(repr(self))']}, {'name': '__lt__', 'start_line': 41, 'end_line': 42, 'text': ['    def __lt__(self, other: object) -> bool:', '        return False']}, {'name': '__le__', 'start_line': 44, 'end_line': 45, 'text': ['    def __le__(self, other: object) -> bool:', '        return False']}, {'name': '__eq__', 'start_line': 47, 'end_line': 48, 'text': ['    def __eq__(self, other: object) -> bool:', '        return isinstance(other, self.__class__)']}, {'name': '__ne__', 'start_line': 50, 'end_line': 51, 'text': ['    def __ne__(self, other: object) -> bool:', '        return not isinstance(other, self.__class__)']}, {'name': '__gt__', 'start_line': 53, 'end_line': 54, 'text': ['    def __gt__(self, other: object) -> bool:', '        return True']}, {'name': '__ge__', 'start_line': 56, 'end_line': 57, 'text': ['    def __ge__(self, other: object) -> bool:', '        return True']}, {'name': '__neg__', 'start_line': 59, 'end_line': 60, 'text': ['    def __neg__(self: object) -> \"NegativeInfinityType\":', '        return NegativeInfinity']}]}, {'name': 'NegativeInfinityType', 'start_line': 66, 'end_line': 92, 'text': ['class NegativeInfinityType:', '    def __repr__(self) -> str:', '        return \"-Infinity\"', '', '    def __hash__(self) -> int:', '        return hash(repr(self))', '', '    def __lt__(self, other: object) -> bool:', '        return True', '', '    def __le__(self, other: object) -> bool:', '        return True', '', '    def __eq__(self, other: object) -> bool:', '        return isinstance(other, self.__class__)', '', '    def __ne__(self, other: object) -> bool:', '        return not isinstance(other, self.__class__)', '', '    def __gt__(self, other: object) -> bool:', '        return False', '', '    def __ge__(self, other: object) -> bool:', '        return False', '', '    def __neg__(self: object) -> InfinityType:', '        return Infinity'], 'methods': [{'name': '__repr__', 'start_line': 67, 'end_line': 68, 'text': ['    def __repr__(self) -> str:', '        return \"-Infinity\"']}, {'name': '__hash__', 'start_line': 70, 'end_line': 71, 'text': ['    def __hash__(self) -> int:', '        return hash(repr(self))']}, {'name': '__lt__', 'start_line': 73, 'end_line': 74, 'text': ['    def __lt__(self, other: object) -> bool:', '        return True']}, {'name': '__le__', 'start_line': 76, 'end_line': 77, 'text': ['    def __le__(self, other: object) -> bool:', '        return True']}, {'name': '__eq__', 'start_line': 79, 'end_line': 80, 'text': ['    def __eq__(self, other: object) -> bool:', '        return isinstance(other, self.__class__)']}, {'name': '__ne__', 'start_line': 82, 'end_line': 83, 'text': ['    def __ne__(self, other: object) -> bool:', '        return not isinstance(other, self.__class__)']}, {'name': '__gt__', 'start_line': 85, 'end_line': 86, 'text': ['    def __gt__(self, other: object) -> bool:', '        return False']}, {'name': '__ge__', 'start_line': 88, 'end_line': 89, 'text': ['    def __ge__(self, other: object) -> bool:', '        return False']}, {'name': '__neg__', 'start_line': 91, 'end_line': 92, 'text': ['    def __neg__(self: object) -> InfinityType:', '        return Infinity']}]}, {'name': 'InvalidVersion', 'start_line': 128, 'end_line': 131, 'text': ['class InvalidVersion(ValueError):', '    \"\"\"', '    An invalid version was found, users should refer to PEP 440.', '    \"\"\"'], 'methods': []}, {'name': '_BaseVersion', 'start_line': 134, 'end_line': 177, 'text': ['class _BaseVersion:', '    _key: Union[CmpKey, LegacyCmpKey]', '', '    def __hash__(self) -> int:', '        return hash(self._key)', '', '    # Please keep the duplicated `isinstance` check', '    # in the six comparisons hereunder', '    # unless you find a way to avoid adding overhead function calls.', '    def __lt__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key < other._key', '', '    def __le__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key <= other._key', '', '    def __eq__(self, other: object) -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key == other._key', '', '    def __ge__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key >= other._key', '', '    def __gt__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key > other._key', '', '    def __ne__(self, other: object) -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key != other._key'], 'methods': [{'name': '__hash__', 'start_line': 137, 'end_line': 138, 'text': ['    def __hash__(self) -> int:', '        return hash(self._key)']}, {'name': '__lt__', 'start_line': 143, 'end_line': 147, 'text': ['    def __lt__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key < other._key']}, {'name': '__le__', 'start_line': 149, 'end_line': 153, 'text': ['    def __le__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key <= other._key']}, {'name': '__eq__', 'start_line': 155, 'end_line': 159, 'text': ['    def __eq__(self, other: object) -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key == other._key']}, {'name': '__ge__', 'start_line': 161, 'end_line': 165, 'text': ['    def __ge__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key >= other._key']}, {'name': '__gt__', 'start_line': 167, 'end_line': 171, 'text': ['    def __gt__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key > other._key']}, {'name': '__ne__', 'start_line': 173, 'end_line': 177, 'text': ['    def __ne__(self, other: object) -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key != other._key']}]}, {'name': 'Version', 'start_line': 214, 'end_line': 347, 'text': ['class Version(_BaseVersion):', '', '    _regex = re.compile(r\"^\\\\s*\" + VERSION_PATTERN + r\"\\\\s*$\", re.VERBOSE | re.IGNORECASE)', '', '    def __init__(self, version: str) -> None:', '', '        # Validate the version and parse it into pieces', '        match = self._regex.search(version)', '        if not match:', '            raise InvalidVersion(f\"Invalid version: \\'{version}\\'\")', '', '        # Store the parsed out pieces of the version', '        self._version = _Version(', '            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,', '            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),', '            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),', '            post=_parse_letter_version(', '                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")', '            ),', '            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),', '            local=_parse_local_version(match.group(\"local\")),', '        )', '', '        # Generate a key which will be used for sorting', '        self._key = _cmpkey(', '            self._version.epoch,', '            self._version.release,', '            self._version.pre,', '            self._version.post,', '            self._version.dev,', '            self._version.local,', '        )', '', '    def __repr__(self) -> str:', '        return f\"<Version(\\'{self}\\')>\"', '', '    def __str__(self) -> str:', '        parts = []', '', '        # Epoch', '        if self.epoch != 0:', '            parts.append(f\"{self.epoch}!\")', '', '        # Release segment', '        parts.append(\".\".join(str(x) for x in self.release))', '', '        # Pre-release', '        if self.pre is not None:', '            parts.append(\"\".join(str(x) for x in self.pre))', '', '        # Post-release', '        if self.post is not None:', '            parts.append(f\".post{self.post}\")', '', '        # Development release', '        if self.dev is not None:', '            parts.append(f\".dev{self.dev}\")', '', '        # Local version segment', '        if self.local is not None:', '            parts.append(f\"+{self.local}\")', '', '        return \"\".join(parts)', '', '    @property', '    def epoch(self) -> int:', '        _epoch: int = self._version.epoch', '        return _epoch', '', '    @property', '    def release(self) -> Tuple[int, ...]:', '        _release: Tuple[int, ...] = self._version.release', '        return _release', '', '    @property', '    def pre(self) -> Optional[Tuple[str, int]]:', '        _pre: Optional[Tuple[str, int]] = self._version.pre', '        return _pre', '', '    @property', '    def post(self) -> Optional[int]:', '        return self._version.post[1] if self._version.post else None', '', '    @property', '    def dev(self) -> Optional[int]:', '        return self._version.dev[1] if self._version.dev else None', '', '    @property', '    def local(self) -> Optional[str]:', '        if self._version.local:', '            return \".\".join(str(x) for x in self._version.local)', '        else:', '            return None', '', '    @property', '    def public(self) -> str:', '        return str(self).split(\"+\", 1)[0]', '', '    @property', '    def base_version(self) -> str:', '        parts = []', '', '        # Epoch', '        if self.epoch != 0:', '            parts.append(f\"{self.epoch}!\")', '', '        # Release segment', '        parts.append(\".\".join(str(x) for x in self.release))', '', '        return \"\".join(parts)', '', '    @property', '    def is_prerelease(self) -> bool:', '        return self.dev is not None or self.pre is not None', '', '    @property', '    def is_postrelease(self) -> bool:', '        return self.post is not None', '', '    @property', '    def is_devrelease(self) -> bool:', '        return self.dev is not None', '', '    @property', '    def major(self) -> int:', '        return self.release[0] if len(self.release) >= 1 else 0', '', '    @property', '    def minor(self) -> int:', '        return self.release[1] if len(self.release) >= 2 else 0', '', '    @property', '    def micro(self) -> int:', '        return self.release[2] if len(self.release) >= 3 else 0'], 'methods': [{'name': '__init__', 'start_line': 218, 'end_line': 245, 'text': ['    def __init__(self, version: str) -> None:', '', '        # Validate the version and parse it into pieces', '        match = self._regex.search(version)', '        if not match:', '            raise InvalidVersion(f\"Invalid version: \\'{version}\\'\")', '', '        # Store the parsed out pieces of the version', '        self._version = _Version(', '            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,', '            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),', '            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),', '            post=_parse_letter_version(', '                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")', '            ),', '            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),', '            local=_parse_local_version(match.group(\"local\")),', '        )', '', '        # Generate a key which will be used for sorting', '        self._key = _cmpkey(', '            self._version.epoch,', '            self._version.release,', '            self._version.pre,', '            self._version.post,', '            self._version.dev,', '            self._version.local,', '        )']}, {'name': '__repr__', 'start_line': 247, 'end_line': 248, 'text': ['    def __repr__(self) -> str:', '        return f\"<Version(\\'{self}\\')>\"']}, {'name': '__str__', 'start_line': 250, 'end_line': 276, 'text': ['    def __str__(self) -> str:', '        parts = []', '', '        # Epoch', '        if self.epoch != 0:', '            parts.append(f\"{self.epoch}!\")', '', '        # Release segment', '        parts.append(\".\".join(str(x) for x in self.release))', '', '        # Pre-release', '        if self.pre is not None:', '            parts.append(\"\".join(str(x) for x in self.pre))', '', '        # Post-release', '        if self.post is not None:', '            parts.append(f\".post{self.post}\")', '', '        # Development release', '        if self.dev is not None:', '            parts.append(f\".dev{self.dev}\")', '', '        # Local version segment', '        if self.local is not None:', '            parts.append(f\"+{self.local}\")', '', '        return \"\".join(parts)']}, {'name': 'epoch', 'start_line': 279, 'end_line': 281, 'text': ['    def epoch(self) -> int:', '        _epoch: int = self._version.epoch', '        return _epoch']}, {'name': 'release', 'start_line': 284, 'end_line': 286, 'text': ['    def release(self) -> Tuple[int, ...]:', '        _release: Tuple[int, ...] = self._version.release', '        return _release']}, {'name': 'pre', 'start_line': 289, 'end_line': 291, 'text': ['    def pre(self) -> Optional[Tuple[str, int]]:', '        _pre: Optional[Tuple[str, int]] = self._version.pre', '        return _pre']}, {'name': 'post', 'start_line': 294, 'end_line': 295, 'text': ['    def post(self) -> Optional[int]:', '        return self._version.post[1] if self._version.post else None']}, {'name': 'dev', 'start_line': 298, 'end_line': 299, 'text': ['    def dev(self) -> Optional[int]:', '        return self._version.dev[1] if self._version.dev else None']}, {'name': 'local', 'start_line': 302, 'end_line': 306, 'text': ['    def local(self) -> Optional[str]:', '        if self._version.local:', '            return \".\".join(str(x) for x in self._version.local)', '        else:', '            return None']}, {'name': 'public', 'start_line': 309, 'end_line': 310, 'text': ['    def public(self) -> str:', '        return str(self).split(\"+\", 1)[0]']}, {'name': 'base_version', 'start_line': 313, 'end_line': 323, 'text': ['    def base_version(self) -> str:', '        parts = []', '', '        # Epoch', '        if self.epoch != 0:', '            parts.append(f\"{self.epoch}!\")', '', '        # Release segment', '        parts.append(\".\".join(str(x) for x in self.release))', '', '        return \"\".join(parts)']}, {'name': 'is_prerelease', 'start_line': 326, 'end_line': 327, 'text': ['    def is_prerelease(self) -> bool:', '        return self.dev is not None or self.pre is not None']}, {'name': 'is_postrelease', 'start_line': 330, 'end_line': 331, 'text': ['    def is_postrelease(self) -> bool:', '        return self.post is not None']}, {'name': 'is_devrelease', 'start_line': 334, 'end_line': 335, 'text': ['    def is_devrelease(self) -> bool:', '        return self.dev is not None']}, {'name': 'major', 'start_line': 338, 'end_line': 339, 'text': ['    def major(self) -> int:', '        return self.release[0] if len(self.release) >= 1 else 0']}, {'name': 'minor', 'start_line': 342, 'end_line': 343, 'text': ['    def minor(self) -> int:', '        return self.release[1] if len(self.release) >= 2 else 0']}, {'name': 'micro', 'start_line': 346, 'end_line': 347, 'text': ['    def micro(self) -> int:', '        return self.release[2] if len(self.release) >= 3 else 0']}]}], 'functions': [{'name': '_parse_letter_version', 'start_line': 350, 'end_line': 383, 'text': ['def _parse_letter_version(', '    letter: str, number: Union[str, bytes, SupportsInt]', ') -> Optional[Tuple[str, int]]:', '', '    if letter:', '        # We consider there to be an implicit 0 in a pre-release if there is', '        # not a numeral associated with it.', '        if number is None:', '            number = 0', '', '        # We normalize any letters to their lower case form', '        letter = letter.lower()', '', '        # We consider some words to be alternate spellings of other words and', '        # in those cases we want to normalize the spellings to our preferred', '        # spelling.', '        if letter == \"alpha\":', '            letter = \"a\"', '        elif letter == \"beta\":', '            letter = \"b\"', '        elif letter in [\"c\", \"pre\", \"preview\"]:', '            letter = \"rc\"', '        elif letter in [\"rev\", \"r\"]:', '            letter = \"post\"', '', '        return letter, int(number)', '    if not letter and number:', '        # We assume if we are given a number, but we are not given a letter', '        # then this is using the implicit post release syntax (e.g. 1.0-1)', '        letter = \"post\"', '', '        return letter, int(number)', '', '    return None']}, {'name': '_parse_local_version', 'start_line': 389, 'end_line': 398, 'text': ['def _parse_local_version(local: str) -> Optional[LocalType]:', '    \"\"\"', '    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").', '    \"\"\"', '    if local is not None:', '        return tuple(', '            part.lower() if not part.isdigit() else int(part)', '            for part in _local_version_separators.split(local)', '        )', '    return None']}, {'name': '_cmpkey', 'start_line': 401, 'end_line': 461, 'text': ['def _cmpkey(', '    epoch: int,', '    release: Tuple[int, ...],', '    pre: Optional[Tuple[str, int]],', '    post: Optional[Tuple[str, int]],', '    dev: Optional[Tuple[str, int]],', '    local: Optional[Tuple[SubLocalType]],', ') -> CmpKey:', '', '    # When we compare a release version, we want to compare it with all of the', \"    # trailing zeros removed. So we'll use a reverse the list, drop all the now\", '    # leading zeros until we come to something non zero, then take the rest', '    # re-reverse it back into the correct order and make it a tuple and use', '    # that for our sorting key.', '    _release = tuple(', '        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))', '    )', '', '    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.', \"    # We'll do this by abusing the pre segment, but we _only_ want to do this\", '    # if there is not a pre or a post segment. If we have one of those then', '    # the normal sorting rules will handle this case correctly.', '    if pre is None and post is None and dev is not None:', '        _pre: PrePostDevType = NegativeInfinity', '    # Versions without a pre-release (except as noted above) should sort after', '    # those with one.', '    elif pre is None:', '        _pre = Infinity', '    else:', '        _pre = pre', '', '    # Versions without a post segment should sort before those with one.', '    if post is None:', '        _post: PrePostDevType = NegativeInfinity', '', '    else:', '        _post = post', '', '    # Versions without a development segment should sort after those with one.', '    if dev is None:', '        _dev: PrePostDevType = Infinity', '', '    else:', '        _dev = dev', '', '    if local is None:', '        # Versions without a local segment should sort before those with one.', '        _local: LocalType = NegativeInfinity', '    else:', '        # Versions with a local segment need that segment parsed to implement', '        # the sorting rules in PEP440.', '        # - Alpha numeric segments sort before numeric segments', '        # - Alpha numeric segments sort lexicographically', '        # - Numeric segments sort numerically', '        # - Shorter versions sort before longer versions when the prefixes', '        #   match exactly', '        _local = tuple(', '            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local', '        )', '', '    return epoch, _release, _pre, _post, _dev, _local']}], 'text': ['\"\"\"Extract reference documentation from the pypa/packaging source tree.', '', 'In the process of copying, some unused methods / classes were removed.', 'These include:', '', '- parse()', '- anything involving LegacyVersion', '', 'This software is made available under the terms of *either* of the licenses', 'found in LICENSE.APACHE or LICENSE.BSD. Contributions to this software is made', 'under the terms of *both* these licenses.', '', 'Vendored from:', '- https://github.com/pypa/packaging/', '- commit ba07d8287b4554754ac7178d177033ea3f75d489 (09/09/2021)', '\"\"\"', '', '', '# This file is dual licensed under the terms of the Apache License, Version', '# 2.0, and the BSD License. See the LICENSE file in the root of this repository', '# for complete details.', '', '', 'import collections', 'import itertools', 'import re', 'from typing import Callable, Optional, SupportsInt, Tuple, Union', '', '__all__ = [\"Version\", \"InvalidVersion\", \"VERSION_PATTERN\"]', '', '', '# Vendored from https://github.com/pypa/packaging/blob/main/packaging/_structures.py', '', 'class InfinityType:', '    def __repr__(self) -> str:', '        return \"Infinity\"', '', '    def __hash__(self) -> int:', '        return hash(repr(self))', '', '    def __lt__(self, other: object) -> bool:', '        return False', '', '    def __le__(self, other: object) -> bool:', '        return False', '', '    def __eq__(self, other: object) -> bool:', '        return isinstance(other, self.__class__)', '', '    def __ne__(self, other: object) -> bool:', '        return not isinstance(other, self.__class__)', '', '    def __gt__(self, other: object) -> bool:', '        return True', '', '    def __ge__(self, other: object) -> bool:', '        return True', '', '    def __neg__(self: object) -> \"NegativeInfinityType\":', '        return NegativeInfinity', '', '', 'Infinity = InfinityType()', '', '', 'class NegativeInfinityType:', '    def __repr__(self) -> str:', '        return \"-Infinity\"', '', '    def __hash__(self) -> int:', '        return hash(repr(self))', '', '    def __lt__(self, other: object) -> bool:', '        return True', '', '    def __le__(self, other: object) -> bool:', '        return True', '', '    def __eq__(self, other: object) -> bool:', '        return isinstance(other, self.__class__)', '', '    def __ne__(self, other: object) -> bool:', '        return not isinstance(other, self.__class__)', '', '    def __gt__(self, other: object) -> bool:', '        return False', '', '    def __ge__(self, other: object) -> bool:', '        return False', '', '    def __neg__(self: object) -> InfinityType:', '        return Infinity', '', '', 'NegativeInfinity = NegativeInfinityType()', '', '', '# Vendored from https://github.com/pypa/packaging/blob/main/packaging/version.py', '', 'InfiniteTypes = Union[InfinityType, NegativeInfinityType]', 'PrePostDevType = Union[InfiniteTypes, Tuple[str, int]]', 'SubLocalType = Union[InfiniteTypes, int, str]', 'LocalType = Union[', '    NegativeInfinityType,', '    Tuple[', '        Union[', '            SubLocalType,', '            Tuple[SubLocalType, str],', '            Tuple[NegativeInfinityType, SubLocalType],', '        ],', '        ...,', '    ],', ']', 'CmpKey = Tuple[', '    int, Tuple[int, ...], PrePostDevType, PrePostDevType, PrePostDevType, LocalType', ']', 'LegacyCmpKey = Tuple[int, Tuple[str, ...]]', 'VersionComparisonMethod = Callable[', '    [Union[CmpKey, LegacyCmpKey], Union[CmpKey, LegacyCmpKey]], bool', ']', '', '_Version = collections.namedtuple(', '    \"_Version\", [\"epoch\", \"release\", \"dev\", \"pre\", \"post\", \"local\"]', ')', '', '', '', 'class InvalidVersion(ValueError):', '    \"\"\"', '    An invalid version was found, users should refer to PEP 440.', '    \"\"\"', '', '', 'class _BaseVersion:', '    _key: Union[CmpKey, LegacyCmpKey]', '', '    def __hash__(self) -> int:', '        return hash(self._key)', '', '    # Please keep the duplicated `isinstance` check', '    # in the six comparisons hereunder', '    # unless you find a way to avoid adding overhead function calls.', '    def __lt__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key < other._key', '', '    def __le__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key <= other._key', '', '    def __eq__(self, other: object) -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key == other._key', '', '    def __ge__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key >= other._key', '', '    def __gt__(self, other: \"_BaseVersion\") -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key > other._key', '', '    def __ne__(self, other: object) -> bool:', '        if not isinstance(other, _BaseVersion):', '            return NotImplemented', '', '        return self._key != other._key', '', '', '# Deliberately not anchored to the start and end of the string, to make it', '# easier for 3rd party code to reuse', 'VERSION_PATTERN = r\"\"\"', '    v?', '    (?:', '        (?:(?P<epoch>[0-9]+)!)?                           # epoch', '        (?P<release>[0-9]+(?:\\\\.[0-9]+)*)                  # release segment', '        (?P<pre>                                          # pre-release', '            [-_\\\\.]?', '            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))', '            [-_\\\\.]?', '            (?P<pre_n>[0-9]+)?', '        )?', '        (?P<post>                                         # post release', '            (?:-(?P<post_n1>[0-9]+))', '            |', '            (?:', '                [-_\\\\.]?', '                (?P<post_l>post|rev|r)', '                [-_\\\\.]?', '                (?P<post_n2>[0-9]+)?', '            )', '        )?', '        (?P<dev>                                          # dev release', '            [-_\\\\.]?', '            (?P<dev_l>dev)', '            [-_\\\\.]?', '            (?P<dev_n>[0-9]+)?', '        )?', '    )', '    (?:\\\\+(?P<local>[a-z0-9]+(?:[-_\\\\.][a-z0-9]+)*))?       # local version', '\"\"\"', '', '', 'class Version(_BaseVersion):', '', '    _regex = re.compile(r\"^\\\\s*\" + VERSION_PATTERN + r\"\\\\s*$\", re.VERBOSE | re.IGNORECASE)', '', '    def __init__(self, version: str) -> None:', '', '        # Validate the version and parse it into pieces', '        match = self._regex.search(version)', '        if not match:', '            raise InvalidVersion(f\"Invalid version: \\'{version}\\'\")', '', '        # Store the parsed out pieces of the version', '        self._version = _Version(', '            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,', '            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),', '            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),', '            post=_parse_letter_version(', '                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")', '            ),', '            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),', '            local=_parse_local_version(match.group(\"local\")),', '        )', '', '        # Generate a key which will be used for sorting', '        self._key = _cmpkey(', '            self._version.epoch,', '            self._version.release,', '            self._version.pre,', '            self._version.post,', '            self._version.dev,', '            self._version.local,', '        )', '', '    def __repr__(self) -> str:', '        return f\"<Version(\\'{self}\\')>\"', '', '    def __str__(self) -> str:', '        parts = []', '', '        # Epoch', '        if self.epoch != 0:', '            parts.append(f\"{self.epoch}!\")', '', '        # Release segment', '        parts.append(\".\".join(str(x) for x in self.release))', '', '        # Pre-release', '        if self.pre is not None:', '            parts.append(\"\".join(str(x) for x in self.pre))', '', '        # Post-release', '        if self.post is not None:', '            parts.append(f\".post{self.post}\")', '', '        # Development release', '        if self.dev is not None:', '            parts.append(f\".dev{self.dev}\")', '', '        # Local version segment', '        if self.local is not None:', '            parts.append(f\"+{self.local}\")', '', '        return \"\".join(parts)', '', '    @property', '    def epoch(self) -> int:', '        _epoch: int = self._version.epoch', '        return _epoch', '', '    @property', '    def release(self) -> Tuple[int, ...]:', '        _release: Tuple[int, ...] = self._version.release', '        return _release', '', '    @property', '    def pre(self) -> Optional[Tuple[str, int]]:', '        _pre: Optional[Tuple[str, int]] = self._version.pre', '        return _pre', '', '    @property', '    def post(self) -> Optional[int]:', '        return self._version.post[1] if self._version.post else None', '', '    @property', '    def dev(self) -> Optional[int]:', '        return self._version.dev[1] if self._version.dev else None', '', '    @property', '    def local(self) -> Optional[str]:', '        if self._version.local:', '            return \".\".join(str(x) for x in self._version.local)', '        else:', '            return None', '', '    @property', '    def public(self) -> str:', '        return str(self).split(\"+\", 1)[0]', '', '    @property', '    def base_version(self) -> str:', '        parts = []', '', '        # Epoch', '        if self.epoch != 0:', '            parts.append(f\"{self.epoch}!\")', '', '        # Release segment', '        parts.append(\".\".join(str(x) for x in self.release))', '', '        return \"\".join(parts)', '', '    @property', '    def is_prerelease(self) -> bool:', '        return self.dev is not None or self.pre is not None', '', '    @property', '    def is_postrelease(self) -> bool:', '        return self.post is not None', '', '    @property', '    def is_devrelease(self) -> bool:', '        return self.dev is not None', '', '    @property', '    def major(self) -> int:', '        return self.release[0] if len(self.release) >= 1 else 0', '', '    @property', '    def minor(self) -> int:', '        return self.release[1] if len(self.release) >= 2 else 0', '', '    @property', '    def micro(self) -> int:', '        return self.release[2] if len(self.release) >= 3 else 0', '', '', 'def _parse_letter_version(', '    letter: str, number: Union[str, bytes, SupportsInt]', ') -> Optional[Tuple[str, int]]:', '', '    if letter:', '        # We consider there to be an implicit 0 in a pre-release if there is', '        # not a numeral associated with it.', '        if number is None:', '            number = 0', '', '        # We normalize any letters to their lower case form', '        letter = letter.lower()', '', '        # We consider some words to be alternate spellings of other words and', '        # in those cases we want to normalize the spellings to our preferred', '        # spelling.', '        if letter == \"alpha\":', '            letter = \"a\"', '        elif letter == \"beta\":', '            letter = \"b\"', '        elif letter in [\"c\", \"pre\", \"preview\"]:', '            letter = \"rc\"', '        elif letter in [\"rev\", \"r\"]:', '            letter = \"post\"', '', '        return letter, int(number)', '    if not letter and number:', '        # We assume if we are given a number, but we are not given a letter', '        # then this is using the implicit post release syntax (e.g. 1.0-1)', '        letter = \"post\"', '', '        return letter, int(number)', '', '    return None', '', '', '_local_version_separators = re.compile(r\"[\\\\._-]\")', '', '', 'def _parse_local_version(local: str) -> Optional[LocalType]:', '    \"\"\"', '    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").', '    \"\"\"', '    if local is not None:', '        return tuple(', '            part.lower() if not part.isdigit() else int(part)', '            for part in _local_version_separators.split(local)', '        )', '    return None', '', '', 'def _cmpkey(', '    epoch: int,', '    release: Tuple[int, ...],', '    pre: Optional[Tuple[str, int]],', '    post: Optional[Tuple[str, int]],', '    dev: Optional[Tuple[str, int]],', '    local: Optional[Tuple[SubLocalType]],', ') -> CmpKey:', '', '    # When we compare a release version, we want to compare it with all of the', \"    # trailing zeros removed. So we'll use a reverse the list, drop all the now\", '    # leading zeros until we come to something non zero, then take the rest', '    # re-reverse it back into the correct order and make it a tuple and use', '    # that for our sorting key.', '    _release = tuple(', '        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))', '    )', '', '    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.', \"    # We'll do this by abusing the pre segment, but we _only_ want to do this\", '    # if there is not a pre or a post segment. If we have one of those then', '    # the normal sorting rules will handle this case correctly.', '    if pre is None and post is None and dev is not None:', '        _pre: PrePostDevType = NegativeInfinity', '    # Versions without a pre-release (except as noted above) should sort after', '    # those with one.', '    elif pre is None:', '        _pre = Infinity', '    else:', '        _pre = pre', '', '    # Versions without a post segment should sort before those with one.', '    if post is None:', '        _post: PrePostDevType = NegativeInfinity', '', '    else:', '        _post = post', '', '    # Versions without a development segment should sort after those with one.', '    if dev is None:', '        _dev: PrePostDevType = Infinity', '', '    else:', '        _dev = dev', '', '    if local is None:', '        # Versions without a local segment should sort before those with one.', '        _local: LocalType = NegativeInfinity', '    else:', '        # Versions with a local segment need that segment parsed to implement', '        # the sorting rules in PEP440.', '        # - Alpha numeric segments sort before numeric segments', '        # - Alpha numeric segments sort lexicographically', '        # - Numeric segments sort numerically', '        # - Shorter versions sort before longer versions when the prefixes', '        #   match exactly', '        _local = tuple(', '            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local', '        )', '', '    return epoch, _release, _pre, _post, _dev, _local']}, '__init__.py': {'classes': [], 'functions': [], 'text': []}, 'kde.py': {'classes': [{'name': 'gaussian_kde', 'start_line': 82, 'end_line': 381, 'text': ['class gaussian_kde:', '    \"\"\"Representation of a kernel-density estimate using Gaussian kernels.', '', '    Kernel density estimation is a way to estimate the probability density', '    function (PDF) of a random variable in a non-parametric way.', '    `gaussian_kde` works for both uni-variate and multi-variate data.   It', '    includes automatic bandwidth determination.  The estimation works best for', '    a unimodal distribution; bimodal or multi-modal distributions tend to be', '    oversmoothed.', '', '    Parameters', '    ----------', '    dataset : array_like', '        Datapoints to estimate from. In case of univariate data this is a 1-D', '        array, otherwise a 2-D array with shape (# of dims, # of data).', '    bw_method : str, scalar or callable, optional', '        The method used to calculate the estimator bandwidth.  This can be', \"        'scott', 'silverman', a scalar constant or a callable.  If a scalar,\", '        this will be used directly as `kde.factor`.  If a callable, it should', '        take a `gaussian_kde` instance as only parameter and return a scalar.', \"        If None (default), 'scott' is used.  See Notes for more details.\", '    weights : array_like, optional', '        weights of datapoints. This must be the same shape as dataset.', '        If None (default), the samples are assumed to be equally weighted', '', '    Attributes', '    ----------', '    dataset : ndarray', '        The dataset with which `gaussian_kde` was initialized.', '    d : int', '        Number of dimensions.', '    n : int', '        Number of datapoints.', '    neff : int', '        Effective number of datapoints.', '', '        .. versionadded:: 1.2.0', '    factor : float', '        The bandwidth factor, obtained from `kde.covariance_factor`, with which', '        the covariance matrix is multiplied.', '    covariance : ndarray', '        The covariance matrix of `dataset`, scaled by the calculated bandwidth', '        (`kde.factor`).', '    inv_cov : ndarray', '        The inverse of `covariance`.', '', '    Methods', '    -------', '    evaluate', '    __call__', '    integrate_gaussian', '    integrate_box_1d', '    integrate_box', '    integrate_kde', '    pdf', '    logpdf', '    resample', '    set_bandwidth', '    covariance_factor', '', '    Notes', '    -----', '    Bandwidth selection strongly influences the estimate obtained from the KDE', '    (much more so than the actual shape of the kernel).  Bandwidth selection', '    can be done by a \"rule of thumb\", by cross-validation, by \"plug-in', '    methods\" or by other means; see [3]_, [4]_ for reviews.  `gaussian_kde`', \"    uses a rule of thumb, the default is Scott's Rule.\", '', \"    Scott's Rule [1]_, implemented as `scotts_factor`, is::\", '', '        n**(-1./(d+4)),', '', '    with ``n`` the number of data points and ``d`` the number of dimensions.', '    In the case of unequally weighted points, `scotts_factor` becomes::', '', '        neff**(-1./(d+4)),', '', '    with ``neff`` the effective number of datapoints.', \"    Silverman's Rule [2]_, implemented as `silverman_factor`, is::\", '', '        (n * (d + 2) / 4.)**(-1. / (d + 4)).', '', '    or in the case of unequally weighted points::', '', '        (neff * (d + 2) / 4.)**(-1. / (d + 4)).', '', '    Good general descriptions of kernel density estimation can be found in [1]_', '    and [2]_, the mathematics for this multi-dimensional implementation can be', '    found in [1]_.', '', '    With a set of weighted samples, the effective number of datapoints ``neff``', '    is defined by::', '', '        neff = sum(weights)^2 / sum(weights^2)', '', '    as detailed in [5]_.', '', '    References', '    ----------', '    .. [1] D.W. Scott, \"Multivariate Density Estimation: Theory, Practice, and', '           Visualization\", John Wiley & Sons, New York, Chicester, 1992.', '    .. [2] B.W. Silverman, \"Density Estimation for Statistics and Data', '           Analysis\", Vol. 26, Monographs on Statistics and Applied Probability,', '           Chapman and Hall, London, 1986.', '    .. [3] B.A. Turlach, \"Bandwidth Selection in Kernel Density Estimation: A', '           Review\", CORE and Institut de Statistique, Vol. 19, pp. 1-33, 1993.', '    .. [4] D.M. Bashtannyk and R.J. Hyndman, \"Bandwidth selection for kernel', '           conditional density estimation\", Computational Statistics & Data', '           Analysis, Vol. 36, pp. 279-298, 2001.', '    .. [5] Gray P. G., 1969, Journal of the Royal Statistical Society.', '           Series A (General), 132, 272', '', '    \"\"\"', '    def __init__(self, dataset, bw_method=None, weights=None):', '        self.dataset = atleast_2d(asarray(dataset))', '        if not self.dataset.size > 1:', '            raise ValueError(\"`dataset` input should have multiple elements.\")', '', '        self.d, self.n = self.dataset.shape', '', '        if weights is not None:', '            self._weights = atleast_1d(weights).astype(float)', '            self._weights /= sum(self._weights)', '            if self.weights.ndim != 1:', '                raise ValueError(\"`weights` input should be one-dimensional.\")', '            if len(self._weights) != self.n:', '                raise ValueError(\"`weights` input should be of length n\")', '            self._neff = 1/sum(self._weights**2)', '', '        self.set_bandwidth(bw_method=bw_method)', '', '    def evaluate(self, points):', '        \"\"\"Evaluate the estimated pdf on a set of points.', '', '        Parameters', '        ----------', '        points : (# of dimensions, # of points)-array', '            Alternatively, a (# of dimensions,) vector can be passed in and', '            treated as a single point.', '', '        Returns', '        -------', '        values : (# of points,)-array', '            The values at each point.', '', '        Raises', '        ------', '        ValueError : if the dimensionality of the input points is different than', '                     the dimensionality of the KDE.', '', '        \"\"\"', '        points = atleast_2d(asarray(points))', '', '        d, m = points.shape', '        if d != self.d:', '            if d == 1 and m == self.d:', '                # points was passed in as a row vector', '                points = reshape(points, (self.d, 1))', '                m = 1', '            else:', '                msg = f\"points have dimension {d}, dataset has dimension {self.d}\"', '                raise ValueError(msg)', '', '        output_dtype = np.common_type(self.covariance, points)', '        result = zeros((m,), dtype=output_dtype)', '', '        whitening = linalg.cholesky(self.inv_cov)', '        scaled_dataset = dot(whitening, self.dataset)', '        scaled_points = dot(whitening, points)', '', '        if m >= self.n:', '            # there are more points than data, so loop over data', '            for i in range(self.n):', '                diff = scaled_dataset[:, i, newaxis] - scaled_points', '                energy = sum(diff * diff, axis=0) / 2.0', '                result += self.weights[i]*exp(-energy)', '        else:', '            # loop over points', '            for i in range(m):', '                diff = scaled_dataset - scaled_points[:, i, newaxis]', '                energy = sum(diff * diff, axis=0) / 2.0', '                result[i] = sum(exp(-energy)*self.weights, axis=0)', '', '        result = result / self._norm_factor', '', '        return result', '', '    __call__ = evaluate', '', '    def scotts_factor(self):', '        \"\"\"Compute Scott\\'s factor.', '', '        Returns', '        -------', '        s : float', \"            Scott's factor.\", '        \"\"\"', '        return power(self.neff, -1./(self.d+4))', '', '    def silverman_factor(self):', '        \"\"\"Compute the Silverman factor.', '', '        Returns', '        -------', '        s : float', '            The silverman factor.', '        \"\"\"', '        return power(self.neff*(self.d+2.0)/4.0, -1./(self.d+4))', '', '    #  Default method to calculate bandwidth, can be overwritten by subclass', '    covariance_factor = scotts_factor', '    covariance_factor.__doc__ = \"\"\"Computes the coefficient (`kde.factor`) that', '        multiplies the data covariance matrix to obtain the kernel covariance', '        matrix. The default is `scotts_factor`.  A subclass can overwrite this', '        method to provide a different method, or set it through a call to', '        `kde.set_bandwidth`.\"\"\"', '', '    def set_bandwidth(self, bw_method=None):', '        \"\"\"Compute the estimator bandwidth with given method.', '', '        The new bandwidth calculated after a call to `set_bandwidth` is used', '        for subsequent evaluations of the estimated density.', '', '        Parameters', '        ----------', '        bw_method : str, scalar or callable, optional', '            The method used to calculate the estimator bandwidth.  This can be', \"            'scott', 'silverman', a scalar constant or a callable.  If a\", '            scalar, this will be used directly as `kde.factor`.  If a callable,', '            it should take a `gaussian_kde` instance as only parameter and', '            return a scalar.  If None (default), nothing happens; the current', '            `kde.covariance_factor` method is kept.', '', '        Notes', '        -----', '        .. versionadded:: 0.11', '', '        \"\"\"', '        if bw_method is None:', '            pass', \"        elif bw_method == 'scott':\", '            self.covariance_factor = self.scotts_factor', \"        elif bw_method == 'silverman':\", '            self.covariance_factor = self.silverman_factor', '        elif np.isscalar(bw_method) and not isinstance(bw_method, str):', \"            self._bw_method = 'use constant'\", '            self.covariance_factor = lambda: bw_method', '        elif callable(bw_method):', '            self._bw_method = bw_method', '            self.covariance_factor = lambda: self._bw_method(self)', '        else:', '            msg = \"`bw_method` should be \\'scott\\', \\'silverman\\', a scalar \" \\\\', '                  \"or a callable.\"', '            raise ValueError(msg)', '', '        self._compute_covariance()', '', '    def _compute_covariance(self):', '        \"\"\"Computes the covariance matrix for each Gaussian kernel using', '        covariance_factor().', '        \"\"\"', '        self.factor = self.covariance_factor()', '        # Cache covariance and inverse covariance of the data', \"        if not hasattr(self, '_data_inv_cov'):\", '            self._data_covariance = atleast_2d(cov(self.dataset, rowvar=1,', '                                               bias=False,', '                                               aweights=self.weights))', '            self._data_inv_cov = linalg.inv(self._data_covariance)', '', '        self.covariance = self._data_covariance * self.factor**2', '        self.inv_cov = self._data_inv_cov / self.factor**2', '        self._norm_factor = sqrt(linalg.det(2*pi*self.covariance))', '', '    def pdf(self, x):', '        \"\"\"', '        Evaluate the estimated pdf on a provided set of points.', '', '        Notes', '        -----', '        This is an alias for `gaussian_kde.evaluate`.  See the ``evaluate``', '        docstring for more details.', '', '        \"\"\"', '        return self.evaluate(x)', '', '    @property', '    def weights(self):', '        try:', '            return self._weights', '        except AttributeError:', '            self._weights = ones(self.n)/self.n', '            return self._weights', '', '    @property', '    def neff(self):', '        try:', '            return self._neff', '        except AttributeError:', '            self._neff = 1/sum(self.weights**2)', '            return self._neff'], 'methods': [{'name': '__init__', 'start_line': 195, 'end_line': 211, 'text': ['    def __init__(self, dataset, bw_method=None, weights=None):', '        self.dataset = atleast_2d(asarray(dataset))', '        if not self.dataset.size > 1:', '            raise ValueError(\"`dataset` input should have multiple elements.\")', '', '        self.d, self.n = self.dataset.shape', '', '        if weights is not None:', '            self._weights = atleast_1d(weights).astype(float)', '            self._weights /= sum(self._weights)', '            if self.weights.ndim != 1:', '                raise ValueError(\"`weights` input should be one-dimensional.\")', '            if len(self._weights) != self.n:', '                raise ValueError(\"`weights` input should be of length n\")', '            self._neff = 1/sum(self._weights**2)', '', '        self.set_bandwidth(bw_method=bw_method)']}, {'name': 'evaluate', 'start_line': 213, 'end_line': 267, 'text': ['    def evaluate(self, points):', '        \"\"\"Evaluate the estimated pdf on a set of points.', '', '        Parameters', '        ----------', '        points : (# of dimensions, # of points)-array', '            Alternatively, a (# of dimensions,) vector can be passed in and', '            treated as a single point.', '', '        Returns', '        -------', '        values : (# of points,)-array', '            The values at each point.', '', '        Raises', '        ------', '        ValueError : if the dimensionality of the input points is different than', '                     the dimensionality of the KDE.', '', '        \"\"\"', '        points = atleast_2d(asarray(points))', '', '        d, m = points.shape', '        if d != self.d:', '            if d == 1 and m == self.d:', '                # points was passed in as a row vector', '                points = reshape(points, (self.d, 1))', '                m = 1', '            else:', '                msg = f\"points have dimension {d}, dataset has dimension {self.d}\"', '                raise ValueError(msg)', '', '        output_dtype = np.common_type(self.covariance, points)', '        result = zeros((m,), dtype=output_dtype)', '', '        whitening = linalg.cholesky(self.inv_cov)', '        scaled_dataset = dot(whitening, self.dataset)', '        scaled_points = dot(whitening, points)', '', '        if m >= self.n:', '            # there are more points than data, so loop over data', '            for i in range(self.n):', '                diff = scaled_dataset[:, i, newaxis] - scaled_points', '                energy = sum(diff * diff, axis=0) / 2.0', '                result += self.weights[i]*exp(-energy)', '        else:', '            # loop over points', '            for i in range(m):', '                diff = scaled_dataset - scaled_points[:, i, newaxis]', '                energy = sum(diff * diff, axis=0) / 2.0', '                result[i] = sum(exp(-energy)*self.weights, axis=0)', '', '        result = result / self._norm_factor', '', '        return result']}, {'name': 'scotts_factor', 'start_line': 271, 'end_line': 279, 'text': ['    def scotts_factor(self):', '        \"\"\"Compute Scott\\'s factor.', '', '        Returns', '        -------', '        s : float', \"            Scott's factor.\", '        \"\"\"', '        return power(self.neff, -1./(self.d+4))']}, {'name': 'silverman_factor', 'start_line': 281, 'end_line': 289, 'text': ['    def silverman_factor(self):', '        \"\"\"Compute the Silverman factor.', '', '        Returns', '        -------', '        s : float', '            The silverman factor.', '        \"\"\"', '        return power(self.neff*(self.d+2.0)/4.0, -1./(self.d+4))']}, {'name': 'set_bandwidth', 'start_line': 299, 'end_line': 337, 'text': ['    def set_bandwidth(self, bw_method=None):', '        \"\"\"Compute the estimator bandwidth with given method.', '', '        The new bandwidth calculated after a call to `set_bandwidth` is used', '        for subsequent evaluations of the estimated density.', '', '        Parameters', '        ----------', '        bw_method : str, scalar or callable, optional', '            The method used to calculate the estimator bandwidth.  This can be', \"            'scott', 'silverman', a scalar constant or a callable.  If a\", '            scalar, this will be used directly as `kde.factor`.  If a callable,', '            it should take a `gaussian_kde` instance as only parameter and', '            return a scalar.  If None (default), nothing happens; the current', '            `kde.covariance_factor` method is kept.', '', '        Notes', '        -----', '        .. versionadded:: 0.11', '', '        \"\"\"', '        if bw_method is None:', '            pass', \"        elif bw_method == 'scott':\", '            self.covariance_factor = self.scotts_factor', \"        elif bw_method == 'silverman':\", '            self.covariance_factor = self.silverman_factor', '        elif np.isscalar(bw_method) and not isinstance(bw_method, str):', \"            self._bw_method = 'use constant'\", '            self.covariance_factor = lambda: bw_method', '        elif callable(bw_method):', '            self._bw_method = bw_method', '            self.covariance_factor = lambda: self._bw_method(self)', '        else:', '            msg = \"`bw_method` should be \\'scott\\', \\'silverman\\', a scalar \" \\\\', '                  \"or a callable.\"', '            raise ValueError(msg)', '', '        self._compute_covariance()']}, {'name': '_compute_covariance', 'start_line': 339, 'end_line': 353, 'text': ['    def _compute_covariance(self):', '        \"\"\"Computes the covariance matrix for each Gaussian kernel using', '        covariance_factor().', '        \"\"\"', '        self.factor = self.covariance_factor()', '        # Cache covariance and inverse covariance of the data', \"        if not hasattr(self, '_data_inv_cov'):\", '            self._data_covariance = atleast_2d(cov(self.dataset, rowvar=1,', '                                               bias=False,', '                                               aweights=self.weights))', '            self._data_inv_cov = linalg.inv(self._data_covariance)', '', '        self.covariance = self._data_covariance * self.factor**2', '        self.inv_cov = self._data_inv_cov / self.factor**2', '        self._norm_factor = sqrt(linalg.det(2*pi*self.covariance))']}, {'name': 'pdf', 'start_line': 355, 'end_line': 365, 'text': ['    def pdf(self, x):', '        \"\"\"', '        Evaluate the estimated pdf on a provided set of points.', '', '        Notes', '        -----', '        This is an alias for `gaussian_kde.evaluate`.  See the ``evaluate``', '        docstring for more details.', '', '        \"\"\"', '        return self.evaluate(x)']}, {'name': 'weights', 'start_line': 368, 'end_line': 373, 'text': ['    def weights(self):', '        try:', '            return self._weights', '        except AttributeError:', '            self._weights = ones(self.n)/self.n', '            return self._weights']}, {'name': 'neff', 'start_line': 376, 'end_line': 381, 'text': ['    def neff(self):', '        try:', '            return self._neff', '        except AttributeError:', '            self._neff = 1/sum(self.weights**2)', '            return self._neff']}]}], 'functions': [], 'text': ['\"\"\"', 'This module was copied from the scipy project.', '', 'In the process of copying, some methods were removed because they depended on', 'other parts of scipy (especially on compiled components), allowing seaborn to', 'have a simple and pure Python implementation. These include:', '', '- integrate_gaussian', '- integrate_box', '- integrate_box_1d', '- integrate_kde', '- logpdf', '- resample', '', 'Additionally, the numpy.linalg module was substituted for scipy.linalg,', 'and the examples section (with doctests) was removed from the docstring', '', 'The original scipy license is copied below:', '', 'Copyright (c) 2001-2002 Enthought, Inc.  2003-2019, SciPy Developers.', 'All rights reserved.', '', 'Redistribution and use in source and binary forms, with or without', 'modification, are permitted provided that the following conditions', 'are met:', '', '1. Redistributions of source code must retain the above copyright', '   notice, this list of conditions and the following disclaimer.', '', '2. Redistributions in binary form must reproduce the above', '   copyright notice, this list of conditions and the following', '   disclaimer in the documentation and/or other materials provided', '   with the distribution.', '', '3. Neither the name of the copyright holder nor the names of its', '   contributors may be used to endorse or promote products derived', '   from this software without specific prior written permission.', '', 'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS', '\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT', 'LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR', 'A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT', 'OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,', 'SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT', 'LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,', 'DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY', 'THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT', '(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE', 'OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.', '', '\"\"\"', '', '# -------------------------------------------------------------------------------', '#', '#  Define classes for (uni/multi)-variate kernel density estimation.', '#', '#  Currently, only Gaussian kernels are implemented.', '#', '#  Written by: Robert Kern', '#', '#  Date: 2004-08-09', '#', '#  Modified: 2005-02-10 by Robert Kern.', '#              Contributed to SciPy', '#            2005-10-07 by Robert Kern.', '#              Some fixes to match the new scipy_core', '#', '#  Copyright 2004-2005 by Enthought, Inc.', '#', '# -------------------------------------------------------------------------------', '', 'import numpy as np', 'from numpy import (asarray, atleast_2d, reshape, zeros, newaxis, dot, exp, pi,', '                   sqrt, ravel, power, atleast_1d, squeeze, sum, transpose,', '                   ones, cov)', 'from numpy import linalg', '', '', \"__all__ = ['gaussian_kde']\", '', '', 'class gaussian_kde:', '    \"\"\"Representation of a kernel-density estimate using Gaussian kernels.', '', '    Kernel density estimation is a way to estimate the probability density', '    function (PDF) of a random variable in a non-parametric way.', '    `gaussian_kde` works for both uni-variate and multi-variate data.   It', '    includes automatic bandwidth determination.  The estimation works best for', '    a unimodal distribution; bimodal or multi-modal distributions tend to be', '    oversmoothed.', '', '    Parameters', '    ----------', '    dataset : array_like', '        Datapoints to estimate from. In case of univariate data this is a 1-D', '        array, otherwise a 2-D array with shape (# of dims, # of data).', '    bw_method : str, scalar or callable, optional', '        The method used to calculate the estimator bandwidth.  This can be', \"        'scott', 'silverman', a scalar constant or a callable.  If a scalar,\", '        this will be used directly as `kde.factor`.  If a callable, it should', '        take a `gaussian_kde` instance as only parameter and return a scalar.', \"        If None (default), 'scott' is used.  See Notes for more details.\", '    weights : array_like, optional', '        weights of datapoints. This must be the same shape as dataset.', '        If None (default), the samples are assumed to be equally weighted', '', '    Attributes', '    ----------', '    dataset : ndarray', '        The dataset with which `gaussian_kde` was initialized.', '    d : int', '        Number of dimensions.', '    n : int', '        Number of datapoints.', '    neff : int', '        Effective number of datapoints.', '', '        .. versionadded:: 1.2.0', '    factor : float', '        The bandwidth factor, obtained from `kde.covariance_factor`, with which', '        the covariance matrix is multiplied.', '    covariance : ndarray', '        The covariance matrix of `dataset`, scaled by the calculated bandwidth', '        (`kde.factor`).', '    inv_cov : ndarray', '        The inverse of `covariance`.', '', '    Methods', '    -------', '    evaluate', '    __call__', '    integrate_gaussian', '    integrate_box_1d', '    integrate_box', '    integrate_kde', '    pdf', '    logpdf', '    resample', '    set_bandwidth', '    covariance_factor', '', '    Notes', '    -----', '    Bandwidth selection strongly influences the estimate obtained from the KDE', '    (much more so than the actual shape of the kernel).  Bandwidth selection', '    can be done by a \"rule of thumb\", by cross-validation, by \"plug-in', '    methods\" or by other means; see [3]_, [4]_ for reviews.  `gaussian_kde`', \"    uses a rule of thumb, the default is Scott's Rule.\", '', \"    Scott's Rule [1]_, implemented as `scotts_factor`, is::\", '', '        n**(-1./(d+4)),', '', '    with ``n`` the number of data points and ``d`` the number of dimensions.', '    In the case of unequally weighted points, `scotts_factor` becomes::', '', '        neff**(-1./(d+4)),', '', '    with ``neff`` the effective number of datapoints.', \"    Silverman's Rule [2]_, implemented as `silverman_factor`, is::\", '', '        (n * (d + 2) / 4.)**(-1. / (d + 4)).', '', '    or in the case of unequally weighted points::', '', '        (neff * (d + 2) / 4.)**(-1. / (d + 4)).', '', '    Good general descriptions of kernel density estimation can be found in [1]_', '    and [2]_, the mathematics for this multi-dimensional implementation can be', '    found in [1]_.', '', '    With a set of weighted samples, the effective number of datapoints ``neff``', '    is defined by::', '', '        neff = sum(weights)^2 / sum(weights^2)', '', '    as detailed in [5]_.', '', '    References', '    ----------', '    .. [1] D.W. Scott, \"Multivariate Density Estimation: Theory, Practice, and', '           Visualization\", John Wiley & Sons, New York, Chicester, 1992.', '    .. [2] B.W. Silverman, \"Density Estimation for Statistics and Data', '           Analysis\", Vol. 26, Monographs on Statistics and Applied Probability,', '           Chapman and Hall, London, 1986.', '    .. [3] B.A. Turlach, \"Bandwidth Selection in Kernel Density Estimation: A', '           Review\", CORE and Institut de Statistique, Vol. 19, pp. 1-33, 1993.', '    .. [4] D.M. Bashtannyk and R.J. Hyndman, \"Bandwidth selection for kernel', '           conditional density estimation\", Computational Statistics & Data', '           Analysis, Vol. 36, pp. 279-298, 2001.', '    .. [5] Gray P. G., 1969, Journal of the Royal Statistical Society.', '           Series A (General), 132, 272', '', '    \"\"\"', '    def __init__(self, dataset, bw_method=None, weights=None):', '        self.dataset = atleast_2d(asarray(dataset))', '        if not self.dataset.size > 1:', '            raise ValueError(\"`dataset` input should have multiple elements.\")', '', '        self.d, self.n = self.dataset.shape', '', '        if weights is not None:', '            self._weights = atleast_1d(weights).astype(float)', '            self._weights /= sum(self._weights)', '            if self.weights.ndim != 1:', '                raise ValueError(\"`weights` input should be one-dimensional.\")', '            if len(self._weights) != self.n:', '                raise ValueError(\"`weights` input should be of length n\")', '            self._neff = 1/sum(self._weights**2)', '', '        self.set_bandwidth(bw_method=bw_method)', '', '    def evaluate(self, points):', '        \"\"\"Evaluate the estimated pdf on a set of points.', '', '        Parameters', '        ----------', '        points : (# of dimensions, # of points)-array', '            Alternatively, a (# of dimensions,) vector can be passed in and', '            treated as a single point.', '', '        Returns', '        -------', '        values : (# of points,)-array', '            The values at each point.', '', '        Raises', '        ------', '        ValueError : if the dimensionality of the input points is different than', '                     the dimensionality of the KDE.', '', '        \"\"\"', '        points = atleast_2d(asarray(points))', '', '        d, m = points.shape', '        if d != self.d:', '            if d == 1 and m == self.d:', '                # points was passed in as a row vector', '                points = reshape(points, (self.d, 1))', '                m = 1', '            else:', '                msg = f\"points have dimension {d}, dataset has dimension {self.d}\"', '                raise ValueError(msg)', '', '        output_dtype = np.common_type(self.covariance, points)', '        result = zeros((m,), dtype=output_dtype)', '', '        whitening = linalg.cholesky(self.inv_cov)', '        scaled_dataset = dot(whitening, self.dataset)', '        scaled_points = dot(whitening, points)', '', '        if m >= self.n:', '            # there are more points than data, so loop over data', '            for i in range(self.n):', '                diff = scaled_dataset[:, i, newaxis] - scaled_points', '                energy = sum(diff * diff, axis=0) / 2.0', '                result += self.weights[i]*exp(-energy)', '        else:', '            # loop over points', '            for i in range(m):', '                diff = scaled_dataset - scaled_points[:, i, newaxis]', '                energy = sum(diff * diff, axis=0) / 2.0', '                result[i] = sum(exp(-energy)*self.weights, axis=0)', '', '        result = result / self._norm_factor', '', '        return result', '', '    __call__ = evaluate', '', '    def scotts_factor(self):', '        \"\"\"Compute Scott\\'s factor.', '', '        Returns', '        -------', '        s : float', \"            Scott's factor.\", '        \"\"\"', '        return power(self.neff, -1./(self.d+4))', '', '    def silverman_factor(self):', '        \"\"\"Compute the Silverman factor.', '', '        Returns', '        -------', '        s : float', '            The silverman factor.', '        \"\"\"', '        return power(self.neff*(self.d+2.0)/4.0, -1./(self.d+4))', '', '    #  Default method to calculate bandwidth, can be overwritten by subclass', '    covariance_factor = scotts_factor', '    covariance_factor.__doc__ = \"\"\"Computes the coefficient (`kde.factor`) that', '        multiplies the data covariance matrix to obtain the kernel covariance', '        matrix. The default is `scotts_factor`.  A subclass can overwrite this', '        method to provide a different method, or set it through a call to', '        `kde.set_bandwidth`.\"\"\"', '', '    def set_bandwidth(self, bw_method=None):', '        \"\"\"Compute the estimator bandwidth with given method.', '', '        The new bandwidth calculated after a call to `set_bandwidth` is used', '        for subsequent evaluations of the estimated density.', '', '        Parameters', '        ----------', '        bw_method : str, scalar or callable, optional', '            The method used to calculate the estimator bandwidth.  This can be', \"            'scott', 'silverman', a scalar constant or a callable.  If a\", '            scalar, this will be used directly as `kde.factor`.  If a callable,', '            it should take a `gaussian_kde` instance as only parameter and', '            return a scalar.  If None (default), nothing happens; the current', '            `kde.covariance_factor` method is kept.', '', '        Notes', '        -----', '        .. versionadded:: 0.11', '', '        \"\"\"', '        if bw_method is None:', '            pass', \"        elif bw_method == 'scott':\", '            self.covariance_factor = self.scotts_factor', \"        elif bw_method == 'silverman':\", '            self.covariance_factor = self.silverman_factor', '        elif np.isscalar(bw_method) and not isinstance(bw_method, str):', \"            self._bw_method = 'use constant'\", '            self.covariance_factor = lambda: bw_method', '        elif callable(bw_method):', '            self._bw_method = bw_method', '            self.covariance_factor = lambda: self._bw_method(self)', '        else:', '            msg = \"`bw_method` should be \\'scott\\', \\'silverman\\', a scalar \" \\\\', '                  \"or a callable.\"', '            raise ValueError(msg)', '', '        self._compute_covariance()', '', '    def _compute_covariance(self):', '        \"\"\"Computes the covariance matrix for each Gaussian kernel using', '        covariance_factor().', '        \"\"\"', '        self.factor = self.covariance_factor()', '        # Cache covariance and inverse covariance of the data', \"        if not hasattr(self, '_data_inv_cov'):\", '            self._data_covariance = atleast_2d(cov(self.dataset, rowvar=1,', '                                               bias=False,', '                                               aweights=self.weights))', '            self._data_inv_cov = linalg.inv(self._data_covariance)', '', '        self.covariance = self._data_covariance * self.factor**2', '        self.inv_cov = self._data_inv_cov / self.factor**2', '        self._norm_factor = sqrt(linalg.det(2*pi*self.covariance))', '', '    def pdf(self, x):', '        \"\"\"', '        Evaluate the estimated pdf on a provided set of points.', '', '        Notes', '        -----', '        This is an alias for `gaussian_kde.evaluate`.  See the ``evaluate``', '        docstring for more details.', '', '        \"\"\"', '        return self.evaluate(x)', '', '    @property', '    def weights(self):', '        try:', '            return self._weights', '        except AttributeError:', '            self._weights = ones(self.n)/self.n', '            return self._weights', '', '    @property', '    def neff(self):', '        try:', '            return self._neff', '        except AttributeError:', '            self._neff = 1/sum(self.weights**2)', '            return self._neff']}, 'husl.py': {'classes': [], 'functions': [{'name': 'husl_to_rgb', 'start_line': 31, 'end_line': 32, 'text': ['def husl_to_rgb(h, s, l):', '    return lch_to_rgb(*husl_to_lch([h, s, l]))']}, {'name': 'husl_to_hex', 'start_line': 35, 'end_line': 36, 'text': ['def husl_to_hex(h, s, l):', '    return rgb_to_hex(husl_to_rgb(h, s, l))']}, {'name': 'rgb_to_husl', 'start_line': 39, 'end_line': 40, 'text': ['def rgb_to_husl(r, g, b):', '    return lch_to_husl(rgb_to_lch(r, g, b))']}, {'name': 'hex_to_husl', 'start_line': 43, 'end_line': 44, 'text': ['def hex_to_husl(hex):', '    return rgb_to_husl(*hex_to_rgb(hex))']}, {'name': 'huslp_to_rgb', 'start_line': 47, 'end_line': 48, 'text': ['def huslp_to_rgb(h, s, l):', '    return lch_to_rgb(*huslp_to_lch([h, s, l]))']}, {'name': 'huslp_to_hex', 'start_line': 51, 'end_line': 52, 'text': ['def huslp_to_hex(h, s, l):', '    return rgb_to_hex(huslp_to_rgb(h, s, l))']}, {'name': 'rgb_to_huslp', 'start_line': 55, 'end_line': 56, 'text': ['def rgb_to_huslp(r, g, b):', '    return lch_to_huslp(rgb_to_lch(r, g, b))']}, {'name': 'hex_to_huslp', 'start_line': 59, 'end_line': 60, 'text': ['def hex_to_huslp(hex):', '    return rgb_to_huslp(*hex_to_rgb(hex))']}, {'name': 'lch_to_rgb', 'start_line': 63, 'end_line': 64, 'text': ['def lch_to_rgb(l, c, h):', '    return xyz_to_rgb(luv_to_xyz(lch_to_luv([l, c, h])))']}, {'name': 'rgb_to_lch', 'start_line': 67, 'end_line': 68, 'text': ['def rgb_to_lch(r, g, b):', '    return luv_to_lch(xyz_to_luv(rgb_to_xyz([r, g, b])))']}, {'name': 'max_chroma', 'start_line': 71, 'end_line': 91, 'text': ['def max_chroma(L, H):', '    hrad = math.radians(H)', '    sinH = (math.sin(hrad))', '    cosH = (math.cos(hrad))', '    sub1 = (math.pow(L + 16, 3.0) / 1560896.0)', '    sub2 = sub1 if sub1 > 0.008856 else (L / 903.3)', '    result = float(\"inf\")', '    for row in m:', '        m1 = row[0]', '        m2 = row[1]', '        m3 = row[2]', '        top = ((0.99915 * m1 + 1.05122 * m2 + 1.14460 * m3) * sub2)', '        rbottom = (0.86330 * m3 - 0.17266 * m2)', '        lbottom = (0.12949 * m3 - 0.38848 * m1)', '        bottom = (rbottom * sinH + lbottom * cosH) * sub2', '', '        for t in (0.0, 1.0):', '            C = (L * (top - 1.05122 * t) / (bottom + 0.17266 * sinH * t))', '            if C > 0.0 and C < result:', '                result = C', '    return result']}, {'name': '_hrad_extremum', 'start_line': 94, 'end_line': 114, 'text': ['def _hrad_extremum(L):', '    lhs = (math.pow(L, 3.0) + 48.0 * math.pow(L, 2.0) + 768.0 * L + 4096.0) / 1560896.0', '    rhs = 1107.0 / 125000.0', '    sub = lhs if lhs > rhs else 10.0 * L / 9033.0', '    chroma = float(\"inf\")', '    result = None', '    for row in m:', '        for limit in (0.0, 1.0):', '            [m1, m2, m3] = row', '            top = -3015466475.0 * m3 * sub + 603093295.0 * m2 * sub - 603093295.0 * limit', '            bottom = 1356959916.0 * m1 * sub - 452319972.0 * m3 * sub', '            hrad = math.atan2(top, bottom)', \"            # This is a math hack to deal with tan quadrants, I'm too lazy to figure\", '            # out how to do this properly', '            if limit == 0.0:', '                hrad += math.pi', '            test = max_chroma(L, math.degrees(hrad))', '            if test < chroma:', '                chroma = test', '                result = hrad', '    return result']}, {'name': 'max_chroma_pastel', 'start_line': 117, 'end_line': 119, 'text': ['def max_chroma_pastel(L):', '    H = math.degrees(_hrad_extremum(L))', '    return max_chroma(L, H)']}, {'name': 'dot_product', 'start_line': 122, 'end_line': 123, 'text': ['def dot_product(a, b):', '    return sum(map(operator.mul, a, b))']}, {'name': 'f', 'start_line': 126, 'end_line': 130, 'text': ['def f(t):', '    if t > lab_e:', '        return (math.pow(t, 1.0 / 3.0))', '    else:', '        return (7.787 * t + 16.0 / 116.0)']}, {'name': 'f_inv', 'start_line': 133, 'end_line': 137, 'text': ['def f_inv(t):', '    if math.pow(t, 3.0) > lab_e:', '        return (math.pow(t, 3.0))', '    else:', '        return (116.0 * t - 16.0) / lab_k']}, {'name': 'from_linear', 'start_line': 140, 'end_line': 144, 'text': ['def from_linear(c):', '    if c <= 0.0031308:', '        return 12.92 * c', '    else:', '        return (1.055 * math.pow(c, 1.0 / 2.4) - 0.055)']}, {'name': 'to_linear', 'start_line': 147, 'end_line': 153, 'text': ['def to_linear(c):', '    a = 0.055', '', '    if c > 0.04045:', '        return (math.pow((c + a) / (1.0 + a), 2.4))', '    else:', '        return (c / 12.92)']}, {'name': 'rgb_prepare', 'start_line': 156, 'end_line': 175, 'text': ['def rgb_prepare(triple):', '    ret = []', '    for ch in triple:', '        ch = round(ch, 3)', '', '        if ch < -0.0001 or ch > 1.0001:', '            raise Exception(f\"Illegal RGB value {ch:f}\")', '', '        if ch < 0:', '            ch = 0', '        if ch > 1:', '            ch = 1', '', '        # Fix for Python 3 which by default rounds 4.5 down to 4.0', '        # instead of Python 2 which is rounded to 5.0 which caused', '        # a couple off by one errors in the tests. Tests now all pass', '        # in Python 2 and Python 3', '        ret.append(int(round(ch * 255 + 0.001, 0)))', '', '    return ret']}, {'name': 'hex_to_rgb', 'start_line': 178, 'end_line': 184, 'text': ['def hex_to_rgb(hex):', \"    if hex.startswith('#'):\", '        hex = hex[1:]', '    r = int(hex[0:2], 16) / 255.0', '    g = int(hex[2:4], 16) / 255.0', '    b = int(hex[4:6], 16) / 255.0', '    return [r, g, b]']}, {'name': 'rgb_to_hex', 'start_line': 187, 'end_line': 189, 'text': ['def rgb_to_hex(triple):', '    [r, g, b] = triple', \"    return '#%02x%02x%02x' % tuple(rgb_prepare([r, g, b]))\"]}, {'name': 'xyz_to_rgb', 'start_line': 192, 'end_line': 194, 'text': ['def xyz_to_rgb(triple):', '    xyz = map(lambda row: dot_product(row, triple), m)', '    return list(map(from_linear, xyz))']}, {'name': 'rgb_to_xyz', 'start_line': 197, 'end_line': 199, 'text': ['def rgb_to_xyz(triple):', '    rgbl = list(map(to_linear, triple))', '    return list(map(lambda row: dot_product(row, rgbl), m_inv))']}, {'name': 'xyz_to_luv', 'start_line': 202, 'end_line': 219, 'text': ['def xyz_to_luv(triple):', '    X, Y, Z = triple', '', '    if X == Y == Z == 0.0:', '        return [0.0, 0.0, 0.0]', '', '    varU = (4.0 * X) / (X + (15.0 * Y) + (3.0 * Z))', '    varV = (9.0 * Y) / (X + (15.0 * Y) + (3.0 * Z))', '    L = 116.0 * f(Y / refY) - 16.0', '', '    # Black will create a divide-by-zero error', '    if L == 0.0:', '        return [0.0, 0.0, 0.0]', '', '    U = 13.0 * L * (varU - refU)', '    V = 13.0 * L * (varV - refV)', '', '    return [L, U, V]']}, {'name': 'luv_to_xyz', 'start_line': 222, 'end_line': 235, 'text': ['def luv_to_xyz(triple):', '    L, U, V = triple', '', '    if L == 0:', '        return [0.0, 0.0, 0.0]', '', '    varY = f_inv((L + 16.0) / 116.0)', '    varU = U / (13.0 * L) + refU', '    varV = V / (13.0 * L) + refV', '    Y = varY * refY', '    X = 0.0 - (9.0 * Y * varU) / ((varU - 4.0) * varV - varU * varV)', '    Z = (9.0 * Y - (15.0 * varV * Y) - (varV * X)) / (3.0 * varV)', '', '    return [X, Y, Z]']}, {'name': 'luv_to_lch', 'start_line': 238, 'end_line': 247, 'text': ['def luv_to_lch(triple):', '    L, U, V = triple', '', '    C = (math.pow(math.pow(U, 2) + math.pow(V, 2), (1.0 / 2.0)))', '    hrad = (math.atan2(V, U))', '    H = math.degrees(hrad)', '    if H < 0.0:', '        H = 360.0 + H', '', '    return [L, C, H]']}, {'name': 'lch_to_luv', 'start_line': 250, 'end_line': 257, 'text': ['def lch_to_luv(triple):', '    L, C, H = triple', '', '    Hrad = math.radians(H)', '    U = (math.cos(Hrad) * C)', '    V = (math.sin(Hrad) * C)', '', '    return [L, U, V]']}, {'name': 'husl_to_lch', 'start_line': 260, 'end_line': 271, 'text': ['def husl_to_lch(triple):', '    H, S, L = triple', '', '    if L > 99.9999999:', '        return [100, 0.0, H]', '    if L < 0.00000001:', '        return [0.0, 0.0, H]', '', '    mx = max_chroma(L, H)', '    C = mx / 100.0 * S', '', '    return [L, C, H]']}, {'name': 'lch_to_husl', 'start_line': 274, 'end_line': 285, 'text': ['def lch_to_husl(triple):', '    L, C, H = triple', '', '    if L > 99.9999999:', '        return [H, 0.0, 100.0]', '    if L < 0.00000001:', '        return [H, 0.0, 0.0]', '', '    mx = max_chroma(L, H)', '    S = C / mx * 100.0', '', '    return [H, S, L]']}, {'name': 'huslp_to_lch', 'start_line': 288, 'end_line': 299, 'text': ['def huslp_to_lch(triple):', '    H, S, L = triple', '', '    if L > 99.9999999:', '        return [100, 0.0, H]', '    if L < 0.00000001:', '        return [0.0, 0.0, H]', '', '    mx = max_chroma_pastel(L)', '    C = mx / 100.0 * S', '', '    return [L, C, H]']}, {'name': 'lch_to_huslp', 'start_line': 302, 'end_line': 313, 'text': ['def lch_to_huslp(triple):', '    L, C, H = triple', '', '    if L > 99.9999999:', '        return [H, 0.0, 100.0]', '    if L < 0.00000001:', '        return [H, 0.0, 0.0]', '', '    mx = max_chroma_pastel(L)', '    S = C / mx * 100.0', '', '    return [H, S, L]']}], 'text': ['import operator', 'import math', '', '__version__ = \"2.1.0\"', '', '', 'm = [', '    [3.2406, -1.5372, -0.4986],', '    [-0.9689, 1.8758, 0.0415],', '    [0.0557, -0.2040, 1.0570]', ']', '', 'm_inv = [', '    [0.4124, 0.3576, 0.1805],', '    [0.2126, 0.7152, 0.0722],', '    [0.0193, 0.1192, 0.9505]', ']', '', '# Hard-coded D65 illuminant', 'refX = 0.95047', 'refY = 1.00000', 'refZ = 1.08883', 'refU = 0.19784', 'refV = 0.46834', 'lab_e = 0.008856', 'lab_k = 903.3', '', '', '# Public API', '', 'def husl_to_rgb(h, s, l):', '    return lch_to_rgb(*husl_to_lch([h, s, l]))', '', '', 'def husl_to_hex(h, s, l):', '    return rgb_to_hex(husl_to_rgb(h, s, l))', '', '', 'def rgb_to_husl(r, g, b):', '    return lch_to_husl(rgb_to_lch(r, g, b))', '', '', 'def hex_to_husl(hex):', '    return rgb_to_husl(*hex_to_rgb(hex))', '', '', 'def huslp_to_rgb(h, s, l):', '    return lch_to_rgb(*huslp_to_lch([h, s, l]))', '', '', 'def huslp_to_hex(h, s, l):', '    return rgb_to_hex(huslp_to_rgb(h, s, l))', '', '', 'def rgb_to_huslp(r, g, b):', '    return lch_to_huslp(rgb_to_lch(r, g, b))', '', '', 'def hex_to_huslp(hex):', '    return rgb_to_huslp(*hex_to_rgb(hex))', '', '', 'def lch_to_rgb(l, c, h):', '    return xyz_to_rgb(luv_to_xyz(lch_to_luv([l, c, h])))', '', '', 'def rgb_to_lch(r, g, b):', '    return luv_to_lch(xyz_to_luv(rgb_to_xyz([r, g, b])))', '', '', 'def max_chroma(L, H):', '    hrad = math.radians(H)', '    sinH = (math.sin(hrad))', '    cosH = (math.cos(hrad))', '    sub1 = (math.pow(L + 16, 3.0) / 1560896.0)', '    sub2 = sub1 if sub1 > 0.008856 else (L / 903.3)', '    result = float(\"inf\")', '    for row in m:', '        m1 = row[0]', '        m2 = row[1]', '        m3 = row[2]', '        top = ((0.99915 * m1 + 1.05122 * m2 + 1.14460 * m3) * sub2)', '        rbottom = (0.86330 * m3 - 0.17266 * m2)', '        lbottom = (0.12949 * m3 - 0.38848 * m1)', '        bottom = (rbottom * sinH + lbottom * cosH) * sub2', '', '        for t in (0.0, 1.0):', '            C = (L * (top - 1.05122 * t) / (bottom + 0.17266 * sinH * t))', '            if C > 0.0 and C < result:', '                result = C', '    return result', '', '', 'def _hrad_extremum(L):', '    lhs = (math.pow(L, 3.0) + 48.0 * math.pow(L, 2.0) + 768.0 * L + 4096.0) / 1560896.0', '    rhs = 1107.0 / 125000.0', '    sub = lhs if lhs > rhs else 10.0 * L / 9033.0', '    chroma = float(\"inf\")', '    result = None', '    for row in m:', '        for limit in (0.0, 1.0):', '            [m1, m2, m3] = row', '            top = -3015466475.0 * m3 * sub + 603093295.0 * m2 * sub - 603093295.0 * limit', '            bottom = 1356959916.0 * m1 * sub - 452319972.0 * m3 * sub', '            hrad = math.atan2(top, bottom)', \"            # This is a math hack to deal with tan quadrants, I'm too lazy to figure\", '            # out how to do this properly', '            if limit == 0.0:', '                hrad += math.pi', '            test = max_chroma(L, math.degrees(hrad))', '            if test < chroma:', '                chroma = test', '                result = hrad', '    return result', '', '', 'def max_chroma_pastel(L):', '    H = math.degrees(_hrad_extremum(L))', '    return max_chroma(L, H)', '', '', 'def dot_product(a, b):', '    return sum(map(operator.mul, a, b))', '', '', 'def f(t):', '    if t > lab_e:', '        return (math.pow(t, 1.0 / 3.0))', '    else:', '        return (7.787 * t + 16.0 / 116.0)', '', '', 'def f_inv(t):', '    if math.pow(t, 3.0) > lab_e:', '        return (math.pow(t, 3.0))', '    else:', '        return (116.0 * t - 16.0) / lab_k', '', '', 'def from_linear(c):', '    if c <= 0.0031308:', '        return 12.92 * c', '    else:', '        return (1.055 * math.pow(c, 1.0 / 2.4) - 0.055)', '', '', 'def to_linear(c):', '    a = 0.055', '', '    if c > 0.04045:', '        return (math.pow((c + a) / (1.0 + a), 2.4))', '    else:', '        return (c / 12.92)', '', '', 'def rgb_prepare(triple):', '    ret = []', '    for ch in triple:', '        ch = round(ch, 3)', '', '        if ch < -0.0001 or ch > 1.0001:', '            raise Exception(f\"Illegal RGB value {ch:f}\")', '', '        if ch < 0:', '            ch = 0', '        if ch > 1:', '            ch = 1', '', '        # Fix for Python 3 which by default rounds 4.5 down to 4.0', '        # instead of Python 2 which is rounded to 5.0 which caused', '        # a couple off by one errors in the tests. Tests now all pass', '        # in Python 2 and Python 3', '        ret.append(int(round(ch * 255 + 0.001, 0)))', '', '    return ret', '', '', 'def hex_to_rgb(hex):', \"    if hex.startswith('#'):\", '        hex = hex[1:]', '    r = int(hex[0:2], 16) / 255.0', '    g = int(hex[2:4], 16) / 255.0', '    b = int(hex[4:6], 16) / 255.0', '    return [r, g, b]', '', '', 'def rgb_to_hex(triple):', '    [r, g, b] = triple', \"    return '#%02x%02x%02x' % tuple(rgb_prepare([r, g, b]))\", '', '', 'def xyz_to_rgb(triple):', '    xyz = map(lambda row: dot_product(row, triple), m)', '    return list(map(from_linear, xyz))', '', '', 'def rgb_to_xyz(triple):', '    rgbl = list(map(to_linear, triple))', '    return list(map(lambda row: dot_product(row, rgbl), m_inv))', '', '', 'def xyz_to_luv(triple):', '    X, Y, Z = triple', '', '    if X == Y == Z == 0.0:', '        return [0.0, 0.0, 0.0]', '', '    varU = (4.0 * X) / (X + (15.0 * Y) + (3.0 * Z))', '    varV = (9.0 * Y) / (X + (15.0 * Y) + (3.0 * Z))', '    L = 116.0 * f(Y / refY) - 16.0', '', '    # Black will create a divide-by-zero error', '    if L == 0.0:', '        return [0.0, 0.0, 0.0]', '', '    U = 13.0 * L * (varU - refU)', '    V = 13.0 * L * (varV - refV)', '', '    return [L, U, V]', '', '', 'def luv_to_xyz(triple):', '    L, U, V = triple', '', '    if L == 0:', '        return [0.0, 0.0, 0.0]', '', '    varY = f_inv((L + 16.0) / 116.0)', '    varU = U / (13.0 * L) + refU', '    varV = V / (13.0 * L) + refV', '    Y = varY * refY', '    X = 0.0 - (9.0 * Y * varU) / ((varU - 4.0) * varV - varU * varV)', '    Z = (9.0 * Y - (15.0 * varV * Y) - (varV * X)) / (3.0 * varV)', '', '    return [X, Y, Z]', '', '', 'def luv_to_lch(triple):', '    L, U, V = triple', '', '    C = (math.pow(math.pow(U, 2) + math.pow(V, 2), (1.0 / 2.0)))', '    hrad = (math.atan2(V, U))', '    H = math.degrees(hrad)', '    if H < 0.0:', '        H = 360.0 + H', '', '    return [L, C, H]', '', '', 'def lch_to_luv(triple):', '    L, C, H = triple', '', '    Hrad = math.radians(H)', '    U = (math.cos(Hrad) * C)', '    V = (math.sin(Hrad) * C)', '', '    return [L, U, V]', '', '', 'def husl_to_lch(triple):', '    H, S, L = triple', '', '    if L > 99.9999999:', '        return [100, 0.0, H]', '    if L < 0.00000001:', '        return [0.0, 0.0, H]', '', '    mx = max_chroma(L, H)', '    C = mx / 100.0 * S', '', '    return [L, C, H]', '', '', 'def lch_to_husl(triple):', '    L, C, H = triple', '', '    if L > 99.9999999:', '        return [H, 0.0, 100.0]', '    if L < 0.00000001:', '        return [H, 0.0, 0.0]', '', '    mx = max_chroma(L, H)', '    S = C / mx * 100.0', '', '    return [H, S, L]', '', '', 'def huslp_to_lch(triple):', '    H, S, L = triple', '', '    if L > 99.9999999:', '        return [100, 0.0, H]', '    if L < 0.00000001:', '        return [0.0, 0.0, H]', '', '    mx = max_chroma_pastel(L)', '    C = mx / 100.0 * S', '', '    return [L, C, H]', '', '', 'def lch_to_huslp(triple):', '    L, C, H = triple', '', '    if L > 99.9999999:', '        return [H, 0.0, 100.0]', '    if L < 0.00000001:', '        return [H, 0.0, 0.0]', '', '    mx = max_chroma_pastel(L)', '    S = C / mx * 100.0', '', '    return [H, S, L]']}, 'appdirs.py': {'classes': [], 'functions': [{'name': 'user_cache_dir', 'start_line': 73, 'end_line': 127, 'text': ['def user_cache_dir(appname=None, appauthor=None, version=None, opinion=True):', '    r\"\"\"Return full path to the user-specific cache dir for this application.', '', '        \"appname\" is the name of application.', '            If None, just the system directory is returned.', '        \"appauthor\" (only used on Windows) is the name of the', '            appauthor or distributing body for this application. Typically', '            it is the owning company name. This falls back to appname. You may', '            pass False to disable it.', '        \"version\" is an optional version path element to append to the', '            path. You might want to use this if you want multiple versions', '            of your app to be able to run independently. If used, this', '            would typically be \"<major>.<minor>\".', '            Only applied when appname is present.', '        \"opinion\" (boolean) can be False to disable the appending of', '            \"Cache\" to the base app data dir for Windows. See', '            discussion below.', '', '    Typical user cache directories are:', '        Mac OS X:   ~/Library/Caches/<AppName>', '        Unix:       ~/.cache/<AppName> (XDG default)', '        Win XP:     C:\\\\Documents and Settings\\\\<username>\\\\Local Settings\\\\Application Data\\\\<AppAuthor>\\\\<AppName>\\\\Cache', '        Vista:      C:\\\\Users\\\\<username>\\\\AppData\\\\Local\\\\<AppAuthor>\\\\<AppName>\\\\Cache', '', '    On Windows the only suggestion in the MSDN docs is that local settings go in', '    the `CSIDL_LOCAL_APPDATA` directory. This is identical to the non-roaming', '    app data dir (the default returned by `user_data_dir` above). Apps typically', '    put cache data somewhere *under* the given dir here. Some examples:', '        ...\\\\Mozilla\\\\Firefox\\\\Profiles\\\\<ProfileName>\\\\Cache', '        ...\\\\Acme\\\\SuperApp\\\\Cache\\\\1.0', '    OPINION: This function appends \"Cache\" to the `CSIDL_LOCAL_APPDATA` value.', '    This can be disabled with the `opinion=False` option.', '    \"\"\"', '    if system == \"win32\":', '        if appauthor is None:', '            appauthor = appname', '        path = os.path.normpath(_get_win_folder(\"CSIDL_LOCAL_APPDATA\"))', '        if appname:', '            if appauthor is not False:', '                path = os.path.join(path, appauthor, appname)', '            else:', '                path = os.path.join(path, appname)', '            if opinion:', '                path = os.path.join(path, \"Cache\")', \"    elif system == 'darwin':\", \"        path = os.path.expanduser('~/Library/Caches')\", '        if appname:', '            path = os.path.join(path, appname)', '    else:', \"        path = os.getenv('XDG_CACHE_HOME', os.path.expanduser('~/.cache'))\", '        if appname:', '            path = os.path.join(path, appname)', '    if appname and version:', '        path = os.path.join(path, version)', '    return path']}, {'name': '_get_win_folder_from_registry', 'start_line': 132, 'end_line': 150, 'text': ['def _get_win_folder_from_registry(csidl_name):', '    \"\"\"This is a fallback technique at best. I\\'m not sure if using the', '    registry for this guarantees us the correct answer for all CSIDL_*', '    names.', '    \"\"\"', '    import winreg as _winreg', '', '    shell_folder_name = {', '        \"CSIDL_APPDATA\": \"AppData\",', '        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",', '        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",', '    }[csidl_name]', '', '    key = _winreg.OpenKey(', '        _winreg.HKEY_CURRENT_USER,', '        r\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\"', '    )', '    dir, type = _winreg.QueryValueEx(key, shell_folder_name)', '    return dir']}, {'name': '_get_win_folder_with_pywin32', 'start_line': 153, 'end_line': 177, 'text': ['def _get_win_folder_with_pywin32(csidl_name):', '    from win32com.shell import shellcon, shell', '    dir = shell.SHGetFolderPath(0, getattr(shellcon, csidl_name), 0, 0)', '    # Try to make this a unicode path because SHGetFolderPath does', '    # not return unicode strings when there is unicode data in the', '    # path.', '    try:', '        dir = unicode(dir)', '', '        # Downgrade to short path name if have highbit chars. See', '        # <http://bugs.activestate.com/show_bug.cgi?id=85099>.', '        has_high_char = False', '        for c in dir:', '            if ord(c) > 255:', '                has_high_char = True', '                break', '        if has_high_char:', '            try:', '                import win32api', '                dir = win32api.GetShortPathName(dir)', '            except ImportError:', '                pass', '    except UnicodeError:', '        pass', '    return dir']}, {'name': '_get_win_folder_with_ctypes', 'start_line': 180, 'end_line': 204, 'text': ['def _get_win_folder_with_ctypes(csidl_name):', '    import ctypes', '', '    csidl_const = {', '        \"CSIDL_APPDATA\": 26,', '        \"CSIDL_COMMON_APPDATA\": 35,', '        \"CSIDL_LOCAL_APPDATA\": 28,', '    }[csidl_name]', '', '    buf = ctypes.create_unicode_buffer(1024)', '    ctypes.windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)', '', '    # Downgrade to short path name if have highbit chars. See', '    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.', '    has_high_char = False', '    for c in buf:', '        if ord(c) > 255:', '            has_high_char = True', '            break', '    if has_high_char:', '        buf2 = ctypes.create_unicode_buffer(1024)', '        if ctypes.windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):', '            buf = buf2', '', '    return buf.value']}, {'name': '_get_win_folder_with_jna', 'start_line': 206, 'end_line': 230, 'text': ['def _get_win_folder_with_jna(csidl_name):', '    import array', '    from com.sun import jna', '    from com.sun.jna.platform import win32', '', '    buf_size = win32.WinDef.MAX_PATH * 2', \"    buf = array.zeros('c', buf_size)\", '    shell = win32.Shell32.INSTANCE', '    shell.SHGetFolderPath(None, getattr(win32.ShlObj, csidl_name), None, win32.ShlObj.SHGFP_TYPE_CURRENT, buf)', '    dir = jna.Native.toString(buf.tostring()).rstrip(\"\\\\0\")', '', '    # Downgrade to short path name if have highbit chars. See', '    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.', '    has_high_char = False', '    for c in dir:', '        if ord(c) > 255:', '            has_high_char = True', '            break', '    if has_high_char:', \"        buf = array.zeros('c', buf_size)\", '        kernel = win32.Kernel32.INSTANCE', '        if kernel.GetShortPathName(dir, buf, buf_size):', '            dir = jna.Native.toString(buf.tostring()).rstrip(\"\\\\0\")', '', '    return dir']}], 'text': ['#!/usr/bin/env python3', '# Copyright (c) 2005-2010 ActiveState Software Inc.', '# Copyright (c) 2013 Eddy Petri\u0219or', '', '# flake8: noqa', '', '\"\"\"', 'This file is directly from', 'https://github.com/ActiveState/appdirs/blob/3fe6a83776843a46f20c2e5587afcffe05e03b39/appdirs.py', '', 'The license of https://github.com/ActiveState/appdirs copied below:', '', '', '# This is the MIT license', '', 'Copyright (c) 2010 ActiveState Software Inc.', '', 'Permission is hereby granted, free of charge, to any person obtaining a', 'copy of this software and associated documentation files (the', '\"Software\"), to deal in the Software without restriction, including', 'without limitation the rights to use, copy, modify, merge, publish,', 'distribute, sublicense, and/or sell copies of the Software, and to', 'permit persons to whom the Software is furnished to do so, subject to', 'the following conditions:', '', 'The above copyright notice and this permission notice shall be included', 'in all copies or substantial portions of the Software.', '', 'THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS', 'OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF', 'MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.', 'IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY', 'CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,', 'TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE', 'SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.', '\"\"\"', '', '\"\"\"Utilities for determining application-specific dirs.', '', 'See <https://github.com/ActiveState/appdirs> for details and usage.', '\"\"\"', '# Dev Notes:', '# - MSDN on where to store app data files:', '#   http://support.microsoft.com/default.aspx?scid=kb;en-us;310294#XSLTH3194121123120121120120', '# - Mac OS X: http://developer.apple.com/documentation/MacOSX/Conceptual/BPFileSystem/index.html', '# - XDG spec for Un*x: https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html', '', '__version__ = \"1.4.4\"', '__version_info__ = tuple(int(segment) for segment in __version__.split(\".\"))', '', '', 'import sys', 'import os', '', 'unicode = str', '', \"if sys.platform.startswith('java'):\", '    import platform', '    os_name = platform.java_ver()[3][0]', '    if os_name.startswith(\\'Windows\\'): # \"Windows XP\", \"Windows 7\", etc.', \"        system = 'win32'\", '    elif os_name.startswith(\\'Mac\\'): # \"Mac OS X\", etc.', \"        system = 'darwin'\", '    else: # \"Linux\", \"SunOS\", \"FreeBSD\", etc.', '        # Setting this to \"linux2\" is not ideal, but only Windows or Mac', '        # are actually checked for and the rest of the module expects', '        # *sys.platform* style strings.', \"        system = 'linux2'\", 'else:', '    system = sys.platform', '', '', 'def user_cache_dir(appname=None, appauthor=None, version=None, opinion=True):', '    r\"\"\"Return full path to the user-specific cache dir for this application.', '', '        \"appname\" is the name of application.', '            If None, just the system directory is returned.', '        \"appauthor\" (only used on Windows) is the name of the', '            appauthor or distributing body for this application. Typically', '            it is the owning company name. This falls back to appname. You may', '            pass False to disable it.', '        \"version\" is an optional version path element to append to the', '            path. You might want to use this if you want multiple versions', '            of your app to be able to run independently. If used, this', '            would typically be \"<major>.<minor>\".', '            Only applied when appname is present.', '        \"opinion\" (boolean) can be False to disable the appending of', '            \"Cache\" to the base app data dir for Windows. See', '            discussion below.', '', '    Typical user cache directories are:', '        Mac OS X:   ~/Library/Caches/<AppName>', '        Unix:       ~/.cache/<AppName> (XDG default)', '        Win XP:     C:\\\\Documents and Settings\\\\<username>\\\\Local Settings\\\\Application Data\\\\<AppAuthor>\\\\<AppName>\\\\Cache', '        Vista:      C:\\\\Users\\\\<username>\\\\AppData\\\\Local\\\\<AppAuthor>\\\\<AppName>\\\\Cache', '', '    On Windows the only suggestion in the MSDN docs is that local settings go in', '    the `CSIDL_LOCAL_APPDATA` directory. This is identical to the non-roaming', '    app data dir (the default returned by `user_data_dir` above). Apps typically', '    put cache data somewhere *under* the given dir here. Some examples:', '        ...\\\\Mozilla\\\\Firefox\\\\Profiles\\\\<ProfileName>\\\\Cache', '        ...\\\\Acme\\\\SuperApp\\\\Cache\\\\1.0', '    OPINION: This function appends \"Cache\" to the `CSIDL_LOCAL_APPDATA` value.', '    This can be disabled with the `opinion=False` option.', '    \"\"\"', '    if system == \"win32\":', '        if appauthor is None:', '            appauthor = appname', '        path = os.path.normpath(_get_win_folder(\"CSIDL_LOCAL_APPDATA\"))', '        if appname:', '            if appauthor is not False:', '                path = os.path.join(path, appauthor, appname)', '            else:', '                path = os.path.join(path, appname)', '            if opinion:', '                path = os.path.join(path, \"Cache\")', \"    elif system == 'darwin':\", \"        path = os.path.expanduser('~/Library/Caches')\", '        if appname:', '            path = os.path.join(path, appname)', '    else:', \"        path = os.getenv('XDG_CACHE_HOME', os.path.expanduser('~/.cache'))\", '        if appname:', '            path = os.path.join(path, appname)', '    if appname and version:', '        path = os.path.join(path, version)', '    return path', '', '', '#---- internal support stuff', '', 'def _get_win_folder_from_registry(csidl_name):', '    \"\"\"This is a fallback technique at best. I\\'m not sure if using the', '    registry for this guarantees us the correct answer for all CSIDL_*', '    names.', '    \"\"\"', '    import winreg as _winreg', '', '    shell_folder_name = {', '        \"CSIDL_APPDATA\": \"AppData\",', '        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",', '        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",', '    }[csidl_name]', '', '    key = _winreg.OpenKey(', '        _winreg.HKEY_CURRENT_USER,', '        r\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\"', '    )', '    dir, type = _winreg.QueryValueEx(key, shell_folder_name)', '    return dir', '', '', 'def _get_win_folder_with_pywin32(csidl_name):', '    from win32com.shell import shellcon, shell', '    dir = shell.SHGetFolderPath(0, getattr(shellcon, csidl_name), 0, 0)', '    # Try to make this a unicode path because SHGetFolderPath does', '    # not return unicode strings when there is unicode data in the', '    # path.', '    try:', '        dir = unicode(dir)', '', '        # Downgrade to short path name if have highbit chars. See', '        # <http://bugs.activestate.com/show_bug.cgi?id=85099>.', '        has_high_char = False', '        for c in dir:', '            if ord(c) > 255:', '                has_high_char = True', '                break', '        if has_high_char:', '            try:', '                import win32api', '                dir = win32api.GetShortPathName(dir)', '            except ImportError:', '                pass', '    except UnicodeError:', '        pass', '    return dir', '', '', 'def _get_win_folder_with_ctypes(csidl_name):', '    import ctypes', '', '    csidl_const = {', '        \"CSIDL_APPDATA\": 26,', '        \"CSIDL_COMMON_APPDATA\": 35,', '        \"CSIDL_LOCAL_APPDATA\": 28,', '    }[csidl_name]', '', '    buf = ctypes.create_unicode_buffer(1024)', '    ctypes.windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)', '', '    # Downgrade to short path name if have highbit chars. See', '    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.', '    has_high_char = False', '    for c in buf:', '        if ord(c) > 255:', '            has_high_char = True', '            break', '    if has_high_char:', '        buf2 = ctypes.create_unicode_buffer(1024)', '        if ctypes.windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):', '            buf = buf2', '', '    return buf.value', '', 'def _get_win_folder_with_jna(csidl_name):', '    import array', '    from com.sun import jna', '    from com.sun.jna.platform import win32', '', '    buf_size = win32.WinDef.MAX_PATH * 2', \"    buf = array.zeros('c', buf_size)\", '    shell = win32.Shell32.INSTANCE', '    shell.SHGetFolderPath(None, getattr(win32.ShlObj, csidl_name), None, win32.ShlObj.SHGFP_TYPE_CURRENT, buf)', '    dir = jna.Native.toString(buf.tostring()).rstrip(\"\\\\0\")', '', '    # Downgrade to short path name if have highbit chars. See', '    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.', '    has_high_char = False', '    for c in dir:', '        if ord(c) > 255:', '            has_high_char = True', '            break', '    if has_high_char:', \"        buf = array.zeros('c', buf_size)\", '        kernel = win32.Kernel32.INSTANCE', '        if kernel.GetShortPathName(dir, buf, buf_size):', '            dir = jna.Native.toString(buf.tostring()).rstrip(\"\\\\0\")', '', '    return dir', '', 'if system == \"win32\":', '    try:', '        import win32com.shell', '        _get_win_folder = _get_win_folder_with_pywin32', '    except ImportError:', '        try:', '            from ctypes import windll', '            _get_win_folder = _get_win_folder_with_ctypes', '        except ImportError:', '            try:', '                import com.sun.jna', '                _get_win_folder = _get_win_folder_with_jna', '            except ImportError:', '                _get_win_folder = _get_win_folder_from_registry']}}, '_stats': {'base.py': {'classes': [{'name': 'Stat', 'start_line': 15, 'end_line': 52, 'text': ['class Stat:', '    \"\"\"Base class for objects that apply statistical transformations.\"\"\"', '', '    # The class supports a partial-function application pattern. The object is', '    # initialized with desired parameters and the result is a callable that', '    # accepts and returns dataframes.', '', '    # The statistical transformation logic should not add any state to the instance', '    # beyond what is defined with the initialization parameters.', '', '    # Subclasses can declare whether the orient dimension should be used in grouping', '    # TODO consider whether this should be a parameter. Motivating example:', '    # use the same KDE class violin plots and univariate density estimation.', '    # In the former case, we would expect separate densities for each unique', '    # value on the orient axis, but we would not in the latter case.', '    group_by_orient: ClassVar[bool] = False', '', '    def _check_param_one_of(self, param: Any, options: Iterable[Any]) -> None:', '        \"\"\"Raise when parameter value is not one of a specified set.\"\"\"', '        value = getattr(self, param)', '        if value not in options:', '            *most, last = options', '            option_str = \", \".join(f\"{x!r}\" for x in most[:-1]) + f\" or {last!r}\"', '            err = \" \".join([', '                f\"The `{param}` parameter for `{self.__class__.__name__}` must be\",', '                f\"one of {option_str}; not {value!r}.\",', '            ])', '            raise ValueError(err)', '', '    def __call__(', '        self,', '        data: DataFrame,', '        groupby: GroupBy,', '        orient: str,', '        scales: dict[str, Scale],', '    ) -> DataFrame:', '        \"\"\"Apply statistical transform to data subgroups and return combined result.\"\"\"', '        return data'], 'methods': [{'name': '_check_param_one_of', 'start_line': 32, 'end_line': 42, 'text': ['    def _check_param_one_of(self, param: Any, options: Iterable[Any]) -> None:', '        \"\"\"Raise when parameter value is not one of a specified set.\"\"\"', '        value = getattr(self, param)', '        if value not in options:', '            *most, last = options', '            option_str = \", \".join(f\"{x!r}\" for x in most[:-1]) + f\" or {last!r}\"', '            err = \" \".join([', '                f\"The `{param}` parameter for `{self.__class__.__name__}` must be\",', '                f\"one of {option_str}; not {value!r}.\",', '            ])', '            raise ValueError(err)']}, {'name': '__call__', 'start_line': 44, 'end_line': 52, 'text': ['    def __call__(', '        self,', '        data: DataFrame,', '        groupby: GroupBy,', '        orient: str,', '        scales: dict[str, Scale],', '    ) -> DataFrame:', '        \"\"\"Apply statistical transform to data subgroups and return combined result.\"\"\"', '        return data']}]}], 'functions': [], 'text': ['\"\"\"Base module for statistical transformations.\"\"\"', 'from __future__ import annotations', 'from collections.abc import Iterable', 'from dataclasses import dataclass', 'from typing import ClassVar, Any', '', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:', '    from pandas import DataFrame', '    from seaborn._core.groupby import GroupBy', '    from seaborn._core.scales import Scale', '', '', '@dataclass', 'class Stat:', '    \"\"\"Base class for objects that apply statistical transformations.\"\"\"', '', '    # The class supports a partial-function application pattern. The object is', '    # initialized with desired parameters and the result is a callable that', '    # accepts and returns dataframes.', '', '    # The statistical transformation logic should not add any state to the instance', '    # beyond what is defined with the initialization parameters.', '', '    # Subclasses can declare whether the orient dimension should be used in grouping', '    # TODO consider whether this should be a parameter. Motivating example:', '    # use the same KDE class violin plots and univariate density estimation.', '    # In the former case, we would expect separate densities for each unique', '    # value on the orient axis, but we would not in the latter case.', '    group_by_orient: ClassVar[bool] = False', '', '    def _check_param_one_of(self, param: Any, options: Iterable[Any]) -> None:', '        \"\"\"Raise when parameter value is not one of a specified set.\"\"\"', '        value = getattr(self, param)', '        if value not in options:', '            *most, last = options', '            option_str = \", \".join(f\"{x!r}\" for x in most[:-1]) + f\" or {last!r}\"', '            err = \" \".join([', '                f\"The `{param}` parameter for `{self.__class__.__name__}` must be\",', '                f\"one of {option_str}; not {value!r}.\",', '            ])', '            raise ValueError(err)', '', '    def __call__(', '        self,', '        data: DataFrame,', '        groupby: GroupBy,', '        orient: str,', '        scales: dict[str, Scale],', '    ) -> DataFrame:', '        \"\"\"Apply statistical transform to data subgroups and return combined result.\"\"\"', '        return data']}, 'aggregation.py': {'classes': [{'name': 'Agg', 'start_line': 16, 'end_line': 41, 'text': ['class Agg(Stat):', '    \"\"\"', '    Aggregate data along the value axis using given method.', '', '    Parameters', '    ----------', '    func : str or callable', '        Name of a :class:`pandas.Series` method or a vector -> scalar function.', '', '    \"\"\"', '    func: str | Callable[[Vector], float] = \"mean\"', '', '    group_by_orient: ClassVar[bool] = True', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        var = {\"x\": \"y\", \"y\": \"x\"}.get(orient)', '        res = (', '            groupby', '            .agg(data, {var: self.func})', '            .dropna()', '            .reset_index(drop=True)', '        )', '        return res'], 'methods': [{'name': '__call__', 'start_line': 30, 'end_line': 41, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        var = {\"x\": \"y\", \"y\": \"x\"}.get(orient)', '        res = (', '            groupby', '            .agg(data, {var: self.func})', '            .dropna()', '            .reset_index(drop=True)', '        )', '        return res']}]}, {'name': 'Est', 'start_line': 45, 'end_line': 95, 'text': ['class Est(Stat):', '    \"\"\"', '    Calculate a point estimate and error bar interval.', '', '    Parameters', '    ----------', '    func : str or callable', '        Name of a :class:`numpy.ndarray` method or a vector -> scalar function.', '    errorbar : str, (str, float) tuple, or callable', '        Name of errorbar method (one of \"ci\", \"pi\", \"se\" or \"sd\"), or a tuple', '        with a method name ane a level parameter, or a function that maps from a', '        vector to a (min, max) interval.', '    n_boot : int', '       Number of bootstrap samples to draw for \"ci\" errorbars.', '    seed : int', '        Seed for the PRNG used to draw bootstrap samples.', '', '    \"\"\"', '    func: str | Callable[[Vector], float] = \"mean\"', '    errorbar: str | tuple[str, float] = (\"ci\", 95)', '    n_boot: int = 1000', '    seed: int | None = None', '', '    group_by_orient: ClassVar[bool] = True', '', '    def _process(', '        self, data: DataFrame, var: str, estimator: EstimateAggregator', '    ) -> DataFrame:', '        # Needed because GroupBy.apply assumes func is DataFrame -> DataFrame', '        # which we could probably make more general to allow Series return', '        res = estimator(data, var)', '        return pd.DataFrame([res])', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        boot_kws = {\"n_boot\": self.n_boot, \"seed\": self.seed}', '        engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)', '', '        var = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        res = (', '            groupby', '            .apply(data, self._process, var, engine)', '            .dropna(subset=[\"x\", \"y\"])', '            .reset_index(drop=True)', '        )', '', '        res = res.fillna({f\"{var}min\": res[var], f\"{var}max\": res[var]})', '', '        return res'], 'methods': [{'name': '_process', 'start_line': 70, 'end_line': 76, 'text': ['    def _process(', '        self, data: DataFrame, var: str, estimator: EstimateAggregator', '    ) -> DataFrame:', '        # Needed because GroupBy.apply assumes func is DataFrame -> DataFrame', '        # which we could probably make more general to allow Series return', '        res = estimator(data, var)', '        return pd.DataFrame([res])']}, {'name': '__call__', 'start_line': 78, 'end_line': 95, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        boot_kws = {\"n_boot\": self.n_boot, \"seed\": self.seed}', '        engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)', '', '        var = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        res = (', '            groupby', '            .apply(data, self._process, var, engine)', '            .dropna(subset=[\"x\", \"y\"])', '            .reset_index(drop=True)', '        )', '', '        res = res.fillna({f\"{var}min\": res[var], f\"{var}max\": res[var]})', '', '        return res']}]}, {'name': 'Rolling', 'start_line': 99, 'end_line': 103, 'text': ['class Rolling(Stat):', '    ...', '', '    def __call__(self, data, groupby, orient, scales):', '        ...'], 'methods': [{'name': '__call__', 'start_line': 102, 'end_line': 103, 'text': ['    def __call__(self, data, groupby, orient, scales):', '        ...']}]}], 'functions': [], 'text': ['from __future__ import annotations', 'from dataclasses import dataclass', 'from typing import ClassVar, Callable', '', 'import pandas as pd', 'from pandas import DataFrame', '', 'from seaborn._core.scales import Scale', 'from seaborn._core.groupby import GroupBy', 'from seaborn._stats.base import Stat', 'from seaborn._statistics import EstimateAggregator', 'from seaborn._core.typing import Vector', '', '', '@dataclass', 'class Agg(Stat):', '    \"\"\"', '    Aggregate data along the value axis using given method.', '', '    Parameters', '    ----------', '    func : str or callable', '        Name of a :class:`pandas.Series` method or a vector -> scalar function.', '', '    \"\"\"', '    func: str | Callable[[Vector], float] = \"mean\"', '', '    group_by_orient: ClassVar[bool] = True', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        var = {\"x\": \"y\", \"y\": \"x\"}.get(orient)', '        res = (', '            groupby', '            .agg(data, {var: self.func})', '            .dropna()', '            .reset_index(drop=True)', '        )', '        return res', '', '', '@dataclass', 'class Est(Stat):', '    \"\"\"', '    Calculate a point estimate and error bar interval.', '', '    Parameters', '    ----------', '    func : str or callable', '        Name of a :class:`numpy.ndarray` method or a vector -> scalar function.', '    errorbar : str, (str, float) tuple, or callable', '        Name of errorbar method (one of \"ci\", \"pi\", \"se\" or \"sd\"), or a tuple', '        with a method name ane a level parameter, or a function that maps from a', '        vector to a (min, max) interval.', '    n_boot : int', '       Number of bootstrap samples to draw for \"ci\" errorbars.', '    seed : int', '        Seed for the PRNG used to draw bootstrap samples.', '', '    \"\"\"', '    func: str | Callable[[Vector], float] = \"mean\"', '    errorbar: str | tuple[str, float] = (\"ci\", 95)', '    n_boot: int = 1000', '    seed: int | None = None', '', '    group_by_orient: ClassVar[bool] = True', '', '    def _process(', '        self, data: DataFrame, var: str, estimator: EstimateAggregator', '    ) -> DataFrame:', '        # Needed because GroupBy.apply assumes func is DataFrame -> DataFrame', '        # which we could probably make more general to allow Series return', '        res = estimator(data, var)', '        return pd.DataFrame([res])', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        boot_kws = {\"n_boot\": self.n_boot, \"seed\": self.seed}', '        engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)', '', '        var = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        res = (', '            groupby', '            .apply(data, self._process, var, engine)', '            .dropna(subset=[\"x\", \"y\"])', '            .reset_index(drop=True)', '        )', '', '        res = res.fillna({f\"{var}min\": res[var], f\"{var}max\": res[var]})', '', '        return res', '', '', '@dataclass', 'class Rolling(Stat):', '    ...', '', '    def __call__(self, data, groupby, orient, scales):', '        ...']}, 'order.py': {'classes': [{'name': 'Perc', 'start_line': 38, 'end_line': 78, 'text': ['class Perc(Stat):', '    \"\"\"', '    Replace observations with percentile values.', '', '    Parameters', '    ----------', '    k : list of numbers or int', '        If a list of numbers, this gives the percentiles (in [0, 100]) to compute.', '        If an integer, compute `k` evenly-spaced percentiles between 0 and 100.', '        For example, `k=5` computes the 0, 25, 50, 75, and 100th percentiles.', '    method : str', '        Method for interpolating percentiles between observed datapoints.', '        See :func:`numpy.percentile` for valid options and more information.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Perc.rst', '', '    \"\"\"', '    k: int | list[float] = 5', '    method: str = \"linear\"', '', '    group_by_orient: ClassVar[bool] = True', '', '    def _percentile(self, data: DataFrame, var: str) -> DataFrame:', '', '        k = list(np.linspace(0, 100, self.k)) if isinstance(self.k, int) else self.k', '        method = cast(_MethodKind, self.method)', '        values = data[var].dropna()', '        if Version(np.__version__) < Version(\"1.22.0\"):', '            res = np.percentile(values, k, interpolation=method)  # type: ignore', '        else:', '            res = np.percentile(data[var].dropna(), k, method=method)', '        return DataFrame({var: res, \"percentile\": k})', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        var = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return groupby.apply(data, self._percentile, var)'], 'methods': [{'name': '_percentile', 'start_line': 62, 'end_line': 71, 'text': ['    def _percentile(self, data: DataFrame, var: str) -> DataFrame:', '', '        k = list(np.linspace(0, 100, self.k)) if isinstance(self.k, int) else self.k', '        method = cast(_MethodKind, self.method)', '        values = data[var].dropna()', '        if Version(np.__version__) < Version(\"1.22.0\"):', '            res = np.percentile(values, k, interpolation=method)  # type: ignore', '        else:', '            res = np.percentile(data[var].dropna(), k, method=method)', '        return DataFrame({var: res, \"percentile\": k})']}, {'name': '__call__', 'start_line': 73, 'end_line': 78, 'text': ['    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        var = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return groupby.apply(data, self._percentile, var)']}]}], 'functions': [], 'text': ['', 'from __future__ import annotations', 'from dataclasses import dataclass', 'from typing import ClassVar, cast', 'try:', '    from typing import Literal', 'except ImportError:', '    from typing_extensions import Literal  # type: ignore', '', 'import numpy as np', 'from pandas import DataFrame', '', 'from seaborn._core.scales import Scale', 'from seaborn._core.groupby import GroupBy', 'from seaborn._stats.base import Stat', 'from seaborn.external.version import Version', '', '', '# From https://github.com/numpy/numpy/blob/main/numpy/lib/function_base.pyi', '_MethodKind = Literal[', '    \"inverted_cdf\",', '    \"averaged_inverted_cdf\",', '    \"closest_observation\",', '    \"interpolated_inverted_cdf\",', '    \"hazen\",', '    \"weibull\",', '    \"linear\",', '    \"median_unbiased\",', '    \"normal_unbiased\",', '    \"lower\",', '    \"higher\",', '    \"midpoint\",', '    \"nearest\",', ']', '', '', '@dataclass', 'class Perc(Stat):', '    \"\"\"', '    Replace observations with percentile values.', '', '    Parameters', '    ----------', '    k : list of numbers or int', '        If a list of numbers, this gives the percentiles (in [0, 100]) to compute.', '        If an integer, compute `k` evenly-spaced percentiles between 0 and 100.', '        For example, `k=5` computes the 0, 25, 50, 75, and 100th percentiles.', '    method : str', '        Method for interpolating percentiles between observed datapoints.', '        See :func:`numpy.percentile` for valid options and more information.', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Perc.rst', '', '    \"\"\"', '    k: int | list[float] = 5', '    method: str = \"linear\"', '', '    group_by_orient: ClassVar[bool] = True', '', '    def _percentile(self, data: DataFrame, var: str) -> DataFrame:', '', '        k = list(np.linspace(0, 100, self.k)) if isinstance(self.k, int) else self.k', '        method = cast(_MethodKind, self.method)', '        values = data[var].dropna()', '        if Version(np.__version__) < Version(\"1.22.0\"):', '            res = np.percentile(values, k, interpolation=method)  # type: ignore', '        else:', '            res = np.percentile(data[var].dropna(), k, method=method)', '        return DataFrame({var: res, \"percentile\": k})', '', '    def __call__(', '        self, data: DataFrame, groupby: GroupBy, orient: str, scales: dict[str, Scale],', '    ) -> DataFrame:', '', '        var = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return groupby.apply(data, self._percentile, var)']}, '__init__.py': {'classes': [], 'functions': [], 'text': []}, 'histogram.py': {'classes': [{'name': 'Hist', 'start_line': 17, 'end_line': 208, 'text': ['class Hist(Stat):', '    \"\"\"', '    Bin observations, count them, and optionally normalize or cumulate.', '', '    Parameters', '    ----------', '    stat : str', '        Aggregate statistic to compute in each bin:', '', '        - `count`: the number of observations', '        - `density`: normalize so that the total area of the histogram equals 1', '        - `percent`: normalize so that bar heights sum to 100', '        - `probability` or `proportion`: normalize so that bar heights sum to 1', '        - `frequency`: divide the number of observations by the bin width', '', '    bins : str, int, or ArrayLike', '        Generic parameter that can be the name of a reference rule, the number', '        of bins, or the bin breaks. Passed to :func:`numpy.histogram_bin_edges`.', '    binwidth : float', '        Width of each bin; overrides `bins` but can be used with `binrange`.', '    binrange : (min, max)', '        Lowest and highest value for bin edges; can be used with either', '        `bins` (when a number) or `binwidth`. Defaults to data extremes.', '    common_norm : bool or list of variables', '        When not `False`, the normalization is applied across groups. Use', '        `True` to normalize across all groups, or pass variable name(s) that', '        define normalization groups.', '    common_bins : bool or list of variables', '        When not `False`, the same bins are used for all groups. Use `True` to', '        share bins across all groups, or pass variable name(s) to share within.', '    cumulative : bool', '        If True, cumulate the bin values.', '    discrete : bool', '        If True, set `binwidth` and `binrange` so that bins have unit width and', '        are centered on integer values', '', '    Notes', '    -----', '', '    The choice of bins for computing and plotting a histogram can exert', '    substantial influence on the insights that one is able to draw from the', '    visualization. If the bins are too large, they may erase important features.', '    On the other hand, bins that are too small may be dominated by random', '    variability, obscuring the shape of the true underlying distribution. The', '    default bin size is determined using a reference rule that depends on the', '    sample size and variance. This works well in many cases, (i.e., with', '    \"well-behaved\" data) but it fails in others. It is always a good to try', '    different bin sizes to be sure that you are not missing something important.', '    This function allows you to specify bins in several different ways, such as', '    by setting the total number of bins to use, the width of each bin, or the', '    specific locations where the bins should break.', '', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Hist.rst', '', '    \"\"\"', '    stat: str = \"count\"', '    bins: str | int | ArrayLike = \"auto\"', '    binwidth: float | None = None', '    binrange: tuple[float, float] | None = None', '    common_norm: bool | list[str] = True', '    common_bins: bool | list[str] = True', '    cumulative: bool = False', '    discrete: bool = False', '', '    def __post_init__(self):', '', '        stat_options = [', '            \"count\", \"density\", \"percent\", \"probability\", \"proportion\", \"frequency\"', '        ]', '        self._check_param_one_of(\"stat\", stat_options)', '', '    def _define_bin_edges(self, vals, weight, bins, binwidth, binrange, discrete):', '        \"\"\"Inner function that takes bin parameters as arguments.\"\"\"', '        vals = vals.dropna()', '', '        if binrange is None:', '            start, stop = vals.min(), vals.max()', '        else:', '            start, stop = binrange', '', '        if discrete:', '            bin_edges = np.arange(start - .5, stop + 1.5)', '        elif binwidth is not None:', '            step = binwidth', '            bin_edges = np.arange(start, stop + step, step)', '        else:', '            bin_edges = np.histogram_bin_edges(vals, bins, binrange, weight)', '', '        # TODO warning or cap on too many bins?', '', '        return bin_edges', '', '    def _define_bin_params(self, data, orient, scale_type):', '        \"\"\"Given data, return numpy.histogram parameters to define bins.\"\"\"', '        vals = data[orient]', '        weights = data.get(\"weight\", None)', '', \"        # TODO We'll want this for ordinal / discrete scales too\", '        # (Do we need discrete as a parameter or just infer from scale?)', '        discrete = self.discrete or scale_type == \"nominal\"', '', '        bin_edges = self._define_bin_edges(', '            vals, weights, self.bins, self.binwidth, self.binrange, discrete,', '        )', '', '        if isinstance(self.bins, (str, int)):', '            n_bins = len(bin_edges) - 1', '            bin_range = bin_edges.min(), bin_edges.max()', '            bin_kws = dict(bins=n_bins, range=bin_range)', '        else:', '            bin_kws = dict(bins=bin_edges)', '', '        return bin_kws', '', '    def _get_bins_and_eval(self, data, orient, groupby, scale_type):', '', '        bin_kws = self._define_bin_params(data, orient, scale_type)', '        return groupby.apply(data, self._eval, orient, bin_kws)', '', '    def _eval(self, data, orient, bin_kws):', '', '        vals = data[orient]', '        weights = data.get(\"weight\", None)', '', '        density = self.stat == \"density\"', '        hist, edges = np.histogram(vals, **bin_kws, weights=weights, density=density)', '', '        width = np.diff(edges)', '        center = edges[:-1] + width / 2', '', '        return pd.DataFrame({orient: center, \"count\": hist, \"space\": width})', '', '    def _normalize(self, data):', '', '        hist = data[\"count\"]', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / data[\"space\"]', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * data[\"space\"]).cumsum()', '            else:', '                hist = hist.cumsum()', '', '        return data.assign(**{self.stat: hist})', '', '    def __call__(self, data, groupby, orient, scales):', '', '        scale_type = scales[orient].__class__.__name__.lower()', '        grouping_vars = [v for v in data if v in groupby.order]', '        if not grouping_vars or self.common_bins is True:', '            bin_kws = self._define_bin_params(data, orient, scale_type)', '            data = groupby.apply(data, self._eval, orient, bin_kws)', '        else:', '            if self.common_bins is False:', '                bin_groupby = GroupBy(grouping_vars)', '            else:', '                bin_groupby = GroupBy(self.common_bins)', '                undefined = set(self.common_bins) - set(grouping_vars)', '                if undefined:', '                    param = f\"{self.__class__.__name__}.common_bins\"', '                    names = \", \".join(f\"{x!r}\" for x in undefined)', '                    msg = f\"Undefined variables(s) passed to `{param}`: {names}.\"', '                    warn(msg)', '            data = bin_groupby.apply(', '                data, self._get_bins_and_eval, orient, groupby, scale_type,', '            )', '', '        if not grouping_vars or self.common_norm is True:', '            data = self._normalize(data)', '        else:', '            if self.common_norm is False:', '                norm_grouper = grouping_vars', '            else:', '                norm_grouper = self.common_norm', '                undefined = set(self.common_norm) - set(grouping_vars)', '                if undefined:', '                    param = f\"{self.__class__.__name__}.common_norm\"', '                    names = \", \".join(f\"{x!r}\" for x in undefined)', '                    msg = f\"Undefined variables(s) passed to `{param}`: {names}.\"', '                    warn(msg)', '            data = GroupBy(norm_grouper).apply(data, self._normalize)', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return data.assign(**{other: data[self.stat]})'], 'methods': [{'name': '__post_init__', 'start_line': 84, 'end_line': 89, 'text': ['    def __post_init__(self):', '', '        stat_options = [', '            \"count\", \"density\", \"percent\", \"probability\", \"proportion\", \"frequency\"', '        ]', '        self._check_param_one_of(\"stat\", stat_options)']}, {'name': '_define_bin_edges', 'start_line': 91, 'end_line': 110, 'text': ['    def _define_bin_edges(self, vals, weight, bins, binwidth, binrange, discrete):', '        \"\"\"Inner function that takes bin parameters as arguments.\"\"\"', '        vals = vals.dropna()', '', '        if binrange is None:', '            start, stop = vals.min(), vals.max()', '        else:', '            start, stop = binrange', '', '        if discrete:', '            bin_edges = np.arange(start - .5, stop + 1.5)', '        elif binwidth is not None:', '            step = binwidth', '            bin_edges = np.arange(start, stop + step, step)', '        else:', '            bin_edges = np.histogram_bin_edges(vals, bins, binrange, weight)', '', '        # TODO warning or cap on too many bins?', '', '        return bin_edges']}, {'name': '_define_bin_params', 'start_line': 112, 'end_line': 132, 'text': ['    def _define_bin_params(self, data, orient, scale_type):', '        \"\"\"Given data, return numpy.histogram parameters to define bins.\"\"\"', '        vals = data[orient]', '        weights = data.get(\"weight\", None)', '', \"        # TODO We'll want this for ordinal / discrete scales too\", '        # (Do we need discrete as a parameter or just infer from scale?)', '        discrete = self.discrete or scale_type == \"nominal\"', '', '        bin_edges = self._define_bin_edges(', '            vals, weights, self.bins, self.binwidth, self.binrange, discrete,', '        )', '', '        if isinstance(self.bins, (str, int)):', '            n_bins = len(bin_edges) - 1', '            bin_range = bin_edges.min(), bin_edges.max()', '            bin_kws = dict(bins=n_bins, range=bin_range)', '        else:', '            bin_kws = dict(bins=bin_edges)', '', '        return bin_kws']}, {'name': '_get_bins_and_eval', 'start_line': 134, 'end_line': 137, 'text': ['    def _get_bins_and_eval(self, data, orient, groupby, scale_type):', '', '        bin_kws = self._define_bin_params(data, orient, scale_type)', '        return groupby.apply(data, self._eval, orient, bin_kws)']}, {'name': '_eval', 'start_line': 139, 'end_line': 150, 'text': ['    def _eval(self, data, orient, bin_kws):', '', '        vals = data[orient]', '        weights = data.get(\"weight\", None)', '', '        density = self.stat == \"density\"', '        hist, edges = np.histogram(vals, **bin_kws, weights=weights, density=density)', '', '        width = np.diff(edges)', '        center = edges[:-1] + width / 2', '', '        return pd.DataFrame({orient: center, \"count\": hist, \"space\": width})']}, {'name': '_normalize', 'start_line': 152, 'end_line': 168, 'text': ['    def _normalize(self, data):', '', '        hist = data[\"count\"]', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / data[\"space\"]', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * data[\"space\"]).cumsum()', '            else:', '                hist = hist.cumsum()', '', '        return data.assign(**{self.stat: hist})']}, {'name': '__call__', 'start_line': 170, 'end_line': 208, 'text': ['    def __call__(self, data, groupby, orient, scales):', '', '        scale_type = scales[orient].__class__.__name__.lower()', '        grouping_vars = [v for v in data if v in groupby.order]', '        if not grouping_vars or self.common_bins is True:', '            bin_kws = self._define_bin_params(data, orient, scale_type)', '            data = groupby.apply(data, self._eval, orient, bin_kws)', '        else:', '            if self.common_bins is False:', '                bin_groupby = GroupBy(grouping_vars)', '            else:', '                bin_groupby = GroupBy(self.common_bins)', '                undefined = set(self.common_bins) - set(grouping_vars)', '                if undefined:', '                    param = f\"{self.__class__.__name__}.common_bins\"', '                    names = \", \".join(f\"{x!r}\" for x in undefined)', '                    msg = f\"Undefined variables(s) passed to `{param}`: {names}.\"', '                    warn(msg)', '            data = bin_groupby.apply(', '                data, self._get_bins_and_eval, orient, groupby, scale_type,', '            )', '', '        if not grouping_vars or self.common_norm is True:', '            data = self._normalize(data)', '        else:', '            if self.common_norm is False:', '                norm_grouper = grouping_vars', '            else:', '                norm_grouper = self.common_norm', '                undefined = set(self.common_norm) - set(grouping_vars)', '                if undefined:', '                    param = f\"{self.__class__.__name__}.common_norm\"', '                    names = \", \".join(f\"{x!r}\" for x in undefined)', '                    msg = f\"Undefined variables(s) passed to `{param}`: {names}.\"', '                    warn(msg)', '            data = GroupBy(norm_grouper).apply(data, self._normalize)', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return data.assign(**{other: data[self.stat]})']}]}], 'functions': [], 'text': ['from __future__ import annotations', 'from dataclasses import dataclass', 'from warnings import warn', '', 'import numpy as np', 'import pandas as pd', '', 'from seaborn._core.groupby import GroupBy', 'from seaborn._stats.base import Stat', '', 'from typing import TYPE_CHECKING', 'if TYPE_CHECKING:', '    from numpy.typing import ArrayLike', '', '', '@dataclass', 'class Hist(Stat):', '    \"\"\"', '    Bin observations, count them, and optionally normalize or cumulate.', '', '    Parameters', '    ----------', '    stat : str', '        Aggregate statistic to compute in each bin:', '', '        - `count`: the number of observations', '        - `density`: normalize so that the total area of the histogram equals 1', '        - `percent`: normalize so that bar heights sum to 100', '        - `probability` or `proportion`: normalize so that bar heights sum to 1', '        - `frequency`: divide the number of observations by the bin width', '', '    bins : str, int, or ArrayLike', '        Generic parameter that can be the name of a reference rule, the number', '        of bins, or the bin breaks. Passed to :func:`numpy.histogram_bin_edges`.', '    binwidth : float', '        Width of each bin; overrides `bins` but can be used with `binrange`.', '    binrange : (min, max)', '        Lowest and highest value for bin edges; can be used with either', '        `bins` (when a number) or `binwidth`. Defaults to data extremes.', '    common_norm : bool or list of variables', '        When not `False`, the normalization is applied across groups. Use', '        `True` to normalize across all groups, or pass variable name(s) that', '        define normalization groups.', '    common_bins : bool or list of variables', '        When not `False`, the same bins are used for all groups. Use `True` to', '        share bins across all groups, or pass variable name(s) to share within.', '    cumulative : bool', '        If True, cumulate the bin values.', '    discrete : bool', '        If True, set `binwidth` and `binrange` so that bins have unit width and', '        are centered on integer values', '', '    Notes', '    -----', '', '    The choice of bins for computing and plotting a histogram can exert', '    substantial influence on the insights that one is able to draw from the', '    visualization. If the bins are too large, they may erase important features.', '    On the other hand, bins that are too small may be dominated by random', '    variability, obscuring the shape of the true underlying distribution. The', '    default bin size is determined using a reference rule that depends on the', '    sample size and variance. This works well in many cases, (i.e., with', '    \"well-behaved\" data) but it fails in others. It is always a good to try', '    different bin sizes to be sure that you are not missing something important.', '    This function allows you to specify bins in several different ways, such as', '    by setting the total number of bins to use, the width of each bin, or the', '    specific locations where the bins should break.', '', '', '    Examples', '    --------', '    .. include:: ../docstrings/objects.Hist.rst', '', '    \"\"\"', '    stat: str = \"count\"', '    bins: str | int | ArrayLike = \"auto\"', '    binwidth: float | None = None', '    binrange: tuple[float, float] | None = None', '    common_norm: bool | list[str] = True', '    common_bins: bool | list[str] = True', '    cumulative: bool = False', '    discrete: bool = False', '', '    def __post_init__(self):', '', '        stat_options = [', '            \"count\", \"density\", \"percent\", \"probability\", \"proportion\", \"frequency\"', '        ]', '        self._check_param_one_of(\"stat\", stat_options)', '', '    def _define_bin_edges(self, vals, weight, bins, binwidth, binrange, discrete):', '        \"\"\"Inner function that takes bin parameters as arguments.\"\"\"', '        vals = vals.dropna()', '', '        if binrange is None:', '            start, stop = vals.min(), vals.max()', '        else:', '            start, stop = binrange', '', '        if discrete:', '            bin_edges = np.arange(start - .5, stop + 1.5)', '        elif binwidth is not None:', '            step = binwidth', '            bin_edges = np.arange(start, stop + step, step)', '        else:', '            bin_edges = np.histogram_bin_edges(vals, bins, binrange, weight)', '', '        # TODO warning or cap on too many bins?', '', '        return bin_edges', '', '    def _define_bin_params(self, data, orient, scale_type):', '        \"\"\"Given data, return numpy.histogram parameters to define bins.\"\"\"', '        vals = data[orient]', '        weights = data.get(\"weight\", None)', '', \"        # TODO We'll want this for ordinal / discrete scales too\", '        # (Do we need discrete as a parameter or just infer from scale?)', '        discrete = self.discrete or scale_type == \"nominal\"', '', '        bin_edges = self._define_bin_edges(', '            vals, weights, self.bins, self.binwidth, self.binrange, discrete,', '        )', '', '        if isinstance(self.bins, (str, int)):', '            n_bins = len(bin_edges) - 1', '            bin_range = bin_edges.min(), bin_edges.max()', '            bin_kws = dict(bins=n_bins, range=bin_range)', '        else:', '            bin_kws = dict(bins=bin_edges)', '', '        return bin_kws', '', '    def _get_bins_and_eval(self, data, orient, groupby, scale_type):', '', '        bin_kws = self._define_bin_params(data, orient, scale_type)', '        return groupby.apply(data, self._eval, orient, bin_kws)', '', '    def _eval(self, data, orient, bin_kws):', '', '        vals = data[orient]', '        weights = data.get(\"weight\", None)', '', '        density = self.stat == \"density\"', '        hist, edges = np.histogram(vals, **bin_kws, weights=weights, density=density)', '', '        width = np.diff(edges)', '        center = edges[:-1] + width / 2', '', '        return pd.DataFrame({orient: center, \"count\": hist, \"space\": width})', '', '    def _normalize(self, data):', '', '        hist = data[\"count\"]', '        if self.stat == \"probability\" or self.stat == \"proportion\":', '            hist = hist.astype(float) / hist.sum()', '        elif self.stat == \"percent\":', '            hist = hist.astype(float) / hist.sum() * 100', '        elif self.stat == \"frequency\":', '            hist = hist.astype(float) / data[\"space\"]', '', '        if self.cumulative:', '            if self.stat in [\"density\", \"frequency\"]:', '                hist = (hist * data[\"space\"]).cumsum()', '            else:', '                hist = hist.cumsum()', '', '        return data.assign(**{self.stat: hist})', '', '    def __call__(self, data, groupby, orient, scales):', '', '        scale_type = scales[orient].__class__.__name__.lower()', '        grouping_vars = [v for v in data if v in groupby.order]', '        if not grouping_vars or self.common_bins is True:', '            bin_kws = self._define_bin_params(data, orient, scale_type)', '            data = groupby.apply(data, self._eval, orient, bin_kws)', '        else:', '            if self.common_bins is False:', '                bin_groupby = GroupBy(grouping_vars)', '            else:', '                bin_groupby = GroupBy(self.common_bins)', '                undefined = set(self.common_bins) - set(grouping_vars)', '                if undefined:', '                    param = f\"{self.__class__.__name__}.common_bins\"', '                    names = \", \".join(f\"{x!r}\" for x in undefined)', '                    msg = f\"Undefined variables(s) passed to `{param}`: {names}.\"', '                    warn(msg)', '            data = bin_groupby.apply(', '                data, self._get_bins_and_eval, orient, groupby, scale_type,', '            )', '', '        if not grouping_vars or self.common_norm is True:', '            data = self._normalize(data)', '        else:', '            if self.common_norm is False:', '                norm_grouper = grouping_vars', '            else:', '                norm_grouper = self.common_norm', '                undefined = set(self.common_norm) - set(grouping_vars)', '                if undefined:', '                    param = f\"{self.__class__.__name__}.common_norm\"', '                    names = \", \".join(f\"{x!r}\" for x in undefined)', '                    msg = f\"Undefined variables(s) passed to `{param}`: {names}.\"', '                    warn(msg)', '            data = GroupBy(norm_grouper).apply(data, self._normalize)', '', '        other = {\"x\": \"y\", \"y\": \"x\"}[orient]', '        return data.assign(**{other: data[self.stat]})']}, 'regression.py': {'classes': [{'name': 'PolyFit', 'start_line': 11, 'end_line': 44, 'text': ['class PolyFit(Stat):', '    \"\"\"', '    Fit a polynomial of the given order and resample data onto predicted curve.', '    \"\"\"', '    # This is a provisional class that is useful for building out functionality.', '    # It may or may not change substantially in form or dissappear as we think', '    # through the organization of the stats subpackage.', '', '    order: int = 2', '    gridsize: int = 100', '', '    def _fit_predict(self, data):', '', '        x = data[\"x\"]', '        y = data[\"y\"]', '        if x.nunique() <= self.order:', '            # TODO warn?', '            xx = yy = []', '        else:', '            p = np.polyfit(x, y, self.order)', '            xx = np.linspace(x.min(), x.max(), self.gridsize)', '            yy = np.polyval(p, xx)', '', '        return pd.DataFrame(dict(x=xx, y=yy))', '', '    # TODO we should have a way of identifying the method that will be applied', '    # and then only define __call__ on a base-class of stats with this pattern', '', '    def __call__(self, data, groupby, orient, scales):', '', '        return (', '            groupby', '            .apply(data.dropna(subset=[\"x\", \"y\"]), self._fit_predict)', '        )'], 'methods': [{'name': '_fit_predict', 'start_line': 22, 'end_line': 34, 'text': ['    def _fit_predict(self, data):', '', '        x = data[\"x\"]', '        y = data[\"y\"]', '        if x.nunique() <= self.order:', '            # TODO warn?', '            xx = yy = []', '        else:', '            p = np.polyfit(x, y, self.order)', '            xx = np.linspace(x.min(), x.max(), self.gridsize)', '            yy = np.polyval(p, xx)', '', '        return pd.DataFrame(dict(x=xx, y=yy))']}, {'name': '__call__', 'start_line': 39, 'end_line': 44, 'text': ['    def __call__(self, data, groupby, orient, scales):', '', '        return (', '            groupby', '            .apply(data.dropna(subset=[\"x\", \"y\"]), self._fit_predict)', '        )']}]}, {'name': 'OLSFit', 'start_line': 48, 'end_line': 50, 'text': ['class OLSFit(Stat):', '', '    ...'], 'methods': []}], 'functions': [], 'text': ['from __future__ import annotations', 'from dataclasses import dataclass', '', 'import numpy as np', 'import pandas as pd', '', 'from seaborn._stats.base import Stat', '', '', '@dataclass', 'class PolyFit(Stat):', '    \"\"\"', '    Fit a polynomial of the given order and resample data onto predicted curve.', '    \"\"\"', '    # This is a provisional class that is useful for building out functionality.', '    # It may or may not change substantially in form or dissappear as we think', '    # through the organization of the stats subpackage.', '', '    order: int = 2', '    gridsize: int = 100', '', '    def _fit_predict(self, data):', '', '        x = data[\"x\"]', '        y = data[\"y\"]', '        if x.nunique() <= self.order:', '            # TODO warn?', '            xx = yy = []', '        else:', '            p = np.polyfit(x, y, self.order)', '            xx = np.linspace(x.min(), x.max(), self.gridsize)', '            yy = np.polyval(p, xx)', '', '        return pd.DataFrame(dict(x=xx, y=yy))', '', '    # TODO we should have a way of identifying the method that will be applied', '    # and then only define __call__ on a base-class of stats with this pattern', '', '    def __call__(self, data, groupby, orient, scales):', '', '        return (', '            groupby', '            .apply(data.dropna(subset=[\"x\", \"y\"]), self._fit_predict)', '        )', '', '', '@dataclass', 'class OLSFit(Stat):', '', '    ...']}}, 'colors': {'xkcd_rgb.py': {'classes': [], 'functions': [], 'text': [\"xkcd_rgb = {'acid green': '#8ffe09',\", \"            'adobe': '#bd6c48',\", \"            'algae': '#54ac68',\", \"            'algae green': '#21c36f',\", \"            'almost black': '#070d0d',\", \"            'amber': '#feb308',\", \"            'amethyst': '#9b5fc0',\", \"            'apple': '#6ecb3c',\", \"            'apple green': '#76cd26',\", \"            'apricot': '#ffb16d',\", \"            'aqua': '#13eac9',\", \"            'aqua blue': '#02d8e9',\", \"            'aqua green': '#12e193',\", \"            'aqua marine': '#2ee8bb',\", \"            'aquamarine': '#04d8b2',\", \"            'army green': '#4b5d16',\", \"            'asparagus': '#77ab56',\", \"            'aubergine': '#3d0734',\", \"            'auburn': '#9a3001',\", \"            'avocado': '#90b134',\", \"            'avocado green': '#87a922',\", \"            'azul': '#1d5dec',\", \"            'azure': '#069af3',\", \"            'baby blue': '#a2cffe',\", \"            'baby green': '#8cff9e',\", \"            'baby pink': '#ffb7ce',\", \"            'baby poo': '#ab9004',\", \"            'baby poop': '#937c00',\", \"            'baby poop green': '#8f9805',\", \"            'baby puke green': '#b6c406',\", \"            'baby purple': '#ca9bf7',\", \"            'baby shit brown': '#ad900d',\", \"            'baby shit green': '#889717',\", \"            'banana': '#ffff7e',\", \"            'banana yellow': '#fafe4b',\", \"            'barbie pink': '#fe46a5',\", \"            'barf green': '#94ac02',\", \"            'barney': '#ac1db8',\", \"            'barney purple': '#a00498',\", \"            'battleship grey': '#6b7c85',\", \"            'beige': '#e6daa6',\", \"            'berry': '#990f4b',\", \"            'bile': '#b5c306',\", \"            'black': '#000000',\", \"            'bland': '#afa88b',\", \"            'blood': '#770001',\", \"            'blood orange': '#fe4b03',\", \"            'blood red': '#980002',\", \"            'blue': '#0343df',\", \"            'blue blue': '#2242c7',\", \"            'blue green': '#137e6d',\", \"            'blue grey': '#607c8e',\", \"            'blue purple': '#5729ce',\", \"            'blue violet': '#5d06e9',\", \"            'blue with a hint of purple': '#533cc6',\", \"            'blue/green': '#0f9b8e',\", \"            'blue/grey': '#758da3',\", \"            'blue/purple': '#5a06ef',\", \"            'blueberry': '#464196',\", \"            'bluegreen': '#017a79',\", \"            'bluegrey': '#85a3b2',\", \"            'bluey green': '#2bb179',\", \"            'bluey grey': '#89a0b0',\", \"            'bluey purple': '#6241c7',\", \"            'bluish': '#2976bb',\", \"            'bluish green': '#10a674',\", \"            'bluish grey': '#748b97',\", \"            'bluish purple': '#703be7',\", \"            'blurple': '#5539cc',\", \"            'blush': '#f29e8e',\", \"            'blush pink': '#fe828c',\", \"            'booger': '#9bb53c',\", \"            'booger green': '#96b403',\", \"            'bordeaux': '#7b002c',\", \"            'boring green': '#63b365',\", \"            'bottle green': '#044a05',\", \"            'brick': '#a03623',\", \"            'brick orange': '#c14a09',\", \"            'brick red': '#8f1402',\", \"            'bright aqua': '#0bf9ea',\", \"            'bright blue': '#0165fc',\", \"            'bright cyan': '#41fdfe',\", \"            'bright green': '#01ff07',\", \"            'bright lavender': '#c760ff',\", \"            'bright light blue': '#26f7fd',\", \"            'bright light green': '#2dfe54',\", \"            'bright lilac': '#c95efb',\", \"            'bright lime': '#87fd05',\", \"            'bright lime green': '#65fe08',\", \"            'bright magenta': '#ff08e8',\", \"            'bright olive': '#9cbb04',\", \"            'bright orange': '#ff5b00',\", \"            'bright pink': '#fe01b1',\", \"            'bright purple': '#be03fd',\", \"            'bright red': '#ff000d',\", \"            'bright sea green': '#05ffa6',\", \"            'bright sky blue': '#02ccfe',\", \"            'bright teal': '#01f9c6',\", \"            'bright turquoise': '#0ffef9',\", \"            'bright violet': '#ad0afd',\", \"            'bright yellow': '#fffd01',\", \"            'bright yellow green': '#9dff00',\", \"            'british racing green': '#05480d',\", \"            'bronze': '#a87900',\", \"            'brown': '#653700',\", \"            'brown green': '#706c11',\", \"            'brown grey': '#8d8468',\", \"            'brown orange': '#b96902',\", \"            'brown red': '#922b05',\", \"            'brown yellow': '#b29705',\", \"            'brownish': '#9c6d57',\", \"            'brownish green': '#6a6e09',\", \"            'brownish grey': '#86775f',\", \"            'brownish orange': '#cb7723',\", \"            'brownish pink': '#c27e79',\", \"            'brownish purple': '#76424e',\", \"            'brownish red': '#9e3623',\", \"            'brownish yellow': '#c9b003',\", \"            'browny green': '#6f6c0a',\", \"            'browny orange': '#ca6b02',\", \"            'bruise': '#7e4071',\", \"            'bubble gum pink': '#ff69af',\", \"            'bubblegum': '#ff6cb5',\", \"            'bubblegum pink': '#fe83cc',\", \"            'buff': '#fef69e',\", \"            'burgundy': '#610023',\", \"            'burnt orange': '#c04e01',\", \"            'burnt red': '#9f2305',\", \"            'burnt siena': '#b75203',\", \"            'burnt sienna': '#b04e0f',\", \"            'burnt umber': '#a0450e',\", \"            'burnt yellow': '#d5ab09',\", \"            'burple': '#6832e3',\", \"            'butter': '#ffff81',\", \"            'butter yellow': '#fffd74',\", \"            'butterscotch': '#fdb147',\", \"            'cadet blue': '#4e7496',\", \"            'camel': '#c69f59',\", \"            'camo': '#7f8f4e',\", \"            'camo green': '#526525',\", \"            'camouflage green': '#4b6113',\", \"            'canary': '#fdff63',\", \"            'canary yellow': '#fffe40',\", \"            'candy pink': '#ff63e9',\", \"            'caramel': '#af6f09',\", \"            'carmine': '#9d0216',\", \"            'carnation': '#fd798f',\", \"            'carnation pink': '#ff7fa7',\", \"            'carolina blue': '#8ab8fe',\", \"            'celadon': '#befdb7',\", \"            'celery': '#c1fd95',\", \"            'cement': '#a5a391',\", \"            'cerise': '#de0c62',\", \"            'cerulean': '#0485d1',\", \"            'cerulean blue': '#056eee',\", \"            'charcoal': '#343837',\", \"            'charcoal grey': '#3c4142',\", \"            'chartreuse': '#c1f80a',\", \"            'cherry': '#cf0234',\", \"            'cherry red': '#f7022a',\", \"            'chestnut': '#742802',\", \"            'chocolate': '#3d1c02',\", \"            'chocolate brown': '#411900',\", \"            'cinnamon': '#ac4f06',\", \"            'claret': '#680018',\", \"            'clay': '#b66a50',\", \"            'clay brown': '#b2713d',\", \"            'clear blue': '#247afd',\", \"            'cloudy blue': '#acc2d9',\", \"            'cobalt': '#1e488f',\", \"            'cobalt blue': '#030aa7',\", \"            'cocoa': '#875f42',\", \"            'coffee': '#a6814c',\", \"            'cool blue': '#4984b8',\", \"            'cool green': '#33b864',\", \"            'cool grey': '#95a3a6',\", \"            'copper': '#b66325',\", \"            'coral': '#fc5a50',\", \"            'coral pink': '#ff6163',\", \"            'cornflower': '#6a79f7',\", \"            'cornflower blue': '#5170d7',\", \"            'cranberry': '#9e003a',\", \"            'cream': '#ffffc2',\", \"            'creme': '#ffffb6',\", \"            'crimson': '#8c000f',\", \"            'custard': '#fffd78',\", \"            'cyan': '#00ffff',\", \"            'dandelion': '#fedf08',\", \"            'dark': '#1b2431',\", \"            'dark aqua': '#05696b',\", \"            'dark aquamarine': '#017371',\", \"            'dark beige': '#ac9362',\", \"            'dark blue': '#00035b',\", \"            'dark blue green': '#005249',\", \"            'dark blue grey': '#1f3b4d',\", \"            'dark brown': '#341c02',\", \"            'dark coral': '#cf524e',\", \"            'dark cream': '#fff39a',\", \"            'dark cyan': '#0a888a',\", \"            'dark forest green': '#002d04',\", \"            'dark fuchsia': '#9d0759',\", \"            'dark gold': '#b59410',\", \"            'dark grass green': '#388004',\", \"            'dark green': '#033500',\", \"            'dark green blue': '#1f6357',\", \"            'dark grey': '#363737',\", \"            'dark grey blue': '#29465b',\", \"            'dark hot pink': '#d90166',\", \"            'dark indigo': '#1f0954',\", \"            'dark khaki': '#9b8f55',\", \"            'dark lavender': '#856798',\", \"            'dark lilac': '#9c6da5',\", \"            'dark lime': '#84b701',\", \"            'dark lime green': '#7ebd01',\", \"            'dark magenta': '#960056',\", \"            'dark maroon': '#3c0008',\", \"            'dark mauve': '#874c62',\", \"            'dark mint': '#48c072',\", \"            'dark mint green': '#20c073',\", \"            'dark mustard': '#a88905',\", \"            'dark navy': '#000435',\", \"            'dark navy blue': '#00022e',\", \"            'dark olive': '#373e02',\", \"            'dark olive green': '#3c4d03',\", \"            'dark orange': '#c65102',\", \"            'dark pastel green': '#56ae57',\", \"            'dark peach': '#de7e5d',\", \"            'dark periwinkle': '#665fd1',\", \"            'dark pink': '#cb416b',\", \"            'dark plum': '#3f012c',\", \"            'dark purple': '#35063e',\", \"            'dark red': '#840000',\", \"            'dark rose': '#b5485d',\", \"            'dark royal blue': '#02066f',\", \"            'dark sage': '#598556',\", \"            'dark salmon': '#c85a53',\", \"            'dark sand': '#a88f59',\", \"            'dark sea green': '#11875d',\", \"            'dark seafoam': '#1fb57a',\", \"            'dark seafoam green': '#3eaf76',\", \"            'dark sky blue': '#448ee4',\", \"            'dark slate blue': '#214761',\", \"            'dark tan': '#af884a',\", \"            'dark taupe': '#7f684e',\", \"            'dark teal': '#014d4e',\", \"            'dark turquoise': '#045c5a',\", \"            'dark violet': '#34013f',\", \"            'dark yellow': '#d5b60a',\", \"            'dark yellow green': '#728f02',\", \"            'darkblue': '#030764',\", \"            'darkgreen': '#054907',\", \"            'darkish blue': '#014182',\", \"            'darkish green': '#287c37',\", \"            'darkish pink': '#da467d',\", \"            'darkish purple': '#751973',\", \"            'darkish red': '#a90308',\", \"            'deep aqua': '#08787f',\", \"            'deep blue': '#040273',\", \"            'deep brown': '#410200',\", \"            'deep green': '#02590f',\", \"            'deep lavender': '#8d5eb7',\", \"            'deep lilac': '#966ebd',\", \"            'deep magenta': '#a0025c',\", \"            'deep orange': '#dc4d01',\", \"            'deep pink': '#cb0162',\", \"            'deep purple': '#36013f',\", \"            'deep red': '#9a0200',\", \"            'deep rose': '#c74767',\", \"            'deep sea blue': '#015482',\", \"            'deep sky blue': '#0d75f8',\", \"            'deep teal': '#00555a',\", \"            'deep turquoise': '#017374',\", \"            'deep violet': '#490648',\", \"            'denim': '#3b638c',\", \"            'denim blue': '#3b5b92',\", \"            'desert': '#ccad60',\", \"            'diarrhea': '#9f8303',\", \"            'dirt': '#8a6e45',\", \"            'dirt brown': '#836539',\", \"            'dirty blue': '#3f829d',\", \"            'dirty green': '#667e2c',\", \"            'dirty orange': '#c87606',\", \"            'dirty pink': '#ca7b80',\", \"            'dirty purple': '#734a65',\", \"            'dirty yellow': '#cdc50a',\", \"            'dodger blue': '#3e82fc',\", \"            'drab': '#828344',\", \"            'drab green': '#749551',\", \"            'dried blood': '#4b0101',\", \"            'duck egg blue': '#c3fbf4',\", \"            'dull blue': '#49759c',\", \"            'dull brown': '#876e4b',\", \"            'dull green': '#74a662',\", \"            'dull orange': '#d8863b',\", \"            'dull pink': '#d5869d',\", \"            'dull purple': '#84597e',\", \"            'dull red': '#bb3f3f',\", \"            'dull teal': '#5f9e8f',\", \"            'dull yellow': '#eedc5b',\", \"            'dusk': '#4e5481',\", \"            'dusk blue': '#26538d',\", \"            'dusky blue': '#475f94',\", \"            'dusky pink': '#cc7a8b',\", \"            'dusky purple': '#895b7b',\", \"            'dusky rose': '#ba6873',\", \"            'dust': '#b2996e',\", \"            'dusty blue': '#5a86ad',\", \"            'dusty green': '#76a973',\", \"            'dusty lavender': '#ac86a8',\", \"            'dusty orange': '#f0833a',\", \"            'dusty pink': '#d58a94',\", \"            'dusty purple': '#825f87',\", \"            'dusty red': '#b9484e',\", \"            'dusty rose': '#c0737a',\", \"            'dusty teal': '#4c9085',\", \"            'earth': '#a2653e',\", \"            'easter green': '#8cfd7e',\", \"            'easter purple': '#c071fe',\", \"            'ecru': '#feffca',\", \"            'egg shell': '#fffcc4',\", \"            'eggplant': '#380835',\", \"            'eggplant purple': '#430541',\", \"            'eggshell': '#ffffd4',\", \"            'eggshell blue': '#c4fff7',\", \"            'electric blue': '#0652ff',\", \"            'electric green': '#21fc0d',\", \"            'electric lime': '#a8ff04',\", \"            'electric pink': '#ff0490',\", \"            'electric purple': '#aa23ff',\", \"            'emerald': '#01a049',\", \"            'emerald green': '#028f1e',\", \"            'evergreen': '#05472a',\", \"            'faded blue': '#658cbb',\", \"            'faded green': '#7bb274',\", \"            'faded orange': '#f0944d',\", \"            'faded pink': '#de9dac',\", \"            'faded purple': '#916e99',\", \"            'faded red': '#d3494e',\", \"            'faded yellow': '#feff7f',\", \"            'fawn': '#cfaf7b',\", \"            'fern': '#63a950',\", \"            'fern green': '#548d44',\", \"            'fire engine red': '#fe0002',\", \"            'flat blue': '#3c73a8',\", \"            'flat green': '#699d4c',\", \"            'fluorescent green': '#08ff08',\", \"            'fluro green': '#0aff02',\", \"            'foam green': '#90fda9',\", \"            'forest': '#0b5509',\", \"            'forest green': '#06470c',\", \"            'forrest green': '#154406',\", \"            'french blue': '#436bad',\", \"            'fresh green': '#69d84f',\", \"            'frog green': '#58bc08',\", \"            'fuchsia': '#ed0dd9',\", \"            'gold': '#dbb40c',\", \"            'golden': '#f5bf03',\", \"            'golden brown': '#b27a01',\", \"            'golden rod': '#f9bc08',\", \"            'golden yellow': '#fec615',\", \"            'goldenrod': '#fac205',\", \"            'grape': '#6c3461',\", \"            'grape purple': '#5d1451',\", \"            'grapefruit': '#fd5956',\", \"            'grass': '#5cac2d',\", \"            'grass green': '#3f9b0b',\", \"            'grassy green': '#419c03',\", \"            'green': '#15b01a',\", \"            'green apple': '#5edc1f',\", \"            'green blue': '#06b48b',\", \"            'green brown': '#544e03',\", \"            'green grey': '#77926f',\", \"            'green teal': '#0cb577',\", \"            'green yellow': '#c9ff27',\", \"            'green/blue': '#01c08d',\", \"            'green/yellow': '#b5ce08',\", \"            'greenblue': '#23c48b',\", \"            'greenish': '#40a368',\", \"            'greenish beige': '#c9d179',\", \"            'greenish blue': '#0b8b87',\", \"            'greenish brown': '#696112',\", \"            'greenish cyan': '#2afeb7',\", \"            'greenish grey': '#96ae8d',\", \"            'greenish tan': '#bccb7a',\", \"            'greenish teal': '#32bf84',\", \"            'greenish turquoise': '#00fbb0',\", \"            'greenish yellow': '#cdfd02',\", \"            'greeny blue': '#42b395',\", \"            'greeny brown': '#696006',\", \"            'greeny grey': '#7ea07a',\", \"            'greeny yellow': '#c6f808',\", \"            'grey': '#929591',\", \"            'grey blue': '#6b8ba4',\", \"            'grey brown': '#7f7053',\", \"            'grey green': '#789b73',\", \"            'grey pink': '#c3909b',\", \"            'grey purple': '#826d8c',\", \"            'grey teal': '#5e9b8a',\", \"            'grey/blue': '#647d8e',\", \"            'grey/green': '#86a17d',\", \"            'greyblue': '#77a1b5',\", \"            'greyish': '#a8a495',\", \"            'greyish blue': '#5e819d',\", \"            'greyish brown': '#7a6a4f',\", \"            'greyish green': '#82a67d',\", \"            'greyish pink': '#c88d94',\", \"            'greyish purple': '#887191',\", \"            'greyish teal': '#719f91',\", \"            'gross green': '#a0bf16',\", \"            'gunmetal': '#536267',\", \"            'hazel': '#8e7618',\", \"            'heather': '#a484ac',\", \"            'heliotrope': '#d94ff5',\", \"            'highlighter green': '#1bfc06',\", \"            'hospital green': '#9be5aa',\", \"            'hot green': '#25ff29',\", \"            'hot magenta': '#f504c9',\", \"            'hot pink': '#ff028d',\", \"            'hot purple': '#cb00f5',\", \"            'hunter green': '#0b4008',\", \"            'ice': '#d6fffa',\", \"            'ice blue': '#d7fffe',\", \"            'icky green': '#8fae22',\", \"            'indian red': '#850e04',\", \"            'indigo': '#380282',\", \"            'indigo blue': '#3a18b1',\", \"            'iris': '#6258c4',\", \"            'irish green': '#019529',\", \"            'ivory': '#ffffcb',\", \"            'jade': '#1fa774',\", \"            'jade green': '#2baf6a',\", \"            'jungle green': '#048243',\", \"            'kelley green': '#009337',\", \"            'kelly green': '#02ab2e',\", \"            'kermit green': '#5cb200',\", \"            'key lime': '#aeff6e',\", \"            'khaki': '#aaa662',\", \"            'khaki green': '#728639',\", \"            'kiwi': '#9cef43',\", \"            'kiwi green': '#8ee53f',\", \"            'lavender': '#c79fef',\", \"            'lavender blue': '#8b88f8',\", \"            'lavender pink': '#dd85d7',\", \"            'lawn green': '#4da409',\", \"            'leaf': '#71aa34',\", \"            'leaf green': '#5ca904',\", \"            'leafy green': '#51b73b',\", \"            'leather': '#ac7434',\", \"            'lemon': '#fdff52',\", \"            'lemon green': '#adf802',\", \"            'lemon lime': '#bffe28',\", \"            'lemon yellow': '#fdff38',\", \"            'lichen': '#8fb67b',\", \"            'light aqua': '#8cffdb',\", \"            'light aquamarine': '#7bfdc7',\", \"            'light beige': '#fffeb6',\", \"            'light blue': '#95d0fc',\", \"            'light blue green': '#7efbb3',\", \"            'light blue grey': '#b7c9e2',\", \"            'light bluish green': '#76fda8',\", \"            'light bright green': '#53fe5c',\", \"            'light brown': '#ad8150',\", \"            'light burgundy': '#a8415b',\", \"            'light cyan': '#acfffc',\", \"            'light eggplant': '#894585',\", \"            'light forest green': '#4f9153',\", \"            'light gold': '#fddc5c',\", \"            'light grass green': '#9af764',\", \"            'light green': '#96f97b',\", \"            'light green blue': '#56fca2',\", \"            'light greenish blue': '#63f7b4',\", \"            'light grey': '#d8dcd6',\", \"            'light grey blue': '#9dbcd4',\", \"            'light grey green': '#b7e1a1',\", \"            'light indigo': '#6d5acf',\", \"            'light khaki': '#e6f2a2',\", \"            'light lavendar': '#efc0fe',\", \"            'light lavender': '#dfc5fe',\", \"            'light light blue': '#cafffb',\", \"            'light light green': '#c8ffb0',\", \"            'light lilac': '#edc8ff',\", \"            'light lime': '#aefd6c',\", \"            'light lime green': '#b9ff66',\", \"            'light magenta': '#fa5ff7',\", \"            'light maroon': '#a24857',\", \"            'light mauve': '#c292a1',\", \"            'light mint': '#b6ffbb',\", \"            'light mint green': '#a6fbb2',\", \"            'light moss green': '#a6c875',\", \"            'light mustard': '#f7d560',\", \"            'light navy': '#155084',\", \"            'light navy blue': '#2e5a88',\", \"            'light neon green': '#4efd54',\", \"            'light olive': '#acbf69',\", \"            'light olive green': '#a4be5c',\", \"            'light orange': '#fdaa48',\", \"            'light pastel green': '#b2fba5',\", \"            'light pea green': '#c4fe82',\", \"            'light peach': '#ffd8b1',\", \"            'light periwinkle': '#c1c6fc',\", \"            'light pink': '#ffd1df',\", \"            'light plum': '#9d5783',\", \"            'light purple': '#bf77f6',\", \"            'light red': '#ff474c',\", \"            'light rose': '#ffc5cb',\", \"            'light royal blue': '#3a2efe',\", \"            'light sage': '#bcecac',\", \"            'light salmon': '#fea993',\", \"            'light sea green': '#98f6b0',\", \"            'light seafoam': '#a0febf',\", \"            'light seafoam green': '#a7ffb5',\", \"            'light sky blue': '#c6fcff',\", \"            'light tan': '#fbeeac',\", \"            'light teal': '#90e4c1',\", \"            'light turquoise': '#7ef4cc',\", \"            'light urple': '#b36ff6',\", \"            'light violet': '#d6b4fc',\", \"            'light yellow': '#fffe7a',\", \"            'light yellow green': '#ccfd7f',\", \"            'light yellowish green': '#c2ff89',\", \"            'lightblue': '#7bc8f6',\", \"            'lighter green': '#75fd63',\", \"            'lighter purple': '#a55af4',\", \"            'lightgreen': '#76ff7b',\", \"            'lightish blue': '#3d7afd',\", \"            'lightish green': '#61e160',\", \"            'lightish purple': '#a552e6',\", \"            'lightish red': '#fe2f4a',\", \"            'lilac': '#cea2fd',\", \"            'liliac': '#c48efd',\", \"            'lime': '#aaff32',\", \"            'lime green': '#89fe05',\", \"            'lime yellow': '#d0fe1d',\", \"            'lipstick': '#d5174e',\", \"            'lipstick red': '#c0022f',\", \"            'macaroni and cheese': '#efb435',\", \"            'magenta': '#c20078',\", \"            'mahogany': '#4a0100',\", \"            'maize': '#f4d054',\", \"            'mango': '#ffa62b',\", \"            'manilla': '#fffa86',\", \"            'marigold': '#fcc006',\", \"            'marine': '#042e60',\", \"            'marine blue': '#01386a',\", \"            'maroon': '#650021',\", \"            'mauve': '#ae7181',\", \"            'medium blue': '#2c6fbb',\", \"            'medium brown': '#7f5112',\", \"            'medium green': '#39ad48',\", \"            'medium grey': '#7d7f7c',\", \"            'medium pink': '#f36196',\", \"            'medium purple': '#9e43a2',\", \"            'melon': '#ff7855',\", \"            'merlot': '#730039',\", \"            'metallic blue': '#4f738e',\", \"            'mid blue': '#276ab3',\", \"            'mid green': '#50a747',\", \"            'midnight': '#03012d',\", \"            'midnight blue': '#020035',\", \"            'midnight purple': '#280137',\", \"            'military green': '#667c3e',\", \"            'milk chocolate': '#7f4e1e',\", \"            'mint': '#9ffeb0',\", \"            'mint green': '#8fff9f',\", \"            'minty green': '#0bf77d',\", \"            'mocha': '#9d7651',\", \"            'moss': '#769958',\", \"            'moss green': '#658b38',\", \"            'mossy green': '#638b27',\", \"            'mud': '#735c12',\", \"            'mud brown': '#60460f',\", \"            'mud green': '#606602',\", \"            'muddy brown': '#886806',\", \"            'muddy green': '#657432',\", \"            'muddy yellow': '#bfac05',\", \"            'mulberry': '#920a4e',\", \"            'murky green': '#6c7a0e',\", \"            'mushroom': '#ba9e88',\", \"            'mustard': '#ceb301',\", \"            'mustard brown': '#ac7e04',\", \"            'mustard green': '#a8b504',\", \"            'mustard yellow': '#d2bd0a',\", \"            'muted blue': '#3b719f',\", \"            'muted green': '#5fa052',\", \"            'muted pink': '#d1768f',\", \"            'muted purple': '#805b87',\", \"            'nasty green': '#70b23f',\", \"            'navy': '#01153e',\", \"            'navy blue': '#001146',\", \"            'navy green': '#35530a',\", \"            'neon blue': '#04d9ff',\", \"            'neon green': '#0cff0c',\", \"            'neon pink': '#fe019a',\", \"            'neon purple': '#bc13fe',\", \"            'neon red': '#ff073a',\", \"            'neon yellow': '#cfff04',\", \"            'nice blue': '#107ab0',\", \"            'night blue': '#040348',\", \"            'ocean': '#017b92',\", \"            'ocean blue': '#03719c',\", \"            'ocean green': '#3d9973',\", \"            'ocher': '#bf9b0c',\", \"            'ochre': '#bf9005',\", \"            'ocre': '#c69c04',\", \"            'off blue': '#5684ae',\", \"            'off green': '#6ba353',\", \"            'off white': '#ffffe4',\", \"            'off yellow': '#f1f33f',\", \"            'old pink': '#c77986',\", \"            'old rose': '#c87f89',\", \"            'olive': '#6e750e',\", \"            'olive brown': '#645403',\", \"            'olive drab': '#6f7632',\", \"            'olive green': '#677a04',\", \"            'olive yellow': '#c2b709',\", \"            'orange': '#f97306',\", \"            'orange brown': '#be6400',\", \"            'orange pink': '#ff6f52',\", \"            'orange red': '#fd411e',\", \"            'orange yellow': '#ffad01',\", \"            'orangeish': '#fd8d49',\", \"            'orangered': '#fe420f',\", \"            'orangey brown': '#b16002',\", \"            'orangey red': '#fa4224',\", \"            'orangey yellow': '#fdb915',\", \"            'orangish': '#fc824a',\", \"            'orangish brown': '#b25f03',\", \"            'orangish red': '#f43605',\", \"            'orchid': '#c875c4',\", \"            'pale': '#fff9d0',\", \"            'pale aqua': '#b8ffeb',\", \"            'pale blue': '#d0fefe',\", \"            'pale brown': '#b1916e',\", \"            'pale cyan': '#b7fffa',\", \"            'pale gold': '#fdde6c',\", \"            'pale green': '#c7fdb5',\", \"            'pale grey': '#fdfdfe',\", \"            'pale lavender': '#eecffe',\", \"            'pale light green': '#b1fc99',\", \"            'pale lilac': '#e4cbff',\", \"            'pale lime': '#befd73',\", \"            'pale lime green': '#b1ff65',\", \"            'pale magenta': '#d767ad',\", \"            'pale mauve': '#fed0fc',\", \"            'pale olive': '#b9cc81',\", \"            'pale olive green': '#b1d27b',\", \"            'pale orange': '#ffa756',\", \"            'pale peach': '#ffe5ad',\", \"            'pale pink': '#ffcfdc',\", \"            'pale purple': '#b790d4',\", \"            'pale red': '#d9544d',\", \"            'pale rose': '#fdc1c5',\", \"            'pale salmon': '#ffb19a',\", \"            'pale sky blue': '#bdf6fe',\", \"            'pale teal': '#82cbb2',\", \"            'pale turquoise': '#a5fbd5',\", \"            'pale violet': '#ceaefa',\", \"            'pale yellow': '#ffff84',\", \"            'parchment': '#fefcaf',\", \"            'pastel blue': '#a2bffe',\", \"            'pastel green': '#b0ff9d',\", \"            'pastel orange': '#ff964f',\", \"            'pastel pink': '#ffbacd',\", \"            'pastel purple': '#caa0ff',\", \"            'pastel red': '#db5856',\", \"            'pastel yellow': '#fffe71',\", \"            'pea': '#a4bf20',\", \"            'pea green': '#8eab12',\", \"            'pea soup': '#929901',\", \"            'pea soup green': '#94a617',\", \"            'peach': '#ffb07c',\", \"            'peachy pink': '#ff9a8a',\", \"            'peacock blue': '#016795',\", \"            'pear': '#cbf85f',\", \"            'periwinkle': '#8e82fe',\", \"            'periwinkle blue': '#8f99fb',\", \"            'perrywinkle': '#8f8ce7',\", \"            'petrol': '#005f6a',\", \"            'pig pink': '#e78ea5',\", \"            'pine': '#2b5d34',\", \"            'pine green': '#0a481e',\", \"            'pink': '#ff81c0',\", \"            'pink purple': '#db4bda',\", \"            'pink red': '#f5054f',\", \"            'pink/purple': '#ef1de7',\", \"            'pinkish': '#d46a7e',\", \"            'pinkish brown': '#b17261',\", \"            'pinkish grey': '#c8aca9',\", \"            'pinkish orange': '#ff724c',\", \"            'pinkish purple': '#d648d7',\", \"            'pinkish red': '#f10c45',\", \"            'pinkish tan': '#d99b82',\", \"            'pinky': '#fc86aa',\", \"            'pinky purple': '#c94cbe',\", \"            'pinky red': '#fc2647',\", \"            'piss yellow': '#ddd618',\", \"            'pistachio': '#c0fa8b',\", \"            'plum': '#580f41',\", \"            'plum purple': '#4e0550',\", \"            'poison green': '#40fd14',\", \"            'poo': '#8f7303',\", \"            'poo brown': '#885f01',\", \"            'poop': '#7f5e00',\", \"            'poop brown': '#7a5901',\", \"            'poop green': '#6f7c00',\", \"            'powder blue': '#b1d1fc',\", \"            'powder pink': '#ffb2d0',\", \"            'primary blue': '#0804f9',\", \"            'prussian blue': '#004577',\", \"            'puce': '#a57e52',\", \"            'puke': '#a5a502',\", \"            'puke brown': '#947706',\", \"            'puke green': '#9aae07',\", \"            'puke yellow': '#c2be0e',\", \"            'pumpkin': '#e17701',\", \"            'pumpkin orange': '#fb7d07',\", \"            'pure blue': '#0203e2',\", \"            'purple': '#7e1e9c',\", \"            'purple blue': '#632de9',\", \"            'purple brown': '#673a3f',\", \"            'purple grey': '#866f85',\", \"            'purple pink': '#e03fd8',\", \"            'purple red': '#990147',\", \"            'purple/blue': '#5d21d0',\", \"            'purple/pink': '#d725de',\", \"            'purpleish': '#98568d',\", \"            'purpleish blue': '#6140ef',\", \"            'purpleish pink': '#df4ec8',\", \"            'purpley': '#8756e4',\", \"            'purpley blue': '#5f34e7',\", \"            'purpley grey': '#947e94',\", \"            'purpley pink': '#c83cb9',\", \"            'purplish': '#94568c',\", \"            'purplish blue': '#601ef9',\", \"            'purplish brown': '#6b4247',\", \"            'purplish grey': '#7a687f',\", \"            'purplish pink': '#ce5dae',\", \"            'purplish red': '#b0054b',\", \"            'purply': '#983fb2',\", \"            'purply blue': '#661aee',\", \"            'purply pink': '#f075e6',\", \"            'putty': '#beae8a',\", \"            'racing green': '#014600',\", \"            'radioactive green': '#2cfa1f',\", \"            'raspberry': '#b00149',\", \"            'raw sienna': '#9a6200',\", \"            'raw umber': '#a75e09',\", \"            'really light blue': '#d4ffff',\", \"            'red': '#e50000',\", \"            'red brown': '#8b2e16',\", \"            'red orange': '#fd3c06',\", \"            'red pink': '#fa2a55',\", \"            'red purple': '#820747',\", \"            'red violet': '#9e0168',\", \"            'red wine': '#8c0034',\", \"            'reddish': '#c44240',\", \"            'reddish brown': '#7f2b0a',\", \"            'reddish grey': '#997570',\", \"            'reddish orange': '#f8481c',\", \"            'reddish pink': '#fe2c54',\", \"            'reddish purple': '#910951',\", \"            'reddy brown': '#6e1005',\", \"            'rich blue': '#021bf9',\", \"            'rich purple': '#720058',\", \"            'robin egg blue': '#8af1fe',\", '            \"robin\\'s egg\": \\'#6dedfd\\',', '            \"robin\\'s egg blue\": \\'#98eff9\\',', \"            'rosa': '#fe86a4',\", \"            'rose': '#cf6275',\", \"            'rose pink': '#f7879a',\", \"            'rose red': '#be013c',\", \"            'rosy pink': '#f6688e',\", \"            'rouge': '#ab1239',\", \"            'royal': '#0c1793',\", \"            'royal blue': '#0504aa',\", \"            'royal purple': '#4b006e',\", \"            'ruby': '#ca0147',\", \"            'russet': '#a13905',\", \"            'rust': '#a83c09',\", \"            'rust brown': '#8b3103',\", \"            'rust orange': '#c45508',\", \"            'rust red': '#aa2704',\", \"            'rusty orange': '#cd5909',\", \"            'rusty red': '#af2f0d',\", \"            'saffron': '#feb209',\", \"            'sage': '#87ae73',\", \"            'sage green': '#88b378',\", \"            'salmon': '#ff796c',\", \"            'salmon pink': '#fe7b7c',\", \"            'sand': '#e2ca76',\", \"            'sand brown': '#cba560',\", \"            'sand yellow': '#fce166',\", \"            'sandstone': '#c9ae74',\", \"            'sandy': '#f1da7a',\", \"            'sandy brown': '#c4a661',\", \"            'sandy yellow': '#fdee73',\", \"            'sap green': '#5c8b15',\", \"            'sapphire': '#2138ab',\", \"            'scarlet': '#be0119',\", \"            'sea': '#3c9992',\", \"            'sea blue': '#047495',\", \"            'sea green': '#53fca1',\", \"            'seafoam': '#80f9ad',\", \"            'seafoam blue': '#78d1b6',\", \"            'seafoam green': '#7af9ab',\", \"            'seaweed': '#18d17b',\", \"            'seaweed green': '#35ad6b',\", \"            'sepia': '#985e2b',\", \"            'shamrock': '#01b44c',\", \"            'shamrock green': '#02c14d',\", \"            'shit': '#7f5f00',\", \"            'shit brown': '#7b5804',\", \"            'shit green': '#758000',\", \"            'shocking pink': '#fe02a2',\", \"            'sick green': '#9db92c',\", \"            'sickly green': '#94b21c',\", \"            'sickly yellow': '#d0e429',\", \"            'sienna': '#a9561e',\", \"            'silver': '#c5c9c7',\", \"            'sky': '#82cafc',\", \"            'sky blue': '#75bbfd',\", \"            'slate': '#516572',\", \"            'slate blue': '#5b7c99',\", \"            'slate green': '#658d6d',\", \"            'slate grey': '#59656d',\", \"            'slime green': '#99cc04',\", \"            'snot': '#acbb0d',\", \"            'snot green': '#9dc100',\", \"            'soft blue': '#6488ea',\", \"            'soft green': '#6fc276',\", \"            'soft pink': '#fdb0c0',\", \"            'soft purple': '#a66fb5',\", \"            'spearmint': '#1ef876',\", \"            'spring green': '#a9f971',\", \"            'spruce': '#0a5f38',\", \"            'squash': '#f2ab15',\", \"            'steel': '#738595',\", \"            'steel blue': '#5a7d9a',\", \"            'steel grey': '#6f828a',\", \"            'stone': '#ada587',\", \"            'stormy blue': '#507b9c',\", \"            'straw': '#fcf679',\", \"            'strawberry': '#fb2943',\", \"            'strong blue': '#0c06f7',\", \"            'strong pink': '#ff0789',\", \"            'sun yellow': '#ffdf22',\", \"            'sunflower': '#ffc512',\", \"            'sunflower yellow': '#ffda03',\", \"            'sunny yellow': '#fff917',\", \"            'sunshine yellow': '#fffd37',\", \"            'swamp': '#698339',\", \"            'swamp green': '#748500',\", \"            'tan': '#d1b26f',\", \"            'tan brown': '#ab7e4c',\", \"            'tan green': '#a9be70',\", \"            'tangerine': '#ff9408',\", \"            'taupe': '#b9a281',\", \"            'tea': '#65ab7c',\", \"            'tea green': '#bdf8a3',\", \"            'teal': '#029386',\", \"            'teal blue': '#01889f',\", \"            'teal green': '#25a36f',\", \"            'tealish': '#24bca8',\", \"            'tealish green': '#0cdc73',\", \"            'terra cotta': '#c9643b',\", \"            'terracota': '#cb6843',\", \"            'terracotta': '#ca6641',\", \"            'tiffany blue': '#7bf2da',\", \"            'tomato': '#ef4026',\", \"            'tomato red': '#ec2d01',\", \"            'topaz': '#13bbaf',\", \"            'toupe': '#c7ac7d',\", \"            'toxic green': '#61de2a',\", \"            'tree green': '#2a7e19',\", \"            'true blue': '#010fcc',\", \"            'true green': '#089404',\", \"            'turquoise': '#06c2ac',\", \"            'turquoise blue': '#06b1c4',\", \"            'turquoise green': '#04f489',\", \"            'turtle green': '#75b84f',\", \"            'twilight': '#4e518b',\", \"            'twilight blue': '#0a437a',\", \"            'ugly blue': '#31668a',\", \"            'ugly brown': '#7d7103',\", \"            'ugly green': '#7a9703',\", \"            'ugly pink': '#cd7584',\", \"            'ugly purple': '#a442a0',\", \"            'ugly yellow': '#d0c101',\", \"            'ultramarine': '#2000b1',\", \"            'ultramarine blue': '#1805db',\", \"            'umber': '#b26400',\", \"            'velvet': '#750851',\", \"            'vermillion': '#f4320c',\", \"            'very dark blue': '#000133',\", \"            'very dark brown': '#1d0200',\", \"            'very dark green': '#062e03',\", \"            'very dark purple': '#2a0134',\", \"            'very light blue': '#d5ffff',\", \"            'very light brown': '#d3b683',\", \"            'very light green': '#d1ffbd',\", \"            'very light pink': '#fff4f2',\", \"            'very light purple': '#f6cefc',\", \"            'very pale blue': '#d6fffe',\", \"            'very pale green': '#cffdbc',\", \"            'vibrant blue': '#0339f8',\", \"            'vibrant green': '#0add08',\", \"            'vibrant purple': '#ad03de',\", \"            'violet': '#9a0eea',\", \"            'violet blue': '#510ac9',\", \"            'violet pink': '#fb5ffc',\", \"            'violet red': '#a50055',\", \"            'viridian': '#1e9167',\", \"            'vivid blue': '#152eff',\", \"            'vivid green': '#2fef10',\", \"            'vivid purple': '#9900fa',\", \"            'vomit': '#a2a415',\", \"            'vomit green': '#89a203',\", \"            'vomit yellow': '#c7c10c',\", \"            'warm blue': '#4b57db',\", \"            'warm brown': '#964e02',\", \"            'warm grey': '#978a84',\", \"            'warm pink': '#fb5581',\", \"            'warm purple': '#952e8f',\", \"            'washed out green': '#bcf5a6',\", \"            'water blue': '#0e87cc',\", \"            'watermelon': '#fd4659',\", \"            'weird green': '#3ae57f',\", \"            'wheat': '#fbdd7e',\", \"            'white': '#ffffff',\", \"            'windows blue': '#3778bf',\", \"            'wine': '#80013f',\", \"            'wine red': '#7b0323',\", \"            'wintergreen': '#20f986',\", \"            'wisteria': '#a87dc2',\", \"            'yellow': '#ffff14',\", \"            'yellow brown': '#b79400',\", \"            'yellow green': '#c0fb2d',\", \"            'yellow ochre': '#cb9d06',\", \"            'yellow orange': '#fcb001',\", \"            'yellow tan': '#ffe36e',\", \"            'yellow/green': '#c8fd3d',\", \"            'yellowgreen': '#bbf90f',\", \"            'yellowish': '#faee66',\", \"            'yellowish brown': '#9b7a01',\", \"            'yellowish green': '#b0dd16',\", \"            'yellowish orange': '#ffab0f',\", \"            'yellowish tan': '#fcfc81',\", \"            'yellowy brown': '#ae8b0c',\", \"            'yellowy green': '#bff128'}\"]}, 'crayons.py': {'classes': [], 'functions': [], 'text': [\"crayons = {'Almond': '#EFDECD',\", \"           'Antique Brass': '#CD9575',\", \"           'Apricot': '#FDD9B5',\", \"           'Aquamarine': '#78DBE2',\", \"           'Asparagus': '#87A96B',\", \"           'Atomic Tangerine': '#FFA474',\", \"           'Banana Mania': '#FAE7B5',\", \"           'Beaver': '#9F8170',\", \"           'Bittersweet': '#FD7C6E',\", \"           'Black': '#000000',\", \"           'Blue': '#1F75FE',\", \"           'Blue Bell': '#A2A2D0',\", \"           'Blue Green': '#0D98BA',\", \"           'Blue Violet': '#7366BD',\", \"           'Blush': '#DE5D83',\", \"           'Brick Red': '#CB4154',\", \"           'Brown': '#B4674D',\", \"           'Burnt Orange': '#FF7F49',\", \"           'Burnt Sienna': '#EA7E5D',\", \"           'Cadet Blue': '#B0B7C6',\", \"           'Canary': '#FFFF99',\", \"           'Caribbean Green': '#00CC99',\", \"           'Carnation Pink': '#FFAACC',\", \"           'Cerise': '#DD4492',\", \"           'Cerulean': '#1DACD6',\", \"           'Chestnut': '#BC5D58',\", \"           'Copper': '#DD9475',\", \"           'Cornflower': '#9ACEEB',\", \"           'Cotton Candy': '#FFBCD9',\", \"           'Dandelion': '#FDDB6D',\", \"           'Denim': '#2B6CC4',\", \"           'Desert Sand': '#EFCDB8',\", \"           'Eggplant': '#6E5160',\", \"           'Electric Lime': '#CEFF1D',\", \"           'Fern': '#71BC78',\", \"           'Forest Green': '#6DAE81',\", \"           'Fuchsia': '#C364C5',\", \"           'Fuzzy Wuzzy': '#CC6666',\", \"           'Gold': '#E7C697',\", \"           'Goldenrod': '#FCD975',\", \"           'Granny Smith Apple': '#A8E4A0',\", \"           'Gray': '#95918C',\", \"           'Green': '#1CAC78',\", \"           'Green Yellow': '#F0E891',\", \"           'Hot Magenta': '#FF1DCE',\", \"           'Inchworm': '#B2EC5D',\", \"           'Indigo': '#5D76CB',\", \"           'Jazzberry Jam': '#CA3767',\", \"           'Jungle Green': '#3BB08F',\", \"           'Laser Lemon': '#FEFE22',\", \"           'Lavender': '#FCB4D5',\", \"           'Macaroni and Cheese': '#FFBD88',\", \"           'Magenta': '#F664AF',\", \"           'Mahogany': '#CD4A4C',\", \"           'Manatee': '#979AAA',\", \"           'Mango Tango': '#FF8243',\", \"           'Maroon': '#C8385A',\", \"           'Mauvelous': '#EF98AA',\", \"           'Melon': '#FDBCB4',\", \"           'Midnight Blue': '#1A4876',\", \"           'Mountain Meadow': '#30BA8F',\", \"           'Navy Blue': '#1974D2',\", \"           'Neon Carrot': '#FFA343',\", \"           'Olive Green': '#BAB86C',\", \"           'Orange': '#FF7538',\", \"           'Orchid': '#E6A8D7',\", \"           'Outer Space': '#414A4C',\", \"           'Outrageous Orange': '#FF6E4A',\", \"           'Pacific Blue': '#1CA9C9',\", \"           'Peach': '#FFCFAB',\", \"           'Periwinkle': '#C5D0E6',\", \"           'Piggy Pink': '#FDDDE6',\", \"           'Pine Green': '#158078',\", \"           'Pink Flamingo': '#FC74FD',\", \"           'Pink Sherbert': '#F78FA7',\", \"           'Plum': '#8E4585',\", \"           'Purple Heart': '#7442C8',\", '           \"Purple Mountains\\' Majesty\": \\'#9D81BA\\',', \"           'Purple Pizzazz': '#FE4EDA',\", \"           'Radical Red': '#FF496C',\", \"           'Raw Sienna': '#D68A59',\", \"           'Razzle Dazzle Rose': '#FF48D0',\", \"           'Razzmatazz': '#E3256B',\", \"           'Red': '#EE204D',\", \"           'Red Orange': '#FF5349',\", \"           'Red Violet': '#C0448F',\", '           \"Robin\\'s Egg Blue\": \\'#1FCECB\\',', \"           'Royal Purple': '#7851A9',\", \"           'Salmon': '#FF9BAA',\", \"           'Scarlet': '#FC2847',\", '           \"Screamin\\' Green\": \\'#76FF7A\\',', \"           'Sea Green': '#93DFB8',\", \"           'Sepia': '#A5694F',\", \"           'Shadow': '#8A795D',\", \"           'Shamrock': '#45CEA2',\", \"           'Shocking Pink': '#FB7EFD',\", \"           'Silver': '#CDC5C2',\", \"           'Sky Blue': '#80DAEB',\", \"           'Spring Green': '#ECEABE',\", \"           'Sunglow': '#FFCF48',\", \"           'Sunset Orange': '#FD5E53',\", \"           'Tan': '#FAA76C',\", \"           'Tickle Me Pink': '#FC89AC',\", \"           'Timberwolf': '#DBD7D2',\", \"           'Tropical Rain Forest': '#17806D',\", \"           'Tumbleweed': '#DEAA88',\", \"           'Turquoise Blue': '#77DDE7',\", \"           'Unmellow Yellow': '#FFFF66',\", \"           'Violet (Purple)': '#926EAE',\", \"           'Violet Red': '#F75394',\", \"           'Vivid Tangerine': '#FFA089',\", \"           'Vivid Violet': '#8F509D',\", \"           'White': '#FFFFFF',\", \"           'Wild Blue Yonder': '#A2ADD0',\", \"           'Wild Strawberry': '#FF43A4',\", \"           'Wild Watermelon': '#FC6C85',\", \"           'Wisteria': '#CDA4DE',\", \"           'Yellow': '#FCE883',\", \"           'Yellow Green': '#C5E384',\", \"           'Yellow Orange': '#FFAE42'}\"]}, '__init__.py': {'classes': [], 'functions': [], 'text': ['from .xkcd_rgb import xkcd_rgb  # noqa: F401', 'from .crayons import crayons  # noqa: F401']}}}, 'ci': {'check_gallery.py': {'classes': [], 'functions': [], 'text': ['\"\"\"Execute the scripts that comprise the example gallery in the online docs.\"\"\"', 'from glob import glob', 'import matplotlib.pyplot as plt', '', 'if __name__ == \"__main__\":', '', '    fnames = sorted(glob(\"examples/*.py\"))', '', '    for fname in fnames:', '', '        print(f\"- {fname}\")', '        with open(fname) as fid:', '            exec(fid.read())', '        plt.close(\"all\")']}, 'cache_datasets.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Cache test datasets before running tests / building docs.', '', 'Avoids race conditions that would arise from parallelization.', '\"\"\"', 'import pathlib', 'import re', '', 'from seaborn import load_dataset', '', 'path = pathlib.Path(\".\")', 'py_files = path.rglob(\"*.py\")', 'ipynb_files = path.rglob(\"*.ipynb\")', '', 'datasets = []', '', 'for fname in py_files:', '    with open(fname) as fid:', '        datasets += re.findall(r\"load_dataset\\\\([\\'\\\\\"](\\\\w+)[\\'\\\\\"]\", fid.read())', '', 'for p in ipynb_files:', '    with p.open() as fid:', '        datasets += re.findall(r\"load_dataset\\\\(\\\\\\\\[\\'\\\\\"](\\\\w+)\\\\\\\\[\\'\\\\\"]\", fid.read())', '', 'for name in sorted(set(datasets)):', '    print(f\"Caching {name}\")', '    load_dataset(name)']}}, 'doc': {'conf.py': {'classes': [], 'functions': [], 'text': ['# Configuration file for the Sphinx documentation builder.', '#', '# This file only contains a selection of the most common options. For a full', '# list see the documentation:', '# https://www.sphinx-doc.org/en/master/usage/configuration.html', '', '# -- Path setup --------------------------------------------------------------', '', '# If extensions (or modules to document with autodoc) are in another directory,', '# add these directories to sys.path here. If the directory is relative to the', '# documentation root, use os.path.abspath to make it absolute, like shown here.', '#', 'import os', 'import sys', 'import time', 'import seaborn', 'from seaborn._core.properties import PROPERTIES', '', \"sys.path.insert(0, os.path.abspath('sphinxext'))\", '', '', '# -- Project information -----------------------------------------------------', '', \"project = 'seaborn'\", 'copyright = f\\'2012-{time.strftime(\"%Y\")}\\'', \"author = 'Michael Waskom'\", 'version = release = seaborn.__version__', '', '', '# -- General configuration ---------------------------------------------------', '', '# Add any Sphinx extension module names here, as strings. They can be', \"# extensions coming with Sphinx (amed 'sphinx.ext.*') or your custom\", '# ones.', 'extensions = [', \"    'sphinx.ext.autodoc',\", \"    'sphinx.ext.doctest',\", \"    'sphinx.ext.coverage',\", \"    'sphinx.ext.mathjax',\", \"    'sphinx.ext.autosummary',\", \"    'sphinx.ext.intersphinx',\", \"    'matplotlib.sphinxext.plot_directive',\", \"    'gallery_generator',\", \"    'tutorial_builder',\", \"    'numpydoc',\", \"    'sphinx_copybutton',\", \"    'sphinx_issues',\", \"    'sphinx_design',\", ']', '', '# Add any paths that contain templates here, relative to this directory.', \"templates_path = ['_templates']\", '', '# The root document.', \"root_doc = 'index'\", '', '# List of patterns, relative to source directory, that match files and', '# directories to ignore when looking for source files.', '# This pattern also affects html_static_path and html_extra_path.', \"exclude_patterns = ['_build', 'docstrings', 'nextgen', 'Thumbs.db', '.DS_Store']\", '', '# The reST default role (used for this markup: `text`) to use for all documents.', \"default_role = 'literal'\", '', '# Generate the API documentation when building', 'autosummary_generate = True', 'numpydoc_show_class_members = False', '', '# Sphinx-issues configuration', \"issues_github_path = 'mwaskom/seaborn'\", '', '# Include the example source for plots in API docs', 'plot_include_source = True', \"plot_formats = [('png', 90)]\", 'plot_html_show_formats = False', 'plot_html_show_source_link = False', '', \"# Don't add a source link in the sidebar\", 'html_show_sourcelink = False', '', '# Control the appearance of type hints', 'autodoc_typehints = \"none\"', 'autodoc_typehints_format = \"short\"', '', '# Allow shorthand references for main function interface', 'rst_prolog = \"\"\"', '.. currentmodule:: seaborn', '\"\"\"', '', '# Define replacements (used in whatsnew bullets)', 'rst_epilog = \"\"\"', '', '.. role:: raw-html(raw)', '   :format: html', '', '.. role:: raw-latex(raw)', '   :format: latex', '', '.. |API| replace:: :raw-html:`<span class=\"badge badge-api\">API</span>` :raw-latex:`{\\\\small\\\\sc [API]}`', '.. |Defaults| replace:: :raw-html:`<span class=\"badge badge-defaults\">Defaults</span>` :raw-latex:`{\\\\small\\\\sc [Defaults]}`', '.. |Docs| replace:: :raw-html:`<span class=\"badge badge-docs\">Docs</span>` :raw-latex:`{\\\\small\\\\sc [Docs]}`', '.. |Feature| replace:: :raw-html:`<span class=\"badge badge-feature\">Feature</span>` :raw-latex:`{\\\\small\\\\sc [Feature]}`', '.. |Enhancement| replace:: :raw-html:`<span class=\"badge badge-enhancement\">Enhancement</span>` :raw-latex:`{\\\\small\\\\sc [Enhancement]}`', '.. |Fix| replace:: :raw-html:`<span class=\"badge badge-fix\">Fix</span>` :raw-latex:`{\\\\small\\\\sc [Fix]}`', '.. |Build| replace:: :raw-html:`<span class=\"badge badge-build\">Build</span>` :raw-latex:`{\\\\small\\\\sc [Deps]}`', '', '\"\"\"  # noqa', '', 'rst_epilog += \"\\\\n\".join([', '    f\".. |{key}| replace:: :ref:`{key} <{val.__class__.__name__.lower()}_property>`\"', '    for key, val in PROPERTIES.items()', '])', '', '# -- Options for HTML output -------------------------------------------------', '', '# The theme to use for HTML and HTML Help pages.  See the documentation for', '# a list of builtin themes.', '#', \"html_theme = 'pydata_sphinx_theme'\", '', '# Add any paths that contain custom static files (such as style sheets) here,', '# relative to this directory. They are copied after the builtin static files,', \"# so a file named 'default.css' will overwrite the builtin 'default.css'.\", \"html_static_path = ['_static', 'example_thumbs']\", 'for path in html_static_path:', '    if not os.path.exists(path):', '        os.makedirs(path)', '', \"html_css_files = [f'css/custom.css?v={seaborn.__version__}']\", '', 'html_logo = \"_static/logo-wide-lightbg.svg\"', 'html_favicon = \"_static/favicon.ico\"', '', 'html_theme_options = {', '    \"icon_links\": [', '        {', '            \"name\": \"GitHub\",', '            \"url\": \"https://github.com/mwaskom/seaborn\",', '            \"icon\": \"fab fa-github\",', '            \"type\": \"fontawesome\",', '        },', '        {', '            \"name\": \"StackOverflow\",', '            \"url\": \"https://stackoverflow.com/tags/seaborn\",', '            \"icon\": \"fab fa-stack-overflow\",', '            \"type\": \"fontawesome\",', '        },', '        {', '            \"name\": \"Twitter\",', '            \"url\": \"https://twitter.com/michaelwaskom\",', '            \"icon\": \"fab fa-twitter\",', '            \"type\": \"fontawesome\",', '        },', '    ],', '    \"show_prev_next\": False,', '    \"navbar_start\": [\"navbar-logo\"],', '    \"navbar_end\": [\"navbar-icon-links\"],', '    \"header_links_before_dropdown\": 8,', '}', '', 'html_context = {', '    \"default_mode\": \"light\",', '}', '', 'html_sidebars = {', '    \"index\": [],', '    \"examples/index\": [],', '    \"**\": [\"sidebar-nav-bs.html\"],', '}', '', '# -- Intersphinx ------------------------------------------------', '', 'intersphinx_mapping = {', \"    'numpy': ('https://numpy.org/doc/stable/', None),\", \"    'scipy': ('https://docs.scipy.org/doc/scipy/', None),\", \"    'matplotlib': ('https://matplotlib.org/stable', None),\", \"    'pandas': ('https://pandas.pydata.org/pandas-docs/stable/', None),\", \"    'statsmodels': ('https://www.statsmodels.org/stable/', None)\", '}']}, 'tools': {'nb_to_doc.py': {'classes': [{'name': 'MetadataError', 'start_line': 41, 'end_line': 42, 'text': ['class MetadataError(Exception):', '    pass'], 'methods': []}], 'functions': [{'name': 'pop_recursive', 'start_line': 45, 'end_line': 62, 'text': ['def pop_recursive(d, key, default=None):', '    \"\"\"dict.pop(key) where `key` is a `.`-delimited list of nested keys.', \"    >>> d = {'a': {'b': 1, 'c': 2}}\", \"    >>> pop_recursive(d, 'a.c')\", '    2', '    >>> d', \"    {'a': {'b': 1}}\", '    \"\"\"', \"    nested = key.split('.')\", '    current = d', '    for k in nested[:-1]:', \"        if hasattr(current, 'get'):\", '            current = current.get(k, {})', '        else:', '            return default', \"    if not hasattr(current, 'pop'):\", '        return default', '    return current.pop(nested[-1], default)']}, {'name': 'strip_output', 'start_line': 65, 'end_line': 103, 'text': ['def strip_output(nb):', '    \"\"\"', '    Strip the outputs, execution count/prompt number and miscellaneous', '    metadata from a notebook object, unless specified to keep either the', '    outputs or counts.', '    \"\"\"', '    keys = {\\'metadata\\': [], \\'cell\\': {\\'metadata\\': [\"execution\"]}}', '', \"    nb.metadata.pop('signature', None)\", \"    nb.metadata.pop('widgets', None)\", '', \"    for field in keys['metadata']:\", '        pop_recursive(nb.metadata, field)', '', \"    if 'NB_KERNEL' in os.environ:\", \"        nb.metadata['kernelspec']['name'] = os.environ['NB_KERNEL']\", \"        nb.metadata['kernelspec']['display_name'] = os.environ['NB_KERNEL']\", '', '    for cell in nb.cells:', '', \"        if 'outputs' in cell:\", \"            cell['outputs'] = []\", \"        if 'prompt_number' in cell:\", \"            cell['prompt_number'] = None\", \"        if 'execution_count' in cell:\", \"            cell['execution_count'] = None\", '', '        # Always remove this metadata', \"        for output_style in ['collapsed', 'scrolled']:\", '            if output_style in cell.metadata:', '                cell.metadata[output_style] = False', \"        if 'metadata' in cell:\", \"            for field in ['collapsed', 'scrolled', 'ExecuteTime']:\", '                cell.metadata.pop(field, None)', \"        for (extra, fields) in keys['cell'].items():\", '            if extra in cell:', '                for field in fields:', '                    pop_recursive(getattr(cell, extra), field)', '    return nb']}], 'text': ['#! /usr/bin/env python', '\"\"\"Execute a .ipynb file, write out a processed .rst and clean .ipynb.', '', 'Some functions in this script were copied from the nbstripout tool:', '', 'Copyright (c) 2015 Min RK, Florian Rathgeber, Michael McNeil Forbes', '2019 Casper da Costa-Luis', '', 'Permission is hereby granted, free of charge, to any person obtaining', 'a copy of this software and associated documentation files (the', '\"Software\"), to deal in the Software without restriction, including', 'without limitation the rights to use, copy, modify, merge, publish,', 'distribute, sublicense, and/or sell copies of the Software, and to', 'permit persons to whom the Software is furnished to do so, subject to', 'the following conditions:', '', 'The above copyright notice and this permission notice shall be', 'included in all copies or substantial portions of the Software.', '', 'THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,', 'EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF', 'MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND', 'NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE', 'LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION', 'OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION', 'WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.', '', '\"\"\"', 'import os', 'import sys', 'import nbformat', 'from nbconvert import RSTExporter', 'from nbconvert.preprocessors import (', '    ExecutePreprocessor,', '    TagRemovePreprocessor,', '    ExtractOutputPreprocessor', ')', 'from traitlets.config import Config', '', '', 'class MetadataError(Exception):', '    pass', '', '', 'def pop_recursive(d, key, default=None):', '    \"\"\"dict.pop(key) where `key` is a `.`-delimited list of nested keys.', \"    >>> d = {'a': {'b': 1, 'c': 2}}\", \"    >>> pop_recursive(d, 'a.c')\", '    2', '    >>> d', \"    {'a': {'b': 1}}\", '    \"\"\"', \"    nested = key.split('.')\", '    current = d', '    for k in nested[:-1]:', \"        if hasattr(current, 'get'):\", '            current = current.get(k, {})', '        else:', '            return default', \"    if not hasattr(current, 'pop'):\", '        return default', '    return current.pop(nested[-1], default)', '', '', 'def strip_output(nb):', '    \"\"\"', '    Strip the outputs, execution count/prompt number and miscellaneous', '    metadata from a notebook object, unless specified to keep either the', '    outputs or counts.', '    \"\"\"', '    keys = {\\'metadata\\': [], \\'cell\\': {\\'metadata\\': [\"execution\"]}}', '', \"    nb.metadata.pop('signature', None)\", \"    nb.metadata.pop('widgets', None)\", '', \"    for field in keys['metadata']:\", '        pop_recursive(nb.metadata, field)', '', \"    if 'NB_KERNEL' in os.environ:\", \"        nb.metadata['kernelspec']['name'] = os.environ['NB_KERNEL']\", \"        nb.metadata['kernelspec']['display_name'] = os.environ['NB_KERNEL']\", '', '    for cell in nb.cells:', '', \"        if 'outputs' in cell:\", \"            cell['outputs'] = []\", \"        if 'prompt_number' in cell:\", \"            cell['prompt_number'] = None\", \"        if 'execution_count' in cell:\", \"            cell['execution_count'] = None\", '', '        # Always remove this metadata', \"        for output_style in ['collapsed', 'scrolled']:\", '            if output_style in cell.metadata:', '                cell.metadata[output_style] = False', \"        if 'metadata' in cell:\", \"            for field in ['collapsed', 'scrolled', 'ExecuteTime']:\", '                cell.metadata.pop(field, None)', \"        for (extra, fields) in keys['cell'].items():\", '            if extra in cell:', '                for field in fields:', '                    pop_recursive(getattr(cell, extra), field)', '    return nb', '', '', 'if __name__ == \"__main__\":', '', '    # Get the desired ipynb file path and parse into components', '    _, fpath, outdir = sys.argv', '    basedir, fname = os.path.split(fpath)', '    fstem = fname[:-6]', '', '    # Read the notebook', '    with open(fpath) as f:', '        nb = nbformat.read(f, as_version=4)', '', '    # Run the notebook', '    kernel = os.environ.get(\"NB_KERNEL\", None)', '    if kernel is None:', '        kernel = nb[\"metadata\"][\"kernelspec\"][\"name\"]', '    ep = ExecutePreprocessor(', '        timeout=600,', '        kernel_name=kernel,', '        extra_arguments=[\"--InlineBackend.rc=figure.dpi=88\"]', '    )', '    ep.preprocess(nb, {\"metadata\": {\"path\": basedir}})', '', '    # Remove plain text execution result outputs', '    for cell in nb.get(\"cells\", {}):', '        if \"show-output\" in cell[\"metadata\"].get(\"tags\", []):', '            continue', '        fields = cell.get(\"outputs\", [])', '        for field in fields:', '            if field[\"output_type\"] == \"execute_result\":', '                data_keys = field[\"data\"].keys()', '                for key in list(data_keys):', '                    if key == \"text/plain\":', '                        field[\"data\"].pop(key)', '                if not field[\"data\"]:', '                    fields.remove(field)', '', '    # Convert to .rst formats', '    exp = RSTExporter()', '', '    c = Config()', '    c.TagRemovePreprocessor.remove_cell_tags = {\"hide\"}', '    c.TagRemovePreprocessor.remove_input_tags = {\"hide-input\"}', '    c.TagRemovePreprocessor.remove_all_outputs_tags = {\"hide-output\"}', '    c.ExtractOutputPreprocessor.output_filename_template = \\\\', '        f\"{fstem}_files/{fstem}_\" + \"{cell_index}_{index}{extension}\"', '', '    exp.register_preprocessor(TagRemovePreprocessor(config=c), True)', '    exp.register_preprocessor(ExtractOutputPreprocessor(config=c), True)', '', '    body, resources = exp.from_notebook_node(nb)', '', '    # Clean the output on the notebook and save a .ipynb back to disk', '    nb = strip_output(nb)', '    with open(fpath, \"wt\") as f:', '        nbformat.write(nb, f)', '', '    # Write the .rst file', '    rst_path = os.path.join(outdir, f\"{fstem}.rst\")', '    with open(rst_path, \"w\") as f:', '        f.write(body)', '', '    # Write the individual image outputs', '    imdir = os.path.join(outdir, f\"{fstem}_files\")', '    if not os.path.exists(imdir):', '        os.mkdir(imdir)', '', '    for imname, imdata in resources[\"outputs\"].items():', '        if imname.startswith(fstem):', '            impath = os.path.join(outdir, f\"{imname}\")', '            with open(impath, \"wb\") as f:', '                f.write(imdata)']}, 'generate_logos.py': {'classes': [], 'functions': [{'name': 'poisson_disc_sample', 'start_line': 15, 'end_line': 58, 'text': ['def poisson_disc_sample(array_radius, pad_radius, candidates=100, d=2, seed=None):', '    \"\"\"Find positions using poisson-disc sampling.\"\"\"', '    # See http://bost.ocks.org/mike/algorithms/', '    rng = np.random.default_rng(seed)', '    uniform = rng.uniform', '    randint = rng.integers', '', '    # Cache the results', '    key = array_radius, pad_radius, seed', '    if key in XY_CACHE:', '        return XY_CACHE[key]', '', '    # Start at a fixed point we know will work', '    start = np.zeros(d)', '    samples = [start]', '    queue = [start]', '', '    while queue:', '', '        # Pick a sample to expand from', '        s_idx = randint(len(queue))', '        s = queue[s_idx]', '', '        for i in range(candidates):', '            # Generate a candidate from this sample', '            coords = uniform(s - 2 * pad_radius, s + 2 * pad_radius, d)', '', '            # Check the three conditions to accept the candidate', '            in_array = np.sqrt(np.sum(coords ** 2)) < array_radius', '            in_ring = np.all(distance.cdist(samples, [coords]) > pad_radius)', '', '            if in_array and in_ring:', '                # Accept the candidate', '                samples.append(coords)', '                queue.append(coords)', '                break', '', '        if (i + 1) == candidates:', \"            # We've exhausted the particular sample\", '            queue.pop(s_idx)', '', '    samples = np.array(samples)', '    XY_CACHE[key] = samples', '    return samples']}, {'name': 'logo', 'start_line': 61, 'end_line': 156, 'text': ['def logo(', '    ax,', '    color_kws, ring, ring_idx, edge,', '    pdf_means, pdf_sigma, dy, y0, w, h,', '    hist_mean, hist_sigma, hist_y0, lw, skip,', '    scatter, pad, scale,', '):', '', '    # Square, invisible axes with specified limits to center the logo', '    ax.set(xlim=(35 + w, 95 - w), ylim=(-3, 53))', '    ax.set_axis_off()', \"    ax.set_aspect('equal')\", '', '    # Magic numbers for the logo circle', '    radius = 27', '    center = 65, 25', '', '    # Full x and y grids for a gaussian curve', '    x = np.arange(101)', '    y = gaussian(x.size, pdf_sigma)', '', '    x0 = 30  # Magic number', '    xx = x[x0:]', '', '    # Vertical distances between the PDF curves', '    n = len(pdf_means)', '    dys = np.linspace(0, (n - 1) * dy, n) - (n * dy / 2)', '    dys -= dys.mean()', '', '    # Compute the PDF curves with vertical offsets', '    pdfs = [h * (y[x0 - m:-m] + y0 + dy) for m, dy in zip(pdf_means, dys)]', '', '    # Add in constants to fill from bottom and to top', '    pdfs.insert(0, np.full(xx.shape, -h))', '    pdfs.append(np.full(xx.shape, 50 + h))', '', '    # Color gradient', '    colors = sns.cubehelix_palette(n + 1 + bool(hist_mean), **color_kws)', '', '    # White fill between curves and around edges', '    bg = patches.Circle(', '        center, radius=radius - 1 + ring, color=\"white\",', '        transform=ax.transData, zorder=0,', '    )', '    ax.add_artist(bg)', '', '    # Clipping artist (not shown) for the interior elements', '    fg = patches.Circle(center, radius=radius - edge, transform=ax.transData)', '', '    # Ring artist to surround the circle (optional)', '    if ring:', '        wedge = patches.Wedge(', '            center, r=radius + edge / 2, theta1=0, theta2=360, width=edge / 2,', '            transform=ax.transData, color=colors[ring_idx], alpha=1', '        )', '        ax.add_artist(wedge)', '', '    # Add histogram bars', '    if hist_mean:', '        hist_color = colors.pop(0)', '        hist_y = gaussian(x.size, hist_sigma)', '        hist = 1.1 * h * (hist_y[x0 - hist_mean:-hist_mean] + hist_y0)', '        dx = x[skip] - x[0]', '        hist_x = xx[::skip]', '        hist_h = h + hist[::skip]', '        # Magic number to avoid tiny sliver of bar on edge', '        use = hist_x < center[0] + radius * .5', '        bars = ax.bar(', '            hist_x[use], hist_h[use], bottom=-h, width=dx,', '            align=\"edge\", color=hist_color, ec=\"w\", lw=lw,', '            zorder=3,', '        )', '        for bar in bars:', '            bar.set_clip_path(fg)', '', '    # Add each smooth PDF \"wave\"', '    for i, pdf in enumerate(pdfs[1:], 1):', '        u = ax.fill_between(xx, pdfs[i - 1] + w, pdf, color=colors[i - 1], lw=0)', '        u.set_clip_path(fg)', '', '    # Add scatterplot in top wave area', '    if scatter:', '        seed = sum(map(ord, \"seaborn logo\"))', '        xy = poisson_disc_sample(radius - edge - ring, pad, seed=seed)', '        clearance = distance.cdist(xy + center, np.c_[xx, pdfs[-2]])', '        use = clearance.min(axis=1) > pad / 1.8', '        x, y = xy[use].T', '        sizes = (x - y) % 9', '', '        points = ax.scatter(', '            x + center[0], y + center[1], s=scale * (10 + sizes * 5),', '            zorder=5, color=colors[-1], ec=\"w\", lw=scale / 2,', '        )', '        path = u.get_paths()[0]', '        points.set_clip_path(path, transform=u.get_transform())', '        u.set_visible(False)']}, {'name': 'savefig', 'start_line': 159, 'end_line': 166, 'text': ['def savefig(fig, shape, variant):', '', '    fig.subplots_adjust(0, 0, 1, 1, 0, 0)', '', '    facecolor = (1, 1, 1, 1) if bg == \"white\" else (1, 1, 1, 0)', '', '    for ext in [\"png\", \"svg\"]:', '        fig.savefig(f\"{STATIC_DIR}/logo-{shape}-{variant}bg.{ext}\", facecolor=facecolor)']}], 'text': ['import numpy as np', 'import seaborn as sns', 'from matplotlib import patches', 'import matplotlib.pyplot as plt', 'from scipy.signal import gaussian', 'from scipy.spatial import distance', '', '', 'XY_CACHE = {}', '', 'STATIC_DIR = \"_static\"', 'plt.rcParams[\"savefig.dpi\"] = 300', '', '', 'def poisson_disc_sample(array_radius, pad_radius, candidates=100, d=2, seed=None):', '    \"\"\"Find positions using poisson-disc sampling.\"\"\"', '    # See http://bost.ocks.org/mike/algorithms/', '    rng = np.random.default_rng(seed)', '    uniform = rng.uniform', '    randint = rng.integers', '', '    # Cache the results', '    key = array_radius, pad_radius, seed', '    if key in XY_CACHE:', '        return XY_CACHE[key]', '', '    # Start at a fixed point we know will work', '    start = np.zeros(d)', '    samples = [start]', '    queue = [start]', '', '    while queue:', '', '        # Pick a sample to expand from', '        s_idx = randint(len(queue))', '        s = queue[s_idx]', '', '        for i in range(candidates):', '            # Generate a candidate from this sample', '            coords = uniform(s - 2 * pad_radius, s + 2 * pad_radius, d)', '', '            # Check the three conditions to accept the candidate', '            in_array = np.sqrt(np.sum(coords ** 2)) < array_radius', '            in_ring = np.all(distance.cdist(samples, [coords]) > pad_radius)', '', '            if in_array and in_ring:', '                # Accept the candidate', '                samples.append(coords)', '                queue.append(coords)', '                break', '', '        if (i + 1) == candidates:', \"            # We've exhausted the particular sample\", '            queue.pop(s_idx)', '', '    samples = np.array(samples)', '    XY_CACHE[key] = samples', '    return samples', '', '', 'def logo(', '    ax,', '    color_kws, ring, ring_idx, edge,', '    pdf_means, pdf_sigma, dy, y0, w, h,', '    hist_mean, hist_sigma, hist_y0, lw, skip,', '    scatter, pad, scale,', '):', '', '    # Square, invisible axes with specified limits to center the logo', '    ax.set(xlim=(35 + w, 95 - w), ylim=(-3, 53))', '    ax.set_axis_off()', \"    ax.set_aspect('equal')\", '', '    # Magic numbers for the logo circle', '    radius = 27', '    center = 65, 25', '', '    # Full x and y grids for a gaussian curve', '    x = np.arange(101)', '    y = gaussian(x.size, pdf_sigma)', '', '    x0 = 30  # Magic number', '    xx = x[x0:]', '', '    # Vertical distances between the PDF curves', '    n = len(pdf_means)', '    dys = np.linspace(0, (n - 1) * dy, n) - (n * dy / 2)', '    dys -= dys.mean()', '', '    # Compute the PDF curves with vertical offsets', '    pdfs = [h * (y[x0 - m:-m] + y0 + dy) for m, dy in zip(pdf_means, dys)]', '', '    # Add in constants to fill from bottom and to top', '    pdfs.insert(0, np.full(xx.shape, -h))', '    pdfs.append(np.full(xx.shape, 50 + h))', '', '    # Color gradient', '    colors = sns.cubehelix_palette(n + 1 + bool(hist_mean), **color_kws)', '', '    # White fill between curves and around edges', '    bg = patches.Circle(', '        center, radius=radius - 1 + ring, color=\"white\",', '        transform=ax.transData, zorder=0,', '    )', '    ax.add_artist(bg)', '', '    # Clipping artist (not shown) for the interior elements', '    fg = patches.Circle(center, radius=radius - edge, transform=ax.transData)', '', '    # Ring artist to surround the circle (optional)', '    if ring:', '        wedge = patches.Wedge(', '            center, r=radius + edge / 2, theta1=0, theta2=360, width=edge / 2,', '            transform=ax.transData, color=colors[ring_idx], alpha=1', '        )', '        ax.add_artist(wedge)', '', '    # Add histogram bars', '    if hist_mean:', '        hist_color = colors.pop(0)', '        hist_y = gaussian(x.size, hist_sigma)', '        hist = 1.1 * h * (hist_y[x0 - hist_mean:-hist_mean] + hist_y0)', '        dx = x[skip] - x[0]', '        hist_x = xx[::skip]', '        hist_h = h + hist[::skip]', '        # Magic number to avoid tiny sliver of bar on edge', '        use = hist_x < center[0] + radius * .5', '        bars = ax.bar(', '            hist_x[use], hist_h[use], bottom=-h, width=dx,', '            align=\"edge\", color=hist_color, ec=\"w\", lw=lw,', '            zorder=3,', '        )', '        for bar in bars:', '            bar.set_clip_path(fg)', '', '    # Add each smooth PDF \"wave\"', '    for i, pdf in enumerate(pdfs[1:], 1):', '        u = ax.fill_between(xx, pdfs[i - 1] + w, pdf, color=colors[i - 1], lw=0)', '        u.set_clip_path(fg)', '', '    # Add scatterplot in top wave area', '    if scatter:', '        seed = sum(map(ord, \"seaborn logo\"))', '        xy = poisson_disc_sample(radius - edge - ring, pad, seed=seed)', '        clearance = distance.cdist(xy + center, np.c_[xx, pdfs[-2]])', '        use = clearance.min(axis=1) > pad / 1.8', '        x, y = xy[use].T', '        sizes = (x - y) % 9', '', '        points = ax.scatter(', '            x + center[0], y + center[1], s=scale * (10 + sizes * 5),', '            zorder=5, color=colors[-1], ec=\"w\", lw=scale / 2,', '        )', '        path = u.get_paths()[0]', '        points.set_clip_path(path, transform=u.get_transform())', '        u.set_visible(False)', '', '', 'def savefig(fig, shape, variant):', '', '    fig.subplots_adjust(0, 0, 1, 1, 0, 0)', '', '    facecolor = (1, 1, 1, 1) if bg == \"white\" else (1, 1, 1, 0)', '', '    for ext in [\"png\", \"svg\"]:', '        fig.savefig(f\"{STATIC_DIR}/logo-{shape}-{variant}bg.{ext}\", facecolor=facecolor)', '', '', 'if __name__ == \"__main__\":', '', '    for bg in [\"white\", \"light\", \"dark\"]:', '', '        color_idx = -1 if bg == \"dark\" else 0', '', '        kwargs = dict(', '            color_kws=dict(start=.3, rot=-.4, light=.8, dark=.3, reverse=True),', '            ring=True, ring_idx=color_idx, edge=1,', '            pdf_means=[8, 24], pdf_sigma=16,', '            dy=1, y0=1.8, w=.5, h=12,', '            hist_mean=2, hist_sigma=10, hist_y0=.6, lw=1, skip=6,', '            scatter=True, pad=1.8, scale=.5,', '        )', '        color = sns.cubehelix_palette(**kwargs[\"color_kws\"])[color_idx]', '', '        # ------------------------------------------------------------------------ #', '', '        fig, ax = plt.subplots(figsize=(2, 2), facecolor=\"w\", dpi=100)', '        logo(ax, **kwargs)', '        savefig(fig, \"mark\", bg)', '', '        # ------------------------------------------------------------------------ #', '', '        fig, axs = plt.subplots(1, 2, figsize=(8, 2), dpi=100,', '                                gridspec_kw=dict(width_ratios=[1, 3]))', '        logo(axs[0], **kwargs)', '', '        font = {', '            \"family\": \"avenir\",', '            \"color\": color,', '            \"weight\": \"regular\",', '            \"size\": 120,', '        }', '        axs[1].text(.01, .35, \"seaborn\", ha=\"left\", va=\"center\",', '                    fontdict=font, transform=axs[1].transAxes)', '        axs[1].set_axis_off()', '        savefig(fig, \"wide\", bg)', '', '        # ------------------------------------------------------------------------ #', '', '        fig, axs = plt.subplots(2, 1, figsize=(2, 2.5), dpi=100,', '                                gridspec_kw=dict(height_ratios=[4, 1]))', '', '        logo(axs[0], **kwargs)', '', '        font = {', '            \"family\": \"avenir\",', '            \"color\": color,', '            \"weight\": \"regular\",', '            \"size\": 34,', '        }', '        axs[1].text(.5, 1, \"seaborn\", ha=\"center\", va=\"top\",', '                    fontdict=font, transform=axs[1].transAxes)', '        axs[1].set_axis_off()', '        savefig(fig, \"tall\", bg)']}, 'extract_examples.py': {'classes': [], 'functions': [{'name': 'line_type', 'start_line': 10, 'end_line': 15, 'text': ['def line_type(line):', '', '    if line.startswith(\"    \"):', '        return \"code\"', '    else:', '        return \"markdown\"']}, {'name': 'add_cell', 'start_line': 18, 'end_line': 26, 'text': ['def add_cell(nb, lines, cell_type):', '', '    cell_objs = {', '        \"code\": nbformat.v4.new_code_cell,', '        \"markdown\": nbformat.v4.new_markdown_cell,', '    }', '    text = \"\\\\n\".join(lines)', '    cell = cell_objs[cell_type](text)', '    nb[\"cells\"].append(cell)']}], 'text': ['\"\"\"Turn the examples section of a function docstring into a notebook.\"\"\"', 'import re', 'import sys', 'import pydoc', 'import seaborn', 'from seaborn.external.docscrape import NumpyDocString', 'import nbformat', '', '', 'def line_type(line):', '', '    if line.startswith(\"    \"):', '        return \"code\"', '    else:', '        return \"markdown\"', '', '', 'def add_cell(nb, lines, cell_type):', '', '    cell_objs = {', '        \"code\": nbformat.v4.new_code_cell,', '        \"markdown\": nbformat.v4.new_markdown_cell,', '    }', '    text = \"\\\\n\".join(lines)', '    cell = cell_objs[cell_type](text)', '    nb[\"cells\"].append(cell)', '', '', 'if __name__ == \"__main__\":', '', '    _, name = sys.argv', '', '    # Parse the docstring and get the examples section', '    obj = getattr(seaborn, name)', '    if obj.__class__.__name__ != \"function\":', '        obj = obj.__init__', '    lines = NumpyDocString(pydoc.getdoc(obj))[\"Examples\"]', '', '    # Remove code indentation, the prompt, and mpl return variable', '    pat = re.compile(r\"\\\\s{4}[>\\\\.]{3} (ax = ){0,1}(g = ){0,1}\")', '', '    nb = nbformat.v4.new_notebook()', '', '    # We always start with at least one line of text', '    cell_type = \"markdown\"', '    cell = []', '', '    for line in lines:', '', '        # Ignore matplotlib plot directive', '        if \".. plot\" in line or \":context:\" in line:', '            continue', '', '        # Ignore blank lines', '        if not line:', '            continue', '', '        if line_type(line) != cell_type:', '            # We are on the first line of the next cell,', '            # so package up the last cell', '            add_cell(nb, cell, cell_type)', '            cell_type = line_type(line)', '            cell = []', '', '        if line_type(line) == \"code\":', '            line = re.sub(pat, \"\", line)', '', '        cell.append(line)', '', '    # Package the final cell', '    add_cell(nb, cell, cell_type)', '', '    nbformat.write(nb, f\"docstrings/{name}.ipynb\")']}, 'set_nb_kernels.py': {'classes': [], 'functions': [], 'text': ['\"\"\"Recursively set the kernel name for all jupyter notebook files.\"\"\"', 'import sys', 'from glob import glob', '', 'import nbformat', '', '', 'if __name__ == \"__main__\":', '', '    _, kernel_name = sys.argv', '', '    nb_paths = glob(\"./**/*.ipynb\", recursive=True)', '    for path in nb_paths:', '', '        with open(path) as f:', '            nb = nbformat.read(f, as_version=4)', '', '        nb[\"metadata\"][\"kernelspec\"][\"name\"] = kernel_name', '        nb[\"metadata\"][\"kernelspec\"][\"display_name\"] = kernel_name', '', '        with open(path, \"w\") as f:', '            nbformat.write(nb, f)']}}, 'sphinxext': {'gallery_generator.py': {'classes': [{'name': 'ExampleGenerator', 'start_line': 164, 'end_line': 329, 'text': ['class ExampleGenerator:', '    \"\"\"Tools for generating an example page from a file\"\"\"', '    def __init__(self, filename, target_dir):', '        self.filename = filename', '        self.target_dir = target_dir', '        self.thumbloc = .5, .5', '        self.extract_docstring()', '        with open(filename) as fid:', '            self.filetext = fid.read()', '', '        outfilename = op.join(target_dir, self.rstfilename)', '', \"        # Only actually run it if the output RST file doesn't\", '        # exist or it was modified less recently than the example', '        file_mtime = op.getmtime(filename)', '        if not op.exists(outfilename) or op.getmtime(outfilename) < file_mtime:', '            self.exec_file()', '        else:', '            print(f\"skipping {self.filename}\")', '', '    @property', '    def dirname(self):', '        return op.split(self.filename)[0]', '', '    @property', '    def fname(self):', '        return op.split(self.filename)[1]', '', '    @property', '    def modulename(self):', '        return op.splitext(self.fname)[0]', '', '    @property', '    def pyfilename(self):', \"        return self.modulename + '.py'\", '', '    @property', '    def rstfilename(self):', '        return self.modulename + \".rst\"', '', '    @property', '    def htmlfilename(self):', \"        return self.modulename + '.html'\", '', '    @property', '    def pngfilename(self):', \"        pngfile = self.modulename + '.png'\", '        return \"_images/\" + pngfile', '', '    @property', '    def thumbfilename(self):', \"        pngfile = self.modulename + '_thumb.png'\", '        return pngfile', '', '    @property', '    def sphinxtag(self):', '        return self.modulename', '', '    @property', '    def pagetitle(self):', \"        return self.docstring.strip().split('\\\\n')[0].strip()\", '', '    @property', '    def plotfunc(self):', '        match = re.search(r\"sns\\\\.(.+plot)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        match = re.search(r\"sns\\\\.(.+map)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        match = re.search(r\"sns\\\\.(.+Grid)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        return \"\"', '', '    @property', '    def components(self):', '', '        objects = re.findall(r\"sns\\\\.(\\\\w+)\\\\(\", self.filetext)', '', '        refs = []', '        for obj in objects:', '            if obj[0].isupper():', '                refs.append(f\":class:`{obj}`\")', '            else:', '                refs.append(f\":func:`{obj}`\")', '        return \", \".join(refs)', '', '    def extract_docstring(self):', '        \"\"\" Extract a module-level docstring', '        \"\"\"', '        lines = open(self.filename).readlines()', '        start_row = 0', \"        if lines[0].startswith('#!'):\", '            lines.pop(0)', '            start_row = 1', '', \"        docstring = ''\", \"        first_par = ''\", '        line_iter = lines.__iter__()', '        tokens = tokenize.generate_tokens(lambda: next(line_iter))', '        for tok_type, tok_content, _, (erow, _), _ in tokens:', '            tok_type = token.tok_name[tok_type]', \"            if tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT'):\", '                continue', \"            elif tok_type == 'STRING':\", '                docstring = eval(tok_content)', '                # If the docstring is formatted with several paragraphs,', '                # extract the first one:', \"                paragraphs = '\\\\n'.join(line.rstrip()\", \"                                       for line in docstring.split('\\\\n')\", \"                                       ).split('\\\\n\\\\n')\", '                if len(paragraphs) > 0:', '                    first_par = paragraphs[0]', '            break', '', '        thumbloc = None', '        for i, line in enumerate(docstring.split(\"\\\\n\")):', '            m = re.match(r\"^_thumb: (\\\\.\\\\d+),\\\\s*(\\\\.\\\\d+)\", line)', '            if m:', '                thumbloc = float(m.group(1)), float(m.group(2))', '                break', '        if thumbloc is not None:', '            self.thumbloc = thumbloc', '            docstring = \"\\\\n\".join([l for l in docstring.split(\"\\\\n\")', '                                   if not l.startswith(\"_thumb\")])', '', '        self.docstring = docstring', '        self.short_desc = first_par', '        self.end_line = erow + 1 + start_row', '', '    def exec_file(self):', '        print(f\"running {self.filename}\")', '', \"        plt.close('all')\", \"        my_globals = {'pl': plt,\", \"                      'plt': plt}\", '        execfile(self.filename, my_globals)', '', '        fig = plt.gcf()', '        fig.canvas.draw()', '        pngfile = op.join(self.target_dir, self.pngfilename)', '        thumbfile = op.join(\"example_thumbs\", self.thumbfilename)', '        self.html = f\"<img src=../{self.pngfilename}>\"', '        fig.savefig(pngfile, dpi=75, bbox_inches=\"tight\")', '', '        cx, cy = self.thumbloc', '        create_thumbnail(pngfile, thumbfile, cx=cx, cy=cy)', '', '    def toctree_entry(self):', '        return f\"   ./{op.splitext(self.htmlfilename)[0]}\\\\n\\\\n\"', '', '    def contents_entry(self):', '        return (\".. raw:: html\\\\n\\\\n\"', '                \"    <div class=\\'thumb align-center\\'>\\\\n\"', '                \"    <a href=./{}>\\\\n\"', '                \"    <img src=../_static/{}>\\\\n\"', '                \"    <span class=\\'thumb-label\\'>\\\\n\"', '                \"    <p>{}</p>\\\\n\"', '                \"    </span>\\\\n\"', '                \"    </a>\\\\n\"', '                \"    </div>\\\\n\\\\n\"', '                \"\\\\n\\\\n\"', '                \"\".format(self.htmlfilename,', '                          self.thumbfilename,', '                          self.plotfunc))'], 'methods': [{'name': '__init__', 'start_line': 166, 'end_line': 182, 'text': ['    def __init__(self, filename, target_dir):', '        self.filename = filename', '        self.target_dir = target_dir', '        self.thumbloc = .5, .5', '        self.extract_docstring()', '        with open(filename) as fid:', '            self.filetext = fid.read()', '', '        outfilename = op.join(target_dir, self.rstfilename)', '', \"        # Only actually run it if the output RST file doesn't\", '        # exist or it was modified less recently than the example', '        file_mtime = op.getmtime(filename)', '        if not op.exists(outfilename) or op.getmtime(outfilename) < file_mtime:', '            self.exec_file()', '        else:', '            print(f\"skipping {self.filename}\")']}, {'name': 'dirname', 'start_line': 185, 'end_line': 186, 'text': ['    def dirname(self):', '        return op.split(self.filename)[0]']}, {'name': 'fname', 'start_line': 189, 'end_line': 190, 'text': ['    def fname(self):', '        return op.split(self.filename)[1]']}, {'name': 'modulename', 'start_line': 193, 'end_line': 194, 'text': ['    def modulename(self):', '        return op.splitext(self.fname)[0]']}, {'name': 'pyfilename', 'start_line': 197, 'end_line': 198, 'text': ['    def pyfilename(self):', \"        return self.modulename + '.py'\"]}, {'name': 'rstfilename', 'start_line': 201, 'end_line': 202, 'text': ['    def rstfilename(self):', '        return self.modulename + \".rst\"']}, {'name': 'htmlfilename', 'start_line': 205, 'end_line': 206, 'text': ['    def htmlfilename(self):', \"        return self.modulename + '.html'\"]}, {'name': 'pngfilename', 'start_line': 209, 'end_line': 211, 'text': ['    def pngfilename(self):', \"        pngfile = self.modulename + '.png'\", '        return \"_images/\" + pngfile']}, {'name': 'thumbfilename', 'start_line': 214, 'end_line': 216, 'text': ['    def thumbfilename(self):', \"        pngfile = self.modulename + '_thumb.png'\", '        return pngfile']}, {'name': 'sphinxtag', 'start_line': 219, 'end_line': 220, 'text': ['    def sphinxtag(self):', '        return self.modulename']}, {'name': 'pagetitle', 'start_line': 223, 'end_line': 224, 'text': ['    def pagetitle(self):', \"        return self.docstring.strip().split('\\\\n')[0].strip()\"]}, {'name': 'plotfunc', 'start_line': 227, 'end_line': 237, 'text': ['    def plotfunc(self):', '        match = re.search(r\"sns\\\\.(.+plot)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        match = re.search(r\"sns\\\\.(.+map)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        match = re.search(r\"sns\\\\.(.+Grid)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        return \"\"']}, {'name': 'components', 'start_line': 240, 'end_line': 250, 'text': ['    def components(self):', '', '        objects = re.findall(r\"sns\\\\.(\\\\w+)\\\\(\", self.filetext)', '', '        refs = []', '        for obj in objects:', '            if obj[0].isupper():', '                refs.append(f\":class:`{obj}`\")', '            else:', '                refs.append(f\":func:`{obj}`\")', '        return \", \".join(refs)']}, {'name': 'extract_docstring', 'start_line': 252, 'end_line': 293, 'text': ['    def extract_docstring(self):', '        \"\"\" Extract a module-level docstring', '        \"\"\"', '        lines = open(self.filename).readlines()', '        start_row = 0', \"        if lines[0].startswith('#!'):\", '            lines.pop(0)', '            start_row = 1', '', \"        docstring = ''\", \"        first_par = ''\", '        line_iter = lines.__iter__()', '        tokens = tokenize.generate_tokens(lambda: next(line_iter))', '        for tok_type, tok_content, _, (erow, _), _ in tokens:', '            tok_type = token.tok_name[tok_type]', \"            if tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT'):\", '                continue', \"            elif tok_type == 'STRING':\", '                docstring = eval(tok_content)', '                # If the docstring is formatted with several paragraphs,', '                # extract the first one:', \"                paragraphs = '\\\\n'.join(line.rstrip()\", \"                                       for line in docstring.split('\\\\n')\", \"                                       ).split('\\\\n\\\\n')\", '                if len(paragraphs) > 0:', '                    first_par = paragraphs[0]', '            break', '', '        thumbloc = None', '        for i, line in enumerate(docstring.split(\"\\\\n\")):', '            m = re.match(r\"^_thumb: (\\\\.\\\\d+),\\\\s*(\\\\.\\\\d+)\", line)', '            if m:', '                thumbloc = float(m.group(1)), float(m.group(2))', '                break', '        if thumbloc is not None:', '            self.thumbloc = thumbloc', '            docstring = \"\\\\n\".join([l for l in docstring.split(\"\\\\n\")', '                                   if not l.startswith(\"_thumb\")])', '', '        self.docstring = docstring', '        self.short_desc = first_par', '        self.end_line = erow + 1 + start_row']}, {'name': 'exec_file', 'start_line': 295, 'end_line': 311, 'text': ['    def exec_file(self):', '        print(f\"running {self.filename}\")', '', \"        plt.close('all')\", \"        my_globals = {'pl': plt,\", \"                      'plt': plt}\", '        execfile(self.filename, my_globals)', '', '        fig = plt.gcf()', '        fig.canvas.draw()', '        pngfile = op.join(self.target_dir, self.pngfilename)', '        thumbfile = op.join(\"example_thumbs\", self.thumbfilename)', '        self.html = f\"<img src=../{self.pngfilename}>\"', '        fig.savefig(pngfile, dpi=75, bbox_inches=\"tight\")', '', '        cx, cy = self.thumbloc', '        create_thumbnail(pngfile, thumbfile, cx=cx, cy=cy)']}, {'name': 'toctree_entry', 'start_line': 313, 'end_line': 314, 'text': ['    def toctree_entry(self):', '        return f\"   ./{op.splitext(self.htmlfilename)[0]}\\\\n\\\\n\"']}, {'name': 'contents_entry', 'start_line': 316, 'end_line': 329, 'text': ['    def contents_entry(self):', '        return (\".. raw:: html\\\\n\\\\n\"', '                \"    <div class=\\'thumb align-center\\'>\\\\n\"', '                \"    <a href=./{}>\\\\n\"', '                \"    <img src=../_static/{}>\\\\n\"', '                \"    <span class=\\'thumb-label\\'>\\\\n\"', '                \"    <p>{}</p>\\\\n\"', '                \"    </span>\\\\n\"', '                \"    </a>\\\\n\"', '                \"    </div>\\\\n\\\\n\"', '                \"\\\\n\\\\n\"', '                \"\".format(self.htmlfilename,', '                          self.thumbfilename,', '                          self.plotfunc))']}]}], 'functions': [{'name': 'execfile', 'start_line': 22, 'end_line': 24, 'text': ['def execfile(filename, globals=None, locals=None):', '    with open(filename, \"rb\") as fp:', \"        exec(compile(fp.read(), filename, 'exec'), globals, locals)\"]}, {'name': 'create_thumbnail', 'start_line': 128, 'end_line': 156, 'text': ['def create_thumbnail(infile, thumbfile,', '                     width=275, height=275,', '                     cx=0.5, cy=0.5, border=4):', '    baseout, extout = op.splitext(thumbfile)', '', '    im = matplotlib.image.imread(infile)', '    rows, cols = im.shape[:2]', '    x0 = int(cx * cols - .5 * width)', '    y0 = int(cy * rows - .5 * height)', '    xslice = slice(x0, x0 + width)', '    yslice = slice(y0, y0 + height)', '    thumb = im[yslice, xslice]', '    thumb[:border, :, :3] = thumb[-border:, :, :3] = 0', '    thumb[:, :border, :3] = thumb[:, -border:, :3] = 0', '', '    dpi = 100', '    fig = plt.figure(figsize=(width / dpi, height / dpi), dpi=dpi)', '', \"    ax = fig.add_axes([0, 0, 1, 1], aspect='auto',\", '                      frameon=False, xticks=[], yticks=[])', '    if all(thumb.shape):', \"        ax.imshow(thumb, aspect='auto', resample=True,\", \"                  interpolation='bilinear')\", '    else:', '        warnings.warn(', '            f\"Bad thumbnail crop. {thumbfile} will be empty.\"', '        )', '    fig.savefig(thumbfile, dpi=dpi)', '    return fig']}, {'name': 'indent', 'start_line': 159, 'end_line': 161, 'text': ['def indent(s, N=4):', '    \"\"\"indent a string\"\"\"', \"    return s.replace('\\\\n', '\\\\n' + N * ' ')\"]}, {'name': 'main', 'start_line': 332, 'end_line': 389, 'text': ['def main(app):', \"    static_dir = op.join(app.builder.srcdir, '_static')\", \"    target_dir = op.join(app.builder.srcdir, 'examples')\", \"    image_dir = op.join(app.builder.srcdir, 'examples/_images')\", '    thumb_dir = op.join(app.builder.srcdir, \"example_thumbs\")', \"    source_dir = op.abspath(op.join(app.builder.srcdir, '..', 'examples'))\", '    if not op.exists(static_dir):', '        os.makedirs(static_dir)', '', '    if not op.exists(target_dir):', '        os.makedirs(target_dir)', '', '    if not op.exists(image_dir):', '        os.makedirs(image_dir)', '', '    if not op.exists(thumb_dir):', '        os.makedirs(thumb_dir)', '', '    if not op.exists(source_dir):', '        os.makedirs(source_dir)', '', '    banner_data = []', '', '    toctree = (\"\\\\n\\\\n\"', '               \".. toctree::\\\\n\"', '               \"   :hidden:\\\\n\\\\n\")', '    contents = \"\\\\n\\\\n\"', '', '    # Write individual example files', '    for filename in sorted(glob.glob(op.join(source_dir, \"*.py\"))):', '', '        ex = ExampleGenerator(filename, target_dir)', '', '        banner_data.append({\"title\": ex.pagetitle,', '                            \"url\": op.join(\\'examples\\', ex.htmlfilename),', '                            \"thumb\": op.join(ex.thumbfilename)})', '        shutil.copyfile(filename, op.join(target_dir, ex.pyfilename))', '        output = RST_TEMPLATE.format(sphinx_tag=ex.sphinxtag,', '                                     docstring=ex.docstring,', '                                     end_line=ex.end_line,', '                                     components=ex.components,', '                                     fname=ex.pyfilename,', '                                     img_file=ex.pngfilename)', \"        with open(op.join(target_dir, ex.rstfilename), 'w') as f:\", '            f.write(output)', '', '        toctree += ex.toctree_entry()', '        contents += ex.contents_entry()', '', '    if len(banner_data) < 10:', '        banner_data = (4 * banner_data)[:10]', '', '    # write index file', \"    index_file = op.join(target_dir, 'index.rst')\", \"    with open(index_file, 'w') as index:\", '        index.write(INDEX_TEMPLATE.format(sphinx_tag=\"example_gallery\",', '                                          toctree=toctree,', '                                          contents=contents))']}, {'name': 'setup', 'start_line': 392, 'end_line': 393, 'text': ['def setup(app):', \"    app.connect('builder-inited', main)\"]}], 'text': ['\"\"\"', 'Sphinx plugin to run example scripts and create a gallery page.', '', 'Lightly modified from the mpld3 project.', '', '\"\"\"', 'import os', 'import os.path as op', 'import re', 'import glob', 'import token', 'import tokenize', 'import shutil', 'import warnings', '', 'import matplotlib', \"matplotlib.use('Agg')\", 'import matplotlib.pyplot as plt  # noqa: E402', '', '', '# Python 3 has no execfile', 'def execfile(filename, globals=None, locals=None):', '    with open(filename, \"rb\") as fp:', \"        exec(compile(fp.read(), filename, 'exec'), globals, locals)\", '', '', 'RST_TEMPLATE = \"\"\"', '', '.. currentmodule:: seaborn', '', '.. _{sphinx_tag}:', '', '{docstring}', '', '.. image:: {img_file}', '', '**seaborn components used:** {components}', '', '.. literalinclude:: {fname}', '    :lines: {end_line}-', '', '\"\"\"', '', '', 'INDEX_TEMPLATE = \"\"\"', ':html_theme.sidebar_secondary.remove:', '', '.. raw:: html', '', '    <style type=\"text/css\">', '    .thumb {{', '        position: relative;', '        float: left;', '        width: 180px;', '        height: 180px;', '        margin: 0;', '    }}', '', '    .thumb img {{', '        position: absolute;', '        display: inline;', '        left: 0;', '        width: 170px;', '        height: 170px;', '        opacity:1.0;', '        filter:alpha(opacity=100); /* For IE8 and earlier */', '    }}', '', '    .thumb:hover img {{', '        -webkit-filter: blur(3px);', '        -moz-filter: blur(3px);', '        -o-filter: blur(3px);', '        -ms-filter: blur(3px);', '        filter: blur(3px);', '        opacity:1.0;', '        filter:alpha(opacity=100); /* For IE8 and earlier */', '    }}', '', '    .thumb span {{', '        position: absolute;', '        display: inline;', '        left: 0;', '        width: 170px;', '        height: 170px;', '        background: #000;', '        color: #fff;', '        visibility: hidden;', '        opacity: 0;', '        z-index: 100;', '    }}', '', '    .thumb p {{', '        position: absolute;', '        top: 45%;', '        width: 170px;', '        font-size: 110%;', '        color: #fff;', '    }}', '', '    .thumb:hover span {{', '        visibility: visible;', '        opacity: .4;', '    }}', '', '    .caption {{', '        position: absolute;', '        width: 180px;', '        top: 170px;', '        text-align: center !important;', '    }}', '    </style>', '', '.. _{sphinx_tag}:', '', 'Example gallery', '===============', '', '{toctree}', '', '{contents}', '', '.. raw:: html', '', '    <div style=\"clear: both\"></div>', '\"\"\"', '', '', 'def create_thumbnail(infile, thumbfile,', '                     width=275, height=275,', '                     cx=0.5, cy=0.5, border=4):', '    baseout, extout = op.splitext(thumbfile)', '', '    im = matplotlib.image.imread(infile)', '    rows, cols = im.shape[:2]', '    x0 = int(cx * cols - .5 * width)', '    y0 = int(cy * rows - .5 * height)', '    xslice = slice(x0, x0 + width)', '    yslice = slice(y0, y0 + height)', '    thumb = im[yslice, xslice]', '    thumb[:border, :, :3] = thumb[-border:, :, :3] = 0', '    thumb[:, :border, :3] = thumb[:, -border:, :3] = 0', '', '    dpi = 100', '    fig = plt.figure(figsize=(width / dpi, height / dpi), dpi=dpi)', '', \"    ax = fig.add_axes([0, 0, 1, 1], aspect='auto',\", '                      frameon=False, xticks=[], yticks=[])', '    if all(thumb.shape):', \"        ax.imshow(thumb, aspect='auto', resample=True,\", \"                  interpolation='bilinear')\", '    else:', '        warnings.warn(', '            f\"Bad thumbnail crop. {thumbfile} will be empty.\"', '        )', '    fig.savefig(thumbfile, dpi=dpi)', '    return fig', '', '', 'def indent(s, N=4):', '    \"\"\"indent a string\"\"\"', \"    return s.replace('\\\\n', '\\\\n' + N * ' ')\", '', '', 'class ExampleGenerator:', '    \"\"\"Tools for generating an example page from a file\"\"\"', '    def __init__(self, filename, target_dir):', '        self.filename = filename', '        self.target_dir = target_dir', '        self.thumbloc = .5, .5', '        self.extract_docstring()', '        with open(filename) as fid:', '            self.filetext = fid.read()', '', '        outfilename = op.join(target_dir, self.rstfilename)', '', \"        # Only actually run it if the output RST file doesn't\", '        # exist or it was modified less recently than the example', '        file_mtime = op.getmtime(filename)', '        if not op.exists(outfilename) or op.getmtime(outfilename) < file_mtime:', '            self.exec_file()', '        else:', '            print(f\"skipping {self.filename}\")', '', '    @property', '    def dirname(self):', '        return op.split(self.filename)[0]', '', '    @property', '    def fname(self):', '        return op.split(self.filename)[1]', '', '    @property', '    def modulename(self):', '        return op.splitext(self.fname)[0]', '', '    @property', '    def pyfilename(self):', \"        return self.modulename + '.py'\", '', '    @property', '    def rstfilename(self):', '        return self.modulename + \".rst\"', '', '    @property', '    def htmlfilename(self):', \"        return self.modulename + '.html'\", '', '    @property', '    def pngfilename(self):', \"        pngfile = self.modulename + '.png'\", '        return \"_images/\" + pngfile', '', '    @property', '    def thumbfilename(self):', \"        pngfile = self.modulename + '_thumb.png'\", '        return pngfile', '', '    @property', '    def sphinxtag(self):', '        return self.modulename', '', '    @property', '    def pagetitle(self):', \"        return self.docstring.strip().split('\\\\n')[0].strip()\", '', '    @property', '    def plotfunc(self):', '        match = re.search(r\"sns\\\\.(.+plot)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        match = re.search(r\"sns\\\\.(.+map)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        match = re.search(r\"sns\\\\.(.+Grid)\\\\(\", self.filetext)', '        if match:', '            return match.group(1)', '        return \"\"', '', '    @property', '    def components(self):', '', '        objects = re.findall(r\"sns\\\\.(\\\\w+)\\\\(\", self.filetext)', '', '        refs = []', '        for obj in objects:', '            if obj[0].isupper():', '                refs.append(f\":class:`{obj}`\")', '            else:', '                refs.append(f\":func:`{obj}`\")', '        return \", \".join(refs)', '', '    def extract_docstring(self):', '        \"\"\" Extract a module-level docstring', '        \"\"\"', '        lines = open(self.filename).readlines()', '        start_row = 0', \"        if lines[0].startswith('#!'):\", '            lines.pop(0)', '            start_row = 1', '', \"        docstring = ''\", \"        first_par = ''\", '        line_iter = lines.__iter__()', '        tokens = tokenize.generate_tokens(lambda: next(line_iter))', '        for tok_type, tok_content, _, (erow, _), _ in tokens:', '            tok_type = token.tok_name[tok_type]', \"            if tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT'):\", '                continue', \"            elif tok_type == 'STRING':\", '                docstring = eval(tok_content)', '                # If the docstring is formatted with several paragraphs,', '                # extract the first one:', \"                paragraphs = '\\\\n'.join(line.rstrip()\", \"                                       for line in docstring.split('\\\\n')\", \"                                       ).split('\\\\n\\\\n')\", '                if len(paragraphs) > 0:', '                    first_par = paragraphs[0]', '            break', '', '        thumbloc = None', '        for i, line in enumerate(docstring.split(\"\\\\n\")):', '            m = re.match(r\"^_thumb: (\\\\.\\\\d+),\\\\s*(\\\\.\\\\d+)\", line)', '            if m:', '                thumbloc = float(m.group(1)), float(m.group(2))', '                break', '        if thumbloc is not None:', '            self.thumbloc = thumbloc', '            docstring = \"\\\\n\".join([l for l in docstring.split(\"\\\\n\")', '                                   if not l.startswith(\"_thumb\")])', '', '        self.docstring = docstring', '        self.short_desc = first_par', '        self.end_line = erow + 1 + start_row', '', '    def exec_file(self):', '        print(f\"running {self.filename}\")', '', \"        plt.close('all')\", \"        my_globals = {'pl': plt,\", \"                      'plt': plt}\", '        execfile(self.filename, my_globals)', '', '        fig = plt.gcf()', '        fig.canvas.draw()', '        pngfile = op.join(self.target_dir, self.pngfilename)', '        thumbfile = op.join(\"example_thumbs\", self.thumbfilename)', '        self.html = f\"<img src=../{self.pngfilename}>\"', '        fig.savefig(pngfile, dpi=75, bbox_inches=\"tight\")', '', '        cx, cy = self.thumbloc', '        create_thumbnail(pngfile, thumbfile, cx=cx, cy=cy)', '', '    def toctree_entry(self):', '        return f\"   ./{op.splitext(self.htmlfilename)[0]}\\\\n\\\\n\"', '', '    def contents_entry(self):', '        return (\".. raw:: html\\\\n\\\\n\"', '                \"    <div class=\\'thumb align-center\\'>\\\\n\"', '                \"    <a href=./{}>\\\\n\"', '                \"    <img src=../_static/{}>\\\\n\"', '                \"    <span class=\\'thumb-label\\'>\\\\n\"', '                \"    <p>{}</p>\\\\n\"', '                \"    </span>\\\\n\"', '                \"    </a>\\\\n\"', '                \"    </div>\\\\n\\\\n\"', '                \"\\\\n\\\\n\"', '                \"\".format(self.htmlfilename,', '                          self.thumbfilename,', '                          self.plotfunc))', '', '', 'def main(app):', \"    static_dir = op.join(app.builder.srcdir, '_static')\", \"    target_dir = op.join(app.builder.srcdir, 'examples')\", \"    image_dir = op.join(app.builder.srcdir, 'examples/_images')\", '    thumb_dir = op.join(app.builder.srcdir, \"example_thumbs\")', \"    source_dir = op.abspath(op.join(app.builder.srcdir, '..', 'examples'))\", '    if not op.exists(static_dir):', '        os.makedirs(static_dir)', '', '    if not op.exists(target_dir):', '        os.makedirs(target_dir)', '', '    if not op.exists(image_dir):', '        os.makedirs(image_dir)', '', '    if not op.exists(thumb_dir):', '        os.makedirs(thumb_dir)', '', '    if not op.exists(source_dir):', '        os.makedirs(source_dir)', '', '    banner_data = []', '', '    toctree = (\"\\\\n\\\\n\"', '               \".. toctree::\\\\n\"', '               \"   :hidden:\\\\n\\\\n\")', '    contents = \"\\\\n\\\\n\"', '', '    # Write individual example files', '    for filename in sorted(glob.glob(op.join(source_dir, \"*.py\"))):', '', '        ex = ExampleGenerator(filename, target_dir)', '', '        banner_data.append({\"title\": ex.pagetitle,', '                            \"url\": op.join(\\'examples\\', ex.htmlfilename),', '                            \"thumb\": op.join(ex.thumbfilename)})', '        shutil.copyfile(filename, op.join(target_dir, ex.pyfilename))', '        output = RST_TEMPLATE.format(sphinx_tag=ex.sphinxtag,', '                                     docstring=ex.docstring,', '                                     end_line=ex.end_line,', '                                     components=ex.components,', '                                     fname=ex.pyfilename,', '                                     img_file=ex.pngfilename)', \"        with open(op.join(target_dir, ex.rstfilename), 'w') as f:\", '            f.write(output)', '', '        toctree += ex.toctree_entry()', '        contents += ex.contents_entry()', '', '    if len(banner_data) < 10:', '        banner_data = (4 * banner_data)[:10]', '', '    # write index file', \"    index_file = op.join(target_dir, 'index.rst')\", \"    with open(index_file, 'w') as index:\", '        index.write(INDEX_TEMPLATE.format(sphinx_tag=\"example_gallery\",', '                                          toctree=toctree,', '                                          contents=contents))', '', '', 'def setup(app):', \"    app.connect('builder-inited', main)\"]}, 'tutorial_builder.py': {'classes': [], 'functions': [{'name': 'main', 'start_line': 49, 'end_line': 76, 'text': ['def main(app):', '', '    content_yaml = Path(app.builder.srcdir) / \"tutorial.yaml\"', '    tutorial_rst = Path(app.builder.srcdir) / \"tutorial.rst\"', '', '    tutorial_dir = Path(app.builder.srcdir) / \"tutorial\"', '    tutorial_dir.mkdir(exist_ok=True)', '', '    with open(content_yaml) as fid:', '        sections = yaml.load(fid, yaml.BaseLoader)', '', '    for section in sections:', '        title = section[\"title\"]', '        section[\"header\"] = \"\\\\n\".join([title, \"-\" * len(title)]) if title else \"\"', '', '    env = Environment().from_string(TEMPLATE)', '    content = env.render(sections=sections)', '', '    with open(tutorial_rst, \"w\") as fid:', '        fid.write(content)', '', '    for section in sections:', '        for page in section[\"pages\"]:', '            if (', '                not (svg_path := tutorial_dir / f\"{page}.svg\").exists()', '                or svg_path.stat().st_mtime < Path(__file__).stat().st_mtime', '            ):', '                write_thumbnail(svg_path, page)']}, {'name': 'write_thumbnail', 'start_line': 79, 'end_line': 92, 'text': ['def write_thumbnail(svg_path, page):', '', '    with (', '        sns.axes_style(\"dark\"),', '        sns.plotting_context(\"notebook\"),', '        sns.color_palette(\"deep\")', '    ):', '        fig = globals()[page]()', '        for ax in fig.axes:', '            ax.set(xticklabels=[], yticklabels=[], xlabel=\"\", ylabel=\"\", title=\"\")', '        with warnings.catch_warnings():', '            warnings.simplefilter(\"ignore\")', '            fig.tight_layout()', '        fig.savefig(svg_path, format=\"svg\")']}, {'name': 'introduction', 'start_line': 95, 'end_line': 127, 'text': ['def introduction():', '', '    tips = sns.load_dataset(\"tips\")', '    fmri = sns.load_dataset(\"fmri\").query(\"region == \\'parietal\\'\")', '    penguins = sns.load_dataset(\"penguins\")', '', '    f = mpl.figure.Figure(figsize=(5, 5))', '    with sns.axes_style(\"whitegrid\"):', '        f.subplots(2, 2)', '', '    sns.scatterplot(', '        tips, x=\"total_bill\", y=\"tip\", hue=\"sex\", size=\"size\",', '        alpha=.75, palette=[\"C0\", \".5\"], legend=False, ax=f.axes[0],', '    )', '    sns.kdeplot(', '        tips.query(\"size != 5\"), x=\"total_bill\", hue=\"size\",', '        palette=\"blend:C0,.5\", fill=True, linewidth=.5,', '        legend=False, common_norm=False, ax=f.axes[1],', '    )', '    sns.lineplot(', '        fmri, x=\"timepoint\", y=\"signal\", hue=\"event\",', '        errorbar=(\"se\", 2), legend=False, palette=[\"C0\", \".5\"], ax=f.axes[2],', '    )', '    sns.boxplot(', '        penguins, x=\"bill_depth_mm\", y=\"species\", hue=\"sex\",', '        whiskerprops=dict(linewidth=1.5), medianprops=dict(linewidth=1.5),', '        boxprops=dict(linewidth=1.5), capprops=dict(linewidth=0),', '        width=.5, palette=[\"C0\", \".8\"], whis=5, ax=f.axes[3],', '    )', '    f.axes[3].legend_ = None', '    for ax in f.axes:', '        ax.set(xticks=[], yticks=[])', '    return f']}, {'name': 'function_overview', 'start_line': 130, 'end_line': 179, 'text': ['def function_overview():', '', '    from matplotlib.patches import FancyBboxPatch', '', '    f = mpl.figure.Figure(figsize=(7, 5))', '    with sns.axes_style(\"white\"):', '        ax = f.subplots()', '    f.subplots_adjust(0, 0, 1, 1)', '    ax.set_axis_off()', '    ax.set(xlim=(0, 1), ylim=(0, 1))', '', '    deep = sns.color_palette(\"deep\")', '    colors = dict(relational=deep[0], distributions=deep[1], categorical=deep[2])', '    dark = sns.color_palette(\"dark\")', '    text_colors = dict(relational=dark[0], distributions=dark[1], categorical=dark[2])', '', '    functions = dict(', '        relational=[\"scatterplot\", \"lineplot\"],', '        distributions=[\"histplot\", \"kdeplot\", \"ecdfplot\", \"rugplot\"],', '        categorical=[', '            \"stripplot\", \"swarmplot\", \"boxplot\", \"violinplot\", \"pointplot\", \"barplot\"', '        ],', '    )', '    pad, w, h = .06, .2, .15', '    xs, y = np.arange(0, 1, 1 / 3) + pad * 1.05, .7', '    for x, mod in zip(xs, functions):', '        color = colors[mod] + (.2,)', '        text_color = text_colors[mod]', '        ax.add_artist(FancyBboxPatch((x, y), w, h, f\"round,pad={pad}\", color=\"white\"))', '        ax.add_artist(FancyBboxPatch(', '            (x, y), w, h, f\"round,pad={pad}\",', '            linewidth=1, edgecolor=text_color, facecolor=color,', '        ))', '        ax.text(', '            x + w / 2, y + h / 2, f\"{mod[:3]}plot\\\\n({mod})\",', '            ha=\"center\", va=\"center\", size=20, color=text_color', '        )', '        for i, func in enumerate(functions[mod]):', '            x_i, y_i = x + w / 2, y - i * .1 - h / 2 - pad', '            xy = x_i - w / 2, y_i - pad / 3', '            ax.add_artist(', '                FancyBboxPatch(xy, w, h / 4, f\"round,pad={pad / 3}\", color=\"white\")', '            )', '            ax.add_artist(FancyBboxPatch(', '                xy, w, h / 4, f\"round,pad={pad / 3}\",', '                linewidth=1, edgecolor=text_color, facecolor=color', '            ))', '            ax.text(x_i, y_i, func, ha=\"center\", va=\"center\", size=16, color=text_color)', '        ax.plot([x_i, x_i], [y, y_i], zorder=-100, color=text_color, lw=1)', '    return f']}, {'name': 'data_structure', 'start_line': 182, 'end_line': 201, 'text': ['def data_structure():', '', '    f = mpl.figure.Figure(figsize=(7, 5))', '    gs = mpl.gridspec.GridSpec(', '        figure=f, ncols=6, nrows=2, height_ratios=(1, 20),', '        left=0, right=.35, bottom=0, top=.9, wspace=.1, hspace=.01', '    )', '    colors = [c + (.5,) for c in sns.color_palette(\"deep\")]', '    f.add_subplot(gs[0, :], facecolor=\".8\")', '    for i in range(gs.ncols):', '        f.add_subplot(gs[1:, i], facecolor=colors[i])', '', '    gs = mpl.gridspec.GridSpec(', '        figure=f, ncols=2, nrows=2, height_ratios=(1, 8), width_ratios=(1, 11),', '        left=.4, right=1, bottom=.2, top=.8, wspace=.015, hspace=.02', '    )', '    f.add_subplot(gs[0, 1:], facecolor=colors[2])', '    f.add_subplot(gs[1:, 0], facecolor=colors[1])', '    f.add_subplot(gs[1, 1], facecolor=colors[0])', '    return f']}, {'name': 'error_bars', 'start_line': 204, 'end_line': 214, 'text': ['def error_bars():', '', '    diamonds = sns.load_dataset(\"diamonds\")', '    with sns.axes_style(\"whitegrid\"):', '        g = sns.catplot(', '            diamonds, x=\"carat\", y=\"clarity\", hue=\"clarity\", kind=\"point\",', '            errorbar=(\"sd\", .5), join=False, legend=False, facet_kws={\"despine\": False},', '            palette=\"ch:s=-.2,r=-.2,d=.4,l=.6_r\", scale=.75, capsize=.3,', '        )', '    g.ax.yaxis.set_inverted(False)', '    return g.figure']}, {'name': 'properties', 'start_line': 217, 'end_line': 243, 'text': ['def properties():', '', '    f = mpl.figure.Figure(figsize=(5, 5))', '', '    x = np.arange(1, 11)', '    y = np.zeros_like(x)', '', '    p = so.Plot(x, y)', '    ps = 14', '    plots = [', '        p.add(so.Dot(pointsize=ps), color=map(str, x)),', '        p.add(so.Dot(color=\".3\", pointsize=ps), alpha=x),', '        p.add(so.Dot(color=\".9\", pointsize=ps, edgewidth=2), edgecolor=x),', '        p.add(so.Dot(color=\".3\"), pointsize=x).scale(pointsize=(4, 18)),', '        p.add(so.Dot(pointsize=ps, color=\".9\", edgecolor=\".2\"), edgewidth=x),', '        p.add(so.Dot(pointsize=ps, color=\".3\"), marker=map(str, x)),', '        p.add(so.Dot(pointsize=ps, color=\".3\", marker=\"x\"), stroke=x),', '    ]', '', '    with sns.axes_style(\"ticks\"):', '        axs = f.subplots(len(plots))', '    for p, ax in zip(plots, axs):', '        p.on(ax).plot()', '        ax.set(xticks=x, yticks=[], xticklabels=[], ylim=(-.2, .3))', '        sns.despine(ax=ax, left=True)', '    f.legends = []', '    return f']}, {'name': 'objects_interface', 'start_line': 246, 'end_line': 271, 'text': ['def objects_interface():', '', '    f = mpl.figure.Figure(figsize=(5, 4))', '    C = sns.color_palette(\"deep\")', '    ax = f.subplots()', '    fontsize = 22', '    rects = [((.135, .50), .69), ((.275, .38), .26), ((.59, .38), .40)]', '    for i, (xy, w) in enumerate(rects):', '        ax.add_artist(mpl.patches.Rectangle(xy, w, .09, color=C[i], alpha=.2, lw=0))', '    ax.text(0, .52, \"Plot(data, \\'x\\', \\'y\\', color=\\'var1\\')\", size=fontsize, color=\".2\")', '    ax.text(0, .40, \".add(Dot(alpha=.5), marker=\\'var2\\')\", size=fontsize, color=\".2\")', '    annots = [', '        (\"Mapped\\\\nin all layers\", (.48, .62), (0, 55)),', '        (\"Set directly\", (.41, .35), (0, -55)),', '        (\"Mapped\\\\nin this layer\", (.80, .35), (0, -55)),', '    ]', '    for i, (text, xy, xytext) in enumerate(annots):', '        ax.annotate(', '            text, xy, xytext,', '            textcoords=\"offset points\", fontsize=18, ha=\"center\", va=\"center\",', '            arrowprops=dict(arrowstyle=\"->\", linewidth=1.5, color=C[i]), color=C[i],', '        )', '    ax.set_axis_off()', '    f.subplots_adjust(0, 0, 1, 1)', '', '    return f']}, {'name': 'relational', 'start_line': 274, 'end_line': 284, 'text': ['def relational():', '', '    mpg = sns.load_dataset(\"mpg\")', '    with sns.axes_style(\"ticks\"):', '        g = sns.relplot(', '            data=mpg, x=\"horsepower\", y=\"mpg\", size=\"displacement\", hue=\"weight\",', '            sizes=(50, 500), hue_norm=(2000, 4500), alpha=.75, legend=False,', '            palette=\"ch:start=-.5,rot=.7,dark=.3,light=.7_r\",', '        )', '    g.figure.set_size_inches(5, 5)', '    return g.figure']}, {'name': 'distributions', 'start_line': 287, 'end_line': 297, 'text': ['def distributions():', '', '    penguins = sns.load_dataset(\"penguins\").dropna()', '    with sns.axes_style(\"white\"):', '        g = sns.displot(', '            penguins, x=\"flipper_length_mm\", row=\"island\",', '            binwidth=4, kde=True, line_kws=dict(linewidth=2), legend=False,', '        )', '    sns.despine(left=True)', '    g.figure.set_size_inches(5, 5)', '    return g.figure']}, {'name': 'categorical', 'start_line': 300, 'end_line': 310, 'text': ['def categorical():', '', '    penguins = sns.load_dataset(\"penguins\").dropna()', '    with sns.axes_style(\"whitegrid\"):', '        g = sns.catplot(', '            penguins, x=\"sex\", y=\"body_mass_g\", hue=\"island\", col=\"sex\",', '            kind=\"box\", whis=np.inf, legend=False, sharex=False,', '        )', '    sns.despine(left=True)', '    g.figure.set_size_inches(5, 5)', '    return g.figure']}, {'name': 'regression', 'start_line': 313, 'end_line': 324, 'text': ['def regression():', '', '    anscombe = sns.load_dataset(\"anscombe\")', '    with sns.axes_style(\"white\"):', '        g = sns.lmplot(', '            anscombe, x=\"x\", y=\"y\", hue=\"dataset\", col=\"dataset\", col_wrap=2,', '            scatter_kws=dict(edgecolor=\".2\", facecolor=\".7\", s=80),', '            line_kws=dict(lw=4), ci=None,', '        )', '    g.set(xlim=(2, None), ylim=(2, None))', '    g.figure.set_size_inches(5, 5)', '    return g.figure']}, {'name': 'axis_grids', 'start_line': 327, 'end_line': 337, 'text': ['def axis_grids():', '', '    penguins = sns.load_dataset(\"penguins\").sample(200, random_state=0)', '    with sns.axes_style(\"ticks\"):', '        g = sns.pairplot(', '            penguins.drop(\"flipper_length_mm\", axis=1),', '            diag_kind=\"kde\", diag_kws=dict(fill=False),', '            plot_kws=dict(s=40, fc=\"none\", ec=\"C0\", alpha=.75, linewidth=.75),', '        )', '    g.figure.set_size_inches(5, 5)', '    return g.figure']}, {'name': 'aesthetics', 'start_line': 340, 'end_line': 349, 'text': ['def aesthetics():', '', '    f = mpl.figure.Figure(figsize=(5, 5))', '    for i, style in enumerate([\"darkgrid\", \"white\", \"ticks\", \"whitegrid\"], 1):', '        with sns.axes_style(style):', '            ax = f.add_subplot(2, 2, i)', '        ax.set(xticks=[0, .25, .5, .75, 1], yticks=[0, .25, .5, .75, 1])', '    sns.despine(ax=f.axes[1])', '    sns.despine(ax=f.axes[2])', '    return f']}, {'name': 'color_palettes', 'start_line': 352, 'end_line': 362, 'text': ['def color_palettes():', '', '    f = mpl.figure.Figure(figsize=(5, 5))', '    palettes = [\"deep\", \"husl\", \"gray\", \"ch:\", \"mako\", \"vlag\", \"icefire\"]', '    axs = f.subplots(len(palettes))', '    x = np.arange(10)', '    for ax, name in zip(axs, palettes):', '        cmap = mpl.colors.ListedColormap(sns.color_palette(name, x.size))', '        ax.pcolormesh(x[None, :], linewidth=.5, edgecolor=\"w\", alpha=.8, cmap=cmap)', '        ax.set_axis_off()', '    return f']}, {'name': 'setup', 'start_line': 365, 'end_line': 366, 'text': ['def setup(app):', '    app.connect(\"builder-inited\", main)']}], 'text': ['from pathlib import Path', 'import warnings', '', 'from jinja2 import Environment', 'import yaml', '', 'import numpy as np', 'import matplotlib as mpl', 'import seaborn as sns', 'import seaborn.objects as so', '', '', 'TEMPLATE = \"\"\"', ':notoc:', '', '.. _tutorial:', '', 'User guide and tutorial', '=======================', '{% for section in sections %}', '{{ section.header }}', '{% for page in section.pages %}', '.. grid:: 1', '  :gutter: 2', '', '  .. grid-item-card::', '', '    .. grid:: 2', '', '      .. grid-item::', '        :columns: 3', '', '        .. image:: ./tutorial/{{ page }}.svg', '          :target: ./tutorial/{{ page }}.html', '', '      .. grid-item::', '        :columns: 9', '        :margin: auto', '', '        .. toctree::', '          :maxdepth: 2', '', '          tutorial/{{ page }}', '{% endfor %}', '{% endfor %}', '\"\"\"', '', '', 'def main(app):', '', '    content_yaml = Path(app.builder.srcdir) / \"tutorial.yaml\"', '    tutorial_rst = Path(app.builder.srcdir) / \"tutorial.rst\"', '', '    tutorial_dir = Path(app.builder.srcdir) / \"tutorial\"', '    tutorial_dir.mkdir(exist_ok=True)', '', '    with open(content_yaml) as fid:', '        sections = yaml.load(fid, yaml.BaseLoader)', '', '    for section in sections:', '        title = section[\"title\"]', '        section[\"header\"] = \"\\\\n\".join([title, \"-\" * len(title)]) if title else \"\"', '', '    env = Environment().from_string(TEMPLATE)', '    content = env.render(sections=sections)', '', '    with open(tutorial_rst, \"w\") as fid:', '        fid.write(content)', '', '    for section in sections:', '        for page in section[\"pages\"]:', '            if (', '                not (svg_path := tutorial_dir / f\"{page}.svg\").exists()', '                or svg_path.stat().st_mtime < Path(__file__).stat().st_mtime', '            ):', '                write_thumbnail(svg_path, page)', '', '', 'def write_thumbnail(svg_path, page):', '', '    with (', '        sns.axes_style(\"dark\"),', '        sns.plotting_context(\"notebook\"),', '        sns.color_palette(\"deep\")', '    ):', '        fig = globals()[page]()', '        for ax in fig.axes:', '            ax.set(xticklabels=[], yticklabels=[], xlabel=\"\", ylabel=\"\", title=\"\")', '        with warnings.catch_warnings():', '            warnings.simplefilter(\"ignore\")', '            fig.tight_layout()', '        fig.savefig(svg_path, format=\"svg\")', '', '', 'def introduction():', '', '    tips = sns.load_dataset(\"tips\")', '    fmri = sns.load_dataset(\"fmri\").query(\"region == \\'parietal\\'\")', '    penguins = sns.load_dataset(\"penguins\")', '', '    f = mpl.figure.Figure(figsize=(5, 5))', '    with sns.axes_style(\"whitegrid\"):', '        f.subplots(2, 2)', '', '    sns.scatterplot(', '        tips, x=\"total_bill\", y=\"tip\", hue=\"sex\", size=\"size\",', '        alpha=.75, palette=[\"C0\", \".5\"], legend=False, ax=f.axes[0],', '    )', '    sns.kdeplot(', '        tips.query(\"size != 5\"), x=\"total_bill\", hue=\"size\",', '        palette=\"blend:C0,.5\", fill=True, linewidth=.5,', '        legend=False, common_norm=False, ax=f.axes[1],', '    )', '    sns.lineplot(', '        fmri, x=\"timepoint\", y=\"signal\", hue=\"event\",', '        errorbar=(\"se\", 2), legend=False, palette=[\"C0\", \".5\"], ax=f.axes[2],', '    )', '    sns.boxplot(', '        penguins, x=\"bill_depth_mm\", y=\"species\", hue=\"sex\",', '        whiskerprops=dict(linewidth=1.5), medianprops=dict(linewidth=1.5),', '        boxprops=dict(linewidth=1.5), capprops=dict(linewidth=0),', '        width=.5, palette=[\"C0\", \".8\"], whis=5, ax=f.axes[3],', '    )', '    f.axes[3].legend_ = None', '    for ax in f.axes:', '        ax.set(xticks=[], yticks=[])', '    return f', '', '', 'def function_overview():', '', '    from matplotlib.patches import FancyBboxPatch', '', '    f = mpl.figure.Figure(figsize=(7, 5))', '    with sns.axes_style(\"white\"):', '        ax = f.subplots()', '    f.subplots_adjust(0, 0, 1, 1)', '    ax.set_axis_off()', '    ax.set(xlim=(0, 1), ylim=(0, 1))', '', '    deep = sns.color_palette(\"deep\")', '    colors = dict(relational=deep[0], distributions=deep[1], categorical=deep[2])', '    dark = sns.color_palette(\"dark\")', '    text_colors = dict(relational=dark[0], distributions=dark[1], categorical=dark[2])', '', '    functions = dict(', '        relational=[\"scatterplot\", \"lineplot\"],', '        distributions=[\"histplot\", \"kdeplot\", \"ecdfplot\", \"rugplot\"],', '        categorical=[', '            \"stripplot\", \"swarmplot\", \"boxplot\", \"violinplot\", \"pointplot\", \"barplot\"', '        ],', '    )', '    pad, w, h = .06, .2, .15', '    xs, y = np.arange(0, 1, 1 / 3) + pad * 1.05, .7', '    for x, mod in zip(xs, functions):', '        color = colors[mod] + (.2,)', '        text_color = text_colors[mod]', '        ax.add_artist(FancyBboxPatch((x, y), w, h, f\"round,pad={pad}\", color=\"white\"))', '        ax.add_artist(FancyBboxPatch(', '            (x, y), w, h, f\"round,pad={pad}\",', '            linewidth=1, edgecolor=text_color, facecolor=color,', '        ))', '        ax.text(', '            x + w / 2, y + h / 2, f\"{mod[:3]}plot\\\\n({mod})\",', '            ha=\"center\", va=\"center\", size=20, color=text_color', '        )', '        for i, func in enumerate(functions[mod]):', '            x_i, y_i = x + w / 2, y - i * .1 - h / 2 - pad', '            xy = x_i - w / 2, y_i - pad / 3', '            ax.add_artist(', '                FancyBboxPatch(xy, w, h / 4, f\"round,pad={pad / 3}\", color=\"white\")', '            )', '            ax.add_artist(FancyBboxPatch(', '                xy, w, h / 4, f\"round,pad={pad / 3}\",', '                linewidth=1, edgecolor=text_color, facecolor=color', '            ))', '            ax.text(x_i, y_i, func, ha=\"center\", va=\"center\", size=16, color=text_color)', '        ax.plot([x_i, x_i], [y, y_i], zorder=-100, color=text_color, lw=1)', '    return f', '', '', 'def data_structure():', '', '    f = mpl.figure.Figure(figsize=(7, 5))', '    gs = mpl.gridspec.GridSpec(', '        figure=f, ncols=6, nrows=2, height_ratios=(1, 20),', '        left=0, right=.35, bottom=0, top=.9, wspace=.1, hspace=.01', '    )', '    colors = [c + (.5,) for c in sns.color_palette(\"deep\")]', '    f.add_subplot(gs[0, :], facecolor=\".8\")', '    for i in range(gs.ncols):', '        f.add_subplot(gs[1:, i], facecolor=colors[i])', '', '    gs = mpl.gridspec.GridSpec(', '        figure=f, ncols=2, nrows=2, height_ratios=(1, 8), width_ratios=(1, 11),', '        left=.4, right=1, bottom=.2, top=.8, wspace=.015, hspace=.02', '    )', '    f.add_subplot(gs[0, 1:], facecolor=colors[2])', '    f.add_subplot(gs[1:, 0], facecolor=colors[1])', '    f.add_subplot(gs[1, 1], facecolor=colors[0])', '    return f', '', '', 'def error_bars():', '', '    diamonds = sns.load_dataset(\"diamonds\")', '    with sns.axes_style(\"whitegrid\"):', '        g = sns.catplot(', '            diamonds, x=\"carat\", y=\"clarity\", hue=\"clarity\", kind=\"point\",', '            errorbar=(\"sd\", .5), join=False, legend=False, facet_kws={\"despine\": False},', '            palette=\"ch:s=-.2,r=-.2,d=.4,l=.6_r\", scale=.75, capsize=.3,', '        )', '    g.ax.yaxis.set_inverted(False)', '    return g.figure', '', '', 'def properties():', '', '    f = mpl.figure.Figure(figsize=(5, 5))', '', '    x = np.arange(1, 11)', '    y = np.zeros_like(x)', '', '    p = so.Plot(x, y)', '    ps = 14', '    plots = [', '        p.add(so.Dot(pointsize=ps), color=map(str, x)),', '        p.add(so.Dot(color=\".3\", pointsize=ps), alpha=x),', '        p.add(so.Dot(color=\".9\", pointsize=ps, edgewidth=2), edgecolor=x),', '        p.add(so.Dot(color=\".3\"), pointsize=x).scale(pointsize=(4, 18)),', '        p.add(so.Dot(pointsize=ps, color=\".9\", edgecolor=\".2\"), edgewidth=x),', '        p.add(so.Dot(pointsize=ps, color=\".3\"), marker=map(str, x)),', '        p.add(so.Dot(pointsize=ps, color=\".3\", marker=\"x\"), stroke=x),', '    ]', '', '    with sns.axes_style(\"ticks\"):', '        axs = f.subplots(len(plots))', '    for p, ax in zip(plots, axs):', '        p.on(ax).plot()', '        ax.set(xticks=x, yticks=[], xticklabels=[], ylim=(-.2, .3))', '        sns.despine(ax=ax, left=True)', '    f.legends = []', '    return f', '', '', 'def objects_interface():', '', '    f = mpl.figure.Figure(figsize=(5, 4))', '    C = sns.color_palette(\"deep\")', '    ax = f.subplots()', '    fontsize = 22', '    rects = [((.135, .50), .69), ((.275, .38), .26), ((.59, .38), .40)]', '    for i, (xy, w) in enumerate(rects):', '        ax.add_artist(mpl.patches.Rectangle(xy, w, .09, color=C[i], alpha=.2, lw=0))', '    ax.text(0, .52, \"Plot(data, \\'x\\', \\'y\\', color=\\'var1\\')\", size=fontsize, color=\".2\")', '    ax.text(0, .40, \".add(Dot(alpha=.5), marker=\\'var2\\')\", size=fontsize, color=\".2\")', '    annots = [', '        (\"Mapped\\\\nin all layers\", (.48, .62), (0, 55)),', '        (\"Set directly\", (.41, .35), (0, -55)),', '        (\"Mapped\\\\nin this layer\", (.80, .35), (0, -55)),', '    ]', '    for i, (text, xy, xytext) in enumerate(annots):', '        ax.annotate(', '            text, xy, xytext,', '            textcoords=\"offset points\", fontsize=18, ha=\"center\", va=\"center\",', '            arrowprops=dict(arrowstyle=\"->\", linewidth=1.5, color=C[i]), color=C[i],', '        )', '    ax.set_axis_off()', '    f.subplots_adjust(0, 0, 1, 1)', '', '    return f', '', '', 'def relational():', '', '    mpg = sns.load_dataset(\"mpg\")', '    with sns.axes_style(\"ticks\"):', '        g = sns.relplot(', '            data=mpg, x=\"horsepower\", y=\"mpg\", size=\"displacement\", hue=\"weight\",', '            sizes=(50, 500), hue_norm=(2000, 4500), alpha=.75, legend=False,', '            palette=\"ch:start=-.5,rot=.7,dark=.3,light=.7_r\",', '        )', '    g.figure.set_size_inches(5, 5)', '    return g.figure', '', '', 'def distributions():', '', '    penguins = sns.load_dataset(\"penguins\").dropna()', '    with sns.axes_style(\"white\"):', '        g = sns.displot(', '            penguins, x=\"flipper_length_mm\", row=\"island\",', '            binwidth=4, kde=True, line_kws=dict(linewidth=2), legend=False,', '        )', '    sns.despine(left=True)', '    g.figure.set_size_inches(5, 5)', '    return g.figure', '', '', 'def categorical():', '', '    penguins = sns.load_dataset(\"penguins\").dropna()', '    with sns.axes_style(\"whitegrid\"):', '        g = sns.catplot(', '            penguins, x=\"sex\", y=\"body_mass_g\", hue=\"island\", col=\"sex\",', '            kind=\"box\", whis=np.inf, legend=False, sharex=False,', '        )', '    sns.despine(left=True)', '    g.figure.set_size_inches(5, 5)', '    return g.figure', '', '', 'def regression():', '', '    anscombe = sns.load_dataset(\"anscombe\")', '    with sns.axes_style(\"white\"):', '        g = sns.lmplot(', '            anscombe, x=\"x\", y=\"y\", hue=\"dataset\", col=\"dataset\", col_wrap=2,', '            scatter_kws=dict(edgecolor=\".2\", facecolor=\".7\", s=80),', '            line_kws=dict(lw=4), ci=None,', '        )', '    g.set(xlim=(2, None), ylim=(2, None))', '    g.figure.set_size_inches(5, 5)', '    return g.figure', '', '', 'def axis_grids():', '', '    penguins = sns.load_dataset(\"penguins\").sample(200, random_state=0)', '    with sns.axes_style(\"ticks\"):', '        g = sns.pairplot(', '            penguins.drop(\"flipper_length_mm\", axis=1),', '            diag_kind=\"kde\", diag_kws=dict(fill=False),', '            plot_kws=dict(s=40, fc=\"none\", ec=\"C0\", alpha=.75, linewidth=.75),', '        )', '    g.figure.set_size_inches(5, 5)', '    return g.figure', '', '', 'def aesthetics():', '', '    f = mpl.figure.Figure(figsize=(5, 5))', '    for i, style in enumerate([\"darkgrid\", \"white\", \"ticks\", \"whitegrid\"], 1):', '        with sns.axes_style(style):', '            ax = f.add_subplot(2, 2, i)', '        ax.set(xticks=[0, .25, .5, .75, 1], yticks=[0, .25, .5, .75, 1])', '    sns.despine(ax=f.axes[1])', '    sns.despine(ax=f.axes[2])', '    return f', '', '', 'def color_palettes():', '', '    f = mpl.figure.Figure(figsize=(5, 5))', '    palettes = [\"deep\", \"husl\", \"gray\", \"ch:\", \"mako\", \"vlag\", \"icefire\"]', '    axs = f.subplots(len(palettes))', '    x = np.arange(10)', '    for ax, name in zip(axs, palettes):', '        cmap = mpl.colors.ListedColormap(sns.color_palette(name, x.size))', '        ax.pcolormesh(x[None, :], linewidth=.5, edgecolor=\"w\", alpha=.8, cmap=cmap)', '        ax.set_axis_off()', '    return f', '', '', 'def setup(app):', '    app.connect(\"builder-inited\", main)']}}}, 'examples': {'residplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Plotting model residuals', '========================', '', '\"\"\"', 'import numpy as np', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', '# Make an example dataset with y ~ x', 'rs = np.random.RandomState(7)', 'x = rs.normal(2, 1, 75)', 'y = 2 + 1.5 * x + rs.normal(0, 2, 75)', '', '# Plot the residuals after fitting a linear model', 'sns.residplot(x=x, y=y, lowess=True, color=\"g\")']}, 'radial_facets.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'FacetGrid with custom projection', '================================', '', '_thumb: .33, .5', '', '\"\"\"', 'import numpy as np', 'import pandas as pd', 'import seaborn as sns', '', 'sns.set_theme()', '', '# Generate an example radial datast', 'r = np.linspace(0, 10, num=100)', \"df = pd.DataFrame({'r': r, 'slow': r, 'medium': 2 * r, 'fast': 4 * r})\", '', '# Convert the dataframe to long-form or \"tidy\" format', \"df = pd.melt(df, id_vars=['r'], var_name='speed', value_name='theta')\", '', '# Set up a grid of axes with a polar projection', 'g = sns.FacetGrid(df, col=\"speed\", hue=\"speed\",', \"                  subplot_kws=dict(projection='polar'), height=4.5,\", '                  sharex=False, sharey=False, despine=False)', '', '# Draw a scatterplot onto each axes in the grid', 'g.map(sns.scatterplot, \"theta\", \"r\")']}, 'strip_regplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Regression fit over a strip plot', '================================', '', '_thumb: .53, .5', '\"\"\"', 'import seaborn as sns', 'sns.set_theme()', '', 'mpg = sns.load_dataset(\"mpg\")', 'sns.catplot(', '    data=mpg, x=\"cylinders\", y=\"acceleration\", hue=\"weight\",', '    native_scale=True, zorder=1', ')', 'sns.regplot(', '    data=mpg, x=\"cylinders\", y=\"acceleration\",', '    scatter=False, truncate=False, order=2, color=\".2\",', ')']}, 'pair_grid_with_kde.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Paired density and scatterplot matrix', '=====================================', '', '_thumb: .5, .5', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"white\")', '', 'df = sns.load_dataset(\"penguins\")', '', 'g = sns.PairGrid(df, diag_sharey=False)', 'g.map_upper(sns.scatterplot, s=15)', 'g.map_lower(sns.kdeplot)', 'g.map_diag(sns.kdeplot, lw=2)']}, 'horizontal_boxplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Horizontal boxplot with observations', '====================================', '', '_thumb: .7, .37', '\"\"\"', 'import seaborn as sns', 'import matplotlib.pyplot as plt', '', 'sns.set_theme(style=\"ticks\")', '', '# Initialize the figure with a logarithmic x axis', 'f, ax = plt.subplots(figsize=(7, 6))', 'ax.set_xscale(\"log\")', '', '# Load the example planets dataset', 'planets = sns.load_dataset(\"planets\")', '', '# Plot the orbital period with horizontal boxes', 'sns.boxplot(x=\"distance\", y=\"method\", data=planets,', '            whis=[0, 100], width=.6, palette=\"vlag\")', '', '# Add in points to show each observation', 'sns.stripplot(x=\"distance\", y=\"method\", data=planets,', '              size=4, color=\".3\", linewidth=0)', '', '# Tweak the visual presentation', 'ax.xaxis.grid(True)', 'ax.set(ylabel=\"\")', 'sns.despine(trim=True, left=True)']}, 'part_whole_bars.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Horizontal bar plots', '====================', '', '\"\"\"', 'import seaborn as sns', 'import matplotlib.pyplot as plt', 'sns.set_theme(style=\"whitegrid\")', '', '# Initialize the matplotlib figure', 'f, ax = plt.subplots(figsize=(6, 15))', '', '# Load the example car crash dataset', 'crashes = sns.load_dataset(\"car_crashes\").sort_values(\"total\", ascending=False)', '', '# Plot the total crashes', 'sns.set_color_codes(\"pastel\")', 'sns.barplot(x=\"total\", y=\"abbrev\", data=crashes,', '            label=\"Total\", color=\"b\")', '', '# Plot the crashes where alcohol was involved', 'sns.set_color_codes(\"muted\")', 'sns.barplot(x=\"alcohol\", y=\"abbrev\", data=crashes,', '            label=\"Alcohol-involved\", color=\"b\")', '', '# Add a legend and informative axis label', 'ax.legend(ncol=2, loc=\"lower right\", frameon=True)', 'ax.set(xlim=(0, 24), ylabel=\"\",', '       xlabel=\"Automobile collisions per billion miles\")', 'sns.despine(left=True, bottom=True)']}, 'faceted_histogram.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Facetting histograms by subsets of data', '=======================================', '', '_thumb: .33, .57', '\"\"\"', 'import seaborn as sns', '', 'sns.set_theme(style=\"darkgrid\")', 'df = sns.load_dataset(\"penguins\")', 'sns.displot(', '    df, x=\"flipper_length_mm\", col=\"species\", row=\"sex\",', '    binwidth=3, height=3, facet_kws=dict(margin_titles=True),', ')']}, 'grouped_violinplots.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Grouped violinplots with split violins', '======================================', '', '_thumb: .44, .47', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the example tips dataset', 'tips = sns.load_dataset(\"tips\")', '', '# Draw a nested violinplot and split the violins for easier comparison', 'sns.violinplot(data=tips, x=\"day\", y=\"total_bill\", hue=\"smoker\",', '               split=True, inner=\"quart\", linewidth=1,', '               palette={\"Yes\": \"b\", \"No\": \".85\"})', 'sns.despine(left=True)']}, 'layered_bivariate_plot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Bivariate plot with multiple elements', '=====================================', '', '', '\"\"\"', 'import numpy as np', 'import seaborn as sns', 'import matplotlib.pyplot as plt', 'sns.set_theme(style=\"dark\")', '', '# Simulate data from a bivariate Gaussian', 'n = 10000', 'mean = [0, 0]', 'cov = [(2, .4), (.4, .2)]', 'rng = np.random.RandomState(0)', 'x, y = rng.multivariate_normal(mean, cov, n).T', '', '# Draw a combo histogram and scatterplot with density contours', 'f, ax = plt.subplots(figsize=(6, 6))', 'sns.scatterplot(x=x, y=y, s=5, color=\".15\")', 'sns.histplot(x=x, y=y, bins=50, pthresh=.1, cmap=\"mako\")', 'sns.kdeplot(x=x, y=y, levels=5, color=\"w\", linewidths=1)']}, 'kde_ridgeplot.py': {'classes': [], 'functions': [{'name': 'label', 'start_line': 36, 'end_line': 39, 'text': ['def label(x, color, label):', '    ax = plt.gca()', '    ax.text(0, .2, label, fontweight=\"bold\", color=color,', '            ha=\"left\", va=\"center\", transform=ax.transAxes)']}], 'text': ['\"\"\"', \"Overlapping densities ('ridge plot')\", '====================================', '', '', '\"\"\"', 'import numpy as np', 'import pandas as pd', 'import seaborn as sns', 'import matplotlib.pyplot as plt', 'sns.set_theme(style=\"white\", rc={\"axes.facecolor\": (0, 0, 0, 0)})', '', '# Create the data', 'rs = np.random.RandomState(1979)', 'x = rs.randn(500)', 'g = np.tile(list(\"ABCDEFGHIJ\"), 50)', 'df = pd.DataFrame(dict(x=x, g=g))', 'm = df.g.map(ord)', 'df[\"x\"] += m', '', '# Initialize the FacetGrid object', 'pal = sns.cubehelix_palette(10, rot=-.25, light=.7)', 'g = sns.FacetGrid(df, row=\"g\", hue=\"g\", aspect=15, height=.5, palette=pal)', '', '# Draw the densities in a few steps', 'g.map(sns.kdeplot, \"x\",', '      bw_adjust=.5, clip_on=False,', '      fill=True, alpha=1, linewidth=1.5)', 'g.map(sns.kdeplot, \"x\", clip_on=False, color=\"w\", lw=2, bw_adjust=.5)', '', '# passing color=None to refline() uses the hue mapping', 'g.refline(y=0, linewidth=2, linestyle=\"-\", color=None, clip_on=False)', '', '', '# Define and use a simple function to label the plot in axes coordinates', 'def label(x, color, label):', '    ax = plt.gca()', '    ax.text(0, .2, label, fontweight=\"bold\", color=color,', '            ha=\"left\", va=\"center\", transform=ax.transAxes)', '', '', 'g.map(label, \"x\")', '', '# Set the subplots to overlap', 'g.figure.subplots_adjust(hspace=-.25)', '', \"# Remove axes details that don't play well with overlap\", 'g.set_titles(\"\")', 'g.set(yticks=[], ylabel=\"\")', 'g.despine(bottom=True, left=True)']}, 'multiple_regression.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Multiple linear regression', '==========================', '', '_thumb: .45, .45', '\"\"\"', 'import seaborn as sns', 'sns.set_theme()', '', '# Load the penguins dataset', 'penguins = sns.load_dataset(\"penguins\")', '', '# Plot sepal width as a function of sepal_length across days', 'g = sns.lmplot(', '    data=penguins,', '    x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"species\",', '    height=5', ')', '', '# Use more informative axis labels than are provided by default', 'g.set_axis_labels(\"Snoot length (mm)\", \"Snoot depth (mm)\")']}, 'scatterplot_sizes.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Scatterplot with continuous hues and sizes', '==========================================', '', '_thumb: .51, .44', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the example planets dataset', 'planets = sns.load_dataset(\"planets\")', '', 'cmap = sns.cubehelix_palette(rot=-.2, as_cmap=True)', 'g = sns.relplot(', '    data=planets,', '    x=\"distance\", y=\"orbital_period\",', '    hue=\"year\", size=\"mass\",', '    palette=cmap, sizes=(10, 200),', ')', 'g.set(xscale=\"log\", yscale=\"log\")', 'g.ax.xaxis.grid(True, \"minor\", linewidth=.25)', 'g.ax.yaxis.grid(True, \"minor\", linewidth=.25)', 'g.despine(left=True, bottom=True)']}, 'hexbin_marginals.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Hexbin plot with marginal distributions', '=======================================', '', '_thumb: .45, .4', '\"\"\"', 'import numpy as np', 'import seaborn as sns', 'sns.set_theme(style=\"ticks\")', '', 'rs = np.random.RandomState(11)', 'x = rs.gamma(2, size=1000)', 'y = -.5 * x + rs.normal(size=1000)', '', 'sns.jointplot(x=x, y=y, kind=\"hex\", color=\"#4CB391\")']}, 'multiple_ecdf.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Facetted ECDF plots', '===================', '', '_thumb: .30, .49', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"ticks\")', 'mpg = sns.load_dataset(\"mpg\")', '', 'colors = (250, 70, 50), (350, 70, 50)', 'cmap = sns.blend_palette(colors, input=\"husl\", as_cmap=True)', 'sns.displot(', '    mpg,', '    x=\"displacement\", col=\"origin\", hue=\"model_year\",', '    kind=\"ecdf\", aspect=.75, linewidth=2, palette=cmap,', ')']}, 'grouped_boxplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Grouped boxplots', '================', '', '_thumb: .66, .45', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"ticks\", palette=\"pastel\")', '', '# Load the example tips dataset', 'tips = sns.load_dataset(\"tips\")', '', '# Draw a nested boxplot to show bills by day and time', 'sns.boxplot(x=\"day\", y=\"total_bill\",', '            hue=\"smoker\", palette=[\"m\", \"g\"],', '            data=tips)', 'sns.despine(offset=10, trim=True)']}, 'timeseries_facets.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Small multiple time series', '--------------------------', '', '_thumb: .42, .58', '', '\"\"\"', 'import seaborn as sns', '', 'sns.set_theme(style=\"dark\")', 'flights = sns.load_dataset(\"flights\")', '', \"# Plot each year's time series in its own facet\", 'g = sns.relplot(', '    data=flights,', '    x=\"month\", y=\"passengers\", col=\"year\", hue=\"year\",', '    kind=\"line\", palette=\"crest\", linewidth=4, zorder=5,', '    col_wrap=3, height=2, aspect=1.5, legend=False,', ')', '', '# Iterate over each subplot to customize further', 'for year, ax in g.axes_dict.items():', '', '    # Add the title as an annotation within the plot', '    ax.text(.8, .85, year, transform=ax.transAxes, fontweight=\"bold\")', '', \"    # Plot every year's time series in the background\", '    sns.lineplot(', '        data=flights, x=\"month\", y=\"passengers\", units=\"year\",', '        estimator=None, color=\".7\", linewidth=1, ax=ax,', '    )', '', '# Reduce the frequency of the x axis ticks', 'ax.set_xticks(ax.get_xticks()[::2])', '', '# Tweak the supporting aspects of the plot', 'g.set_titles(\"\")', 'g.set_axis_labels(\"\", \"Passengers\")', 'g.tight_layout()']}, 'regression_marginals.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Linear regression with marginal distributions', '=============================================', '', '_thumb: .65, .65', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"darkgrid\")', '', 'tips = sns.load_dataset(\"tips\")', 'g = sns.jointplot(x=\"total_bill\", y=\"tip\", data=tips,', '                  kind=\"reg\", truncate=False,', '                  xlim=(0, 60), ylim=(0, 12),', '                  color=\"m\", height=7)']}, 'jitter_stripplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Conditional means with observations', '===================================', '', '\"\"\"', 'import pandas as pd', 'import seaborn as sns', 'import matplotlib.pyplot as plt', '', 'sns.set_theme(style=\"whitegrid\")', 'iris = sns.load_dataset(\"iris\")', '', '# \"Melt\" the dataset to \"long-form\" or \"tidy\" representation', 'iris = pd.melt(iris, \"species\", var_name=\"measurement\")', '', '# Initialize the figure', 'f, ax = plt.subplots()', 'sns.despine(bottom=True, left=True)', '', '# Show each observation with a scatterplot', 'sns.stripplot(', '    data=iris, x=\"value\", y=\"measurement\", hue=\"species\",', '    dodge=True, alpha=.25, zorder=1, legend=False', ')', '', '# Show the conditional means, aligning each pointplot in the', '# center of the strips by adjusting the width allotted to each', '# category (.8 by default) by the number of hue levels', 'sns.pointplot(', '    data=iris, x=\"value\", y=\"measurement\", hue=\"species\",', '    join=False, dodge=.8 - .8 / 3, palette=\"dark\",', '    markers=\"d\", scale=.75, errorbar=None', ')', '', '# Improve the legend', 'sns.move_legend(', '    ax, loc=\"lower right\", ncol=3, frameon=True, columnspacing=1, handletextpad=0', ')']}, 'faceted_lineplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Line plots on multiple facets', '=============================', '', '_thumb: .48, .42', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"ticks\")', '', 'dots = sns.load_dataset(\"dots\")', '', '# Define the palette as a list to specify exact values', 'palette = sns.color_palette(\"rocket_r\")', '', '# Plot the lines on two facets', 'sns.relplot(', '    data=dots,', '    x=\"time\", y=\"firing_rate\",', '    hue=\"coherence\", size=\"choice\", col=\"align\",', '    kind=\"line\", size_order=[\"T1\", \"T2\"], palette=palette,', '    height=5, aspect=.75, facet_kws=dict(sharex=False),', ')']}, 'simple_violinplots.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Violinplots with observations', '=============================', '', '\"\"\"', 'import numpy as np', 'import seaborn as sns', '', 'sns.set_theme()', '', '# Create a random dataset across several variables', 'rs = np.random.default_rng(0)', 'n, p = 40, 8', 'd = rs.normal(0, 2, (n, p))', 'd += np.log(np.arange(1, p + 1)) * -5 + 10', '', '# Show each distribution with both violins and points', 'sns.violinplot(data=d, palette=\"light:g\", inner=\"points\", orient=\"h\")']}, 'joint_histogram.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Joint and marginal histograms', '=============================', '', '_thumb: .52, .505', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"ticks\")', '', '# Load the planets dataset and initialize the figure', 'planets = sns.load_dataset(\"planets\")', 'g = sns.JointGrid(data=planets, x=\"year\", y=\"distance\", marginal_ticks=True)', '', '# Set a log scaling on the y axis', 'g.ax_joint.set(yscale=\"log\")', '', '# Create an inset legend for the histogram colorbar', 'cax = g.figure.add_axes([.15, .55, .02, .2])', '', '# Add the joint and marginal histogram plots', 'g.plot_joint(', '    sns.histplot, discrete=(True, False),', '    cmap=\"light:#03012d\", pmax=.8, cbar=True, cbar_ax=cax', ')', 'g.plot_marginals(sns.histplot, element=\"step\", color=\"#03012d\")']}, 'three_variable_histogram.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Trivariate histogram with two categorical variables', '===================================================', '', '_thumb: .32, .55', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"dark\")', '', 'diamonds = sns.load_dataset(\"diamonds\")', 'sns.displot(', '    data=diamonds, x=\"price\", y=\"color\", col=\"clarity\",', '    log_scale=(True, False), col_wrap=4, height=4, aspect=.7,', ')']}, 'multiple_bivariate_kde.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Multiple bivariate KDE plots', '============================', '', '_thumb: .6, .45', '\"\"\"', 'import seaborn as sns', 'import matplotlib.pyplot as plt', '', 'sns.set_theme(style=\"darkgrid\")', 'iris = sns.load_dataset(\"iris\")', '', '# Set up the figure', 'f, ax = plt.subplots(figsize=(8, 8))', 'ax.set_aspect(\"equal\")', '', '# Draw a contour plot to represent each bivariate density', 'sns.kdeplot(', '    data=iris.query(\"species != \\'versicolor\\'\"),', '    x=\"sepal_width\",', '    y=\"sepal_length\",', '    hue=\"species\",', '    thresh=.1,', ')']}, 'spreadsheet_heatmap.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Annotated heatmaps', '==================', '', '\"\"\"', 'import matplotlib.pyplot as plt', 'import seaborn as sns', 'sns.set_theme()', '', '# Load the example flights dataset and convert to long-form', 'flights_long = sns.load_dataset(\"flights\")', 'flights = flights_long.pivot(\"month\", \"year\", \"passengers\")', '', '# Draw a heatmap with the numeric values in each cell', 'f, ax = plt.subplots(figsize=(9, 6))', 'sns.heatmap(flights, annot=True, fmt=\"d\", linewidths=.5, ax=ax)']}, 'paired_pointplots.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Paired categorical plots', '========================', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the example Titanic dataset', 'titanic = sns.load_dataset(\"titanic\")', '', '# Set up a grid to plot survival probability against several variables', 'g = sns.PairGrid(titanic, y_vars=\"survived\",', '                 x_vars=[\"class\", \"sex\", \"who\", \"alone\"],', '                 height=5, aspect=.5)', '', '# Draw a seaborn pointplot onto each Axes', 'g.map(sns.pointplot, scale=1.3, errwidth=4, color=\"xkcd:plum\")', 'g.set(ylim=(0, 1))', 'sns.despine(fig=g.fig, left=True)']}, 'anscombes_quartet.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', \"Anscombe's quartet\", '==================', '', '_thumb: .4, .4', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"ticks\")', '', \"# Load the example dataset for Anscombe's quartet\", 'df = sns.load_dataset(\"anscombe\")', '', '# Show the results of a linear regression within each dataset', 'sns.lmplot(', '    data=df, x=\"x\", y=\"y\", col=\"dataset\", hue=\"dataset\",', '    col_wrap=2, palette=\"muted\", ci=None,', '    height=4, scatter_kws={\"s\": 50, \"alpha\": 1}', ')']}, 'marginal_ticks.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Scatterplot with marginal ticks', '===============================', '', '_thumb: .66, .34', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"white\", color_codes=True)', 'mpg = sns.load_dataset(\"mpg\")', '', '# Use JointGrid directly to draw a custom plot', 'g = sns.JointGrid(data=mpg, x=\"mpg\", y=\"acceleration\", space=0, ratio=17)', 'g.plot_joint(sns.scatterplot, size=mpg[\"horsepower\"], sizes=(30, 120),', '             color=\"g\", alpha=.6, legend=False)', 'g.plot_marginals(sns.rugplot, height=1, color=\"g\", alpha=.6)']}, 'logistic_regression.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Faceted logistic regression', '===========================', '', '_thumb: .58, .5', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"darkgrid\")', '', '# Load the example Titanic dataset', 'df = sns.load_dataset(\"titanic\")', '', '# Make a custom palette with gendered colors', 'pal = dict(male=\"#6495ED\", female=\"#F08080\")', '', '# Show the survival probability as a function of age and sex', 'g = sns.lmplot(x=\"age\", y=\"survived\", col=\"sex\", hue=\"sex\", data=df,', '               palette=pal, y_jitter=.02, logistic=True, truncate=False)', 'g.set(xlim=(0, 80), ylim=(-.05, 1.05))']}, 'scatterplot_categorical.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Scatterplot with categorical variables', '======================================', '', '_thumb: .45, .45', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\", palette=\"muted\")', '', '# Load the penguins dataset', 'df = sns.load_dataset(\"penguins\")', '', '# Draw a categorical scatterplot to show each observation', 'ax = sns.swarmplot(data=df, x=\"body_mass_g\", y=\"sex\", hue=\"species\")', 'ax.set(ylabel=\"\")']}, 'histogram_stacked.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Stacked histogram on a log scale', '================================', '', '_thumb: .5, .45', '', '\"\"\"', 'import seaborn as sns', 'import matplotlib as mpl', 'import matplotlib.pyplot as plt', '', 'sns.set_theme(style=\"ticks\")', '', 'diamonds = sns.load_dataset(\"diamonds\")', '', 'f, ax = plt.subplots(figsize=(7, 5))', 'sns.despine(f)', '', 'sns.histplot(', '    diamonds,', '    x=\"price\", hue=\"cut\",', '    multiple=\"stack\",', '    palette=\"light:m_r\",', '    edgecolor=\".3\",', '    linewidth=.5,', '    log_scale=True,', ')', 'ax.xaxis.set_major_formatter(mpl.ticker.ScalarFormatter())', 'ax.set_xticks([500, 1000, 2000, 5000, 10000])']}, 'joint_kde.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Joint kernel density estimate', '=============================', '', '_thumb: .6, .4', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"ticks\")', '', '# Load the penguins dataset', 'penguins = sns.load_dataset(\"penguins\")', '', '# Show the joint distribution using kernel density estimation', 'g = sns.jointplot(', '    data=penguins,', '    x=\"bill_length_mm\", y=\"bill_depth_mm\", hue=\"species\",', '    kind=\"kde\",', ')']}, 'smooth_bivariate_kde.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Smooth kernel density with marginal histograms', '==============================================', '', '_thumb: .48, .41', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"white\")', '', 'df = sns.load_dataset(\"penguins\")', '', 'g = sns.JointGrid(data=df, x=\"body_mass_g\", y=\"bill_depth_mm\", space=0)', 'g.plot_joint(sns.kdeplot,', '             fill=True, clip=((2200, 6800), (10, 25)),', '             thresh=0, levels=100, cmap=\"rocket\")', 'g.plot_marginals(sns.histplot, color=\"#03051A\", alpha=1, bins=25)']}, 'large_distributions.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Plotting large distributions', '============================', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', 'diamonds = sns.load_dataset(\"diamonds\")', 'clarity_ranking = [\"I1\", \"SI2\", \"SI1\", \"VS2\", \"VS1\", \"VVS2\", \"VVS1\", \"IF\"]', '', 'sns.boxenplot(x=\"clarity\", y=\"carat\",', '              color=\"b\", order=clarity_ranking,', '              scale=\"linear\", data=diamonds)']}, 'errorband_lineplots.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Timeseries plot with error bands', '================================', '', '_thumb: .48, .45', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"darkgrid\")', '', '# Load an example dataset with long-form data', 'fmri = sns.load_dataset(\"fmri\")', '', '# Plot the responses for different events and regions', 'sns.lineplot(x=\"timepoint\", y=\"signal\",', '             hue=\"region\", style=\"event\",', '             data=fmri)']}, 'pointplot_anova.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Plotting a three-way ANOVA', '==========================', '', '_thumb: .42, .5', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the example exercise dataset', 'exercise = sns.load_dataset(\"exercise\")', '', '# Draw a pointplot to show pulse as a function of three categorical factors', 'g = sns.catplot(', '    data=exercise, x=\"time\", y=\"pulse\", hue=\"kind\", col=\"diet\",', '    capsize=.2, palette=\"YlGnBu_d\", errorbar=\"se\",', '    kind=\"point\", height=6, aspect=.75,', ')', 'g.despine(left=True)']}, 'grouped_barplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Grouped barplots', '================', '', '_thumb: .36, .5', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', 'penguins = sns.load_dataset(\"penguins\")', '', '# Draw a nested barplot by species and sex', 'g = sns.catplot(', '    data=penguins, kind=\"bar\",', '    x=\"species\", y=\"body_mass_g\", hue=\"sex\",', '    errorbar=\"sd\", palette=\"dark\", alpha=.6, height=6', ')', 'g.despine(left=True)', 'g.set_axis_labels(\"\", \"Body mass (g)\")', 'g.legend.set_title(\"\")']}, 'many_facets.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Plotting on a large number of facets', '====================================', '', '_thumb: .4, .3', '', '\"\"\"', 'import numpy as np', 'import pandas as pd', 'import seaborn as sns', 'import matplotlib.pyplot as plt', '', 'sns.set_theme(style=\"ticks\")', '', '# Create a dataset with many short random walks', 'rs = np.random.RandomState(4)', 'pos = rs.randint(-1, 2, (20, 5)).cumsum(axis=1)', 'pos -= pos[:, 0, np.newaxis]', 'step = np.tile(range(5), 20)', 'walk = np.repeat(range(20), 5)', 'df = pd.DataFrame(np.c_[pos.flat, step, walk],', '                  columns=[\"position\", \"step\", \"walk\"])', '', '# Initialize a grid of plots with an Axes for each walk', 'grid = sns.FacetGrid(df, col=\"walk\", hue=\"walk\", palette=\"tab20c\",', '                     col_wrap=4, height=1.5)', '', '# Draw a horizontal line to show the starting point', 'grid.refline(y=0, linestyle=\":\")', '', '# Draw a line plot to show the trajectory of each random walk', 'grid.map(plt.plot, \"step\", \"position\", marker=\"o\")', '', '# Adjust the tick positions and labels', 'grid.set(xticks=np.arange(5), yticks=[-3, 3],', '         xlim=(-.5, 4.5), ylim=(-3.5, 3.5))', '', '# Adjust the arrangement of the plots', 'grid.fig.tight_layout(w_pad=1)']}, 'pairgrid_dotplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Dot plot with several variables', '===============================', '', '_thumb: .3, .3', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the dataset', 'crashes = sns.load_dataset(\"car_crashes\")', '', '# Make the PairGrid', 'g = sns.PairGrid(crashes.sort_values(\"total\", ascending=False),', '                 x_vars=crashes.columns[:-3], y_vars=[\"abbrev\"],', '                 height=10, aspect=.25)', '', '# Draw a dot plot using the stripplot function', 'g.map(sns.stripplot, size=10, orient=\"h\", jitter=False,', '      palette=\"flare_r\", linewidth=1, edgecolor=\"w\")', '', '# Use the same x axis limits on all columns and add better labels', 'g.set(xlim=(0, 25), xlabel=\"Crashes\", ylabel=\"\")', '', '# Use semantically meaningful titles for the columns', 'titles = [\"Total crashes\", \"Speeding crashes\", \"Alcohol crashes\",', '          \"Not distracted crashes\", \"No previous crashes\"]', '', 'for ax, title in zip(g.axes.flat, titles):', '', '    # Set a different title for each axes', '    ax.set(title=title)', '', '    # Make the grid horizontal instead of vertical', '    ax.xaxis.grid(False)', '    ax.yaxis.grid(True)', '', 'sns.despine(left=True, bottom=True)']}, 'wide_data_lineplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Lineplot from a wide-form dataset', '=================================', '', '_thumb: .52, .5', '', '\"\"\"', 'import numpy as np', 'import pandas as pd', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', 'rs = np.random.RandomState(365)', 'values = rs.randn(365, 4).cumsum(axis=0)', 'dates = pd.date_range(\"1 1 2016\", periods=365, freq=\"D\")', 'data = pd.DataFrame(values, dates, columns=[\"A\", \"B\", \"C\", \"D\"])', 'data = data.rolling(7).mean()', '', 'sns.lineplot(data=data, palette=\"tab10\", linewidth=2.5)']}, 'different_scatter_variables.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Scatterplot with multiple semantics', '===================================', '', '_thumb: .45, .5', '', '\"\"\"', 'import seaborn as sns', 'import matplotlib.pyplot as plt', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the example diamonds dataset', 'diamonds = sns.load_dataset(\"diamonds\")', '', '# Draw a scatter plot while assigning point colors and sizes to different', '# variables in the dataset', 'f, ax = plt.subplots(figsize=(6.5, 6.5))', 'sns.despine(f, left=True, bottom=True)', 'clarity_ranking = [\"I1\", \"SI2\", \"SI1\", \"VS2\", \"VS1\", \"VVS2\", \"VVS1\", \"IF\"]', 'sns.scatterplot(x=\"carat\", y=\"price\",', '                hue=\"clarity\", size=\"depth\",', '                palette=\"ch:r=-.2,d=.3_r\",', '                hue_order=clarity_ranking,', '                sizes=(1, 8), linewidth=0,', '                data=diamonds, ax=ax)']}, 'scatter_bubbles.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Scatterplot with varying point sizes and hues', '==============================================', '', '_thumb: .45, .5', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"white\")', '', '# Load the example mpg dataset', 'mpg = sns.load_dataset(\"mpg\")', '', '# Plot miles per gallon against horsepower with other semantics', 'sns.relplot(x=\"horsepower\", y=\"mpg\", hue=\"origin\", size=\"weight\",', '            sizes=(40, 400), alpha=.5, palette=\"muted\",', '            height=6, data=mpg)']}, 'wide_form_violinplot.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Violinplot from a wide-form dataset', '===================================', '', '_thumb: .6, .45', '\"\"\"', 'import seaborn as sns', 'import matplotlib.pyplot as plt', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the example dataset of brain network correlations', 'df = sns.load_dataset(\"brain_networks\", header=[0, 1, 2], index_col=0)', '', '# Pull out a specific subset of networks', 'used_networks = [1, 3, 4, 5, 6, 7, 8, 11, 12, 13, 16, 17]', 'used_columns = (df.columns.get_level_values(\"network\")', '                          .astype(int)', '                          .isin(used_networks))', 'df = df.loc[:, used_columns]', '', '# Compute the correlation matrix and average over networks', 'corr_df = df.corr().groupby(level=\"network\").mean()', 'corr_df.index = corr_df.index.astype(int)', 'corr_df = corr_df.sort_index().T', '', '# Set up the matplotlib figure', 'f, ax = plt.subplots(figsize=(11, 6))', '', '# Draw a violinplot with a narrower bandwidth than the default', 'sns.violinplot(data=corr_df, palette=\"Set3\", bw=.2, cut=1, linewidth=1)', '', '# Finalize the figure', 'ax.set(ylim=(-.7, 1.05))', 'sns.despine(left=True, bottom=True)']}, 'palette_choices.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Color palette choices', '=====================', '', '\"\"\"', 'import numpy as np', 'import seaborn as sns', 'import matplotlib.pyplot as plt', 'sns.set_theme(style=\"white\", context=\"talk\")', 'rs = np.random.RandomState(8)', '', '# Set up the matplotlib figure', 'f, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(7, 5), sharex=True)', '', '# Generate some sequential data', 'x = np.array(list(\"ABCDEFGHIJ\"))', 'y1 = np.arange(1, 11)', 'sns.barplot(x=x, y=y1, palette=\"rocket\", ax=ax1)', 'ax1.axhline(0, color=\"k\", clip_on=False)', 'ax1.set_ylabel(\"Sequential\")', '', '# Center the data to make it diverging', 'y2 = y1 - 5.5', 'sns.barplot(x=x, y=y2, palette=\"vlag\", ax=ax2)', 'ax2.axhline(0, color=\"k\", clip_on=False)', 'ax2.set_ylabel(\"Diverging\")', '', '# Randomly reorder the data to make it qualitative', 'y3 = rs.choice(y1, len(y1), replace=False)', 'sns.barplot(x=x, y=y3, palette=\"deep\", ax=ax3)', 'ax3.axhline(0, color=\"k\", clip_on=False)', 'ax3.set_ylabel(\"Qualitative\")', '', '# Finalize the plot', 'sns.despine(bottom=True)', 'plt.setp(f.axes, yticks=[])', 'plt.tight_layout(h_pad=2)']}, 'scatterplot_matrix.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Scatterplot Matrix', '==================', '', '_thumb: .3, .2', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"ticks\")', '', 'df = sns.load_dataset(\"penguins\")', 'sns.pairplot(df, hue=\"species\")']}, 'heat_scatter.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Scatterplot heatmap', '-------------------', '', '_thumb: .5, .5', '', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the brain networks dataset, select subset, and collapse the multi-index', 'df = sns.load_dataset(\"brain_networks\", header=[0, 1, 2], index_col=0)', '', 'used_networks = [1, 5, 6, 7, 8, 12, 13, 17]', 'used_columns = (df.columns', '                  .get_level_values(\"network\")', '                  .astype(int)', '                  .isin(used_networks))', 'df = df.loc[:, used_columns]', '', 'df.columns = df.columns.map(\"-\".join)', '', '# Compute a correlation matrix and convert to long-form', 'corr_mat = df.corr().stack().reset_index(name=\"correlation\")', '', '# Draw each cell as a scatter point with varying size and color', 'g = sns.relplot(', '    data=corr_mat,', '    x=\"level_0\", y=\"level_1\", hue=\"correlation\", size=\"correlation\",', '    palette=\"vlag\", hue_norm=(-1, 1), edgecolor=\".7\",', '    height=10, sizes=(50, 250), size_norm=(-.2, .8),', ')', '', '# Tweak the figure to finalize', 'g.set(xlabel=\"\", ylabel=\"\", aspect=\"equal\")', 'g.despine(left=True, bottom=True)', 'g.ax.margins(.02)', 'for label in g.ax.get_xticklabels():', '    label.set_rotation(90)', 'for artist in g.legend.legendHandles:', '    artist.set_edgecolor(\".7\")']}, 'structured_heatmap.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Discovering structure in heatmap data', '=====================================', '', '_thumb: .3, .25', '\"\"\"', 'import pandas as pd', 'import seaborn as sns', 'sns.set_theme()', '', '# Load the brain networks example dataset', 'df = sns.load_dataset(\"brain_networks\", header=[0, 1, 2], index_col=0)', '', '# Select a subset of the networks', 'used_networks = [1, 5, 6, 7, 8, 12, 13, 17]', 'used_columns = (df.columns.get_level_values(\"network\")', '                          .astype(int)', '                          .isin(used_networks))', 'df = df.loc[:, used_columns]', '', '# Create a categorical palette to identify the networks', 'network_pal = sns.husl_palette(8, s=.45)', 'network_lut = dict(zip(map(str, used_networks), network_pal))', '', '# Convert the palette to vectors that will be drawn on the side of the matrix', 'networks = df.columns.get_level_values(\"network\")', 'network_colors = pd.Series(networks, index=df.columns).map(network_lut)', '', '# Draw the full plot', 'g = sns.clustermap(df.corr(), center=0, cmap=\"vlag\",', '                   row_colors=network_colors, col_colors=network_colors,', '                   dendrogram_ratio=(.1, .2),', '                   cbar_pos=(.02, .32, .03, .2),', '                   linewidths=.75, figsize=(12, 13))', '', 'g.ax_row_dendrogram.remove()']}, 'multiple_conditional_kde.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Conditional kernel density estimate', '===================================', '', '_thumb: .4, .5', '\"\"\"', 'import seaborn as sns', 'sns.set_theme(style=\"whitegrid\")', '', '# Load the diamonds dataset', 'diamonds = sns.load_dataset(\"diamonds\")', '', '# Plot the distribution of clarity ratings, conditional on carat', 'sns.displot(', '    data=diamonds,', '    x=\"carat\", hue=\"cut\",', '    kind=\"kde\", height=6,', '    multiple=\"fill\", clip=(0, None),', '    palette=\"ch:rot=-.25,hue=1,light=.75\",', ')']}, 'many_pairwise_correlations.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Plotting a diagonal correlation matrix', '======================================', '', '_thumb: .3, .6', '\"\"\"', 'from string import ascii_letters', 'import numpy as np', 'import pandas as pd', 'import seaborn as sns', 'import matplotlib.pyplot as plt', '', 'sns.set_theme(style=\"white\")', '', '# Generate a large random dataset', 'rs = np.random.RandomState(33)', 'd = pd.DataFrame(data=rs.normal(size=(100, 26)),', '                 columns=list(ascii_letters[26:]))', '', '# Compute the correlation matrix', 'corr = d.corr()', '', '# Generate a mask for the upper triangle', 'mask = np.triu(np.ones_like(corr, dtype=bool))', '', '# Set up the matplotlib figure', 'f, ax = plt.subplots(figsize=(11, 9))', '', '# Generate a custom diverging colormap', 'cmap = sns.diverging_palette(230, 20, as_cmap=True)', '', '# Draw the heatmap with the mask and correct aspect ratio', 'sns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,', '            square=True, linewidths=.5, cbar_kws={\"shrink\": .5})']}, 'palette_generation.py': {'classes': [], 'functions': [], 'text': ['\"\"\"', 'Different cubehelix palettes', '============================', '', '_thumb: .4, .65', '\"\"\"', 'import numpy as np', 'import seaborn as sns', 'import matplotlib.pyplot as plt', '', 'sns.set_theme(style=\"white\")', 'rs = np.random.RandomState(50)', '', '# Set up the matplotlib figure', 'f, axes = plt.subplots(3, 3, figsize=(9, 9), sharex=True, sharey=True)', '', '# Rotate the starting point around the cubehelix hue circle', 'for ax, s in zip(axes.flat, np.linspace(0, 3, 10)):', '', '    # Create a cubehelix colormap to use with kdeplot', '    cmap = sns.cubehelix_palette(start=s, light=1, as_cmap=True)', '', '    # Generate and plot a random bivariate dataset', '    x, y = rs.normal(size=(2, 50))', '    sns.kdeplot(', '        x=x, y=y,', '        cmap=cmap, fill=True,', '        clip=(-5, 5), cut=10,', '        thresh=0, levels=15,', '        ax=ax,', '    )', '    ax.set_axis_off()', '', 'ax.set(xlim=(-3.5, 3.5), ylim=(-3.5, 3.5))', 'f.subplots_adjust(0, 0, 1, 1, .08, .08)']}}}\n\n###\n\n\nPlease provide the class name, function or method name, or the exact line numbers that need to be edited.\n### Examples:\n```\nfull_path1/file1.py\nline: 10\nclass: MyClass1\nline: 51\n\nfull_path2/file2.py\nfunction: MyClass2.my_method\nline: 12\n\nfull_path3/file3.py\nfunction: my_function\nline: 24\nline: 156\n```\n\nReturn just the location(s)", "num_tokens of the message": 693581}
